{"id":15425,"date":"2023-09-11T15:48:39","date_gmt":"2023-09-11T22:48:39","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15425"},"modified":"2024-09-29T18:17:05","modified_gmt":"2024-09-30T01:17:05","slug":"stdarray-of-class-types-and-brace-elision","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/stdarray-of-class-types-and-brace-elision\/","title":{"rendered":"17.4 &#8212; std::array of class types, and brace elision"},"content":{"rendered":"<p>A <code>std::array<\/code> isn&#8217;t limited to elements of fundamental types.  Rather, the elements of a <code>std::array<\/code> can be any object type, including compound types.  This means you can create a <code>std::array<\/code> of pointers, or a <code>std::array<\/code> of structs (or classes)<\/p>\n<p>However, initializing a <code>std::array<\/code> of structs or classes tends to trip new programmers up, so we&#8217;re going to spend a lesson explicitly covering this topic.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>We&#8217;ll use structs to illustrate our points in this lesson.  The material applies equally well to classes.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Defining and assigning to a <code>std::array<\/code> of structs<\/p>\n<p>Let&#8217;s start with a simple struct:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">struct House\r\n{\r\n    int number{};\r\n    int stories{};\r\n    int roomsPerStory{};\r\n};<\/code><\/pre>\n<p>Defining a <code>std::array<\/code> of <code>House<\/code> and assigning elements works just like you&#8217;d expect:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nstruct House\r\n{\r\n    int number{};\r\n    int stories{};\r\n    int roomsPerStory{};\r\n};\r\n\r\nint main()\r\n{\r\n    std::array&lt;House, 3&gt; houses{};\r\n\r\n    houses[0] = { 13, 1, 7 };\r\n    houses[1] = { 14, 2, 5 };\r\n    houses[2] = { 15, 2, 4 };\r\n\r\n    for (const auto&amp; house : houses)\r\n    {\r\n        std::cout &lt;&lt; \"House number \" &lt;&lt; house.number\r\n                  &lt;&lt; \" has \" &lt;&lt; (house.stories * house.roomsPerStory)\r\n                  &lt;&lt; \" rooms.\\n\";\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The above outputs the following:<\/p>\n<pre>\nHouse number 13 has 7 rooms.\r\nHouse number 14 has 10 rooms.\r\nHouse number 15 has 8 rooms.\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Initializing a <code>std::array<\/code> of structs<\/p>\n<p>Initializing an array of structs also works just like you&#8217;d expect, so long as you are explicit about the element type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nstruct House\r\n{\r\n    int number{};\r\n    int stories{};\r\n    int roomsPerStory{};\r\n};\r\n\r\nint main()\r\n{\r\n    constexpr std::array houses { \/\/ use CTAD to deduce template arguments &lt;House, 3&gt;\r\n            House{ 13, 1, 7 },\r\n            House{ 14, 2, 5 },\r\n            House{ 15, 2, 4 }\r\n        };\r\n\r\n    for (const auto&amp; house : houses)\r\n    {\r\n        std::cout &lt;&lt; \"House number \" &lt;&lt; house.number\r\n            &lt;&lt; \" has \" &lt;&lt; (house.stories * house.roomsPerStory)\r\n            &lt;&lt; \" rooms.\\n\";\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, we&#8217;re using CTAD to deduce the type of the <code>std::array<\/code> as <code>std::array&lt;House, 3&gt;<\/code>.  We then provide 3 <code>House<\/code> objects as initializers, which works just fine.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Initialization without explicitly specifying the element type for each initializer<\/p>\n<p>In the above example, you&#8217;ll note that each initializer requires us to list the element type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    constexpr std::array houses {\r\n            House{ 13, 1, 7 }, \/\/ we mention House here\r\n            House{ 14, 2, 5 }, \/\/ and here\r\n            House{ 15, 2, 4 }  \/\/ and here\r\n        };<\/code><\/pre>\n<p>But we did not have to do the same in the assignment case:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    \/\/ The compiler knows that each element of houses is a House\r\n    \/\/ so it will implicitly convert the right hand side of each assignment to a House\r\n    houses[0] = { 13, 1, 7 };\r\n    houses[1] = { 14, 2, 5 };\r\n    houses[2] = { 15, 2, 4 };<\/code><\/pre>\n<p>So you might think to try something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    \/\/ doesn't work\r\n    constexpr std::array&lt;House, 3&gt; houses { \/\/ we're telling the compiler that each element is a House\r\n            { 13, 1, 7 }, \/\/ but not mentioning it here\r\n            { 14, 2, 5 },\r\n            { 15, 2, 4 } \r\n        };<\/code><\/pre>\n<p>Perhaps surprisingly, this doesn&#8217;t work.  Let&#8217;s explore why.<\/p>\n<p>A <code>std::array<\/code> is defined as a struct that contains a single C-style array member (whose name is implementation defined), like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template&lt;typename T, std::size_t N&gt;\r\nstruct array\r\n{\r\n    T implementation_defined_name[N]; \/\/ a C-style array with N elements of type T\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>We haven&#8217;t covered C-style arrays yet, but for the purposes of this lesson, all you need to know is that <code>T implementation_defined_name[N];<\/code> is a fixed-size array of N elements of type T (just like <code>std::array&lt;T, N&gt; implementation_defined_name;<\/code>).<\/p>\n<p>We cover C-style arrays in upcoming lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-c-style-arrays\/\">17.7 -- Introduction to C-style arrays<\/a>.\n<\/p><\/div>\n<p>So when we try to initialize <code>houses<\/code> per the above, the compiler interprets the initialization like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Doesn't work\r\nconstexpr std::array&lt;House, 3&gt; houses { \/\/ initializer for houses\r\n    { 13, 1, 7 }, \/\/ initializer for C-style array member with implementation_defined_name\r\n    { 14, 2, 5 }, \/\/ ?\r\n    { 15, 2, 4 }  \/\/ ?\r\n};<\/code><\/pre>\n<p>The compiler will interpret <code>{ 13, 1, 7 }<\/code> as the initializer for the first member of <code>houses<\/code>, which is the C-style array with the implementation defined name.  This will initialize the C-style array element 0 with <code>{ 13, 1, 7 }<\/code> and the rest of the members will be zero-initialized.  Then the compiler will discover we&#8217;ve provided two more initialization values (<code>{ 14, 2, 7 }<\/code> and <code>{ 15, 2, 5 }<\/code>) and produce a compilation error telling us that we&#8217;ve provided too many initialization values.<\/p>\n<p>The correct way to initialize the above is to add an extra set of braces as follows:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ This works as expected\r\nconstexpr std::array&lt;House, 3&gt; houses { \/\/ initializer for houses\r\n    { \/\/ extra set of braces to initialize the C-style array member with implementation_defined_name\r\n        { 13, 4, 30 }, \/\/ initializer for array element 0\r\n        { 14, 3, 10 }, \/\/ initializer for array element 1\r\n        { 15, 3, 40 }, \/\/ initializer for array element 2\r\n     }\r\n};<\/code><\/pre>\n<p>Note the extra set of braces that are required (to begin initialization of the C-style array member inside the <code>std::array <\/code>struct).  Within those braces, we can then initialize each element individually, each inside its own set of braces.<\/p>\n<p>This is why you&#8217;ll see <code>std::array<\/code> initializers with an extra set of braces when the element type requires a list of values and we are not explicitly providing the element type as part of the initializer.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>When initializing a <code>std::array<\/code> with a struct, class, or array and not providing the element type with each initializer, you&#8217;ll need an extra pair of braces so that the compiler will properly interpret what to initialize.<\/p>\n<p>This is an artifact of aggregate initialization, and other standard library container types (that use list constructors) do not require the double braces in these cases.\n<\/p><\/div>\n<p>Here&#8217;s a full example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nstruct House\r\n{\r\n    int number{};\r\n    int stories{};\r\n    int roomsPerStory{};\r\n};\r\n\r\nint main()\r\n{\r\n    constexpr std::array&lt;House, 3&gt; houses {{ \/\/ note double braces\r\n        { 13, 1, 7 },\r\n        { 14, 2, 5 },\r\n        { 15, 2, 4 }\r\n    }};\r\n\r\n    for (const auto&amp; house : houses)\r\n    {\r\n        std::cout &lt;&lt; \"House number \" &lt;&lt; house.number\r\n                  &lt;&lt; \" has \" &lt;&lt; (house.stories * house.roomsPerStory)\r\n                  &lt;&lt; \" rooms.\\n\";\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Brace elision for aggregates<\/p>\n<p>Given the explanation above, you may be wondering why the above case requires double braces, but all other cases we&#8217;ve seen only require single braces:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    constexpr std::array&lt;int, 5&gt; arr { 1, 2, 3, 4, 5 }; \/\/ single braces\r\n\r\n    for (const auto n : arr)\r\n        std::cout &lt;&lt; n &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>It turns out that you can supply double braces for such arrays:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    constexpr std::array&lt;int, 5&gt; arr {{ 1, 2, 3, 4, 5 }}; \/\/ double braces\r\n\r\n    for (const auto n : arr)\r\n        std::cout &lt;&lt; n &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, aggregates in C++ support a concept called <strong>brace elision<\/strong>, which lays out some rules for when multiple braces may be omitted.  Generally, you can omit braces when initializing a <code>std::array<\/code> with scalar (single) values, or when initializing with class types or arrays where the type is explicitly named with each element.<\/p>\n<p>There is no harm in always initializing <code>std::array<\/code> with double braces, as it avoids having to think about whether brace-elision is applicable in a specific case or not.  Alternatively, you can try to single-brace init, and the compiler will generally complain if it can&#8217;t figure it out.  In that case, you can quickly add an extra set of braces.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Another example<\/p>\n<p>Here&#8217;s one more example where we initialize a <code>std::array<\/code> with <code>Student<\/code> structs.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\n\/\/ Each student has an id and a name\r\nstruct Student\r\n{\r\n\tint id{};\r\n\tstd::string_view name{};\r\n};\r\n\r\n\/\/ Our array of 3 students (single braced since we mention Student with each initializer)\r\nconstexpr std::array students{ Student{0, \"Alex\"}, Student{ 1, \"Joe\" }, Student{ 2, \"Bob\" } };\r\n\r\nconst Student* findStudentById(int id)\r\n{\r\n\t\/\/ Look through all the students\r\n\tfor (auto&amp; s : students)\r\n\t{\r\n\t\t\/\/ Return student with matching id\r\n\t\tif (s.id == id) return &amp;s;\r\n\t}\r\n\r\n\t\/\/ No matching id found\r\n\treturn nullptr;\r\n}\r\n\r\nint main()\r\n{\r\n\tconstexpr std::string_view nobody { \"nobody\" };\r\n\r\n\tconst Student* s1 { findStudentById(1) };\r\n\tstd::cout &lt;&lt; \"You found: \" &lt;&lt; (s1 ? s1-&gt;name : nobody) &lt;&lt; '\\n';\r\n\r\n\tconst Student* s2 { findStudentById(3) };\r\n\tstd::cout &lt;&lt; \"You found: \" &lt;&lt; (s2 ? s2-&gt;name : nobody) &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nYou found: Joe\r\nYou found: nobody\r\n<\/pre>\n<p>Note that because <code>std::array students<\/code> is constexpr, our <code>findStudentById()<\/code> function must return a const pointer, which means our <code>Student<\/code> pointers in <code>main()<\/code> must also be const.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Define a struct named <code>Item<\/code> that contains two members: <code>std::string_view name<\/code> and <code>int gold<\/code>.  Define a <code>std::array<\/code> and initialize it with 4 Item objects.  Use CTAD to deduce the element type and array size.<\/p>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_0'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_0\" style=\"display:none; margin-bottom: 1em\">Hint: You will need to explicitly specify the element type for each initializer.<\/div>\n<p>The program should print the following:<\/p>\n<pre>\nA sword costs 5 gold.\r\nA dagger costs 3 gold.\r\nA club costs 2 gold.\r\nA spear costs 7 gold.\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nstruct Item\r\n{\r\n    std::string_view name {};\r\n    int gold {};\r\n};\r\n\r\ntemplate &lt;std::size_t N&gt;\r\nvoid printStore(const std::array&lt;Item, N&gt;&amp; arr)\r\n{\r\n    for (const auto&amp; item: arr)\r\n    {\r\n        std::cout &lt;&lt; \"A \" &lt;&lt; item.name &lt;&lt; \" costs \" &lt;&lt; item.gold &lt;&lt; \" gold.\\n\";\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    constexpr std::array store { \/\/ CTAD, single braces due to brace elision\r\n        Item { \"sword\",    5 },\r\n        Item { \"dagger\",   3 },\r\n        Item { \"club\",     2 },\r\n        Item { \"spear\",    7 } };\r\n    printStore(store);\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because we are explicitly specifying the element type for each initializer, we can use CTAD and single braces (due to brace elision) here.\n<\/p><\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>Update your solution to quiz 1 to not explicitly specify the element type for each initializer.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nstruct Item\r\n{\r\n    std::string_view name {};\r\n    int gold {};\r\n};\r\n\r\ntemplate &lt;std::size_t N&gt;\r\nvoid printStore(const std::array&lt;Item, N&gt;&amp; arr)\r\n{\r\n    for (const auto&amp; item: arr)\r\n    {\r\n        std::cout &lt;&lt; \"A \" &lt;&lt; item.name &lt;&lt; \" costs \" &lt;&lt; item.gold &lt;&lt; \" gold.\\n\";\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    constexpr std::array&lt;Item, 4&gt; store {{ \/\/ No CTAD, must use double braces\r\n        { \"sword\",    5 },\r\n        { \"dagger\",   3 },\r\n        { \"club\",     2 },\r\n        { \"spear\",    7 }\r\n    }};\r\n    printStore(store);\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because we are not explicitly specifying the element type for each initializer, we can&#8217;t use CTAD nor brace elision.  That means we must use double-braces.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/arrays-of-references-via-stdreference_wrapper\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.5<\/span>Arrays of references via std::reference_wrapper\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/passing-and-returning-stdarray\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.3<\/span>Passing and returning std::array\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>A std::array isn&#8217;t limited to elements of fundamental types. Rather, the elements of a std::array can be any object type, including compound types. This means you can create a std::array of pointers, or a std::array of structs (or classes) However, initializing a std::array of structs or classes tends to trip &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15425"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15425"}],"version-history":[{"count":13,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15425\/revisions"}],"predecessor-version":[{"id":17688,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15425\/revisions\/17688"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15425"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15425"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15425"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}