{"id":15361,"date":"2023-09-11T12:59:10","date_gmt":"2023-09-11T19:59:10","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15361"},"modified":"2024-08-06T16:57:17","modified_gmt":"2024-08-06T23:57:17","slug":"class-templates-with-member-functions","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/class-templates-with-member-functions\/","title":{"rendered":"15.5 &#8212; Class templates with member functions"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-templates\/\">11.6 -- Function templates<\/a>, we took a look at function templates:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;typename T&gt; \/\/ this is the template parameter declaration\r\nT max(T x, T y) \/\/ this is the function template definition for max&lt;T&gt;\r\n{\r\n    return (x &lt; y) ? y : x;\r\n}<\/code><\/pre>\n<p>With a function template, we can define type template parameters (e.g. <code>typename T<\/code>) and then use them as the type of our function parameters (<code>T x, T y<\/code>).<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-templates\/\">13.13 -- Class templates<\/a>, we covered class templates, which allow us to use type template parameters for the type of our data members of class types (struct, classes, and unions):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nstruct Pair\r\n{\r\n    T first{};\r\n    T second{};\r\n};\r\n\r\n\/\/ Here's a deduction guide for our Pair (required in C++17 or older)\r\n\/\/ Pair objects initialized with arguments of type T and T should deduce to Pair&lt;T&gt;\r\ntemplate &lt;typename T&gt;\r\nPair(T, T) -&gt; Pair&lt;T&gt;;\r\n\r\nint main()\r\n{\r\n    Pair&lt;int&gt; p1{ 5, 6 };        \/\/ instantiates Pair&lt;int&gt; and creates object p1\r\n    std::cout &lt;&lt; p1.first &lt;&lt; ' ' &lt;&lt; p1.second &lt;&lt; '\\n';\r\n\r\n    Pair&lt;double&gt; p2{ 1.2, 3.4 }; \/\/ instantiates Pair&lt;double&gt; and creates object p2\r\n    std::cout &lt;&lt; p2.first &lt;&lt; ' ' &lt;&lt; p2.second &lt;&lt; '\\n';\r\n\r\n    Pair&lt;double&gt; p3{ 7.8, 9.0 }; \/\/ creates object p3 using prior definition for Pair&lt;double&gt;\r\n    std::cout &lt;&lt; p3.first &lt;&lt; ' ' &lt;&lt; p3.second &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We discuss deduction guides in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-template-argument-deduction-ctad-and-deduction-guides\/#DeductionGuide\">13.14 -- Class template argument deduction (CTAD) and deduction guides<\/a>.\n<\/p><\/div>\n<p>In this lesson, we&#8217;ll combine elements of both function templates and class templates as we take a closer look at class templates that have member functions.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Type template parameters in member functions<\/p>\n<p>Type template parameters defined as part of a class template parameter declaration can be used both as the type of data members and as the type of member function parameters.<\/p>\n<p>In the following example, we rewrite the above <code>Pair<\/code> class template, converting it from a struct to a class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;ios&gt;       \/\/ for std::boolalpha\r\n#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nclass Pair\r\n{\r\nprivate:\r\n    T m_first{};\r\n    T m_second{};\r\n\r\npublic:\r\n    \/\/ When we define a member function inside the class definition,\r\n    \/\/ the template parameter declaration belonging to the class applies\r\n    Pair(const T&amp; first, const T&amp; second)\r\n        : m_first{ first }\r\n        , m_second{ second }\r\n    {\r\n    }\r\n\r\n    bool isEqual(const Pair&lt;T&gt;&amp; pair);\r\n};\r\n\r\n\/\/ When we define a member function outside the class definition,\r\n\/\/ we need to resupply a template parameter declaration\r\ntemplate &lt;typename T&gt;\r\nbool Pair&lt;T&gt;::isEqual(const Pair&lt;T&gt;&amp; pair)\r\n{\r\n    return m_first == pair.m_first &amp;&amp; m_second == pair.m_second;\r\n}\r\n\r\nint main()\r\n{\r\n    Pair p1{ 5, 6 }; \/\/ uses CTAD to infer type Pair&lt;int&gt;\r\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; \"isEqual(5, 6): \" &lt;&lt; p1.isEqual( Pair{5, 6} ) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; \"isEqual(5, 7): \" &lt;&lt; p1.isEqual( Pair{5, 7} ) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The above should be pretty straightforward, but there are a few things worth noting.<\/p>\n<p>First, because our class has private members, it is not an aggregate, and therefore can&#8217;t use aggregate initialization.  Instead, we have to initialize our class objects using a constructor.<\/p>\n<p>Since our class data members are of type <code>T<\/code>, we make the parameters of our constructor type <code>const T&amp;<\/code>, so the user can supply initialization values of the same type.  Because <code>T<\/code> might be expensive to copy, it&#8217;s safer to pass by const reference than by value.<\/p>\n<p>Note that when we define a member function inside the class template definition, we don&#8217;t need to provide a template parameter declaration for the member function.  Such member functions implicitly use the class template parameter declaration.<\/p>\n<p>Second, we don&#8217;t need deduction guides for CTAD to work with non-aggregate classes.  A matching constructor provides the compiler with the information it needs to deduce the template parameters from the initializers.<\/p>\n<p>Third, let&#8217;s look more closely at the case where we define a member function for a class template outside of the class template definition:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;typename T&gt;\r\nbool Pair&lt;T&gt;::isEqual(const Pair&lt;T&gt;&amp; pair)\r\n{\r\n    return m_first == pair.m_first &amp;&amp; m_second == pair.m_second;\r\n}<\/code><\/pre>\n<p>Since this member function definition is separate from the class template definition, we need to resupply a template parameter declaration (<code>template &lt;typename T&gt;<\/code>) so the compiler knows what <code>T<\/code> is.<\/p>\n<p>Also, when we define a member function outside of the class, we need to qualify the member function name with the fully templated name of the class template (<code>Pair&lt;T&gt;::isEqual<\/code>, not <code>Pair::isEqual<\/code>).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Injected class names<\/p>\n<p>In a prior lesson, we noted that the name of a constructor must match the name of the class.  But in our class template for <code>Pair&lt;T&gt;<\/code> above, we named our constructor <code>Pair<\/code>, not <code>Pair&lt;T&gt;<\/code>.  Somehow this still works, even though the names don&#8217;t match.<\/p>\n<p>Within the scope of a class, the unqualified name of the class is called an <strong>injected class name<\/strong>.  In a class template, the injected class name serves as shorthand for the fully templated name.  <\/p>\n<p>Because <code>Pair<\/code> is the injected class name of <code>Pair&lt;T&gt;<\/code>, within the scope of our <code>Pair&lt;T&gt;<\/code> class template, any use of <code>Pair<\/code> will be treated as if we had written <code>Pair&lt;T&gt;<\/code> instead.  Therefore, although we named the constructor <code>Pair<\/code>, the compiler treats it as if we had written <code>Pair&lt;T&gt;<\/code> instead.  The names now match!<\/p>\n<p>This means that we can also define our <code>isEqual()<\/code> member function like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;typename T&gt;\r\nbool Pair&lt;T&gt;::isEqual(const Pair&amp; pair) \/\/ note the parameter has type Pair, not Pair&lt;T&gt;\r\n{\r\n    return m_first == pair.m_first &amp;&amp; m_second == pair.m_second;\r\n}<\/code><\/pre>\n<p>Because this is a definition for a member function of <code>Pair&lt;T&gt;<\/code>, we&#8217;re in the scope of the <code>Pair&lt;T&gt;<\/code> class template.  Therefore, any use of <code>Pair<\/code> is shorthand for <code>Pair&lt;T&gt;<\/code>!<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-template-argument-deduction-ctad-and-deduction-guides\/\">13.14 -- Class template argument deduction (CTAD) and deduction guides<\/a>, we noted that CTAD doesn&#8217;t work with function parameters (as it is argument deduction, not parameter deduction).  However, using an injected class name as a function parameter is okay, as it is shorthand for the fully templated name, not a use of CTAD.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Where to define member functions for class templates outside the class<\/p>\n<p>With member functions for class templates, the compiler needs to see both the class definition (to ensure that the member function template is declared as part of the class) and the template member function definition (to know how to instantiate the template).  Therefore, we typically want to define both a class and its member function templates in the same location.<\/p>\n<p>When a member function template is defined <em>inside<\/em> the class definition, the template member function definition is part of the class definition, so anywhere the class definition can be seen, the template member function definition can also be seen.  This makes things easy (at the cost of cluttering our class definition).<\/p>\n<p>When a member function template is defined <em>outside<\/em> the class definition, it should generally be defined immediately below the class definition.  That way, anywhere the class definition can be seen, the member function template definitions immediately below the class definition will also be seen.<\/p>\n<p>In the typical case where a class is defined in a header file, this means any member function templates defined outside the class should also be defined in the same header file, below the class definition.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-template-instantiation\/\">11.7 -- Function template instantiation<\/a>, we noted that functions implicitly instantiated from templates are implicitly inline.  This includes both non-member and member function templates.  Therefore, there is no issue including member function templates defined in header files into multiple code files, as the functions instantiated from those templates will be implicitly inline (and the linker will de-duplicate them).\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Any member function templates defined outside the class definition should be defined just below the class definition (in the same file).\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Write a class template named Triad that has 3 private data members with independent type template parameters.  The class should have a constructor, access functions, and a <code>print()<\/code> member function that is defined outside the class.<\/p>\n<p>The following program should compile and run:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nint main()\r\n{\r\n\tTriad&lt;int, int, int&gt; t1{ 1, 2, 3 };\r\n\tt1.print();\r\n\tstd::cout &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; t1.first() &lt;&lt; '\\n';\r\n\r\n\tusing namespace std::literals::string_literals;\r\n\tconst Triad t2{ 1, 2.3, \"Hello\"s };\r\n\tt2.print();\r\n\tstd::cout &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>and produce the output:<\/p>\n<pre>\n[1, 2, 3]\r\n1\r\n[1, 2.3, Hello]\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\ntemplate &lt;typename T, typename U, typename V&gt;\r\nclass Triad\r\n{\r\nprivate:\r\n\tT m_first{};\r\n\tU m_second{};\r\n\tV m_third{};\r\n\r\npublic:\r\n\tTriad(const T&amp; first, const U&amp; second, const V&amp; third)\r\n\t\t: m_first{ first }\r\n\t\t, m_second{ second }\r\n\t\t, m_third{ third }\r\n\t{\r\n\t}\r\n\r\n\tconst T&amp; first() const { return m_first; }\r\n\tconst U&amp; second() const { return m_second; }\r\n\tconst V&amp; third() const { return m_third; }\r\n\r\n\tvoid print() const;\r\n};\r\n\r\ntemplate &lt;typename T, typename U, typename V&gt;\r\nvoid Triad&lt;T, U, V&gt;::print() const\r\n{\r\n\tstd::cout &lt;&lt; '[' &lt;&lt; m_first &lt;&lt; \", \" &lt;&lt; m_second &lt;&lt; \", \" &lt;&lt; m_third &lt;&lt; ']' ;\r\n}\r\n\r\nint main()\r\n{\r\n\tTriad&lt;int, int, int&gt; t1{ 1, 2, 3 };\r\n\tt1.print();\r\n\tstd::cout &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; t1.first() &lt;&lt; '\\n';\r\n\r\n\tusing namespace std::literals::string_literals;\r\n\tconst Triad t2{ 1, 2.3, \"Hello\"s };\r\n\tt2.print();\r\n\tstd::cout &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>If we remove the <code>const<\/code> from the <code>print()<\/code> function declaration and definition, the program will no longer compile.  Why not?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p><code>t2<\/code> is a const object, so only const member functions can be invoked on <code>t2<\/code>.  If we make <code>print()<\/code> a non-const member function, then <code>t2<\/code> is not allowed to call it.  This is because a non-const member function could conceivably modify the implicit object, which would be a violation of the constness of the const object (<code>t2<\/code> in this case).\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/static-member-variables\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">15.6<\/span>Static member variables\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-destructors\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">15.4<\/span>Introduction to destructors\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we took a look at function templates: template &lt;typename T&gt; \/\/ this is the template parameter declaration T max(T x, T y) \/\/ this is the function template definition for max&lt;T&gt; { return (x &lt; y) ? y : x; } With a function template, we can &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15361"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15361"}],"version-history":[{"count":12,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15361\/revisions"}],"predecessor-version":[{"id":17444,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15361\/revisions\/17444"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15361"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15361"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15361"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}