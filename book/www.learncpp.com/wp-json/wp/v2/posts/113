{"id":113,"date":"2007-08-03T20:25:20","date_gmt":"2007-08-04T04:25:20","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/76-function-overloading\/"},"modified":"2023-12-28T17:31:45","modified_gmt":"2023-12-29T01:31:45","slug":"introduction-to-function-overloading","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-function-overloading\/","title":{"rendered":"11.1 &#8212; Introduction to function overloading"},"content":{"rendered":"<p>Consider the following function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int add(int x, int y)\r\n{\r\n    return x + y;\r\n}<\/code><\/pre>\n<p>This trivial function adds two integers and returns an integer result.  However, what if we also want a function that can add two floating point numbers?  This <code>add()<\/code> function is not suitable, as any floating point parameters would be converted to integers, causing the floating point arguments to lose their fractional values.<\/p>\n<p>One way to work around this issue is to define multiple functions with slightly different names:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int addInteger(int x, int y)\r\n{\r\n    return x + y;\r\n}\r\n\r\ndouble addDouble(double x, double y)\r\n{\r\n    return x + y;\r\n}<\/code><\/pre>\n<p>However, for best effect, this requires that you define a consistent function naming standard for similar functions that have parameters of different types, remember the names of these functions, and actually call the correct one.<\/p>\n<p>And then what happens when we want to have a similar function that adds 3 integers instead of 2?  Managing unique names for each function quickly becomes burdensome.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Introduction to function overloading<\/p>\n<p>Fortunately, C++ has an elegant solution to handle such cases.  <strong>Function overloading<\/strong> allows us to create multiple functions with the same name, so long as each identically named function has different parameter types (or the functions can be otherwise differentiated).  Each function sharing a name (in the same scope) is called an <strong>overloaded function<\/strong> (sometimes called an <strong>overload<\/strong> for short).<\/p>\n<p>To overload our <code>add()<\/code> function, we can simply declare another <code>add()<\/code> function that takes double parameters:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">double add(double x, double y)\r\n{\r\n    return x + y;\r\n}<\/code><\/pre>\n<p>We now have two versions of <code>add()<\/code> in the same scope:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int add(int x, int y) \/\/ integer version\r\n{\r\n    return x + y;\r\n}\r\n\r\ndouble add(double x, double y) \/\/ floating point version\r\n{\r\n    return x + y;\r\n}\r\n\r\nint main()\r\n{\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The above program will compile.  Although you might expect these functions to result in a naming conflict, that is not the case here.  Because the parameter types of these functions differ, the compiler is able to differentiate these functions, and will treat them as separate functions that just happen to share a name.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Functions can be overloaded so long as each overloaded function can be differentiated by the compiler.  If an overloaded function can not be differentiated, a compile error will result.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>Operators can also be overloaded in a similar manner.  We&#8217;ll discuss operator overloading in <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-operator-overloading\/\">21.1 -- Introduction to operator overloading<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Introduction to overload resolution<\/p>\n<p>Additionally, when a function call is made to a function that has been overloaded, the compiler will try to match the function call to the appropriate overload based on the arguments used in the function call.  This is called <strong>overload resolution<\/strong>.<\/p>\n<p>Here&#8217;s a simple example demonstrating this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y)\r\n{\r\n    return x + y;\r\n}\r\n\r\ndouble add(double x, double y)\r\n{\r\n    return x + y;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; add(1, 2); \/\/ calls add(int, int)\r\n    std::cout &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; add(1.2, 3.4); \/\/ calls add(double, double)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The above program compiles and produces the result:<\/p>\n<pre>\r\n3\r\n4.6\r\n<\/pre>\n<p>When we provide integer arguments in the call to <code>add(1, 2)<\/code>, the compiler will determine that we&#8217;re trying to call <code>add(int, int)<\/code>.  And when we provide floating point arguments in the call to <code>add(1.2, 3.4)<\/code>, the compiler will determine that we&#8217;re trying to call <code>add(double, double)<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Making it compile<\/p>\n<p>In order for a program using overloaded functions to compile, two things have to be true:<\/p>\n<ol>\n<li>Each overloaded function has to be differentiated from the others.  We discuss how functions can be differentiated in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-overload-differentiation\/\">11.2 -- Function overload differentiation<\/a>.<\/li>\n<li>Each call to an overloaded function has to resolve to an overloaded function.  We discuss how the compiler matches function calls to overloaded functions in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-overload-resolution-and-ambiguous-matches\/\">11.3 -- Function overload resolution and ambiguous matches<\/a>.<\/li>\n<\/ol>\n<p>If an overloaded function is not differentiated, or if a function call to an overloaded function can not be resolved to an overloaded function, then a compile error will result.<\/p>\n<p>In the next lesson, we&#8217;ll explore how overloaded functions can be differentiated from each other.  Then, in the following lesson, we&#8217;ll explore how the compiler resolves function calls to overloaded functions.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Conclusion<\/p>\n<p>Function overloading provides a great way to reduce the complexity of your program by reducing the number of function names you need to remember.  It can and should be used liberally.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Use function overloading to make your program simpler.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-overload-differentiation\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">11.2<\/span>Function overload differentiation\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-10-summary-and-quiz\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">10.x<\/span>Chapter 10 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Consider the following function: int add(int x, int y) { return x + y; } This trivial function adds two integers and returns an integer result. However, what if we also want a function that can add two floating point numbers? This add() function is not suitable, as any floating &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/113"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=113"}],"version-history":[{"count":35,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/113\/revisions"}],"predecessor-version":[{"id":16379,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/113\/revisions\/16379"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=113"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=113"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=113"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}