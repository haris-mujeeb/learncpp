{"id":10563,"date":"2020-12-21T11:29:24","date_gmt":"2020-12-21T19:29:24","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=10563"},"modified":"2024-11-10T11:46:36","modified_gmt":"2024-11-10T19:46:36","slug":"common-semantic-errors-in-c","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/common-semantic-errors-in-c\/","title":{"rendered":"9.3 &#8212; Common semantic errors in C++"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/syntax-and-semantic-errors\/\">3.1 -- Syntax and semantic errors<\/a>, we covered <code>syntax errors<\/code>, which occur when you write code that is not valid according to the grammar of the C++ language.  The compiler will notify you of such errors, so they are trivial to catch, and usually straightforward to fix.<\/p>\n<p>We also covered <code>semantic errors<\/code>, which occur when you write code that does not do what you intended.  The compiler generally will not catch semantic errors (though in some cases, smart compilers may be able to generate a warning).<\/p>\n<p>Semantic errors can cause most of the same symptoms of <code>undefined behavior<\/code>, such as causing the program to produce the wrong results, causing erratic behavior, corrupting program data, causing the program to crash -- or they may not have any impact at all.<\/p>\n<p>When writing programs, it is almost inevitable that you will make semantic errors.  You will probably notice some of these just by using the program: for example, if you were writing a maze game, and your character was able to walk through walls.  Testing your program (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-testing-your-code\/\">9.1 -- Introduction to testing your code<\/a>) can also help surface semantic errors.<\/p>\n<p>But there&#8217;s one other thing that can help -- and that&#8217;s knowing which type of semantic errors are most common, so you can spend a little more time ensuring things are right in those cases.<\/p>\n<p>In this lesson, we&#8217;ll cover a bunch of the most common types of semantic errors that occur in C++ (most of which have to do with flow control in some way).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Conditional logic errors<\/p>\n<p>One of the most common types of semantic errors is a conditional logic error.  A <strong>conditional logic error<\/strong> occurs when the programmer incorrectly codes the logic of a conditional statement or loop condition.  Here is a simple example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter an integer: \";\r\n    int x{};\r\n    std::cin &gt;&gt; x;\r\n\r\n    if (x &gt;= 5) \/\/ oops, we used operator&gt;= instead of operator&gt;\r\n        std::cout &lt;&lt; x &lt;&lt; \" is greater than 5\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Here&#8217;s a run of the program that exhibits the conditional logic error:<\/p>\n<pre>\r\nEnter an integer: 5\r\n5 is greater than 5\r\n<\/pre>\n<p>When the user enters <code>5<\/code>, the conditional expression <code>x &gt;= 5<\/code> evaluates to <code>true<\/code>, so the associated statement is executed.<\/p>\n<p>Here&#8217;s another example, using a for loop:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter an integer: \";\r\n    int x{};\r\n    std::cin &gt;&gt; x;\r\n\r\n    \/\/ oops, we used operator&gt; instead of operator&lt;\r\n    for (int count{ 1 }; count &gt; x; ++count)\r\n    {\r\n        std::cout &lt;&lt; count &lt;&lt; ' ';\r\n    }\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program is supposed to print all of the numbers between 1 and the number the user entered.  But here&#8217;s what it actually does:<\/p>\n<pre>\r\nEnter an integer: 5\r\n<\/pre>\n<p>It didn&#8217;t print anything.  This happens because on entrance to the for loop, <code>count &gt; x<\/code> is <code>false<\/code>, so the loop never iterates at all.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Infinite loops<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-loops-and-while-statements\/\">8.8 -- Introduction to loops and while statements<\/a>, we covered infinite loops, and showed this example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n \r\nint main()\r\n{\r\n    int count{ 1 };\r\n    while (count &lt;= 10) \/\/ this condition will never be false\r\n    {\r\n        std::cout &lt;&lt; count &lt;&lt; ' '; \/\/ so this line will repeatedly execute\r\n    }\r\n \r\n    std::cout &lt;&lt; '\\n'; \/\/ this line will never execute\r\n\r\n    return 0; \/\/ this line will never execute\r\n}<\/code><\/pre>\n<p>In this case, we forgot to increment <code>count<\/code>, so the loop condition will never be false, and the loop will continue to print:<\/p>\n<pre>\r\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\r\n<\/pre>\n<p>&#8230; until the user shuts down the program.<\/p>\n<p>Here&#8217;s another example that teachers love asking as a quiz question.  What&#8217;s wrong with the following code?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    for (unsigned int count{ 5 }; count &gt;= 0; --count)\r\n    {\r\n        if (count == 0)\r\n            std::cout &lt;&lt; \"blastoff! \";\r\n        else\r\n          std::cout &lt;&lt; count &lt;&lt; ' ';\r\n    }\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program is supposed to print <code>5 4 3 2 1 blastoff!<\/code>, which it does, but it doesn&#8217;t stop there.  In actuality, it prints:<\/p>\n<pre>\r\n5 4 3 2 1 blastoff! 4294967295 4294967294 4294967293 4294967292 4294967291\r\n<\/pre>\n<p>and then just keeps decrementing.  The program will never terminate, because <code>count &gt;= 0<\/code> can never be <code>false<\/code> when <code>count<\/code> is an unsigned integer.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Off-by-one errors<\/p>\n<p>An <strong>off-by-one<\/strong> error is an error that occurs when a loop executes one too many or one too few times.  Here&#8217;s an example that we covered in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/for-statements\/\">8.10 -- For statements<\/a>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    for (int count{ 1 }; count &lt; 5; ++count)\r\n    {\r\n        std::cout &lt;&lt; count &lt;&lt; ' ';\r\n    }\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The programmer intended for this code to print <code>1 2 3 4 5<\/code>.  However, the wrong relational operator was used (<code>&lt;<\/code> instead of <code>&lt;=<\/code>), so the loop executes one fewer times than intended, printing <code>1 2 3 4<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Incorrect operator precedence<\/p>\n<p>From lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/logical-operators\/\">6.8 -- Logical operators<\/a>, the following program makes an operator precedence mistake:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x{ 5 };\r\n    int y{ 7 };\r\n\r\n    if (!x &gt; y) \/\/ oops: operator precedence issue\r\n        std::cout &lt;&lt; x &lt;&lt; \" is not greater than \" &lt;&lt; y &lt;&lt; '\\n';\r\n    else\r\n        std::cout &lt;&lt; x &lt;&lt; \" is greater than \" &lt;&lt; y &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because <code>logical NOT<\/code> has higher precedence than <code>operator&gt;<\/code>, the conditional evaluates as if it was written <code>(!x) &gt; y<\/code>, which isn&#8217;t what the programmer intended.<\/p>\n<p>As a result, this program prints:<\/p>\n<pre>\r\n5 is greater than 7\r\n<\/pre>\n<p>This can also happen when mixing Logical OR and Logical AND in the same expression (Logical AND takes precedence over Logical OR).  Use explicit parenthesization to avoid these kinds of errors.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Precision issues with floating point types<\/p>\n<p>The following floating point variable doesn&#8217;t have enough precision to store the entire number:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    float f{ 0.123456789f };\r\n    std::cout &lt;&lt; f &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because of this lack of precision, the number is rounded slightly:<\/p>\n<pre>\r\n0.123457\r\n<\/pre>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/relational-operators-and-floating-point-comparisons\/\">6.7 -- Relational operators and floating point comparisons<\/a>, we talked about how using <code>operator==<\/code> and <code>operator!=<\/code> can be problematic with floating point numbers due to small rounding errors (as well as what to do about it).  Here&#8217;s an example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    double d{ 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 }; \/\/ should sum to 1.0\r\n\r\n    if (d == 1.0)\r\n        std::cout &lt;&lt; \"equal\\n\";\r\n    else\r\n        std::cout &lt;&lt; \"not equal\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\r\nnot equal\r\n<\/pre>\n<p>The more arithmetic you do with a floating point number, the more it will accumulate small rounding errors.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Integer division<\/p>\n<p>In the following example, we mean to do a floating point division, but because both operands are integers, we end up doing an integer division instead:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x{ 5 };\r\n    int y{ 3 };\r\n\r\n    std::cout &lt;&lt; x &lt;&lt; \" divided by \" &lt;&lt; y &lt;&lt; \" is: \" &lt;&lt; x \/ y &lt;&lt; '\\n'; \/\/ integer division\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\n5 divided by 3 is: 1\r\n<\/pre>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/arithmetic-operators\/\">6.2 -- Arithmetic operators<\/a>, we showed that we can use static_cast to convert one of the integral operands to a floating point value in order to do floating point division.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Accidental null statements<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/common-if-statement-problems\/\">8.3 -- Common if statement problems<\/a>, we covered <code>null statements<\/code>, which are statements that do nothing.<\/p>\n<p>In the below program, we only want to blow up the world if we have the user&#8217;s permission:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid blowUpWorld()\r\n{\r\n    std::cout &lt;&lt; \"Kaboom!\\n\";\r\n} \r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Should we blow up the world again? (y\/n): \";\r\n    char c{};\r\n    std::cin &gt;&gt; c;\r\n\r\n    if (c == 'y');     \/\/ accidental null statement here\r\n        blowUpWorld(); \/\/ so this will always execute since it's not part of the if-statement\r\n \r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, because of an accidental <code>null statement<\/code>, the function call to <code>blowUpWorld()<\/code> is always executed, so we blow it up regardless:<\/p>\n<pre>\r\nShould we blow up the world again? (y\/n): n\r\nKaboom!\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Not using a compound statement when one is required<\/p>\n<p>Another variant of the above program that always blows up the world:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid blowUpWorld()\r\n{\r\n    std::cout &lt;&lt; \"Kaboom!\\n\";\r\n} \r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Should we blow up the world again? (y\/n): \";\r\n    char c{};\r\n    std::cin &gt;&gt; c;\r\n\r\n    if (c == 'y')\r\n        std::cout &lt;&lt; \"Okay, here we go...\\n\";\r\n        blowUpWorld(); \/\/ Will always execute.  Should be inside compound statement.\r\n \r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\r\nShould we blow up the world again? (y\/n): n\r\nKaboom!\r\n<\/pre>\n<p>A <code>dangling else<\/code> (covered in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/common-if-statement-problems\/\">8.3 -- Common if statement problems<\/a>) also falls into this category.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using assignment instead of equality inside a conditional<\/p>\n<p>Because the assignment operator (<code>=<\/code>) and equality operator (<code>==<\/code>) are similar, we may intend to use equality but accidentally use assignment instead:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid blowUpWorld()\r\n{\r\n    std::cout &lt;&lt; \"Kaboom!\\n\";\r\n} \r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Should we blow up the world again? (y\/n): \";\r\n    char c{};\r\n    std::cin &gt;&gt; c;\r\n\r\n    if (c = 'y') \/\/ uses assignment operator instead of equality operator\r\n        blowUpWorld();\r\n \r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\r\nShould we blow up the world again? (y\/n): n\r\nKaboom!\r\n<\/pre>\n<p>The assignment operator returns its left operand.  <code>c = 'y'<\/code> executes first, which assigns <code>y<\/code> to <code>c<\/code> and returns <code>c<\/code>.  Then <code>if (c)<\/code> is evaluated.  Since <code>c<\/code> is now non-zero, it is implicitly converted to  <code>bool<\/code> value <code>true<\/code>, and the statement associated with the if-statement executes.<\/p>\n<p>Because assignment inside a conditional is almost never intended, modern compilers will often warn when they encounter this.  However, if you aren&#8217;t in the habit of resolving all your warnings, such warnings can easily get lost.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Forgetting to use the function call operator when calling a function<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint getValue()\r\n{\r\n    return 5;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; getValue &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>While you might expect this program to print <code>5<\/code>, it will most likely print <code>1<\/code> (on some compilers, it will print a memory address in hex).<\/p>\n<p>Instead of using <code>getValue()<\/code> (which would call the function and produce an <code>int<\/code> return value), we&#8217;ve used <code>getValue<\/code> without the function call operator.  In many cases, this will result in a value that gets converted to <code>bool<\/code> value <code>true<\/code>).<\/p>\n<p>In our example above, it is this <code>bool<\/code> value <code>true<\/code> that is output, which prints <code>1<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Using a function&#8217;s name without calling it generally yields a function pointer holding the address of the function.  Such a function pointer will implicitly convert to a <code>bool<\/code> value.  And since this pointer should never have address <code>0<\/code>, that <code>bool<\/code> value will always be <code>true<\/code>.<\/p>\n<p>We cover function pointers in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-pointers\/\">20.1 -- Function Pointers<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">What else?<\/p>\n<p>The above represents a good sample of the most common type of semantic errors new C++ programmers tend to make, but there are plenty more.  Readers, if you have any additional ones that you think are common pitfalls, leave a note in the comments.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/detecting-and-handling-errors\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">9.4<\/span>Detecting and handling errors\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/code-coverage\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">9.2<\/span>Code coverage\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we covered syntax errors, which occur when you write code that is not valid according to the grammar of the C++ language. The compiler will notify you of such errors, so they are trivial to catch, and usually straightforward to fix. We also covered semantic errors, which &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/10563"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=10563"}],"version-history":[{"count":24,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/10563\/revisions"}],"predecessor-version":[{"id":17838,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/10563\/revisions\/17838"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=10563"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=10563"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=10563"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}