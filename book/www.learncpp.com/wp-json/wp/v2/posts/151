{"id":151,"date":"2007-11-09T15:39:53","date_gmt":"2007-11-09T23:39:53","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/912-shallow-vs-deep-copying\/"},"modified":"2023-09-11T12:40:40","modified_gmt":"2023-09-11T19:40:40","slug":"shallow-vs-deep-copying","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/shallow-vs-deep-copying\/","title":{"rendered":"21.13 &#8212; Shallow vs. deep copying"},"content":{"rendered":"<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Shallow copying<\/p>\n<p>Because C++ does not know much about your class, the default copy constructor and default assignment operators it provides use a copying method known as a memberwise copy (also known as a <strong>shallow copy<\/strong>).  This means that C++ copies each member of the class individually (using the assignment operator for overloaded operator=, and direct initialization for the copy constructor).  When classes are simple (e.g. do not contain any dynamically allocated memory), this works very well.<\/p>\n<p>For example, let&#8217;s take a look at our Fraction class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n \r\nclass Fraction\r\n{\r\nprivate:\r\n    int m_numerator { 0 };\r\n    int m_denominator { 1 };\r\n \r\npublic:\r\n    \/\/ Default constructor\r\n    Fraction(int numerator = 0, int denominator = 1)\r\n        : m_numerator{ numerator }\r\n        , m_denominator{ denominator }\r\n    {\r\n        assert(denominator != 0);\r\n    }\r\n \r\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1);\r\n};\r\n \r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)\r\n{\r\n\tout &lt;&lt; f1.m_numerator &lt;&lt; '\/' &lt;&lt; f1.m_denominator;\r\n\treturn out;\r\n}<\/code><\/pre>\n<p>The default copy constructor and default assignment operator provided by the compiler for this class look something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n \r\nclass Fraction\r\n{\r\nprivate:\r\n    int m_numerator { 0 };\r\n    int m_denominator { 1 };\r\n \r\npublic:\r\n    \/\/ Default constructor\r\n    Fraction(int numerator = 0, int denominator = 1)\r\n        : m_numerator{ numerator }\r\n        , m_denominator{ denominator }\r\n    {\r\n        assert(denominator != 0);\r\n    }\r\n \r\n    \/\/ Possible implementation of implicit copy constructor\r\n    Fraction(const Fraction&amp; f)\r\n        : m_numerator{ f.m_numerator }\r\n        , m_denominator{ f.m_denominator }\r\n    {\r\n    }\r\n\r\n    \/\/ Possible implementation of implicit assignment operator\r\n    Fraction&amp; operator= (const Fraction&amp; fraction)\r\n    {\r\n        \/\/ self-assignment guard\r\n        if (this == &amp;fraction)\r\n            return *this;\r\n \r\n        \/\/ do the copy\r\n        m_numerator = fraction.m_numerator;\r\n        m_denominator = fraction.m_denominator;\r\n \r\n        \/\/ return the existing object so we can chain this operator\r\n        return *this;\r\n    }\r\n\r\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)\r\n    {\r\n\tout &lt;&lt; f1.m_numerator &lt;&lt; '\/' &lt;&lt; f1.m_denominator;\r\n\treturn out;\r\n    }\r\n};<\/code><\/pre>\n<p>Note that because these default versions work just fine for copying this class, there&#8217;s really no reason to write our own version of these functions in this case.<\/p>\n<p>However, when designing classes that handle dynamically allocated memory, memberwise (shallow) copying can get us in a lot of trouble!  This is because shallow copies of a pointer just copy the address of the pointer -- it does not allocate any memory or copy the contents being pointed to!<\/p>\n<p>Let&#8217;s take a look at an example of this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cstring&gt; \/\/ for strlen()\r\n#include &lt;cassert&gt; \/\/ for assert()\r\n\r\nclass MyString\r\n{\r\nprivate:\r\n    char* m_data{};\r\n    int m_length{};\r\n \r\npublic:\r\n    MyString(const char* source = \"\" )\r\n    {\r\n        assert(source); \/\/ make sure source isn't a null string\r\n\r\n        \/\/ Find the length of the string\r\n        \/\/ Plus one character for a terminator\r\n        m_length = std::strlen(source) + 1;\r\n        \r\n        \/\/ Allocate a buffer equal to this length\r\n        m_data = new char[m_length];\r\n        \r\n        \/\/ Copy the parameter string into our internal buffer\r\n        for (int i{ 0 }; i &lt; m_length; ++i)\r\n            m_data[i] = source[i];\r\n    }\r\n \r\n    ~MyString() \/\/ destructor\r\n    {\r\n        \/\/ We need to deallocate our string\r\n        delete[] m_data;\r\n    }\r\n \r\n    char* getString() { return m_data; }\r\n    int getLength() { return m_length; }\r\n};<\/code><\/pre>\n<p>The above is a simple string class that allocates memory to hold a string that we pass in.  Note that we have not defined a copy constructor or overloaded assignment operator.  Consequently, C++ will provide a default copy constructor and default assignment operator that do a shallow copy.  The copy constructor will look something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">MyString::MyString(const MyString&amp; source)\r\n    : m_length { source.m_length }\r\n    , m_data { source.m_data }\r\n{\r\n}<\/code><\/pre>\n<p>Note that m_data is just a shallow pointer copy of source.m_data, meaning they now both point to the same thing.<\/p>\n<p>Now, consider the following snippet of code:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    MyString hello{ \"Hello, world!\" };\r\n    {\r\n        MyString copy{ hello }; \/\/ use default copy constructor\r\n    } \/\/ copy is a local variable, so it gets destroyed here.  The destructor deletes copy's string, which leaves hello with a dangling pointer\r\n\r\n    std::cout &lt;&lt; hello.getString() &lt;&lt; '\\n'; \/\/ this will have undefined behavior\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>While this code looks harmless enough, it contains an insidious problem that will cause the program to exhibit undefined behavior!<\/p>\n<p>Let&#8217;s break down this example line by line:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    MyString hello{ \"Hello, world!\" };<\/code><\/pre>\n<p>This line is harmless enough.  This calls the MyString constructor, which allocates some memory, sets hello.m_data to point to it, and then copies the string &#8220;Hello, world!&#8221; into it.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    MyString copy{ hello }; \/\/ use default copy constructor<\/code><\/pre>\n<p>This line seems harmless enough as well, but it&#8217;s actually the source of our problem!  When this line is evaluated, C++ will use the default copy constructor (because we haven&#8217;t provided our own).  This copy constructor will do a shallow copy, initializing copy.m_data to the same address of hello.m_data.  As a result, copy.m_data and hello.m_data are now both pointing to the same piece of memory!<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">} \/\/ copy gets destroyed here<\/code><\/pre>\n<p>When copy goes out of scope, the MyString destructor is called on copy.  The destructor deletes the dynamically allocated memory that both copy.m_data and hello.m_data are pointing to!  Consequently, by deleting copy, we&#8217;ve also (inadvertently) affected hello.  Variable copy then gets destroyed, but hello.m_data is left pointing to the deleted (invalid) memory!<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    std::cout &lt;&lt; hello.getString() &lt;&lt; '\\n'; \/\/ this will have undefined behavior<\/code><\/pre>\n<p>Now you can see why this program has undefined behavior.  We deleted the string that hello was pointing to, and now we are trying to print the value of memory that is no longer allocated.<\/p>\n<p>The root of this problem is the shallow copy done by the copy constructor -- doing a shallow copy on pointer values in a copy constructor or overloaded assignment operator is almost always asking for trouble.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Deep copying<\/p>\n<p>One answer to this problem is to do a deep copy on any non-null pointers being copied.  A <strong>deep copy<\/strong> allocates memory for the copy and then copies the actual value, so that the copy lives in distinct memory from the source.  This way, the copy and source are distinct and will not affect each other in any way.  Doing deep copies requires that we write our own copy constructors and overloaded assignment operators.<\/p>\n<p>Let&#8217;s go ahead and show how this is done for our MyString class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ assumes m_data is initialized\r\nvoid MyString::deepCopy(const MyString&amp; source)\r\n{\r\n    \/\/ first we need to deallocate any value that this string is holding!\r\n    delete[] m_data;\r\n\r\n    \/\/ because m_length is not a pointer, we can shallow copy it\r\n    m_length = source.m_length;\r\n\r\n    \/\/ m_data is a pointer, so we need to deep copy it if it is non-null\r\n    if (source.m_data)\r\n    {\r\n        \/\/ allocate memory for our copy\r\n        m_data = new char[m_length];\r\n\r\n        \/\/ do the copy\r\n        for (int i{ 0 }; i &lt; m_length; ++i)\r\n            m_data[i] = source.m_data[i];\r\n    }\r\n    else\r\n        m_data = nullptr;\r\n}\r\n\r\n\/\/ Copy constructor\r\nMyString::MyString(const MyString&amp; source)\r\n{\r\n    deepCopy(source);\r\n}<\/code><\/pre>\n<p>As you can see, this is quite a bit more involved than a simple shallow copy!  First, we have to check to make sure source even has a string (line 11).  If it does, then we allocate enough memory to hold a copy of that string (line 14).  Finally, we have to manually copy the string (lines 17 and 18).<\/p>\n<p>Now let&#8217;s do the overloaded assignment operator.  The overloaded assignment operator is slightly trickier:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Assignment operator\r\nMyString&amp; MyString::operator=(const MyString&amp; source)\r\n{\r\n    \/\/ check for self-assignment\r\n    if (this != &amp;source)\r\n    {\r\n        \/\/ now do the deep copy\r\n        deepCopy(source);\r\n    }\r\n\r\n    return *this;\r\n}<\/code><\/pre>\n<p>Note that our assignment operator is very similar to our copy constructor, but there are three major differences:<\/p>\n<ul>\n<li> We added a self-assignment check.\n<li> We return *this so we can chain the assignment operator.\n<li> We need to explicitly deallocate any value that the string is already holding (so we don&#8217;t have a memory leak when m_data is reallocated later).  This is handled inside deepCopy().\n<\/ul>\n<p>When the overloaded assignment operator is called, the item being assigned to may already contain a previous value, which we need to make sure we clean up before we assign memory for new values.  For non-dynamically allocated variables (which are a fixed size), we don&#8217;t have to bother because the new value just overwrites the old one.  However, for dynamically allocated variables, we need to explicitly deallocate any old memory before we allocate any new memory.  If we don&#8217;t, the code will not crash, but we will have a memory leak that will eat away our free memory every time we do an assignment!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The rule of three<\/p>\n<p>Remember the rule of three?  If a class requires a user-defined destructor, copy constructor, or copy assignment operator, then it probably requires all three.  This is why.  If we&#8217;re user-defining any of these functions, it&#8217;s probably because we&#8217;re dealing with dynamic memory allocation.  We need the copy constructor and copy assignment to handle deep copies, and the destructor to deallocate memory.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A better solution<\/p>\n<p>Classes in the standard library that deal with dynamic memory, such as std::string and std::vector, handle all of their memory management, and have overloaded copy constructors and assignment operators that do proper deep copying.  So instead of doing your own memory management, you can just initialize or assign them like normal fundamental variables!  That makes these classes simpler to use, less error-prone, and you don&#8217;t have to spend time writing your own overloaded functions!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Summary<\/p>\n<ul>\n<li>The default copy constructor and default assignment operators do shallow copies, which is fine for classes that contain no dynamically allocated variables.\n<li>Classes with dynamically allocated variables need to have a copy constructor and assignment operator that do a deep copy.\n<li>Favor using classes in the standard library over doing your own memory management.\n<\/ul>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-operators-and-function-templates\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.14<\/span>Overloading operators and function templates\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-the-assignment-operator\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.12<\/span>Overloading the assignment operator\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Shallow copying Because C++ does not know much about your class, the default copy constructor and default assignment operators it provides use a copying method known as a memberwise copy (also known as a shallow copy). This means that C++ copies each member of the class individually (using the assignment &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/151"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=151"}],"version-history":[{"count":42,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/151\/revisions"}],"predecessor-version":[{"id":15353,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/151\/revisions\/15353"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=151"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=151"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=151"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}