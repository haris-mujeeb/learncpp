{"id":17892,"date":"2024-11-26T16:49:45","date_gmt":"2024-11-27T00:49:45","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=17892"},"modified":"2025-03-17T11:19:26","modified_gmt":"2025-03-17T18:19:26","slug":"constexpr-functions-part-4","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-functions-part-4\/","title":{"rendered":"F.4 &#8212; Constexpr functions (part 4)"},"content":{"rendered":"<p class=\"cpp-section\">Constexpr\/consteval functions can use non-const local variables<\/p>\n<p>Within a constexpr or consteval function, we can use local variables that are not constexpr, and the value of these variables can be changed.<\/p>\n<p>As a silly example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nconsteval int doSomething(int x, int y) \/\/ function is consteval\r\n{\r\n    x = x + 2;       \/\/ we can modify the value of non-const function parameters\r\n\r\n    int z { x + y }; \/\/ we can instantiate non-const local variables\r\n    if (x &gt; y)\r\n        z = z - 1;   \/\/ and then modify their values\r\n\r\n    return z;\r\n}\r\n\r\nint main()\r\n{\r\n    constexpr int g { doSomething(5, 6) };\r\n    std::cout &lt;&lt; g &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When such functions are evaluated at compile-time, the compiler will essentially &#8220;execute&#8221; the function and return the calculated value.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constexpr\/consteval functions can use function parameters and local variables as arguments in constexpr function calls<\/p>\n<p>Above, we noted, &#8220;When a constexpr (or consteval) function is being evaluated at compile-time, any other functions it calls are required to be evaluated at compile-time.&#8221;<\/p>\n<p>Perhaps surprisingly, a constexpr or consteval function can use its function parameters (which aren&#8217;t constexpr) or even local variables (which may not be const at all) as arguments in a constexpr function call.  When a constexpr or consteval function is being evaluated at compile-time, the value of all function parameters and local variables must be known to the compiler (otherwise it couldn&#8217;t evaluate them at compile-time).  Therefore, in this specific context, C++ allows these values to be used as arguments in a call to a constexpr function, and that constexpr function call can still be evaluated at compile-time.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nconstexpr int goo(int c) \/\/ goo() is now constexpr\r\n{\r\n    return c;\r\n}\r\n\r\nconstexpr int foo(int b) \/\/ b is not a constant expression within foo()\r\n{\r\n    return goo(b);       \/\/ if foo() is resolved at compile-time, then `goo(b)` can also be resolved at compile-time\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; foo(5);\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, <code>foo(5)<\/code> may or may not be evaluated at compile time.  If it is, then the compiler knows that <code>b<\/code> is <code>5<\/code>.  And even though <code>b<\/code> is not constexpr, the compiler can treat the call to <code>goo(b)<\/code> as if it were <code>goo(5)<\/code> and evaluate that function call at compile-time.  If <code>foo(5)<\/code> is instead resolved at runtime, then <code>goo(b)<\/code> will also be resolved at runtime.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Can a constexpr function call a non-constexpr function?<\/p>\n<p>The answer is yes, but only when the constexpr function is being evaluated in a non-constant context.  A non-constexpr function may not be called when a constexpr function is evaluating in a constant context (because then the constexpr function wouldn&#8217;t be able to produce a compile-time constant value), and doing so will produce a compilation error.<\/p>\n<p>Calling a non-constexpr function is allowed so that a constexpr function can do something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;type_traits&gt; \/\/ for std::is_constant_evaluated\r\n\r\nconstexpr int someFunction()\r\n{\r\n    if (std::is_constant_evaluated()) \/\/ if evaluating in constant context\r\n        return someConstexprFcn();\r\n    else\r\n        return someNonConstexprFcn();\r\n}<\/code><\/pre>\n<p>Now consider this variant:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">constexpr int someFunction(bool b)\r\n{\r\n    if (b)\r\n        return someConstexprFcn();\r\n    else\r\n        return someNonConstexprFcn();\r\n}<\/code><\/pre>\n<p>This is legal as long as <code>someFunction(false)<\/code> is never called in a constant expression.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>Prior to C++23, the C++ standard says that a constexpr function must return a constexpr value for at least one set of arguments, otherwise it is technically ill-formed.  Calling a non-constexpr function unconditionally in a constexpr function makes the constexpr function ill-formed.  However, compilers are not required to generate errors or warnings for such cases -- therefore, the compiler probably won&#8217;t complain unless you try to call such a constexpr function in a constant context.  In C++23, this requirement was rescinded.\n<\/p><\/div>\n<p>For best results, we&#8217;d advise the following:<\/p>\n<ol start=\"1\">\n<li>Avoid calling non-constexpr functions from within a constexpr function if possible.\n<\/li>\n<li>If your constexpr function requires different behavior for constant and non-constant contexts, conditionalize the behavior with <code>if (std::is_constant_evaluated())<\/code> (in C++20) or <code>if consteval<\/code> (C++23 onward).\n<\/li>\n<li>Always test your constexpr functions in a constant context, as they may work when called in a non-constant context but fail in a constant context.\n<\/li>\n<\/ol>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">When should I constexpr a function?<\/p>\n<p>As a general rule, if a function can be evaluated as part of a required constant expression, it should be made <code>constexpr<\/code>.<\/p>\n<p>A <strong>pure function<\/strong> is a function that meets the following criteria:<\/p>\n<ul>\n<li>The function always returns the same return result when given the same arguments\n<\/li>\n<li>The function has no side effects (e.g. it doesn&#8217;t change the value of static local or global variables, doesn&#8217;t do input or output, etc&#8230;).\n<\/li>\n<\/ul>\n<p>Pure functions should generally be made constexpr.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>Constexpr functions don&#8217;t always need to be pure.  In C++23, constexpr functions can use and modify static local variables.  Since the value of a static local persists across function calls, modifying a static local variable is considered a side-effect.\n<\/p><\/div>\n<p>That said, if your program is trivial or a throw-away and you don&#8217;t constexpr a function, the world isn&#8217;t going to end.  Hopefully.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Unless you have a specific reason not to, a function that can be evaluated as part of a constant expression should be made <code>constexpr<\/code> (even if it isn&#8217;t currently used that way).<\/p>\n<p>A function that cannot be evaluated as part of a required constant expression should not be marked as <code>constexpr<\/code>.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Why not constexpr every function?<\/p>\n<p>There are a few reasons you may not want to <code>constexpr<\/code> a function:<\/p>\n<ol start=\"1\">\n<li><code>constexpr<\/code> signals that a function can be used in a constant expression.  If your function cannot be evaluated as part of a constant expression, it should not be marked as <code>constexpr<\/code>.\n<\/li>\n<li><code>constexpr<\/code> is part of the interface of a function.  Once a function is made constexpr, it can be called by other constexpr functions or used in contexts that require constant expressions.  Removing the <code>constexpr<\/code> later will break such code.\n<\/li>\n<li><code>constexpr<\/code> functions can be harder to debug since you can&#8217;t breakpoint or step through them in a debugger.\n<\/li>\n<\/ol>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><a name=\"constexprruntimeeval\"><\/a>Why constexpr a function when it is not actually evaluated at compile-time? <a href=\"#constexprruntimeeval\"><i class=\"fa fa-link\" style=\"font-size: 0.8em;\"><\/i><\/a><\/p>\n<p>New programmers sometimes ask, &#8220;why should I constexpr a function when it is only evaluated at runtime in my program (e.g. because the arguments in the function call are non-const)&#8221;?<\/p>\n<p>There are a few reasons:<\/p>\n<ol start=\"1\">\n<li>There&#8217;s little downside to using constexpr, and it may help the compiler optimize your program to be smaller and faster.\n<\/li>\n<li>Just because you&#8217;re not calling the function in a compile-time evaluatable context right now doesn&#8217;t mean you won&#8217;t call it in such a context when you modify or extend your program.  And if you haven&#8217;t constexpr&#8217;d the function already, you may not think to when you do start to call it in such a context, and then you&#8217;ll miss out on the performance benefits.  Or you may be forced to constexpr it later when you need to use the return value in a context that requires a constant expression somewhere.\n<\/li>\n<li>Repetition helps ingrain best practices.\n<\/li>\n<\/ol>\n<p>On a non-trivial project, it&#8217;s a good idea to implement your functions with the mindset that they may be reused (or extended) in the future.  Any time you modify an existing function, you risk breaking it, and that means it needs to be retested, which takes time and energy.  It&#8217;s often worth spending an extra minute or two &#8220;doing it right the first time&#8221; so you don&#8217;t have to redo (and retest) it again later.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-f-summary-and-quiz\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">F.X<\/span>Chapter F summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-functions-part-3-and-consteval\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">F.3<\/span>Constexpr functions (part 3) and consteval\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Constexpr\/consteval functions can use non-const local variables Within a constexpr or consteval function, we can use local variables that are not constexpr, and the value of these variables can be changed. As a silly example: #include &lt;iostream&gt; consteval int doSomething(int x, int y) \/\/ function is consteval { x = &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/17892"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=17892"}],"version-history":[{"count":6,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/17892\/revisions"}],"predecessor-version":[{"id":18253,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/17892\/revisions\/18253"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=17892"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=17892"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=17892"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}