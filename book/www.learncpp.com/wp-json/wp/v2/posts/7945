{"id":7945,"date":"2019-02-01T11:56:56","date_gmt":"2019-02-01T19:56:56","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=7945"},"modified":"2024-12-30T19:55:29","modified_gmt":"2024-12-31T03:55:29","slug":"basic-debugging-tactics","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/basic-debugging-tactics\/","title":{"rendered":"3.4 &#8212; Basic debugging tactics"},"content":{"rendered":"<p>In the previous lesson, we explored a strategy for finding issues by running our programs and using guesswork to home in on where the problem is.  In this lesson, we&#8217;ll explore some basic tactics for actually making those guesses and collecting information to help find issues.<\/p>\n<p class=\"cpp-section\">Debugging tactic #1: Commenting out your code<\/p>\n<p>Let&#8217;s start with an easy one.  If your program is exhibiting erroneous behavior, one way to reduce the amount of code you have to search through is to comment some code out and see if the issue persists.  If the issue remains unchanged, the commented out code probably wasn&#8217;t responsible.<\/p>\n<p>Consider the following code:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    getNames(); \/\/ ask user to enter a bunch of names\r\n    doMaintenance(); \/\/ do some random stuff\r\n    sortNames(); \/\/ sort them in alphabetical order\r\n    printNames(); \/\/ print the sorted list of names\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Let&#8217;s say this program is supposed to print the names the user enters in alphabetical order, but its printing them in reverse alphabetical order.  Where&#8217;s the problem?  Is <em>getNames<\/em> entering the names incorrectly?  Is <em>sortNames<\/em> sorting them backwards?  Is <em>printNames<\/em> printing them backwards?  It could be any of those things.  But we might suspect doMaintenance() has nothing to do with the problem, so let&#8217;s comment it out.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    getNames(); \/\/ ask user to enter a bunch of names\r\n\/\/    doMaintenance(); \/\/ do some random stuff\r\n    sortNames(); \/\/ sort them in alphabetical order\r\n    printNames(); \/\/ print the sorted list of names\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>There are three likely outcomes:<\/p>\n<ul>\n<li>If the problem goes away, then <em>doMaintenance<\/em> must be causing the problem, and we should focus our attention there.\n<\/li>\n<li>If the problem is unchanged (which is more likely), then we can reasonably assume that <em>doMaintenance<\/em> wasn&#8217;t at fault, and we can exclude the entire function from our search for now.  This doesn&#8217;t help us understand whether the actual problem is before or after the call to <em>doMaintenance<\/em>, but it reduces the amount of code we have to subsequently look through.\n<\/li>\n<li>If commenting out <em>doMaintenance<\/em> causes the problem to morph into some other related problem (e.g. the program stops printing names), then it&#8217;s likely that <em>doMaintenance<\/em> is doing something useful that some other code is dependent on.  In this case, we probably can&#8217;t tell whether the issue is in <em>doMaintenance<\/em> or elsewhere, so we can uncomment <em>doMaintenance<\/em> and try some other approach.\n<\/li>\n<\/ul>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Don&#8217;t forget which functions you&#8217;ve commented out so you can uncomment them later!<\/p>\n<p>After making many debugging-related changes, it&#8217;s very easy to miss undoing one or two.  If that happens, you&#8217;ll end up fixing one bug but introducing others!<\/p>\n<p>Having a good version control system is extremely useful here, as you can diff your code against the main branch to see all the debugging-related changes you&#8217;ve made (and ensure that they are reverted before you commit your change).\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>An alternate approach to repeatedly adding\/removing or uncommenting\/commenting debug statements is to use a 3rd party library that will let you leave debug statements in your code but compile them out in release mode via a preprocessor macro.  <a href=\"https:\/\/github.com\/sharkdp\/dbg-macro\/blob\/master\/dbg.h\">dbg<\/a> is one such header-only library that exists to help facilitate this (via the <code>DBG_MACRO_DISABLE<\/code> preprocessor macro).<\/p>\n<p>We discuss header-only libraries in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/inline-functions-and-variables\/\">7.9 -- Inline functions and variables<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Debugging tactic #2: Validating your code flow<\/p>\n<p>Another problem common in more complex programs is that the program is calling a function too many or too few times (including not at all).<\/p>\n<p>In such cases, it can be helpful to place statements at the top of your functions to print the function&#8217;s name.  That way, when the program runs, you can see which functions are getting called.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>When printing information for debugging purposes, use <code>std::cerr<\/code> instead of <code>std::cout<\/code>.  One reason for this is that <code>std::cout<\/code> may be buffered, which means a bit of time may pass between when you ask <code>std::cout<\/code> to output text and when it actually does.  If you output using <code>std::cout<\/code> and then your program crashes immediately afterward, <code>std::cout<\/code> may or may not have actually output yet.  This can mislead you about where the issue is.  On the other hand, <code>std::cerr<\/code> is unbuffered, which means anything you send to it will output immediately.  This helps ensure all debug output appears as soon as possible (at the cost of some performance, which we usually don&#8217;t care about when debugging).<\/p>\n<p>Using <code>std::cerr<\/code> also helps make clear that the information being output is for an error case rather than a normal case.<\/p>\n<p>We discuss when to use <code>std::cout<\/code> vs <code>std::cerr<\/code> further in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/detecting-and-handling-errors\/\">9.4 -- Detecting and handling errors<\/a>.\n<\/div>\n<p>Consider the following simple program that doesn&#8217;t work correctly:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint getValue()\r\n{\r\n\treturn 4;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; getValue &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>You may need to disable &#8220;Treat warnings as errors&#8221; for the above to compile.<\/p>\n<p>Although we expect this program to print the value <em>4<\/em>, it should print the value:<\/p>\n<pre>\r\n1\r\n<\/pre>\n<p>On Visual Studio (and possibly some other compilers), it may print the following instead:<\/p>\n<pre>\r\n00101424\r\n<\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We discuss why some compilers print <code>1<\/code> vs an address (and what to do if your compiler prints <code>1<\/code> but you want it to print an address) in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-pointers\/\">20.1 -- Function Pointers<\/a>.\n<\/div>\n<p>Let&#8217;s add some debugging statements to these functions:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint getValue()\r\n{\r\nstd::cerr &lt;&lt; \"getValue() called\\n\";\r\n\treturn 4;\r\n}\r\n\r\nint main()\r\n{\r\nstd::cerr &lt;&lt; \"main() called\\n\";\r\n    std::cout &lt;&lt; getValue &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>When adding temporary debug statements, it can be helpful to not indent them.  This makes them easier to find for removal later.<\/p>\n<p>If you are using clang-format to format your code, it will try to auto-indent these lines.  You can suppress the automatic formatting like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ clang-format off\r\nstd::cerr &lt;&lt; \"main() called\\n\";\r\n\/\/ clang-format on<\/code><\/pre>\n<\/div>\n<p>Now when these functions execute, they&#8217;ll output their names, indicating that they were called:<\/p>\n<pre>\r\nmain() called\r\n1\r\n<\/pre>\n<p>Now we can see that function <em>getValue<\/em> was never called.  There must be some problem with the code that calls the function.  Let&#8217;s take a closer look at that line:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    std::cout &lt;&lt; getValue &lt;&lt; '\\n';<\/code><\/pre>\n<p>Oh, look, we forgot the parenthesis on the function call.  It should be:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint getValue()\r\n{\r\nstd::cerr &lt;&lt; \"getValue() called\\n\";\r\n\treturn 4;\r\n}\r\n\r\nint main()\r\n{\r\nstd::cerr &lt;&lt; \"main() called\\n\";\r\n    std::cout &lt;&lt; getValue() &lt;&lt; '\\n'; \/\/ added parenthesis here\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This will now produce the correct output<\/p>\n<pre>\r\nmain() called\r\ngetValue() called\r\n4\r\n<\/pre>\n<p>And we can remove the temporary debugging statements.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Debugging tactic #3: Printing values<\/p>\n<p>With some types of bugs, the program may be calculating or passing the wrong value.<\/p>\n<p>We can also output the value of variables (including parameters) or expressions to ensure that they are correct.<\/p>\n<p>Consider the following program that is supposed to add two numbers but doesn&#8217;t work correctly:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y)\r\n{\r\n\treturn x + y;\r\n}\r\n\r\nvoid printResult(int z)\r\n{\r\n\tstd::cout &lt;&lt; \"The answer is: \" &lt;&lt; z &lt;&lt; '\\n';\r\n}\r\n\r\nint getUserInput()\r\n{\r\n\tstd::cout &lt;&lt; \"Enter a number: \";\r\n\tint x{};\r\n\tstd::cin &gt;&gt; x;\r\n\treturn x;\r\n}\r\n\r\nint main()\r\n{\r\n\tint x{ getUserInput() };\r\n\tint y{ getUserInput() };\r\n\r\n\tint z{ add(x, 5) };\r\n\tprintResult(z);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Here&#8217;s some output from this program:<\/p>\n<pre>\r\nEnter a number: 4\r\nEnter a number: 3\r\nThe answer is: 9\r\n<\/pre>\n<p>That&#8217;s not right.  Do you see the error?  Even in this short program, it can be hard to spot.  Let&#8217;s add some code to debug our values:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y)\r\n{\r\n\treturn x + y;\r\n}\r\n\r\nvoid printResult(int z)\r\n{\r\n\tstd::cout &lt;&lt; \"The answer is: \" &lt;&lt; z &lt;&lt; '\\n';\r\n}\r\n\r\nint getUserInput()\r\n{\r\n\tstd::cout &lt;&lt; \"Enter a number: \";\r\n\tint x{};\r\n\tstd::cin &gt;&gt; x;\r\n\treturn x;\r\n}\r\n\r\nint main()\r\n{\r\n\tint x{ getUserInput() };\r\nstd::cerr &lt;&lt; \"main::x = \" &lt;&lt; x &lt;&lt; '\\n';\r\n\tint y{ getUserInput() };\r\nstd::cerr &lt;&lt; \"main::y = \" &lt;&lt; y &lt;&lt; '\\n';\r\n\r\n\tint z{ add(x, 5) };\r\nstd::cerr &lt;&lt; \"main::z = \" &lt;&lt; z &lt;&lt; '\\n';\r\n\tprintResult(z);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Here&#8217;s the above output:<\/p>\n<pre>\r\nEnter a number: 4\r\nmain::x = 4\r\nEnter a number: 3\r\nmain::y = 3\r\nmain::z = 9\r\nThe answer is: 9\r\n<\/pre>\n<p>Variables <em>x<\/em> and <em>y<\/em> are getting the right values, but variable <em>z<\/em> isn&#8217;t.  The issue must be between those two points, which makes function <em>add<\/em> a key suspect.<\/p>\n<p>Let&#8217;s modify function add:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y)\r\n{\r\nstd::cerr &lt;&lt; \"add() called (x=\" &lt;&lt; x &lt;&lt;\", y=\" &lt;&lt; y &lt;&lt; \")\\n\";\r\n\treturn x + y;\r\n}\r\n\r\nvoid printResult(int z)\r\n{\r\n\tstd::cout &lt;&lt; \"The answer is: \" &lt;&lt; z &lt;&lt; '\\n';\r\n}\r\n\r\nint getUserInput()\r\n{\r\n\tstd::cout &lt;&lt; \"Enter a number: \";\r\n\tint x{};\r\n\tstd::cin &gt;&gt; x;\r\n\treturn x;\r\n}\r\n\r\nint main()\r\n{\r\n\tint x{ getUserInput() };\r\nstd::cerr &lt;&lt; \"main::x = \" &lt;&lt; x &lt;&lt; '\\n';\r\n\tint y{ getUserInput() };\r\nstd::cerr &lt;&lt; \"main::y = \" &lt;&lt; y &lt;&lt; '\\n';\r\n\r\n\tint z{ add(x, 5) };\r\nstd::cerr &lt;&lt; \"main::z = \" &lt;&lt; z &lt;&lt; '\\n';\r\n\tprintResult(z);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Now we&#8217;ll get the output:<\/p>\n<pre>\r\nEnter a number: 4\r\nmain::x = 4\r\nEnter a number: 3\r\nmain::y = 3\r\nadd() called (x=4, y=5)\r\nmain::z = 9\r\nThe answer is: 9\r\n<\/pre>\n<p>Variable <em>y<\/em> had value 3, but somehow our function <em>add<\/em> got the value 5 for parameter <em>y<\/em>.  We must have passed the wrong argument.  Sure enough:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\tint z{ add(x, 5) };<\/code><\/pre>\n<p>There it is.  We passed the literal <em>5<\/em> instead of the value of variable <em>y<\/em> as an argument.  That&#8217;s an easy fix, and then we can remove the debug statements.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">One more example<\/p>\n<p>This program is very similar to the prior one, but also doesn&#8217;t work like it should:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y)\r\n{\r\n\treturn x + y;\r\n}\r\n\r\nvoid printResult(int z)\r\n{\r\n\tstd::cout &lt;&lt; \"The answer is: \" &lt;&lt; z &lt;&lt; '\\n';\r\n}\r\n\r\nint getUserInput()\r\n{\r\n\tstd::cout &lt;&lt; \"Enter a number: \";\r\n\tint x{};\r\n\tstd::cin &gt;&gt; x;\r\n\treturn --x;\r\n}\r\n\r\nint main()\r\n{\r\n\tint x{ getUserInput() };\r\n\tint y{ getUserInput() };\r\n\r\n\tint z { add(x, y) };\r\n\tprintResult(z);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>If we run this code and see the following:<\/p>\n<pre>\r\nEnter a number: 4\r\nEnter a number: 3\r\nThe answer is: 5\r\n<\/pre>\n<p>Hmmm, something is wrong.  But where?<\/p>\n<p>Let&#8217;s instrument this code with some debugging:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y)\r\n{\r\nstd::cerr &lt;&lt; \"add() called (x=\" &lt;&lt; x &lt;&lt; \", y=\" &lt;&lt; y &lt;&lt; \")\\n\";\r\n\treturn x + y;\r\n}\r\n\r\nvoid printResult(int z)\r\n{\r\nstd::cerr &lt;&lt; \"printResult() called (z=\" &lt;&lt; z &lt;&lt; \")\\n\";\r\n\tstd::cout &lt;&lt; \"The answer is: \" &lt;&lt; z &lt;&lt; '\\n';\r\n}\r\n\r\nint getUserInput()\r\n{\r\nstd::cerr &lt;&lt; \"getUserInput() called\\n\";\r\n\tstd::cout &lt;&lt; \"Enter a number: \";\r\n\tint x{};\r\n\tstd::cin &gt;&gt; x;\r\n\treturn --x;\r\n}\r\n\r\nint main()\r\n{\r\nstd::cerr &lt;&lt; \"main() called\\n\";\r\n\tint x{ getUserInput() };\r\nstd::cerr &lt;&lt; \"main::x = \" &lt;&lt; x &lt;&lt; '\\n';\r\n\tint y{ getUserInput() };\r\nstd::cerr &lt;&lt; \"main::y = \" &lt;&lt; y &lt;&lt; '\\n';\r\n\r\n\tint z{ add(x, y) };\r\nstd::cerr &lt;&lt; \"main::z = \" &lt;&lt; z &lt;&lt; '\\n';\r\n\tprintResult(z);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Now let&#8217;s run the program again with the same inputs:<\/p>\n<pre>\r\nmain() called\r\ngetUserInput() called\r\nEnter a number: 4\r\nmain::x = 3\r\ngetUserInput() called\r\nEnter a number: 3\r\nmain::y = 2\r\nadd() called (x=3, y=2)\r\nmain::z = 5\r\nprintResult() called (z=5)\r\nThe answer is: 5\r\n<\/pre>\n<p>Now we can immediately see something going wrong: The user is entering the value <em>4<\/em>, but main&#8217;s <em>x<\/em> is getting value <em>3<\/em>.  Something must be going wrong between where the user enters input and where that value is assigned to main&#8217;s variable <em>x<\/em>.  Let&#8217;s make sure that the program is getting the correct value from the user by adding some debug code to function <em>getUserInput<\/em>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y)\r\n{\r\nstd::cerr &lt;&lt; \"add() called (x=\" &lt;&lt; x &lt;&lt; \", y=\" &lt;&lt; y &lt;&lt; \")\\n\";\r\n\treturn x + y;\r\n}\r\n\r\nvoid printResult(int z)\r\n{\r\nstd::cerr &lt;&lt; \"printResult() called (z=\" &lt;&lt; z &lt;&lt; \")\\n\";\r\n\tstd::cout &lt;&lt; \"The answer is: \" &lt;&lt; z &lt;&lt; '\\n';\r\n}\r\n\r\nint getUserInput()\r\n{\r\nstd::cerr &lt;&lt; \"getUserInput() called\\n\";\r\n\tstd::cout &lt;&lt; \"Enter a number: \";\r\n\tint x{};\r\n\tstd::cin &gt;&gt; x;\r\nstd::cerr &lt;&lt; \"getUserInput::x = \" &lt;&lt; x &lt;&lt; '\\n'; \/\/ added this additional line of debugging\r\n\treturn --x;\r\n}\r\n\r\nint main()\r\n{\r\nstd::cerr &lt;&lt; \"main() called\\n\";\r\n\tint x{ getUserInput() };\r\nstd::cerr &lt;&lt; \"main::x = \" &lt;&lt; x &lt;&lt; '\\n';\r\n\tint y{ getUserInput() };\r\nstd::cerr &lt;&lt; \"main::y = \" &lt;&lt; y &lt;&lt; '\\n';\r\n\r\n\tint z{ add(x, y) };\r\nstd::cerr &lt;&lt; \"main::z = \" &lt;&lt; z &lt;&lt; '\\n';\r\n\tprintResult(z);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>And the output:<\/p>\n<pre>\r\nmain() called\r\ngetUserInput() called\r\nEnter a number: 4\r\ngetUserInput::x = 4\r\nmain::x = 3\r\ngetUserInput() called\r\nEnter a number: 3\r\ngetUserInput::x = 3\r\nmain::y = 2\r\nadd() called (x=3, y=2)\r\nmain::z = 5\r\nprintResult() called (z=5)\r\nThe answer is: 5\r\n<\/pre>\n<p>With this additional line of debugging, we can see that the user input is received correctly into getUserInput&#8217;s variable <em>x<\/em>.  And yet somehow main&#8217;s variable <em>x<\/em> is getting the wrong value.  The problem must be between those two points.  The only culprit left is the return value from function <em>getUserInput<\/em>.  Let&#8217;s look at that line more closely.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\treturn --x;<\/code><\/pre>\n<p>Hmmm, that&#8217;s odd.  What&#8217;s that <code>--<\/code> symbol before x?  We haven&#8217;t covered that yet in these tutorials, so don&#8217;t worry if you don&#8217;t know what it means.  But even without knowing what it means, through your debugging efforts, you can be reasonably sure that this particular line is at fault -- and thus, it&#8217;s likely this <code>--<\/code> symbol is causing the problem.<\/p>\n<p>Since we really want <em>getUserInput<\/em> to return just the value of <em>x<\/em>, let&#8217;s remove the <code>--<\/code> and see what happens:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y)\r\n{\r\nstd::cerr &lt;&lt; \"add() called (x=\" &lt;&lt; x &lt;&lt; \", y=\" &lt;&lt; y &lt;&lt; \")\\n\";\r\n\treturn x + y;\r\n}\r\n\r\nvoid printResult(int z)\r\n{\r\nstd::cerr &lt;&lt; \"printResult() called (z=\" &lt;&lt; z &lt;&lt; \")\\n\";\r\n\tstd::cout &lt;&lt; \"The answer is: \" &lt;&lt; z &lt;&lt; '\\n';\r\n}\r\n\r\nint getUserInput()\r\n{\r\nstd::cerr &lt;&lt; \"getUserInput() called\\n\";\r\n\tstd::cout &lt;&lt; \"Enter a number: \";\r\n\tint x{};\r\n\tstd::cin &gt;&gt; x;\r\nstd::cerr &lt;&lt; \"getUserInput::x = \" &lt;&lt; x &lt;&lt; '\\n';\r\n\treturn x; \/\/ removed -- before x\r\n}\r\n\r\nint main()\r\n{\r\nstd::cerr &lt;&lt; \"main() called\\n\";\r\n\tint x{ getUserInput() };\r\nstd::cerr &lt;&lt; \"main::x = \" &lt;&lt; x &lt;&lt; '\\n';\r\n\tint y{ getUserInput() };\r\nstd::cerr &lt;&lt; \"main::y = \" &lt;&lt; y &lt;&lt; '\\n';\r\n\r\n\tint z{ add(x, y) };\r\nstd::cerr &lt;&lt; \"main::z = \" &lt;&lt; z &lt;&lt; '\\n';\r\n\tprintResult(z);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>And now the output:<\/p>\n<pre>\r\nmain() called\r\ngetUserInput() called\r\nEnter a number: 4\r\ngetUserInput::x = 4\r\nmain::x = 4\r\ngetUserInput() called\r\nEnter a number: 3\r\ngetUserInput::x = 3\r\nmain::y = 3\r\nadd() called (x=4, y=3)\r\nmain::z = 7\r\nprintResult() called (z=7)\r\nThe answer is: 7\r\n<\/pre>\n<p>The program is now working correctly.  Even without understanding what <code>--<\/code> was doing, we were able to identify the specific line of code causing the issue, and then fix the issue.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Why using printing statements to debug isn&#8217;t great<\/p>\n<p>While adding debug statements to programs for diagnostic purposes is a common rudimentary technique, and a functional one (especially when a debugger is not available for some reason), it&#8217;s not that great for a number of reasons:<\/p>\n<ol>\n<li>Debug statements clutter your code.<\/li>\n<li>Debug statements clutter the output of your program.<\/li>\n<li>Debug statements require modification of your code to both add and to remove, which can introduce new bugs.<\/li>\n<li>Debug statements must be removed after you&#8217;re done with them, which makes them non-reusable.<\/li>\n<\/ol>\n<p>We can do better.  We&#8217;ll explore how in future lessons.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/more-debugging-tactics\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">3.5<\/span>More debugging tactics\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/a-strategy-for-debugging\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">3.3<\/span>A strategy for debugging\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the previous lesson, we explored a strategy for finding issues by running our programs and using guesswork to home in on where the problem is. In this lesson, we&#8217;ll explore some basic tactics for actually making those guesses and collecting information to help find issues. Let&#8217;s start with an &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/7945"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=7945"}],"version-history":[{"count":30,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/7945\/revisions"}],"predecessor-version":[{"id":18054,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/7945\/revisions\/18054"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=7945"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=7945"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=7945"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}