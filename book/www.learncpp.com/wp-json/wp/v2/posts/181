{"id":181,"date":"2008-02-01T13:50:23","date_gmt":"2008-02-01T21:50:23","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/123-virtual-destructors-virtual-assignment-and-overriding-virtualization\/"},"modified":"2024-10-18T17:01:10","modified_gmt":"2024-10-19T00:01:10","slug":"virtual-destructors-virtual-assignment-and-overriding-virtualization","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/virtual-destructors-virtual-assignment-and-overriding-virtualization\/","title":{"rendered":"25.4 &#8212; Virtual destructors, virtual assignment, and overriding virtualization"},"content":{"rendered":"<p class=\"cpp-section\">Virtual destructors<\/p>\n<p>Although C++ provides a default destructor for your classes if you do not provide one yourself, it is sometimes the case that you will want to provide your own destructor (particularly if the class needs to deallocate memory).  You should <em>always<\/em> make your destructors virtual if you&#8217;re dealing with inheritance.  Consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\nclass Base\r\n{\r\npublic:\r\n    ~Base() \/\/ note: not virtual\r\n    {\r\n        std::cout &lt;&lt; \"Calling ~Base()\\n\";\r\n    }\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\nprivate:\r\n    int* m_array {};\r\n\r\npublic:\r\n    Derived(int length)\r\n      : m_array{ new int[length] }\r\n    {\r\n    }\r\n\r\n    ~Derived() \/\/ note: not virtual (your compiler may warn you about this)\r\n    {\r\n        std::cout &lt;&lt; \"Calling ~Derived()\\n\";\r\n        delete[] m_array;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Derived* derived { new Derived(5) };\r\n    Base* base { derived };\r\n\r\n    delete base;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Note: If you compile the above example, your compiler may warn you about the non-virtual destructor (which is intentional for this example).  You may need to disable the compiler flag that treats warnings as errors to proceed.<\/p>\n<p>Because base is a Base pointer, when base is deleted, the program looks to see if the Base destructor is virtual.  It&#8217;s not, so it assumes it only needs to call the Base destructor.  We can see this in the fact that the above example prints:<\/p>\n<pre>\r\nCalling ~Base()\r\n<\/pre>\n<p>However, we really want the delete function to call Derived&#8217;s destructor (which will call Base&#8217;s destructor in turn), otherwise m_array will not be deleted.  We do this by making Base&#8217;s destructor virtual:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\nclass Base\r\n{\r\npublic:\r\n    virtual ~Base() \/\/ note: virtual\r\n    {\r\n        std::cout &lt;&lt; \"Calling ~Base()\\n\";\r\n    }\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\nprivate:\r\n    int* m_array {};\r\n\r\npublic:\r\n    Derived(int length)\r\n      : m_array{ new int[length] }\r\n    {\r\n    }\r\n\r\n    virtual ~Derived() \/\/ note: virtual\r\n    {\r\n        std::cout &lt;&lt; \"Calling ~Derived()\\n\";\r\n        delete[] m_array;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Derived* derived { new Derived(5) };\r\n    Base* base { derived };\r\n\r\n    delete base;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Now this program produces the following result:<\/p>\n<pre>\r\nCalling ~Derived()\r\nCalling ~Base()\r\n<\/pre>\n<div class=\"cpp-note cpp-lightpurplebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Rule<\/p>\n<p>Whenever you are dealing with inheritance, you should make any explicit destructors virtual.\n<\/p><\/div>\n<p>As with normal virtual member functions, if a base class function is virtual, all derived overrides will be considered virtual regardless of whether they are specified as such.  It is not necessary to create an empty derived class destructor just to mark it as virtual.<\/p>\n<p>Note that if you want your base class to have a virtual destructor that is otherwise empty, you can define your destructor this way:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    virtual ~Base() = default; \/\/ generate a virtual default destructor<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Virtual assignment<\/p>\n<p>It is possible to make the assignment operator virtual.  However, unlike the destructor case where virtualization is always a good idea, virtualizing the assignment operator really opens up a bag full of worms and gets into some advanced topics outside of the scope of this tutorial.  Consequently, we are going to recommend you leave your assignments non-virtual for now, in the interest of simplicity.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Ignoring virtualization<\/p>\n<p>Very rarely you may want to ignore the virtualization of a function.  For example, consider the following code:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string_view&gt;\r\nclass Base\r\n{\r\npublic:\r\n    virtual ~Base() = default;\r\n    virtual std::string_view getName() const { return \"Base\"; }\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\npublic:\r\n    virtual std::string_view getName() const { return \"Derived\"; }\r\n};<\/code><\/pre>\n<p>There may be cases where you want a Base pointer to a Derived object to call Base::getName() instead of Derived::getName().  To do so, simply use the scope resolution operator:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\nint main()\r\n{\r\n    Derived derived {};\r\n    const Base&amp; base { derived };\r\n\r\n    \/\/ Calls Base::getName() instead of the virtualized Derived::getName()\r\n    std::cout &lt;&lt; base.Base::getName() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>You probably won&#8217;t use this very often, but it&#8217;s good to know it&#8217;s at least possible.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Should we make all destructors virtual?<\/p>\n<p>This is a common question asked by new programmers.  As noted in the top example, if the base class destructor isn&#8217;t marked as virtual, then the program is at risk for leaking memory if a programmer later deletes a base class pointer that is pointing to a derived object.  One way to avoid this is to mark all your destructors as virtual.  But should you?<\/p>\n<p>It&#8217;s easy to say yes, so that way you can later use any class as a base class -- but there&#8217;s a performance penalty for doing so (a virtual pointer added to every instance of your class). So you have to balance that cost, as well as your intent.<\/p>\n<p>We&#8217;d suggest the following: If a class isn&#8217;t explicitly designed to be a base class, then it&#8217;s generally better to have no virtual members and no virtual destructor.  The class can still be used via composition.  If a class is designed to be used as a base class and\/or has any virtual functions, then it should always have a virtual destructor.<\/p>\n<p>If the decision is made to have a class not be inheritable, then the next question is whether it&#8217;s possible to enforce this.<\/p>\n<p>Conventional wisdom (as initially put forth by Herb Sutter, a highly regarded C++ guru) has suggested avoiding the non-virtual destructor memory leak situation as follows, &#8220;A base class destructor should be either public and virtual, or protected and non-virtual.&#8221;  A base class with a protected destructor can&#8217;t be deleted using a base class pointer, which prevents deleting a derived class object through a base class pointer.<\/p>\n<p>Unfortunately, this also prevents <em>any<\/em> use of the base class destructor by the public.  That means:<\/p>\n<ul>\n<li>We shouldn&#8217;t dynamically allocate base class objects by we have no conventional way to delete them (there are non-conventional workarounds, but yuck).\n<\/li>\n<li>We can&#8217;t even statically allocate base class objects because the destructor isn&#8217;t accessible when they go out of scope.\n<\/li>\n<\/ul>\n<p>In other words, using this method, to make the derived class safe, we have to make the base class practically unusable by itself.<\/p>\n<p>Now that the <code>final<\/code> specifier has been introduced into the language, our recommendations are as follows:<\/p>\n<ul>\n<li>If you intend your class to be inherited from, make sure your destructor is virtual and public.\n<\/li>\n<li>If you do not intend your class to be inherited from, mark your class as final.  This will prevent other classes from inheriting from it in the first place, without imposing any other use restrictions on the class itself.\n<\/li>\n<\/ul>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/early-binding-and-late-binding\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">25.5<\/span>Early binding and late binding\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/the-override-and-final-specifiers-and-covariant-return-types\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">25.3<\/span>The override and final specifiers, and covariant return types\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Virtual destructors Although C++ provides a default destructor for your classes if you do not provide one yourself, it is sometimes the case that you will want to provide your own destructor (particularly if the class needs to deallocate memory). You should always make your destructors virtual if you&#8217;re dealing &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/181"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=181"}],"version-history":[{"count":28,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/181\/revisions"}],"predecessor-version":[{"id":17770,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/181\/revisions\/17770"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=181"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=181"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=181"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}