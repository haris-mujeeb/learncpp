{"id":16354,"date":"2023-12-28T17:30:43","date_gmt":"2023-12-29T01:30:43","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=16354"},"modified":"2024-09-28T15:03:55","modified_gmt":"2024-09-28T22:03:55","slug":"chapter-11-summary-and-quiz","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-11-summary-and-quiz\/","title":{"rendered":"11.x &#8212; Chapter 11 summary and quiz"},"content":{"rendered":"<p>Nice work.  Function templates may seem pretty complex, but they are a very powerful way to make your code work with objects of different types.  We&#8217;ll see a lot more template stuff in future chapters, so hold on to your hat.<\/p>\n<p class=\"cpp-section\">Chapter Review<\/p>\n<p><strong>Function overloading<\/strong> allows us to create multiple functions with the same name, so long as each identically named function has different set of parameter types (or the functions can be otherwise differentiated).  Such a function is called an <strong>overloaded function<\/strong> (or <strong>overload<\/strong> for short).  Return types are not considered for differentiation.  <\/p>\n<p>When resolving overloaded functions, if an exact match isn&#8217;t found, the compiler will favor overloaded functions that can be matched via numeric promotions over those that require numeric conversions.  When a function call is made to function that has been overloaded, the compiler will try to match the function call to the appropriate overload based on the arguments used in the function call.  This is called <strong>overload resolution<\/strong>.<\/p>\n<p>An <strong>ambiguous match<\/strong> occurs when the compiler finds two or more functions that can match a function call to an overloaded function and can&#8217;t determine which one is best.<\/p>\n<p>A <strong>default argument<\/strong> is a default value provided for a function parameter.  Parameters with default arguments must always be the rightmost parameters, and they are not used to differentiate functions when resolving overloaded functions.<\/p>\n<p><strong>Function templates<\/strong> allow us to create a function-like definition that serves as a pattern for creating related functions.  In a function template, we use <strong>type template parameters<\/strong> as placeholders for any types we want to be specified later.  The syntax that tells the compiler we&#8217;re defining a template and declares the template types is called a <strong>template parameter declaration<\/strong>.  <\/p>\n<p>The process of creating functions (with specific types) from function templates (with template types) is called <strong>function template instantiation<\/strong> (or <strong>instantiation<\/strong>) for short.  When this process happens due to a function call, it&#8217;s called <strong>implicit instantiation<\/strong>.  An instantiated function is called a <strong>function instance<\/strong> (or <strong>instance<\/strong> for short, or sometimes a <strong>template function<\/strong>).<\/p>\n<p><strong>Template argument deduction<\/strong> allows the compiler to deduce the actual type that should be used to instantiate a function from the arguments of the function call.  Template argument deduction does not do type conversion.<\/p>\n<p>Template types are sometimes called <strong>generic types<\/strong>, and programming using templates is sometimes called <strong>generic programming<\/strong>.<\/p>\n<p>In C++20, when the auto keyword is used as a parameter type in a normal function, the compiler will automatically convert the function into a function template with each auto parameter becoming an independent template type parameter. This method for creating a function template is called an <strong>abbreviated function template<\/strong>.<\/p>\n<p>A <strong>non-type template parameter<\/strong> is a template parameter with a fixed type that serves as a placeholder for a constexpr value passed in as a template argument.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>1a) What is the output of this program and why?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid print(int x)\r\n{\r\n    std::cout &lt;&lt; \"int \" &lt;&lt; x &lt;&lt; '\\n';\r\n}\r\n\r\nvoid print(double x)\r\n{\r\n    std::cout &lt;&lt; \"double \" &lt;&lt; x &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    short s { 5 };\r\n    print(s);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>The output is <code>int 5<\/code>.  Converting a <code>short<\/code> to an <code>int<\/code> is a numeric promotion, whereas converting a <code>short<\/code> to a <code>double<\/code> is a numeric conversion.  The compiler will favor the option that is a numeric promotion over the option that is a numeric conversion.\n<\/div>\n<p>1b) Why won&#8217;t the following compile?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid print()\r\n{\r\n    std::cout &lt;&lt; \"void\\n\";\r\n}\r\n\r\nvoid print(int x=0)\r\n{\r\n    std::cout &lt;&lt; \"int \" &lt;&lt; x &lt;&lt; '\\n';\r\n}\r\n\r\nvoid print(double x)\r\n{\r\n    std::cout &lt;&lt; \"double \" &lt;&lt; x &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    print(5.0f);\r\n    print();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p>Because parameters with default arguments aren&#8217;t counted for resolving overloaded functions, the compiler can&#8217;t tell whether the call to <code>print()<\/code> should resolve to <code>print()<\/code> or <code>print(int x=0)<\/code>.\n<\/div>\n<p>1c) Why won&#8217;t the following compile?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid print(long x)\r\n{\r\n    std::cout &lt;&lt; \"long \" &lt;&lt; x &lt;&lt; '\\n';\r\n}\r\n\r\nvoid print(double x)\r\n{\r\n    std::cout &lt;&lt; \"double \" &lt;&lt; x &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    print(5);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<p>The literal 5 is an <code>int<\/code>.  Converting an <code>int<\/code> to a <code>long<\/code> or a <code>double<\/code> is a numeric conversion, and the compiler will be unable to determine which function is a better match.\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #1<\/p>\n<p>Write a function template named <code>add()<\/code> that allows the users to add 2 values of the same type.  The following program should run:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ write your add function template here\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; add(2, 3) &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; add(1.2, 3.4) &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>and produce the following output:<\/p>\n<pre>\n5\r\n4.6\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nT add(T x, T y)\r\n{\r\n\treturn x + y;\r\n}\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; add(2, 3) &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; add(1.2, 3.4) &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p><p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #2<\/p><br \/>\nWrite a function template named <code>mult()<\/code> that allows the user to multiply one value of any type (first parameter) and an integer (second parameter).  The second parameter should not be a template type.  The function should return the same type as the first parameter.  The following program should run:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ write your mult function template here\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; mult(2, 3) &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; mult(1.2, 3) &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>and produce the following output:<\/p>\n<pre>\n6\r\n3.6\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nT mult(T x, int y)\r\n{\r\n\treturn x * y;\r\n}\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; mult(2, 3) &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; mult(1.2, 3) &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #3<\/p>\n<p>Write a function template named <code>sub()<\/code> that allows the user to subtract two values of different types.  The following program should run:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ write your sub function template here\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; sub(3, 2) &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; sub(3.5, 2) &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; sub(4, 1.5) &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>and produce the following output:<\/p>\n<pre>\n1\r\n1.5\r\n2.5\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_5'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_5\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T, typename U&gt;\r\nauto sub(T x, U y)\r\n{\r\n\treturn x - y;\r\n}\r\n\r\n\/* \r\n\/\/If C++20 capable, you can use an abbreviated function template instead\r\nauto sub(auto x, auto y)\r\n{\r\n\treturn x - y;\r\n}\r\n*\/\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; sub(3, 2) &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; sub(3.5, 2) &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; sub(4, 1.5) &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #3<\/p>\n<p>What is the output of this program and why?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nint count(T) \/\/ This is the same as int count(T x), except we're not giving the parameter a name since we don't use the parameter\r\n{\r\n    static int c { 0 };\r\n    return ++c;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; count(1) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; count(1) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; count(2.3) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; count&lt;double&gt;(1) &lt;&lt; '\\n';\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_6'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_6\" style=\"display:none\">\n<pre>\n1\r\n2\r\n1\r\n2\r\n<\/pre>\n<p>When <code>count(1)<\/code> is called, the compiler will instantiate the function <code>count&lt;int&gt;(int)<\/code> and call it.  This will return value <code>1<\/code>.<\/p>\n<p>When <code>count(1)<\/code> is called again, the compiler will see that <code>count&lt;int&gt;(int)<\/code> already exists, and call it again.  This will return value <code>2<\/code>.<\/p>\n<p>When <code>count(2.3)<\/code> is called, the compiler will instantiate the function with prototype <code>count&lt;double&gt;(double)<\/code> and call it.  This is a new function with its own <code>static c<\/code> variable, so this will return value <code>1<\/code>.<\/p>\n<p>When <code>count&lt;double&gt;(1)<\/code> is called, the compiler will see that we&#8217;re explicitly requesting the double version of <code>count()<\/code>.  This function already exists due to the prior statement, so <code>count&lt;double&gt;(double)<\/code> will be called and the <code>int<\/code> argument will be implicitly converted to a <code>double<\/code>.  This function will return value <code>2<\/code>.\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #4<\/p>\n<p>What is the output of this program?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint foo(int n)\r\n{\r\n    return n + 10;\r\n}\r\n\r\ntemplate &lt;typename T&gt;\r\nint foo(T n)\r\n{\r\n    return n;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; foo(1) &lt;&lt; '\\n'; \/\/ #1\r\n\r\n    short s { 2 };\r\n    std::cout &lt;&lt; foo(s) &lt;&lt; '\\n'; \/\/ #2\r\n    \r\n    std::cout &lt;&lt; foo&lt;int&gt;(4) &lt;&lt; '\\n'; \/\/ #3\r\n\r\n    std::cout &lt;&lt; foo&lt;int&gt;(s) &lt;&lt; '\\n'; \/\/ #4\r\n\r\n    std::cout &lt;&lt; foo&lt;&gt;(6) &lt;&lt; '\\n'; \/\/ #5\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_7'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_7\" style=\"display:none\">\n<pre>\n11\r\n2\r\n4\r\n2\r\n6\r\n<\/pre>\n<p>In case 1, <code>foo(1)<\/code> matches <code>foo(int)<\/code> exactly, so non-template function <code>foo(int)<\/code> is called.<\/p>\n<p>In case 2, <code>foo(s)<\/code> does not match non-template function <code>foo(int)<\/code> exactly, but the argument <code>s<\/code> can be converted to an <code>int<\/code> so <code>foo(int)<\/code> is a candidate.  However, the compiler will prefer to use function template <code>foo&lt;T&gt;(T)<\/code> to stencil out exact match <code>foo&lt;short&gt;(short)<\/code>.  So this calls <code>foo&lt;short&gt;(short)<\/code>.<\/p>\n<p>In case 3, <code>foo&lt;int&gt;(4)<\/code> is an explicit call to <code>foo&lt;int&gt;<\/code>, so <code>foo(int)<\/code> isn&#8217;t considered.  The compiler stencils out <code>foo&lt;int&gt;(int)<\/code> and calls it.<\/p>\n<p>In case 4, this is also an explicit call to <code>foo&lt;int&gt;<\/code>.  The compiler promotes argument <code>s<\/code> to an <code>int<\/code> to match the parameter.<\/p>\n<p>In case 5, this syntax will only match function templates, so <code>foo(int)<\/code> is not considered.  <code>foo&lt;int&gt;(int)<\/code> is called.\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-functions\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">F.1<\/span>Constexpr functions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/using-function-templates-in-multiple-files\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">11.10<\/span>Using function templates in multiple files\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Nice work. Function templates may seem pretty complex, but they are a very powerful way to make your code work with objects of different types. We&#8217;ll see a lot more template stuff in future chapters, so hold on to your hat. Chapter Review allows us to create multiple functions with &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/16354"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=16354"}],"version-history":[{"count":7,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/16354\/revisions"}],"predecessor-version":[{"id":17675,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/16354\/revisions\/17675"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=16354"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=16354"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=16354"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}