{"id":13001,"date":"2022-04-24T19:49:30","date_gmt":"2022-04-25T02:49:30","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=13001"},"modified":"2024-03-25T14:48:52","modified_gmt":"2024-03-25T21:48:52","slug":"class-template-argument-deduction-ctad-and-deduction-guides","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/class-template-argument-deduction-ctad-and-deduction-guides\/","title":{"rendered":"13.14 &#8212; Class template argument deduction (CTAD) and deduction guides"},"content":{"rendered":"<p class=\"cpp-section\"><a name=\"CTAD\"><\/a>Class template argument deduction (CTAD) <span class=\"cpp-section-pill cpp-section-standard\">C++17<\/span> <a href=\"#CTAD\"><i class=\"fa fa-link\" style=\"font-size: 0.8em;\"><\/i><\/a><\/p>\n<p>Starting in C++17, when instantiating an object from a class template, the compiler can deduce the template types from the types of the object&#8217;s initializer (this is called <strong>class template argument deduction<\/strong> or <strong>CTAD<\/strong> for short).  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;utility&gt; \/\/ for std::pair\r\n\r\nint main()\r\n{\r\n    std::pair&lt;int, int&gt; p1{ 1, 2 }; \/\/ explicitly specify class template std::pair&lt;int, int&gt; (C++11 onward)\r\n    std::pair p2{ 1, 2 };           \/\/ CTAD used to deduce std::pair&lt;int, int&gt; from the initializers (C++17)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>CTAD is only performed if no template argument list is present.  Therefore, both of the following are errors:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;utility&gt; \/\/ for std::pair\r\n\r\nint main()\r\n{\r\n    std::pair&lt;&gt; p1 { 1, 2 };    \/\/ error: too few template arguments, both arguments not deduced\r\n    std::pair&lt;int&gt; p2 { 3, 4 }; \/\/ error: too few template arguments, second argument not deduced\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>Many future lessons on this site make use of CTAD.  If you&#8217;re compiling these examples using the C++14 standard (or older), you&#8217;ll get an error about missing template arguments.  You&#8217;ll need to explicitly add such arguments to the example to make it compile.\n<\/p><\/div>\n<p>Since CTAD is a form of type deduction, we can use literal suffixes to change the deduced type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;utility&gt; \/\/ for std::pair\r\n\r\nint main()\r\n{\r\n    std::pair p1 { 3.4f, 5.6f }; \/\/ deduced to pair&lt;float, float&gt;\r\n    std::pair p2 { 1u, 2u };     \/\/ deduced to pair&lt;unsigned int, unsigned int&gt;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><a name=\"DeductionGuide\"><\/a>Template argument deduction guides <span class=\"cpp-section-pill cpp-section-standard\">C++17<\/span> <a href=\"#DeductionGuide\"><i class=\"fa fa-link\" style=\"font-size: 0.8em;\"><\/i><\/a><\/p>\n<p>In most cases, CTAD works right out of the box.  However, in certain cases, the compiler may need a little extra help understanding how to deduce the template arguments properly.<\/p>\n<p>You may be surprised to find that the following program (which is almost identical to the example that uses <code>std::pair<\/code> above) doesn&#8217;t compile in C++17 (only):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ define our own Pair type\r\ntemplate &lt;typename T, typename U&gt;\r\nstruct Pair\r\n{\r\n    T first{};\r\n    U second{};\r\n};\r\n\r\nint main()\r\n{\r\n    Pair&lt;int, int&gt; p1{ 1, 2 }; \/\/ ok: we're explicitly specifying the template arguments\r\n    Pair p2{ 1, 2 };           \/\/ compile error in C++17 (okay in C++20)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>If you compile this in C++17, you&#8217;ll likely get some error about &#8220;class template argument deduction failed&#8221;  or &#8220;cannot deduce template arguments&#8221; or &#8220;No viable constructor or deduction guide&#8221;.  This is because in C++17, CTAD doesn&#8217;t know how to deduce the template arguments for aggregate class templates.  To address this, we can provide the compiler with a <strong>deduction guide<\/strong>, which tells the compiler how to deduce the template arguments for a given class template.<\/p>\n<p>Here&#8217;s the same program with a deduction guide:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;typename T, typename U&gt;\r\nstruct Pair\r\n{\r\n    T first{};\r\n    U second{};\r\n};\r\n\r\n\/\/ Here's a deduction guide for our Pair (needed in C++17 only)\r\n\/\/ Pair objects initialized with arguments of type T and U should deduce to Pair&lt;T, U&gt;\r\ntemplate &lt;typename T, typename U&gt;\r\nPair(T, U) -&gt; Pair&lt;T, U&gt;;\r\n    \r\nint main()\r\n{\r\n    Pair&lt;int, int&gt; p1{ 1, 2 }; \/\/ explicitly specify class template Pair&lt;int, int&gt; (C++11 onward)\r\n    Pair p2{ 1, 2 };           \/\/ CTAD used to deduce Pair&lt;int, int&gt; from the initializers (C++17)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This example should compile under C++17.<\/p>\n<p>The deduction guide for our <code>Pair<\/code> class is pretty simple, but let&#8217;s take a closer look at how it works.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Here's a deduction guide for our Pair (needed in C++17 only)\r\n\/\/ Pair objects initialized with arguments of type T and U should deduce to Pair&lt;T, U&gt;\r\ntemplate &lt;typename T, typename U&gt;\r\nPair(T, U) -&gt; Pair&lt;T, U&gt;;<\/code><\/pre>\n<p>First, we use the same template type definition as in our <code>Pair<\/code> class.  This makes sense, because if our deduction guide is going to tell the compiler how to deduce the types for a <code>Pair&lt;T, U&gt;<\/code>, we have to define what <code>T<\/code> and <code>U<\/code> are (template types).  Second, on the right hand side of the arrow, we have the type that we&#8217;re helping the compiler to deduce.  In this case, we want the compiler to be able to deduce template arguments for objects of type <code>Pair&lt;T, U&gt;<\/code>, so that&#8217;s exactly what we put here.  Finally, on the left side of the arrow, we tell the compiler what kind of declaration to look for.  In this case, we&#8217;re telling it to look for a declaration of some object named <code>Pair<\/code> with two arguments (one of type <code>T<\/code>, the other of type <code>U<\/code>).  We could also write this as <code>Pair(T t, U u)<\/code> (where <code>t<\/code> and <code>u<\/code> are the names of the parameters, but since we don&#8217;t use <code>t<\/code> and <code>u<\/code>, we don&#8217;t need to give them names).<\/p>\n<p>Putting it all together, we&#8217;re telling the compiler that if it sees a declaration of a <code>Pair<\/code> with two arguments (of types <code>T<\/code> and <code>U<\/code> respectively), it should deduce the type to be a <code>Pair&lt;T, U&gt;<\/code>.<\/p>\n<p>So when the compiler sees the definition <code>Pair p2{ 1, 2 };<\/code> in our program, it will say, &#8220;oh, this is a declaration of a <code>Pair<\/code> and there are two arguments of type <code>int<\/code> and <code>int<\/code>, so using the deduction guide, I should deduce this to be a <code>Pair&lt;int, int&gt;<\/code>&#8220;.<\/p>\n<p>Here&#8217;s a similar example for a Pair that takes a single template type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;typename T&gt;\r\nstruct Pair\r\n{\r\n    T first{};\r\n    T second{};\r\n};\r\n\r\n\/\/ Here's a deduction guide for our Pair (needed in C++17 only)\r\n\/\/ Pair objects initialized with arguments of type T and T should deduce to Pair&lt;T&gt;\r\ntemplate &lt;typename T&gt;\r\nPair(T, T) -&gt; Pair&lt;T&gt;;\r\n\r\nint main()\r\n{\r\n    Pair&lt;int&gt; p1{ 1, 2 }; \/\/ explicitly specify class template Pair&lt;int&gt; (C++11 onward)\r\n    Pair p2{ 1, 2 };      \/\/ CTAD used to deduce Pair&lt;int&gt; from the initializers (C++17)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this case, our deduction guide maps a <code>Pair(T, T)<\/code> (a <code>Pair<\/code> with two arguments of type <code>T<\/code>) to a <code>Pair&lt;T&gt;<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>C++20 added the ability for the compiler to automatically generate deduction guides for aggregates, so deduction guides should only need to be provided for C++17 compatibility.<\/p>\n<p>Because of this, the version of <code>Pair<\/code> without the deduction guides should compile in C++20.<\/p>\n<p><code>std::pair<\/code> (and other standard library template types) come with pre-defined deduction guides, which is why our example above that uses <code>std::pair<\/code> compiles fine in C++17 without us having to provide deduction guides ourselves.\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Non-aggregates don&#8217;t need deduction guides in C++17 because the presence of a constructor serves the same purpose.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Type template parameters with default values<\/p>\n<p>Just like function parameters can have default arguments, template parameters can be given default values.  These will be used when the template parameter isn&#8217;t explicitly specified and can&#8217;t be deduced.<\/p>\n<p>Here&#8217;s a modification of our <code>Pair&lt;T, U&gt;<\/code> class template program above, with type template parameters <code>T<\/code> and <code>U<\/code> defaulted to type <code>int<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;typename T=int, typename U=int&gt; \/\/ default T and U to type int\r\nstruct Pair\r\n{\r\n    T first{};\r\n    U second{};\r\n};\r\n\r\ntemplate &lt;typename T, typename U&gt;\r\nPair(T, U) -&gt; Pair&lt;T, U&gt;;\r\n\r\nint main()\r\n{\r\n    Pair&lt;int, int&gt; p1{ 1, 2 }; \/\/ explicitly specify class template Pair&lt;int, int&gt; (C++11 onward)\r\n    Pair p2{ 1, 2 };           \/\/ CTAD used to deduce Pair&lt;int, int&gt; from the initializers (C++17)\r\n\r\n    Pair p3;                   \/\/ uses default Pair&lt;int, int&gt;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Our definition for <code>p3<\/code> does not explicitly specify types for the type template parameters, nor is there an initializer for these types to be deduced from.  Therefore, the compiler will use the types specified in the defaults, which means <code>p3<\/code> will be of type <code>Pair&lt;int, int&gt;<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">CTAD doesn&#8217;t work with non-static member initialization<\/p>\n<p>When initializing the member of a class type using non-static member initialization, CTAD will not work in this context.  All template arguments must be explicitly specified:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;utility&gt; \/\/ for std::pair\r\n\r\nstruct Foo\r\n{\r\n    std::pair&lt;int, int&gt; p1{ 1, 2 }; \/\/ ok, template arguments explicitly specified\r\n    std::pair p2{ 1, 2 };           \/\/ compile error, CTAD can't be used in this context\r\n};\r\n\r\nint main()\r\n{\r\n    std::pair p3{ 1, 2 };           \/\/ ok, CTAD can be used here\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">CTAD doesn&#8217;t work with function parameters<\/p>\n<p>CTAD stands for class template <em>argument<\/em> deduction, not class template <em>parameter<\/em> deduction, so it will only deduce the type of template arguments, not template parameters.<\/p>\n<p>Therefore, CTAD can&#8217;t be used in function parameters.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;utility&gt;\r\n\r\nvoid print(std::pair p) \/\/ compile error, CTAD can't be used here\r\n{\r\n    std::cout &lt;&lt; p.first &lt;&lt; ' ' &lt;&lt; p.second &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::pair p { 1, 2 }; \/\/ p deduced to std::pair&lt;int, int&gt;\r\n    print(p);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In such cases, you should use a template instead:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;utility&gt;\r\n\r\ntemplate &lt;typename T, typename U&gt;\r\nvoid print(std::pair&lt;T, U&gt; p)\r\n{\r\n    std::cout &lt;&lt; p.first &lt;&lt; ' ' &lt;&lt; p.second &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::pair p { 1, 2 }; \/\/ p deduced to std::pair&lt;int, int&gt;\r\n    print(p);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/alias-templates\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.15<\/span>Alias templates\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-templates\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.13<\/span>Class templates\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Class template argument deduction (CTAD) C++17 Starting in C++17, when instantiating an object from a class template, the compiler can deduce the template types from the types of the object&#8217;s initializer (this is called or for short). For example: #include &lt;utility&gt; \/\/ for std::pair int main() { std::pair&lt;int, int&gt; p1{ &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/13001"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=13001"}],"version-history":[{"count":26,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/13001\/revisions"}],"predecessor-version":[{"id":16854,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/13001\/revisions\/16854"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=13001"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=13001"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=13001"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}