{"id":1674,"date":"2015-04-23T16:22:46","date_gmt":"2015-04-24T00:22:46","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=1674"},"modified":"2025-02-11T19:01:58","modified_gmt":"2025-02-12T03:01:58","slug":"scoped-enumerations-enum-classes","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/scoped-enumerations-enum-classes\/","title":{"rendered":"13.6 &#8212; Scoped enumerations (enum classes)"},"content":{"rendered":"<p>Although unscoped enumerations are distinct types in C++, they are not type safe, and in some cases will allow you to do things that don&#8217;t make sense.  Consider the following case:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    enum Color\r\n    {\r\n        red,\r\n        blue,\r\n    };\r\n\r\n    enum Fruit\r\n    {\r\n        banana,\r\n        apple,\r\n    };\r\n\t\r\n    Color color { red };\r\n    Fruit fruit { banana };\r\n\r\n    if (color == fruit) \/\/ The compiler will compare color and fruit as integers\r\n        std::cout &lt;&lt; \"color and fruit are equal\\n\"; \/\/ and find they are equal!\r\n    else\r\n        std::cout &lt;&lt; \"color and fruit are not equal\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\ncolor and fruit are equal\r\n<\/pre>\n<p>When <code>color<\/code> and <code>fruit<\/code> are compared, the compiler will look to see if it knows how to compare a <code>Color<\/code> and a <code>Fruit<\/code>.  It doesn&#8217;t.  Next, it will try converting <code>Color<\/code> and\/or <code>Fruit<\/code> to integers to see if it can find a match.  Eventually the compiler will determine that if it converts both to integers, it can do the comparison.  Since <code>color<\/code> and <code>fruit<\/code> are both set to enumerators that convert to integer value <code>0<\/code>, <code>color<\/code> will equal <code>fruit<\/code>.<\/p>\n<p>This doesn&#8217;t make sense semantically since <code>color<\/code> and <code>fruit<\/code> are from different enumerations and are not intended to be comparable.  With standard enumerators, there&#8217;s no easy way to prevent this.<\/p>\n<p>Because of such challenges, as well as the namespace pollution problem (unscoped enumerations defined in the global scope put their enumerators in the global namespace), the C++ designers determined that a cleaner solution for enumerations would be of use.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Scoped enumerations<\/p>\n<p>That solution is the <strong>scoped enumeration<\/strong> (often called an <strong>enum class<\/strong> in C++ for reasons that will become obvious shortly).<\/p>\n<p>Scoped enumerations work similarly to unscoped enumerations (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/unscoped-enumerations\/\">13.2 -- Unscoped enumerations<\/a>), but have two primary differences: They won&#8217;t implicitly convert to integers, and the enumerators are <em>only<\/em> placed into the scope region of the enumeration (not into the scope region where the enumeration is defined).<\/p>\n<p>To make a scoped enumeration, we use the keywords <code>enum class<\/code>.  The rest of the scoped enumeration definition is the same as an unscoped enumeration definition.  Here&#8217;s an example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\nint main()\r\n{\r\n    enum class Color \/\/ \"enum class\" defines this as a scoped enumeration rather than an unscoped enumeration\r\n    {\r\n        red, \/\/ red is considered part of Color's scope region\r\n        blue,\r\n    };\r\n\r\n    enum class Fruit\r\n    {\r\n        banana, \/\/ banana is considered part of Fruit's scope region\r\n        apple,\r\n    };\r\n\r\n    Color color { Color::red }; \/\/ note: red is not directly accessible, we have to use Color::red\r\n    Fruit fruit { Fruit::banana }; \/\/ note: banana is not directly accessible, we have to use Fruit::banana\r\n\t\r\n    if (color == fruit) \/\/ compile error: the compiler doesn't know how to compare different types Color and Fruit\r\n        std::cout &lt;&lt; \"color and fruit are equal\\n\";\r\n    else\r\n        std::cout &lt;&lt; \"color and fruit are not equal\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program produces a compile error on line 19, since the scoped enumeration won&#8217;t convert to any type that can be compared with another type.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>The <code>class<\/code> keyword (along with the <code>static<\/code> keyword), is one of the most overloaded keywords in the C++ language, and can have different meanings depending on context.  Although scoped enumerations use the <code>class<\/code> keyword, they aren&#8217;t considered to be a &#8220;class type&#8221; (which is reserved for structs, classes, and unions).<\/p>\n<p><code>enum struct<\/code> also works in this context, and behaves identically to <code>enum class<\/code>.  However, use of <code>enum struct<\/code> is non-idiomatic, so avoid its use.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Scoped enumerations define their own scope regions<\/p>\n<p>Unlike unscoped enumerations, which place their enumerators in the same scope as the enumeration itself, scoped enumerations place their enumerators <em>only<\/em> in the scope region of the enumeration.  In other words, scoped enumerations act like a namespace for their enumerators.  This built-in namespacing helps reduce global namespace pollution and the potential for name conflicts when scoped enumerations are used in the global scope.<\/p>\n<p>To access a scoped enumerator, we do so just as if it was in a namespace having the same name as the scoped enumeration:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    enum class Color \/\/ \"enum class\" defines this as a scoped enum rather than an unscoped enum\r\n    {\r\n        red, \/\/ red is considered part of Color's scope region\r\n        blue,\r\n    };\r\n\r\n    std::cout &lt;&lt; red &lt;&lt; '\\n';        \/\/ compile error: red not defined in this scope region\r\n    std::cout &lt;&lt; Color::red &lt;&lt; '\\n'; \/\/ compile error: std::cout doesn't know how to print this (will not implicitly convert to int)\r\n\r\n    Color color { Color::blue }; \/\/ okay\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because scoped enumerations offer their own implicit namespacing for enumerators, there&#8217;s no need to put scoped enumerations inside another scope region (such as a namespace), unless there&#8217;s some other compelling reason to do so, as it would be redundant.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Scoped enumerations don&#8217;t implicitly convert to integers<\/p>\n<p>Unlike non-scoped enumerators, scoped enumerators won&#8217;t implicitly convert to integers.  In most cases, this is a good thing because it rarely makes sense to do so, and it helps prevent semantic errors, such as comparing enumerators from different enumerations, or expressions such as <code>red + 5<\/code>.<\/p>\n<p>Note that you can still compare enumerators from within the same scoped enumeration (since they are of the same type):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\nint main()\r\n{\r\n    enum class Color\r\n    {\r\n        red,\r\n        blue,\r\n    };\r\n\r\n    Color shirt { Color::red };\r\n\r\n    if (shirt == Color::red) \/\/ this Color to Color comparison is okay\r\n        std::cout &lt;&lt; \"The shirt is red!\\n\";\r\n    else if (shirt == Color::blue)\r\n        std::cout &lt;&lt; \"The shirt is blue!\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>There are occasionally cases where it is useful to be able to treat a scoped enumerator as an integral value.  In these cases, you can explicitly convert a scoped enumerator to an integer by using a <code>static_cast<\/code>.  A better choice in C++23 is to use <code>std::to_underlying()<\/code> (defined in the &lt;utility&gt; header), which converts an enumerator to a value of the underlying type of the enumeration.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;utility&gt; \/\/ for std::to_underlying() (C++23)\r\n\r\nint main()\r\n{\r\n    enum class Color\r\n    {\r\n        red,\r\n        blue,\r\n    };\r\n\r\n    Color color { Color::blue };\r\n\r\n    std::cout &lt;&lt; color &lt;&lt; '\\n'; \/\/ won't work, because there's no implicit conversion to int\r\n    std::cout &lt;&lt; static_cast&lt;int&gt;(color) &lt;&lt; '\\n';   \/\/ explicit conversion to int, will print 1\r\n    std::cout &lt;&lt; std::to_underlying(color) &lt;&lt; '\\n'; \/\/ convert to underlying type, will print 1 (C++23)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Conversely, you can also <code>static_cast<\/code> an integer to a scoped enumerator, which can be useful when doing input from users:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    enum class Pet\r\n    {\r\n        cat, \/\/ assigned 0\r\n        dog, \/\/ assigned 1\r\n        pig, \/\/ assigned 2\r\n        whale, \/\/ assigned 3\r\n    };\r\n\r\n    std::cout &lt;&lt; \"Enter a pet (0=cat, 1=dog, 2=pig, 3=whale): \";\r\n\r\n    int input{};\r\n    std::cin &gt;&gt; input; \/\/ input an integer\r\n\r\n    Pet pet{ static_cast&lt;Pet&gt;(input) }; \/\/ static_cast our integer to a Pet\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>As of C++17, you can list initialize a scoped enumeration using an integral value without the static_cast (and unlike an unscoped enumeration, you don&#8217;t need to specify a base):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">   \/\/ using enum class Pet from prior example\r\n   Pet pet { 1 }; \/\/ okay<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Favor scoped enumerations over unscoped enumerations unless there&#8217;s a compelling reason to do otherwise.\n<\/p><\/div>\n<p>Despite the benefits that scoped enumerations offer, unscoped enumerations are still commonly used in C++ because there are situations where we desire the implicit conversion to int (doing lots of static_casting gets annoying) and we don&#8217;t need the extra namespacing.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><a name=\"operatorplus\"><\/a>Easing the conversion of scoped enumerators to integers (advanced) <a href=\"#operatorplus\"><i class=\"fa fa-link\" style=\"font-size: 0.8em;\"><\/i><\/a><\/p>\n<p>Scoped enumerations are great, but the lack of implicit conversion to integers can sometimes be a pain point.  If we need to convert a scoped enumeration to integers often (e.g. cases where we want to use scoped enumerators as array indices), having to use static_cast every time we want a conversion can clutter our code significantly.<\/p>\n<p>If you find yourself in the situation where it would be useful to make conversion of scoped enumerators to integers easier, a useful hack is to overload the unary <code>operator+<\/code> to perform this conversion:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;type_traits&gt; \/\/ for std::underlying_type_t\r\n\r\nenum class Animals\r\n{\r\n    chicken, \/\/ 0\r\n    dog, \/\/ 1\r\n    cat, \/\/ 2\r\n    elephant, \/\/ 3\r\n    duck, \/\/ 4\r\n    snake, \/\/ 5\r\n\r\n    maxAnimals,\r\n};\r\n\r\n\/\/ Overload the unary + operator to convert an enum to the underlying type\r\n\/\/ adapted from https:\/\/stackoverflow.com\/a\/42198760, thanks to Pixelchemist for the idea\r\n\/\/ In C++23, you can #include &lt;utility&gt; and return std::to_underlying(a) instead\r\ntemplate &lt;typename T&gt;\r\nconstexpr auto operator+(T a) noexcept\r\n{\r\n    return static_cast&lt;std::underlying_type_t&lt;T&gt;&gt;(a);\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; +Animals::elephant &lt;&lt; '\\n'; \/\/ convert Animals::elephant to an integer using unary operator+\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n3\r\n<\/pre>\n<p>This method prevents unintended implicit conversions to an integral type, but provides a convenient way to explicitly request such conversions as needed.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><code>using enum<\/code> statements <span class=\"cpp-section-pill cpp-section-standard\">C++20<\/span><\/p>\n<p>Introduced in C++20, a <code>using enum<\/code> statement imports all of the enumerators from an enum into the current scope.  When used with an enum class type, this allows us to access the enum class enumerators without having to prefix each with the name of the enum class.<\/p>\n<p>This can be useful in cases where we would otherwise have many identical, repeated prefixes, such as within a switch statement:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nenum class Color\r\n{\r\n    black,\r\n    red,\r\n    blue,\r\n};\r\n\r\nconstexpr std::string_view getColor(Color color)\r\n{\r\n    using enum Color; \/\/ bring all Color enumerators into current scope (C++20)\r\n    \/\/ We can now access the enumerators of Color without using a Color:: prefix\r\n\r\n    switch (color)\r\n    {\r\n    case black: return \"black\"; \/\/ note: black instead of Color::black\r\n    case red:   return \"red\";\r\n    case blue:  return \"blue\";\r\n    default:    return \"???\";\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    Color shirt{ Color::blue };\r\n\r\n    std::cout &lt;&lt; \"Your shirt is \" &lt;&lt; getColor(shirt) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, <code>Color<\/code> is an enum class, so we normally would access the enumerators using a fully qualified name (e.g. <code>Color::blue<\/code>).  However, within function <code>getColor()<\/code>, we&#8217;ve added the statement <code>using enum Color;<\/code>, which allows us to access those enumerators without the <code>Color::<\/code> prefix.<\/p>\n<p>This saves us from having multiple, redundant, obvious prefixes inside the switch statement.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Define an enum class named Animal that contains the following animals: pig, chicken, goat, cat, dog, duck.  Write a function named getAnimalName() that takes an Animal parameter and uses a switch statement to return the name for that animal as a std::string_view (or std::string if you&#8217;re using C++14).  Write another function named printNumberOfLegs() that uses a switch statement to print the number of legs each animal walks on.  Make sure both functions have a default case that prints an error message.  Call printNumberOfLegs() from main() with a cat and a chicken.  Your output should look like this:<\/p>\n<pre>\nA cat has 4 legs.\r\nA chicken has 2 legs.\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt; \/\/ C++17\r\n\/\/#include &lt;string&gt; \/\/ for C++14\r\n\r\nenum class Animal\r\n{\r\n    pig,\r\n    chicken,\r\n    goat,\r\n    cat,\r\n    dog,\r\n    duck,\r\n};\r\n\r\nconstexpr std::string_view getAnimalName(Animal animal) \/\/ C++17\r\n\/\/ const std::string getAnimalName(Animal animal) \/\/ C++14\r\n{\r\n    \/\/ If C++20 capable, could use `using enum Animal` here to reduce Animal prefix redundancy\r\n    switch (animal)\r\n    {\r\n        case Animal::chicken:\r\n            return \"chicken\";\r\n        case Animal::duck:\r\n            return \"duck\";\r\n        case Animal::pig:\r\n            return \"pig\";\r\n        case Animal::goat:\r\n            return \"goat\";\r\n        case Animal::cat:\r\n            return \"cat\";\r\n        case Animal::dog:\r\n            return \"dog\";\r\n\r\n        default:\r\n            return \"???\";\r\n    }\r\n}\r\n\r\nvoid printNumberOfLegs(Animal animal)\r\n{\r\n    std::cout &lt;&lt; \"A \" &lt;&lt; getAnimalName(animal) &lt;&lt; \" has \";\r\n\r\n    \/\/ If C++20 capable, could use `using enum Animal` here to reduce Animal prefix redundancy\r\n    switch (animal)\r\n    {\r\n        case Animal::chicken:\r\n        case Animal::duck:\r\n            std::cout &lt;&lt; 2;\r\n            break;\r\n\r\n        case Animal::pig:\r\n        case Animal::goat:\r\n        case Animal::cat:\r\n        case Animal::dog:\r\n            std::cout &lt;&lt; 4;\r\n            break;\r\n\r\n        default:\r\n            std::cout &lt;&lt; \"???\";\r\n            break;\r\n    }\r\n\r\n    std::cout &lt;&lt; \" legs.\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    printNumberOfLegs(Animal::cat);\r\n    printNumberOfLegs(Animal::chicken);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-structs-members-and-member-selection\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.7<\/span>Introduction to structs, members, and member selection\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-overloading-the-i-o-operators\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.5<\/span>Introduction to overloading the I\/O operators\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Although unscoped enumerations are distinct types in C++, they are not type safe, and in some cases will allow you to do things that don&#8217;t make sense. Consider the following case: #include &lt;iostream&gt; int main() { enum Color { red, blue, }; enum Fruit { banana, apple, }; Color color &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1674"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=1674"}],"version-history":[{"count":59,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1674\/revisions"}],"predecessor-version":[{"id":18187,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1674\/revisions\/18187"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=1674"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=1674"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=1674"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}