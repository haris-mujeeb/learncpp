{"id":15392,"date":"2023-09-11T14:28:05","date_gmt":"2023-09-11T21:28:05","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15392"},"modified":"2024-11-11T13:51:29","modified_gmt":"2024-11-11T21:51:29","slug":"stdvector-and-the-unsigned-length-and-subscript-problem","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/stdvector-and-the-unsigned-length-and-subscript-problem\/","title":{"rendered":"16.3 &#8212; std::vector and the unsigned length and subscript problem"},"content":{"rendered":"<p>In the prior lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdvector-and-list-constructors\/\">16.2 -- Introduction to std::vector and list constructors<\/a>, we introduced <code>operator[]<\/code>, which can be used to subscript an array to access an element.<\/p>\n<p>In this lesson, we&#8217;ll look at other ways to access array elements, as well as a few different ways to get the length of an container class (the number of elements currently in the container class).<\/p>\n<p>But before we can do that, we need to discuss one major mistake that the designers of C++ made, and how it affects all the container classes in the C++ standard library.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The container length sign problem<\/p>\n<p>Let&#8217;s start with an assertion: the data type used for subscripting an array should match the data type used for storing the length of the array.  This is so that all elements in the longest possible array can be indexed, and no more.<\/p>\n<p>As Bjarne Stroustrup <a href=\"https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2019\/p1428r0.pdf\">recalls<\/a>, when the container classes in the C++ standard library was being designed (circa 1997), the designers had to choose whether to make the length (and array subscripts) signed or unsigned.  They chose to make them unsigned.<\/p>\n<p>The reasons given for this: the subscripts of the standard library array types can&#8217;t be negative, using an unsigned type allows arrays of greater length due to the extra bit (something that was important in the 16-bit days), and range-checking the subscript requires one conditional check instead of two (since no check was needed to ensure the index was less than 0).  <\/p>\n<p>In retrospect, this is generally regarded as having been the wrong choice.  We now understand that using unsigned values to try to enforce non-negativity doesn&#8217;t work due to the implicit conversion rules (since a negative signed integer will just implicitly convert to a large unsigned integer, producing a garbage result), the extra bit of range typically isn&#8217;t needed on 32-bit or 64-bit systems (since you probably aren&#8217;t creating arrays with more than 2 billion elements), and the commonly used <code>operator[]<\/code> doesn&#8217;t do range-checking anyway.<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/unsigned-integers-and-why-to-avoid-them\/\">4.5 -- Unsigned integers, and why to avoid them<\/a>, we discussed the reasons why we prefer to use signed values to hold quantities.  We also noted that mixing signed and unsigned values is a recipe for unexpected behavior.  So the fact that the standard library container classes use unsigned values for the length (and indices) is problematic, as it makes it impossible to avoid unsigned values when using these types.<\/p>\n<p>For now, we are stuck with this choice and the unnecessary complexity it causes.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><a name=\"constexprconversions\"><\/a>A review: sign conversions are narrowing conversions, except when constexpr <a href=\"#constexprconversions\"><i class=\"fa fa-link\" style=\"font-size: 0.8em;\"><\/i><\/a><\/p>\n<p>Before we proceed further, let&#8217;s quickly recap some material from lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/narrowing-conversions-list-initialization-and-constexpr-initializers\/\">10.4 -- Narrowing conversions, list initialization, and constexpr initializers<\/a> regarding sign conversions (integral conversions from signed to unsigned or vice-versa) because we&#8217;ll be talking about these a lot in this chapter.<\/p>\n<p>Sign conversions are considered to be narrowing conversions because a signed or unsigned type cannot hold all the values contained in the range of the opposing type.  When such a conversion would be performed at runtime, the compiler will issue an error in contexts where narrowing conversions are disallowed (such as in list initialization), and may or may not issue a warning in other contexts where such a conversion is performed.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid foo(unsigned int)\r\n{\r\n}\r\n\r\nint main()\r\n{\r\n    int s { 5 };\r\n    \r\n    [[maybe_unused]] unsigned int u { s }; \/\/ compile error: list initialization disallows narrowing conversion\r\n    foo(s);                                \/\/ possible warning: copy initialization allows narrowing conversion\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, the initialization of variable <code>u<\/code> produces a compilation error because narrowing conversions are disallowed when doing list initialization.  The call to <code>foo()<\/code> performs copy initialization, which does allow narrowing conversions, and which may or may not produce a warning depending on how aggressive the compiler is in producing sign conversion warnings.  For example, both GCC and Clang will produce warnings in this case when compiler flag <code>-Wsign-conversion<\/code> is used.<\/p>\n<p>However, if the value to be sign converted is constexpr and can be converted to an equivalent value in the opposing type, the sign conversion is <em>not<\/em> considered to be narrowing.  This is because the compiler can guarantee that the conversion is safe, or halt the compilation process.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid foo(unsigned int)\r\n{\r\n}\r\n\r\nint main()\r\n{\r\n    constexpr int s { 5 };                 \/\/ now constexpr\r\n    [[maybe_unused]] unsigned int u { s }; \/\/ ok: s is constexpr and can be converted safely, not a narrowing conversion\r\n    foo(s);                                \/\/ ok: s is constexpr and can be converted safely, not a narrowing conversion\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this case, since <code>s<\/code> is constexpr and the value to be converted (<code>5<\/code>) can be represented as an unsigned value, the conversion is not considered to be narrowing and can be performed implicitly without issue.  <\/p>\n<p>This non-narrowing constexpr conversion (from <code>constexpr int<\/code> to <code>constexpr std::size_t<\/code>) will be something we make use of a lot.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><a name=\"size_type\"><\/a>The length and indices of <code>std::vector<\/code> have type <code>size_type<\/code> <a href=\"#size_type\"><i class=\"fa fa-link\" style=\"font-size: 0.8em;\"><\/i><\/a><\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/typedefs-and-type-aliases\/\">10.7 -- Typedefs and type aliases<\/a>, we mentioned that typedefs and type aliases are often used in cases where we need a name for a type that may vary (e.g. because it is implementation-defined).  For example <code>std::size_t<\/code> is a typedef for some large unsigned integral type, usually <code>unsigned long<\/code> or <code>unsigned long long<\/code>.<\/p>\n<p>Each of the standard library container classes defines a nested typedef member named <code>size_type<\/code> (sometimes written as <code>T::size_type<\/code>), which is an alias for the type used for the length (and indices, if supported) of the container.<\/p>\n<p>You&#8217;ll typically see <code>size_type<\/code> appear in documentation and in compiler warnings\/error messages.  For example, this <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/container\/vector\/size\">documentation for the <code>size()<\/code> member function<\/a>  of <code>std::vector<\/code> indicates that <code>size()<\/code> returns a value of <code>size_type<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover nested typedefs in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/nested-types-member-types\/\">15.3 -- Nested types (member types)<\/a>.\n<\/p><\/div>\n<p><code>size_type<\/code> is almost always an alias for <code>std::size_t<\/code>, but can be overridden (in rare cases) to use a different type.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p><code>size_type<\/code> is a nested typedef defined in standard library container classes, used as the type for the length (and indices, if supported) of the container class.<\/p>\n<p><code>size_type<\/code> defaults to <code>std::size_t<\/code>, and since this is almost never changed, we can reasonably assume <code>size_type<\/code> is an alias for <code>std::size_t<\/code>.\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>All of the standard library containers except <code>std::array<\/code> use <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/memory\/allocator\"><code>std::allocator<\/code><\/a> to allocate memory.  For these containers, <code>T::size_type<\/code> is derived from the <code>size_type<\/code> of the allocator used.  Since <code>std::allocator<\/code> can allocate up to <code>std::size_t<\/code> bytes of memory, <code>std::allocator&lt;T&gt;::size_type<\/code> is defined as <code>std::size_t<\/code>.  Therefore, <code>T::size_type<\/code> defaults to <code>std::size_t<\/code>.<\/p>\n<p>Only in cases where a custom allocator whose <code>T::size_type<\/code> is defined as something other than <code>std::size_t<\/code> will a container&#8217;s <code>T::size_type<\/code> be something other than <code>std::size_t<\/code>.  This is rare and something done on a per-application basis, so it&#8217;s generally safe to assume <code>T::size_type<\/code> will be <code>std::size_t<\/code> unless your application is using such a custom allocator (and you will know if that is the case).\n<\/div>\n<p>When accessing the <code>size_type<\/code> member of a container class, we must scope qualify it with the fully templated name of the container class.  For example, <code>std::vector&lt;int&gt;::size_type<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Getting the length of a <code>std::vector<\/code> using the <code>size()<\/code> member function or <code>std::size()<\/code><\/p>\n<p>We can ask a container class object for its length using the <code>size()<\/code> member function (which returns the length as unsigned <code>size_type<\/code>):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::vector prime { 2, 3, 5, 7, 11 };\r\n    std::cout &lt;&lt; \"length: \" &lt;&lt; prime.size() &lt;&lt; '\\n'; \/\/ returns length as type `size_type` (alias for `std::size_t`)\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nlength: 5\r\n<\/pre>\n<p>Unlike <code>std::string<\/code> and <code>std::string_view<\/code>, which have both a <code>length()<\/code> and a <code>size()<\/code> member function (that do the same thing), <code>std::vector<\/code> (and most other container types in C++) only has <code>size()<\/code>.  And now you understand why the length of a container is sometimes ambiguously called its size.<\/p>\n<p>In C++17, we can also use the <code>std::size()<\/code> non-member function (which for container classes just calls the <code>size()<\/code> member function).<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::vector prime { 2, 3, 5, 7, 11 };\r\n    std::cout &lt;&lt; \"length: \" &lt;&lt; std::size(prime); \/\/ C++17, returns length as type `size_type` (alias for `std::size_t`)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Because <code>std::size()<\/code> can also be used on non-decayed C-style arrays, this method is sometimes favored over the using the <code>size()<\/code> member function (particularly when writing function templates that can accept either a container class or non-decayed C-style array argument).<\/p>\n<p>We discuss C-style array decay in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/c-style-array-decay\/\">17.8 -- C-style array decay<\/a>.\n<\/p><\/div>\n<p>If we want to use either of the above methods to store the length in a variable with a signed type, this will likely result in a signed\/unsigned conversion warning or error.  The simplest thing to do here is static_cast the result to the desired type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::vector prime { 2, 3, 5, 7, 11 };\r\n    int length { static_cast&lt;int&gt;(prime.size()) }; \/\/ static_cast return value to int\r\n    std::cout &lt;&lt; \"length: \" &lt;&lt; length ;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Getting the length of a <code>std::vector<\/code> using <code>std::ssize()<\/code> <span class=\"cpp-section-pill cpp-section-standard\">C++20<\/span><\/p>\n<p>C++20 introduces the <code>std::ssize()<\/code> non-member function, which returns the length as a large <em>signed<\/em> integral type (usually <code>std::ptrdiff_t<\/code>, which is the type normally used as the signed counterpart to <code>std::size_t<\/code>):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::vector prime{ 2, 3, 5, 7, 11 };\r\n    std::cout &lt;&lt; \"length: \" &lt;&lt; std::ssize(prime); \/\/ C++20, returns length as a large signed integral type\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This is the only function of the three which returns the length as a signed type.<\/p>\n<p>If you want to use this method to store the length in a variable with a signed type, you have a couple of options.<\/p>\n<p>First, because the <code>int<\/code> type may be smaller than the signed type returned by <code>std::ssize()<\/code>, if you are going to assign the length to an <code>int<\/code> variable, you should static_cast the result to <code>int<\/code> to make any such conversion explicit (otherwise you might get a narrowing conversion warning or error):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::vector prime{ 2, 3, 5, 7, 11 };\r\n    int length { static_cast&lt;int&gt;(std::ssize(prime)) }; \/\/ static_cast return value to int\r\n    std::cout &lt;&lt; \"length: \" &lt;&lt; length;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Alternatively, you can use <code>auto<\/code> to have the compiler deduce the correct signed type to use for the variable:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::vector prime{ 2, 3, 5, 7, 11 };\r\n    auto length { std::ssize(prime) }; \/\/ use auto to deduce signed type, as returned by std::ssize()\r\n    std::cout &lt;&lt; \"length: \" &lt;&lt; length;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Accessing array elements using <code>operator[]<\/code> does no bounds checking<\/p>\n<p>In the prior lesson, we introduced the subscript operator (<code>operator[]<\/code>):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::vector prime{ 2, 3, 5, 7, 11 };\r\n\r\n    std::cout &lt;&lt; prime[3];  \/\/ print the value of element with index 3 (7)\r\n    std::cout &lt;&lt; prime[9]; \/\/ invalid index (undefined behavior)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><code>operator[]<\/code> does not do bounds checking.  The index for operator[] can be non-const.  We&#8217;ll discuss this further in a later section.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Accessing array elements using the <code>at()<\/code> member function does runtime bounds checking<\/p>\n<p>The array container classes support another method for accessing an array.  The <code>at()<\/code> member function can be used to do array access with runtime bounds checking:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::vector prime{ 2, 3, 5, 7, 11 };\r\n\r\n    std::cout &lt;&lt; prime.at(3); \/\/ print the value of element with index 3\r\n    std::cout &lt;&lt; prime.at(9); \/\/ invalid index (throws exception)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, the call to <code>prime.at(3)<\/code> checks to ensure the index 3 is valid, and because it is, it returns a reference to array element 3.  We can then print this value.  However, the call to <code>prime.at(9)<\/code> fails (at runtime) because 9 is not a valid index for this array.  Instead of returning a reference, the <code>at()<\/code> function generates an error that terminates the program.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>When the <code>at()<\/code> member function encounters an out-of-bounds index, it actually throws an exception of type <code>std::out_of_range<\/code>.  If the exception is not handled, the program will be terminated.  We cover exceptions and how to handle them in <a href=\"https:\/\/www.learncpp.com#Chapter27\">chapter 27<\/a>.\n<\/div>\n<p>Just like <code>operator[]<\/code>, the index passed to <code>at()<\/code> can be non-const.<\/p>\n<p>Because it does runtime bounds checking on every call, <code>at()<\/code> is slower (but safer) than <code>operator[]<\/code>.  Despite being less safe, <code>operator[]<\/code> is typically used over <code>at()<\/code>, primarily because it&#8217;s better to do bounds checking prior to indexing, so we don&#8217;t try to use an invalid index in the first place.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Indexing <code>std::vector<\/code> with a constexpr signed int<\/p>\n<p>When indexing a <code>std::vector<\/code> with a constexpr (signed) int, we can let the compiler implicitly convert this to a <code>std::size_t<\/code> without it being a narrowing conversion:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::vector prime{ 2, 3, 5, 7, 11 };\r\n\r\n    std::cout &lt;&lt; prime[3] &lt;&lt; '\\n';     \/\/ okay: 3 converted from int to std::size_t, not a narrowing conversion\r\n \r\n    constexpr int index { 3 };         \/\/ constexpr\r\n    std::cout &lt;&lt; prime[index] &lt;&lt; '\\n'; \/\/ okay: constexpr index implicitly converted to std::size_t, not a narrowing conversion\r\n   \r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Indexing <code>std::vector<\/code> with a non-constexpr value<\/p>\n<p>The subscripts used to index an array can be non-const:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::vector prime{ 2, 3, 5, 7, 11 };\r\n\r\n    std::size_t index { 3 };           \/\/ non-constexpr\r\n    std::cout &lt;&lt; prime[index] &lt;&lt; '\\n'; \/\/ operator[] expects an index of type std::size_t, no conversion required\r\n   \r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, as per our best practices (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/unsigned-integers-and-why-to-avoid-them\/\">4.5 -- Unsigned integers, and why to avoid them<\/a>), we generally want to avoid using unsigned types to hold quantities.<\/p>\n<p>When our subscript is a non-constexpr signed value, we run into problems:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::vector prime{ 2, 3, 5, 7, 11 };\r\n\r\n    int index { 3 };                   \/\/ non-constexpr\r\n    std::cout &lt;&lt; prime[index] &lt;&lt; '\\n'; \/\/ possible warning: index implicitly converted to std::size_t, narrowing conversion\r\n   \r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this example, <code>index<\/code> is a non-constexpr signed int.  The subscript of <code>operator[]<\/code> defined as part of <code>std::vector<\/code> has type <code>size_type<\/code> (an alias for <code>std::size_t<\/code>).  Therefore, when we call <code>prime[index]<\/code>, our signed int must be converted to <code>std::size_t<\/code>.<\/p>\n<p>Such a conversion should not be dangerous (because the index of a <code>std::vector<\/code> is expected to be non-negative, and a non-negative signed value will safely convert to an unsigned value).  But when performed at runtime, this is considered to be a narrowing conversion, and your compiler should produce a warning about this being an unsafe conversion (if it doesn&#8217;t, you should consider modifying your warnings so that it does).<\/p>\n<p>Because array subscripting is common, and each such conversion will generate a warning, this can easily clutter up your compilation log with spurious warnings.  Or, if you have &#8220;treat warning as errors&#8221; enabled, it will halt your compilation.<\/p>\n<p>There are many possible ways to avoid this issue (e.g. <code>static_cast<\/code> your <code>int<\/code> to a <code>std::size_t<\/code> every time you index an array), but all inevitably end up cluttering or complicating your code in some way.  The simplest thing to do in this case is use a variable of type std::size_t as your index, and do not use this variable for anything but indexing.  That way you&#8217;ll avoid any non-constexpr conversions in the first place.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>Another good alternative is instead of indexing the <code>std::vector<\/code> itself, index the result of the <code>data()<\/code> member function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::vector prime{ 2, 3, 5, 7, 11 };\r\n\r\n    int index { 3 };                          \/\/ non-constexpr signed value\r\n    std::cout &lt;&lt; prime.data()[index] &lt;&lt; '\\n'; \/\/ okay: no sign conversion warnings\r\n   \r\n    return 0;\r\n}<\/code><\/pre>\n<p>Under the hood, <code>std::vector<\/code> holds its elements in a C-style array.  The <code>data()<\/code> member function returns a pointer to this underlying C-style array, which we can then index.  Since C-style arrays allow indexing with both signed and unsigned types, we don&#8217;t run into any sign conversion issues.  We discuss C-style arrays further in lessons <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-c-style-arrays\/\">17.7 -- Introduction to C-style arrays<\/a> and <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/c-style-array-decay\/\">17.8 -- C-style array decay<\/a>.\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>We&#8217;ll discuss additional options to address such indexing challenges in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/arrays-loops-and-sign-challenge-solutions\/\">16.7 -- Arrays, loops, and sign challenge solutions<\/a>.\n<\/p><\/div>\n<p><p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p><p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p><\/p>\n<p>Initialize a <code>std::vector<\/code> with the following values: &#8216;h&#8217;, &#8216;e&#8217;, &#8216;l&#8217;, &#8216;l&#8217;, &#8216;o&#8217;.  Then print the length of the array (use <code>std::size()<\/code>).  Finally, print the value of the element with index 1 using the subscript operator and the <code>at()<\/code> member function.<\/p>\n<p>The program should output the following:<\/p>\n<pre>\nThe array has 5 elements.\r\nee\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::vector arr { 'h', 'e', 'l', 'l', 'o' };\r\n    std::cout &lt;&lt; \"The array has \" &lt;&lt; std::size(arr) &lt;&lt; \" elements.\\n\";\r\n    std::cout &lt;&lt; arr[1] &lt;&lt; arr.at(1) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>a) What is <code>size_type<\/code> and what is it used for?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p><code>size_type<\/code> is a nested typedef that is an alias for the type used to store the length (and indices, if supported) of a standard library container.\n<\/div>\n<p>b) What type does <code>size_type<\/code> default to?  Is it signed or unsigned?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<p><code>std::size_t<\/code>, which is an unsigned type.\n<\/div>\n<p>c) Which functions to get the length of a container return <code>size_type<\/code>?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<p>The <code>size()<\/code> member function and <code>std::size<\/code> both return <code>size_type<\/code>.\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/passing-stdvector\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">16.4<\/span>Passing std::vector\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdvector-and-list-constructors\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">16.2<\/span>Introduction to std::vector and list constructors\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the prior lesson , we introduced operator[], which can be used to subscript an array to access an element. In this lesson, we&#8217;ll look at other ways to access array elements, as well as a few different ways to get the length of an container class (the number of &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15392"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15392"}],"version-history":[{"count":16,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15392\/revisions"}],"predecessor-version":[{"id":17850,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15392\/revisions\/17850"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15392"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15392"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15392"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}