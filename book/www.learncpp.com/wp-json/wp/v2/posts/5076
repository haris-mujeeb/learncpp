{"id":5076,"date":"2016-11-23T13:57:38","date_gmt":"2016-11-23T21:57:38","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=5076"},"modified":"2024-02-18T21:22:42","modified_gmt":"2024-02-19T05:22:42","slug":"printing-inherited-classes-using-operator","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/printing-inherited-classes-using-operator\/","title":{"rendered":"25.11 &#8212; Printing inherited classes using operator&lt;&lt;"},"content":{"rendered":"<p>Consider the following program that makes use of a virtual function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n\tvirtual void print() const { std::cout &lt;&lt; \"Base\";  }\r\n};\r\n\r\nclass Derived : public Base\r\n{\r\npublic:\r\n\tvoid print() const override { std::cout &lt;&lt; \"Derived\"; }\r\n};\r\n\r\nint main()\r\n{\r\n\tDerived d{};\r\n\tBase&amp; b{ d };\r\n\tb.print(); \/\/ will call Derived::print()\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>By now, you should be comfortable with the fact that b.print() will call Derived::print() (because b is referencing a Derived class object, Base::print() is a virtual function, and Derived::print() is an override).<\/p>\n<p>While calling member functions like this to do output is okay, this style of function doesn&#8217;t mix well with std::cout:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tDerived d{};\r\n\tBase&amp; b{ d };\r\n\r\n\tstd::cout &lt;&lt; \"b is a \";\r\n\tb.print(); \/\/ messy, we have to break our print statement to call this function\r\n\tstd::cout &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In this lesson, we&#8217;ll look at how to override operator&lt;&lt; for classes using inheritance, so that we can use operator&lt;&lt; as expected, like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::cout &lt;&lt; \"b is a \" &lt;&lt; b &lt;&lt; '\\n'; \/\/ much better<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The challenges with operator&lt;&lt;<\/p>\n<p>Let&#8217;s start by overloading operator&lt;&lt; in the typical way:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n\tvirtual void print() const { std::cout &lt;&lt; \"Base\"; }\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Base&amp; b)\r\n\t{\r\n\t\tout &lt;&lt; \"Base\";\r\n\t\treturn out;\r\n\t}\r\n};\r\n\r\nclass Derived : public Base\r\n{\r\npublic:\r\n\tvoid print() const override { std::cout &lt;&lt; \"Derived\"; }\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Derived&amp; d)\r\n\t{\r\n\t\tout &lt;&lt; \"Derived\";\r\n\t\treturn out;\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tBase b{};\r\n\tstd::cout &lt;&lt; b &lt;&lt; '\\n';\r\n\r\n\tDerived d{};\r\n\tstd::cout &lt;&lt; d &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Because there is no need for virtual function resolution here, this program works as we&#8217;d expect, and prints:<\/p>\n<pre>\r\nBase\r\nDerived\r\n<\/pre>\n<p>Now, consider the following main() function instead:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    Derived d{};\r\n    Base&amp; bref{ d };\r\n    std::cout &lt;&lt; bref &lt;&lt; '\\n';\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\r\nBase\r\n<\/pre>\n<p>That&#8217;s probably not what we were expecting.  This happens because our version of operator&lt;&lt; that handles Base objects isn&#8217;t virtual, so std::cout &lt;&lt; bref calls the version of operator&lt;&lt; that handles Base objects rather than Derived objects.<\/p>\n<p>Therein lies the challenge.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Can we make operator&lt;&lt; virtual?<\/p>\n<p>If this issue is that operator&lt;&lt; isn&#8217;t virtual, can&#8217;t we simply make it virtual?<\/p>\n<p>The short answer is no.  There are a number of reasons for this.<\/p>\n<p>First, only member functions can be virtualized -- this makes sense, since only classes can inherit from other classes, and there&#8217;s no way to override a function that lives outside of a class (you can overload non-member functions, but not override them).  Because we typically implement operator&lt;&lt; as a friend, and friends aren&#8217;t considered member functions, a friend version of operator&lt;&lt; is ineligible to be virtualized.  (For a review of why we implement operator&lt;&lt; this way, please revisit lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-operators-using-member-functions\/\">21.5 -- Overloading operators using member functions<\/a>).<\/p>\n<p>Second, even if we could virtualize operator&lt;&lt; there&#8217;s the problem that the function parameters for Base::operator&lt;&lt; and Derived::operator&lt;&lt; differ (the Base version would take a Base parameter and the Derived version would take a Derived parameter).  Consequently, the Derived version wouldn&#8217;t be considered an override of the Base version, and thus be ineligible for virtual function resolution.<\/p>\n<p>So what&#8217;s a programmer to do?<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A solution<\/p>\n<p>The answer, as it turns out, is surprisingly simple.<\/p>\n<p>First, we set up <code>operator&lt;&lt;<\/code> as a friend in our base class as usual.  But rather than have <code>operator&lt;&lt;<\/code> determine what to print, we will instead have it call a normal member function that <em>can<\/em> be virtualized!  This virtual function will do the work of determining what to print for each class.<\/p>\n<p>In this first solution, our virtual member function (which we call <code>identify()<\/code>) returns a <code>std::string<\/code>, which is printed by <code>Base::operator&lt;&lt;<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n\t\/\/ Here's our overloaded operator&lt;&lt;\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Base&amp; b)\r\n\t{\r\n\t\t\/\/ Call virtual function identify() to get the string to be printed\r\n\t\tout &lt;&lt; b.identify();\r\n\t\treturn out;\r\n\t}\r\n\r\n\t\/\/ We'll rely on member function identify() to return the string to be printed\r\n\t\/\/ Because identify() is a normal member function, it can be virtualized\r\n\tvirtual std::string identify() const\r\n\t{\r\n\t\treturn \"Base\";\r\n\t}\r\n};\r\n\r\nclass Derived : public Base\r\n{\r\npublic:\r\n\t\/\/ Here's our override identify() function to handle the Derived case\r\n\tstd::string identify() const override\r\n\t{\r\n\t\treturn \"Derived\";\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tBase b{};\r\n\tstd::cout &lt;&lt; b &lt;&lt; '\\n';\r\n\r\n\tDerived d{};\r\n\tstd::cout &lt;&lt; d &lt;&lt; '\\n'; \/\/ note that this works even with no operator&lt;&lt; that explicitly handles Derived objects\r\n\r\n\tBase&amp; bref{ d };\r\n\tstd::cout &lt;&lt; bref &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints the expected result:<\/p>\n<pre>\nBase\r\nDerived\r\nDerived\r\n<\/pre>\n<p>Let&#8217;s examine how this works in more detail.<\/p>\n<p>In the case of <code>Base b<\/code>, <code>operator&lt;&lt;<\/code> is called with parameter <code>b<\/code> referencing the Base object.  Virtual function call <code>b.identify()<\/code> thus resolves to <code>Base::identify()<\/code>, which returns &#8220;Base&#8221; to be printed.  Nothing too special here.<\/p>\n<p>In the case of <code>Derived d<\/code>, the compiler first looks to see if there&#8217;s an <code>operator&lt;&lt;<\/code> that takes a Derived object.  There isn&#8217;t one, because we didn&#8217;t define one.  Next the compiler looks to see if there&#8217;s an <code>operator&lt;&lt;<\/code> that takes a Base object.  There is, so the compiler does an implicit upcast of our Derived object to a Base&#038; and calls the function (we could have done this upcast ourselves, but the compiler is helpful in this regard).  Because parameter <code>b<\/code> is referencing a Derived object, virtual function call <code>b.identify()<\/code> resolves to <code>Derived::identify()<\/code>, which returns &#8220;Derived&#8221; to be printed.<\/p>\n<p>Note that we don&#8217;t need to define an <code>operator&lt;&lt;<\/code> for each derived class!  The version that handles Base objects works just fine for both Base objects and any class derived from Base!<\/p>\n<p>The third case proceeds as a mix of the first two.  First, the compiler matches variable bref with <code>operator&lt;&lt;<\/code> that takes a Base reference.  Because parameter <code>b<\/code> is referencing a Derived object, <code>b.identify()<\/code> resolves to <code>Derived::identify()<\/code>, which returns &#8220;Derived&#8221;.<\/p>\n<p>Problem solved.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A more flexible solution<\/p>\n<p>The above solution works great, but has two potential shortcomings:<\/p>\n<ol start=\"1\">\n<li>It makes the assumption that the desired output can be represented as a single std::string.\n<\/li>\n<li>Our <code>identify()<\/code> member function does not have access to the stream object.\n<\/li>\n<\/ol>\n<p>The latter is problematic in cases where we need a stream object, such as when we want to print the value of a member variable that has an overloaded operator&lt;&lt;.<\/p>\n<p>Fortunately, it&#8217;s straightforward to modify the above example to resolve both of these issues.  In the previous version, virtual function <code>identify()<\/code> returned a string to be printed by <code>Base::operator&lt;&lt;<\/code>.  In this version, we&#8217;ll instead define virtual member function <code>print()<\/code> and delegate responsibility for printing <em>directly<\/em> to that function.<\/p>\n<p>Here&#8217;s an example that illustrates the idea:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n\t\/\/ Here's our overloaded operator&lt;&lt;\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Base&amp; b)\r\n\t{\r\n\t\t\/\/ Delegate printing responsibility for printing to virtual member function print()\r\n\t\treturn b.print(out);\r\n\t}\r\n\r\n\t\/\/ We'll rely on member function print() to do the actual printing\r\n\t\/\/ Because print() is a normal member function, it can be virtualized\r\n\tvirtual std::ostream&amp; print(std::ostream&amp; out) const\r\n\t{\r\n\t\tout &lt;&lt; \"Base\";\r\n\t\treturn out;\r\n\t}\r\n};\r\n\r\n\/\/ Some class or struct with an overloaded operator&lt;&lt;\r\nstruct Employee\r\n{\r\n\tstd::string name{};\r\n\tint id{};\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Employee&amp; e)\r\n\t{\r\n\t\tout &lt;&lt; \"Employee(\" &lt;&lt; e.name &lt;&lt; \", \" &lt;&lt; e.id &lt;&lt; \")\";\r\n\t\treturn out;\r\n\t}\r\n};\r\n\r\nclass Derived : public Base\r\n{\r\nprivate:\r\n\tEmployee m_e{}; \/\/ Derived now has an Employee member\r\n\r\npublic:\r\n\tDerived(const Employee&amp; e)\r\n\t\t: m_e{ e }\r\n\t{\r\n\t}\r\n\r\n\t\/\/ Here's our override print() function to handle the Derived case\r\n\tstd::ostream&amp; print(std::ostream&amp; out) const override\r\n\t{\r\n\t\tout &lt;&lt; \"Derived: \";\r\n\r\n\t\t\/\/ Print the Employee member using the stream object\r\n\t\tout &lt;&lt; m_e;\r\n\r\n\t\treturn out;\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tBase b{};\r\n\tstd::cout &lt;&lt; b &lt;&lt; '\\n';\r\n\r\n\tDerived d{ Employee{\"Jim\", 4}};\r\n\tstd::cout &lt;&lt; d &lt;&lt; '\\n'; \/\/ note that this works even with no operator&lt;&lt; that explicitly handles Derived objects\r\n\r\n\tBase&amp; bref{ d };\r\n\tstd::cout &lt;&lt; bref &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This outputs:<\/p>\n<pre>\nBase\r\nDerived: Employee(Jim, 4)\r\nDerived: Employee(Jim, 4)\r\n<\/pre>\n<p>In this version, <code>Base::operator&lt;&lt;<\/code> doesn&#8217;t do any printing itself.  Instead, it just calls virtual member function <code>print()<\/code> and passes it the stream object.  The <code>print()<\/code> function then uses this stream object to do its own printing.  <code>Base::print()<\/code> uses the stream object to print &#8220;Base&#8221;.  More interestingly, <code>Derived::print()<\/code> uses the stream object to print both &#8220;Derived: &#8221; and to call <code>Employee::operator&lt;&lt;<\/code> to print the value of member <code>m_e<\/code>.  The latter would have been more challenging to do in the prior example!<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-25-summary-and-quiz\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">25.x<\/span>Chapter 25 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/dynamic-casting\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">25.10<\/span>Dynamic casting\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Consider the following program that makes use of a virtual function: #include &lt;iostream&gt; class Base { public: virtual void print() const { std::cout &lt;&lt; &#8220;Base&#8221;; } }; class Derived : public Base { public: void print() const override { std::cout &lt;&lt; &#8220;Derived&#8221;; } }; int main() { Derived d{}; Base&amp; &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5076"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=5076"}],"version-history":[{"count":20,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5076\/revisions"}],"predecessor-version":[{"id":16691,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5076\/revisions\/16691"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=5076"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=5076"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=5076"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}