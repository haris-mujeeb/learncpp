{"id":15424,"date":"2023-09-11T15:46:38","date_gmt":"2023-09-11T22:46:38","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15424"},"modified":"2024-12-02T13:10:35","modified_gmt":"2024-12-02T21:10:35","slug":"passing-and-returning-stdarray","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/passing-and-returning-stdarray\/","title":{"rendered":"17.3 &#8212; Passing and returning std::array"},"content":{"rendered":"<p>An object of type <code>std::array<\/code> can be passed to a function just like any other object.  That means if we pass a <code>std::array<\/code> by value, an expensive copy will be made.  Therefore, we typically pass <code>std::array<\/code> by (const) reference to avoid such copies.<\/p>\n<p>With a <code>std::array<\/code>, both the element type and array length are part of the type information of the object.  Therefore, when we use a <code>std::array<\/code> as a function parameter, we have to explicitly specify both the element type and array length:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nvoid passByRef(const std::array&lt;int, 5&gt;&amp; arr) \/\/ we must explicitly specify &lt;int, 5&gt; here\r\n{\r\n    std::cout &lt;&lt; arr[0] &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::array arr{ 9, 7, 5, 3, 1 }; \/\/ CTAD deduces type std::array&lt;int, 5&gt;\r\n    passByRef(arr);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>CTAD doesn&#8217;t (currently) work with function parameters, so we cannot just specify <code>std::array<\/code> here and let the compiler deduce the template arguments.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using function templates to pass <code>std::array<\/code> of different element types or lengths<\/p>\n<p>To write a function that can accept <code>std::array<\/code> with any kind of element type or any length, we can create a function template that parameterizes both the element type and length of our <code>std::array<\/code>, and then C++ will use that function template to instantiate real functions with actual types and lengths.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover function templates in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-templates\/\">11.6 -- Function templates<\/a>.\n<\/p><\/div>\n<p>Since <code>std::array<\/code> is defined like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template&lt;typename T, std::size_t N&gt; \/\/ N is a non-type template parameter\r\nstruct array;<\/code><\/pre>\n<p>We can create a function template that uses the same template parameter declaration:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T, std::size_t N&gt; \/\/ note that this template parameter declaration matches the one for std::array\r\nvoid passByRef(const std::array&lt;T, N&gt;&amp; arr)\r\n{\r\n    static_assert(N != 0); \/\/ fail if this is a zero-length std::array\r\n\r\n    std::cout &lt;&lt; arr[0] &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::array arr{ 9, 7, 5, 3, 1 }; \/\/ use CTAD to infer std::array&lt;int, 5&gt;\r\n    passByRef(arr);  \/\/ ok: compiler will instantiate passByRef(const std::array&lt;int, 5&gt;&amp; arr)\r\n\r\n    std::array arr2{ 1, 2, 3, 4, 5, 6 }; \/\/ use CTAD to infer std::array&lt;int, 6&gt;\r\n    passByRef(arr2); \/\/ ok: compiler will instantiate passByRef(const std::array&lt;int, 6&gt;&amp; arr)\r\n\r\n    std::array arr3{ 1.2, 3.4, 5.6, 7.8, 9.9 }; \/\/ use CTAD to infer std::array&lt;double, 5&gt;\r\n    passByRef(arr3); \/\/ ok: compiler will instantiate passByRef(const std::array&lt;double, 5&gt;&amp; arr)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, we&#8217;ve created a single function template named <code>passByRef()<\/code> that has a parameter of type <code>std::array&lt;T, N&gt;<\/code>.   <code>T<\/code> and <code>N<\/code> are defined in the template parameter declaration on the previous line: <code>template &lt;typename T, std::size_t N&gt;<\/code>.  <code>T<\/code> is a standard type template parameter that allows the caller to specify the element type.  <code>N<\/code> is a non-type template parameter of type <code>std::size_t<\/code> that allows the caller to specify the array length.<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Note that the type of the non-type template parameter for <code>std::array<\/code> should be <code>std::size_t<\/code>, not <code>int<\/code>!  This is because <code>std::array<\/code> is defined as <code>template&lt;class T, std::size_t N&gt; struct array;<\/code>.  If you use <code>int<\/code> as the type of the non-type template parameter, the compiler will be unable to match the argument of type <code>std::array&lt;T, std::size_t&gt;<\/code> with the parameter of type <code>std::array&lt;T, int&gt;<\/code> (and templates won&#8217;t do conversions).\n<\/div>\n<p>Therefore, when we call <code>passByRef(arr)<\/code> from <code>main()<\/code> (where <code>arr<\/code> is defined as a <code>std::array&lt;int, 5&gt;<\/code>), the compiler will instantiate and call <code>void passByRef(const std::array&lt;int, 5&gt;&amp; arr)<\/code>.  A similar process happens for <code>arr2<\/code> and <code>arr3<\/code>.<\/p>\n<p>Thus, we&#8217;ve created a single function template that can instantiate functions to handle <code>std::array<\/code> arguments of any element type and length!<\/p>\n<p>If desired, it is also possible to only template one of the two template parameters.  In the following example, we parameterize only the length of the <code>std::array<\/code>, but the element type is explicitly defined as <code>int<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\ntemplate &lt;std::size_t N&gt; \/\/ note: only the length has been templated here\r\nvoid passByRef(const std::array&lt;int, N&gt;&amp; arr) \/\/ we've defined the element type as int\r\n{\r\n    static_assert(N != 0); \/\/ fail if this is a zero-length std::array\r\n\r\n    std::cout &lt;&lt; arr[0] &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::array arr{ 9, 7, 5, 3, 1 }; \/\/ use CTAD to infer std::array&lt;int, 5&gt;\r\n    passByRef(arr);  \/\/ ok: compiler will instantiate passByRef(const std::array&lt;int, 5&gt;&amp; arr)\r\n\r\n    std::array arr2{ 1, 2, 3, 4, 5, 6 }; \/\/ use CTAD to infer std::array&lt;int, 6&gt;\r\n    passByRef(arr2); \/\/ ok: compiler will instantiate passByRef(const std::array&lt;int, 6&gt;&amp; arr)\r\n\r\n    std::array arr3{ 1.2, 3.4, 5.6, 7.8, 9.9 }; \/\/ use CTAD to infer std::array&lt;double, 5&gt;\r\n    passByRef(arr3); \/\/ error: compiler can't find matching function\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Auto non-type template parameters <span class=\"cpp-section-pill cpp-section-standard\">C++20<\/span><\/p>\n<p>Having to remember (or look up) the type of a non-type template parameter so that you can use it in a template parameter declaration for your own function templates is a pain.<\/p>\n<p>In C++20, we can use <code>auto<\/code> in a template parameter declaration to have a non-type template parameter deduce its type from the argument:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T, auto N&gt; \/\/ now using auto to deduce type of N\r\nvoid passByRef(const std::array&lt;T, N&gt;&amp; arr)\r\n{\r\n    static_assert(N != 0); \/\/ fail if this is a zero-length std::array\r\n\r\n    std::cout &lt;&lt; arr[0] &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::array arr{ 9, 7, 5, 3, 1 }; \/\/ use CTAD to infer std::array&lt;int, 5&gt;\r\n    passByRef(arr);  \/\/ ok: compiler will instantiate passByRef(const std::array&lt;int, 5&gt;&amp; arr)\r\n\r\n    std::array arr2{ 1, 2, 3, 4, 5, 6 }; \/\/ use CTAD to infer std::array&lt;int, 6&gt;\r\n    passByRef(arr2); \/\/ ok: compiler will instantiate passByRef(const std::array&lt;int, 6&gt;&amp; arr)\r\n\r\n    std::array arr3{ 1.2, 3.4, 5.6, 7.8, 9.9 }; \/\/ use CTAD to infer std::array&lt;double, 5&gt;\r\n    passByRef(arr3); \/\/ ok: compiler will instantiate passByRef(const std::array&lt;double, 5&gt;&amp; arr)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>If your compiler is C++20 capable, this is fine to use.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Static asserting on array length<\/p>\n<p>Consider the following template function, which is similar to the one presented above:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T, std::size_t N&gt;\r\nvoid printElement3(const std::array&lt;T, N&gt;&amp; arr)\r\n{\r\n    std::cout &lt;&lt; arr[3] &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::array arr{ 9, 7, 5, 3, 1 };\r\n    printElement3(arr);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>While <code>printElement3()<\/code> works fine in this case, there&#8217;s a potential bug waiting for a unwary programmer in this program.  See it?<\/p>\n<p>The above program prints the value of the array element with index 3.  This is fine as long as the array has a valid element with index 3.  However, the compiler will happily let you pass in arrays where index 3 is out of bounds.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T, std::size_t N&gt;\r\nvoid printElement3(const std::array&lt;T, N&gt;&amp; arr)\r\n{\r\n    std::cout &lt;&lt; arr[3] &lt;&lt; '\\n'; \/\/ invalid index\r\n}\r\n\r\nint main()\r\n{\r\n    std::array arr{ 9, 7 }; \/\/ a 2-element array (valid indexes 0 and 1)\r\n    printElement3(arr);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This leads to undefined behavior.  Ideally, we&#8217;d like the compiler to warn us when we try to do something like this!<\/p>\n<p>One advantage that template parameters have over function parameters is that template parameters are compile-time constants.  This means we can take advantage of capabilities that require constant expressions.<\/p>\n<p>So one solution is to use <code>std::get()<\/code> (which does compile-time bounds checking) instead of <code>operator[]<\/code> (which does no bounds checking):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T, std::size_t N&gt;\r\nvoid printElement3(const std::array&lt;T, N&gt;&amp; arr)\r\n{\r\n    std::cout &lt;&lt; std::get&lt;3&gt;(arr) &lt;&lt; '\\n'; \/\/ checks that index 3 is valid at compile-time\r\n}\r\n\r\nint main()\r\n{\r\n    std::array arr{ 9, 7, 5, 3, 1 };\r\n    printElement3(arr); \/\/ okay\r\n\r\n    std::array arr2{ 9, 7 };\r\n    printElement3(arr2); \/\/ compile error\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When the compiler reaches the call to <code>printElement3(arr2)<\/code>, it will instantiate the function <code>printElement3(const std::array&lt;int, 2&gt;&amp;)<\/code>.  Inside the body of this function is the line <code>std::get&lt;3&gt;(arr)<\/code>.  Since the array parameter&#8217;s length is 2, this is a invalid access, and the compiler will emit an error.<\/p>\n<p>An alternative solution is to use <code>static_assert<\/code> to validate a precondition on the array length ourselves:<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover preconditions in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/assert-and-static_assert\/\">9.6 -- Assert and static_assert<\/a>.\n<\/p><\/div>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T, std::size_t N&gt;\r\nvoid printElement3(const std::array&lt;T, N&gt;&amp; arr)\r\n{\r\n    \/\/ precondition: array length must be greater than 3 so element 3 exists\r\n    static_assert (N &gt; 3);\r\n\r\n    \/\/ we can assume the array length is greater than 3 beyond this point\r\n\r\n    std::cout &lt;&lt; arr[3] &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::array arr{ 9, 7, 5, 3, 1 };\r\n    printElement3(arr); \/\/ okay\r\n\r\n    std::array arr2{ 9, 7 };\r\n    printElement3(arr2); \/\/ compile error\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When the compiler reaches the call to <code>printElement3(arr2)<\/code>, it will instantiate the function <code>printElement3(const std::array&lt;int, 2&gt;&amp;)<\/code>.  Inside the body of this function is the line <code>static_assert (N &gt; 3)<\/code>.  Since the <code>N<\/code> template non-type parameter has value <code>2<\/code>, and <code>2 &gt; 3<\/code> is false, the compiler will emit an error.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>In the example above, you may be wondering why we use <code>static_assert (N &gt; 3);<\/code> instead of <code>static_assert (std::size(arr) &gt; 3)<\/code>.  The latter won&#8217;t compile prior to C++23 due to the language defect mentioned in the prior lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdarray-length-and-indexing\/\">17.2 -- std::array length and indexing<\/a>).\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Returning a <code>std::array<\/code><\/p>\n<p>Syntax aside, passing a <code>std::array<\/code> to a function is conceptually simple -- pass it by (const) reference.  But what if we have a function that needs to return a <code>std::array<\/code>?  Things are a little more complicated.  Unlike <code>std::vector<\/code>, <code>std::array<\/code> is not move-capable, so returning a <code>std::array<\/code> by value will make a copy of the array.  The elements inside the array will be moved if they are move-capable, and copied otherwise.<\/p>\n<p>There are two conventional options here, and which you should pick depends on circumstances.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Returning a <code>std::array<\/code> by value<\/p>\n<p>It is okay to return a <code>std:array<\/code> by value when all of the following are true:<\/p>\n<ul>\n<li>The array isn&#8217;t huge.\n<\/li>\n<li>The element type is cheap to copy (or move).\n<\/li>\n<li>The code isn&#8217;t being used in a performance-sensitive context.\n<\/li>\n<\/ul>\n<p>In such cases, a copy of the <code>std::array<\/code> will be made, but if all of the above are true, the performance hit will be minor, and sticking with the most conventional way to return data to the caller may be the best choice.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;limits&gt;\r\n\r\n\/\/ return by value\r\ntemplate &lt;typename T, std::size_t N&gt;\r\nstd::array&lt;T, N&gt; inputArray() \/\/ return by value\r\n{\r\n\tstd::array&lt;T, N&gt; arr{};\r\n\tstd::size_t index { 0 };\r\n\twhile (index &lt; N)\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Enter value #\" &lt;&lt; index &lt;&lt; \": \";\r\n\t\tstd::cin &gt;&gt; arr[index];\r\n\r\n\t\tif (!std::cin) \/\/ handle bad input\r\n\t\t{\r\n\t\t\tstd::cin.clear();\r\n\t\t\tstd::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\t++index;\r\n\t}\r\n\r\n\treturn arr;\r\n}\r\n\r\nint main()\r\n{\r\n\tstd::array&lt;int, 5&gt; arr { inputArray&lt;int, 5&gt;() };\r\n\r\n\tstd::cout &lt;&lt; \"The value of element 2 is \" &lt;&lt; arr[2] &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>There are a few nice things about this method:<\/p>\n<ul>\n<li>It uses the most conventional way to return data to the caller.\n<\/li>\n<li>It&#8217;s obvious that the function is returning a value.\n<\/li>\n<li>We can define an array and use the function to initialize it in a single statement.\n<\/li>\n<\/ul>\n<p>There are also a few downsides:<\/p>\n<ul>\n<li>The function returns a copy of the array and all its elements, which isn&#8217;t cheap.\n<\/li>\n<li>When we call the function, we must explicitly supply the template arguments since there is no parameter to deduce them from.\n<\/li>\n<\/ul>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Returning a <code>std::array<\/code> via an out parameter<\/p>\n<p>In cases where return by value is too expensive, we can use an out-parameter instead.  In this case, the caller is responsible for passing in the <code>std::array<\/code> by non-const reference (or by address), and the function can then modify this array.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;limits&gt;\r\n#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T, std::size_t N&gt;\r\nvoid inputArray(std::array&lt;T, N&gt;&amp; arr) \/\/ pass by non-const reference\r\n{\r\n\tstd::size_t index { 0 };\r\n\twhile (index &lt; N)\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Enter value #\" &lt;&lt; index &lt;&lt; \": \";\r\n\t\tstd::cin &gt;&gt; arr[index];\r\n\r\n\t\tif (!std::cin) \/\/ handle bad input\r\n\t\t{\r\n\t\t\tstd::cin.clear();\r\n\t\t\tstd::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\t++index;\r\n\t}\r\n\r\n}\r\n\r\nint main()\r\n{\r\n\tstd::array&lt;int, 5&gt; arr {};\r\n\tinputArray(arr);\r\n\r\n\tstd::cout &lt;&lt; \"The value of element 2 is \" &lt;&lt; arr[2] &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>The primary advantage of this method is that no copy of the array is ever made, so this is efficient.<\/p>\n<p>There are also a few downsides:<\/p>\n<ul>\n<li>This method of returning data is non-conventional, and it is not easy to tell that the function is modifying the argument.\n<\/li>\n<li>We can only use this method to assign values to the array, not initialize it.\n<\/li>\n<li>Such a function cannot be used to produce temporary objects.\n<\/li>\n<\/ul>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Returning a <code>std::vector<\/code> instead<\/p>\n<p><code>std::vector<\/code> is move-capable and can be returned by value without making expensive copies.  If you&#8217;re returning a <code>std::array<\/code> by value, your <code>std::array<\/code> probably isn&#8217;t constexpr, and you should consider using (and returning) <code>std::vector<\/code> instead.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Complete the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    constexpr std::array arr1 { 1, 4, 9, 16 };\r\n    printArray(arr1);\r\n\r\n    constexpr std::array arr2 { 'h', 'e', 'l', 'l', 'o' };\r\n    printArray(arr2);\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>When run, it should print:<\/p>\n<pre>\nThe array (1, 4, 9, 16) has length 4\r\nThe array (h, e, l, l, o) has length 5\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T, std::size_t N&gt;\r\nvoid printArray(const std::array&lt;T, N&gt;&amp; arr)\r\n{\r\n    std::cout &lt;&lt; \"The array (\";\r\n\r\n    auto separator {\"\"};\r\n    for (const auto&amp; e: arr)\r\n    {\r\n        std::cout &lt;&lt; separator &lt;&lt; e;\r\n        separator = \", \";\r\n    }\r\n    \r\n    std::cout &lt;&lt; \") has length \" &lt;&lt; N &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    constexpr std::array arr1 { 1, 4, 9, 16 };\r\n    printArray(arr1);\r\n\r\n    constexpr std::array arr2 { 'h', 'e', 'l', 'l', 'o' };\r\n    printArray(arr2);\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdarray-of-class-types-and-brace-elision\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.4<\/span>std::array of class types, and brace elision\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdarray-length-and-indexing\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.2<\/span>std::array length and indexing\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>An object of type std::array can be passed to a function just like any other object. That means if we pass a std::array by value, an expensive copy will be made. Therefore, we typically pass std::array by (const) reference to avoid such copies. With a std::array, both the element type &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15424"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15424"}],"version-history":[{"count":12,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15424\/revisions"}],"predecessor-version":[{"id":17943,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15424\/revisions\/17943"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15424"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15424"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15424"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}