{"id":133,"date":"2007-09-11T18:19:49","date_gmt":"2007-09-12T02:19:49","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/810-const-class-objects-and-member-functions\/"},"modified":"2025-02-12T11:31:57","modified_gmt":"2025-02-12T19:31:57","slug":"const-class-objects-and-const-member-functions","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/const-class-objects-and-const-member-functions\/","title":{"rendered":"14.4 &#8212; Const class objects and const member functions"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constant-variables-named-constants\/\">5.1 -- Constant variables (named constants)<\/a>, you learned that objects of a fundamental data type (<code>int<\/code>, <code>double<\/code>, <code>char<\/code>, etc&#8230;) can be made constant via the <code>const<\/code> keyword.  All const variables must be initialized at time of creation.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">const int x;      \/\/ compile error: not initialized\r\nconst int y{};    \/\/ ok: value initialized\r\nconst int z{ 5 }; \/\/ ok: list initialized<\/code><\/pre>\n<p>Similarly, class type objects (struct, classes, and unions) can also be made const by using the <code>const<\/code> keyword.  Such objects must also be initialized at the time of creation.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">struct Date\r\n{\r\n    int year {};\r\n    int month {};\r\n    int day {};\r\n};\r\n\r\nint main()\r\n{\r\n    const Date today { 2020, 10, 14 }; \/\/ const class type object\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Just like with normal variables, you&#8217;ll generally want to make your class type objects const (or constexpr) when you need to ensure they aren&#8217;t modified after creation.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Modifying the data members of const objects is disallowed<\/p>\n<p>Once a const class type object has been initialized, any attempt to modify the data members of the object is disallowed, as it would violate the const-ness of the object.  This includes both changing member variables directly (if they are public), or calling member functions that set the value of member variables.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">struct Date\r\n{\r\n    int year {};\r\n    int month {};\r\n    int day {};\r\n\r\n    void incrementDay()\r\n    {\r\n        ++day;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    const Date today { 2020, 10, 14 }; \/\/ const\r\n\r\n    today.day += 1;        \/\/ compile error: can't modify member of const object\r\n    today.incrementDay();  \/\/ compile error: can't call member function that modifies member of const object\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Const objects may not call non-const member functions<\/p>\n<p>You may be surprised to find that this code also causes a compilation error:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Date\r\n{\r\n    int year {};\r\n    int month {};\r\n    int day {};\r\n\r\n    void print()\r\n    {\r\n        std::cout &lt;&lt; year &lt;&lt; '\/' &lt;&lt; month &lt;&lt; '\/' &lt;&lt; day;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    const Date today { 2020, 10, 14 }; \/\/ const\r\n\r\n    today.print();  \/\/ compile error: can't call non-const member function\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Even though <code>print()<\/code> does not try to modify a member variable, our call to <code>today.print()<\/code> is still a const violation.  This happens because the <code>print()<\/code> member function itself is not declared as const.  The compiler won&#8217;t let us call a non-const member function on a const object.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Const member functions<\/p>\n<p>To address the above issue, we need to make <code>print()<\/code> a const member function.  A <strong>const member function<\/strong> is a member function that guarantees it will not modify the object or call any non-const member functions (as they may modify the object).<\/p>\n<p>Making <code>print()<\/code> a const member function is easy -- we simply append the <code>const<\/code> keyword to the function prototype, after the parameter list, but before the function body:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Date\r\n{\r\n    int year {};\r\n    int month {};\r\n    int day {};\r\n\r\n    void print() const \/\/ now a const member function\r\n    {\r\n        std::cout &lt;&lt; year &lt;&lt; '\/' &lt;&lt; month &lt;&lt; '\/' &lt;&lt; day;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    const Date today { 2020, 10, 14 }; \/\/ const\r\n\r\n    today.print();  \/\/ ok: const object can call const member function\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, <code>print()<\/code> has been made a const member function, which means we can call it on const objects (such as <code>today<\/code>).<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>For member functions defined outside of the class definition, the <code>const<\/code> keyword must be used on both the function declaration in the class definition, and on the function definition outside the class definition.  We show an example of this in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/classes-and-header-files\/\">15.2 -- Classes and header files<\/a>.<\/p>\n<p>Constructors may not be made const, as they need to initialize the members of the object, which requires modifying them.  We cover constructors in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-constructors\/\">14.9 -- Introduction to constructors<\/a>.\n<\/p><\/div>\n<p>A const member function that attempts to change a data member or call a non-const member function will cause a compiler error to occur.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">struct Date\r\n{\r\n    int year {};\r\n    int month {};\r\n    int day {};\r\n\r\n    void incrementDay() const \/\/ made const\r\n    {\r\n        ++day; \/\/ compile error: const function can't modify member\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    const Date today { 2020, 10, 14 }; \/\/ const\r\n\r\n    today.incrementDay();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this example, <code>incrementDay()<\/code> has been marked as a const member function, but it attempts to change <code>day<\/code>.  This will cause a compiler error.<\/p>\n<p>Const member functions can modify non-members (such as local variables and function parameters) and call non-member functions per usual.  The const only applies to members.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>A const member function may not: modify the implicit object, call non-const member functions.<br \/>\nA const member function may: modify objects that aren&#8217;t the implicit object, call const member functions, call non-member functions.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Const member functions may be called on non-const objects<\/p>\n<p>Const member functions may also be called on non-const objects:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Date\r\n{\r\n    int year {};\r\n    int month {};\r\n    int day {};\r\n\r\n    void print() const \/\/ const\r\n    {\r\n        std::cout &lt;&lt; year &lt;&lt; '\/' &lt;&lt; month &lt;&lt; '\/' &lt;&lt; day;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Date today { 2020, 10, 14 }; \/\/ non-const\r\n\r\n    today.print();  \/\/ ok: can call const member function on non-const object\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because const member functions can be called on both const and non-const objects, if a member function does not modify the state of the object, it should be made const.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>A member function that does not (and will not ever) modify the state of the object should be made const, so that it can be called on both const and non-const objects.\n<\/p><\/div>\n<p>Be careful about what member functions you apply <code>const<\/code> to.  Once a member function is made const, that function can be called on const objects.  Later removal of <code>const<\/code> on a member function will break any code that calls that member function on a const object.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Const objects via pass by const reference<\/p>\n<p>Although instantiating const local variables is one way to create const objects, a more common way to get a const object is by passing an object to a function by const reference.<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pass-by-lvalue-reference\/\">12.5 -- Pass by lvalue reference<\/a>, we covered the merits of passing class type arguments by const reference instead of by value.  To recap, passing a class type argument by value causes a copy of the class to be made (which is slow) -- most of the time, we don&#8217;t need a copy, a reference to the original argument works just fine and avoids making a copy.  We typically make the reference const to allow the function to accept const lvalue arguments and rvalue arguments (e.g. literals and temporary objects).<\/p>\n<p>Can you figure out what&#8217;s wrong with the following code?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Date\r\n{\r\n    int year {};\r\n    int month {};\r\n    int day {};\r\n\r\n    void print() \/\/ non-const\r\n    {\r\n        std::cout &lt;&lt; year &lt;&lt; '\/' &lt;&lt; month &lt;&lt; '\/' &lt;&lt; day;\r\n    }\r\n};\r\n\r\nvoid doSomething(const Date&amp; date)\r\n{\r\n    date.print();\r\n}\r\n\r\nint main()\r\n{\r\n    Date today { 2020, 10, 14 }; \/\/ non-const\r\n    today.print();\r\n\r\n    doSomething(today);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The answer is that inside of the <code>doSomething()<\/code> function, <code>date<\/code> is treated as a const object (because it was passed by const reference).  And with that const <code>date<\/code>, we&#8217;re calling non-const member function <code>print()<\/code>.  Since we can&#8217;t call non-const member functions on const objects, this will cause a compile error.<\/p>\n<p>The fix is simple: make <code>print()<\/code> const:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Date\r\n{\r\n    int year {};\r\n    int month {};\r\n    int day {};\r\n\r\n    void print() const \/\/ now const\r\n    {\r\n        std::cout &lt;&lt; year &lt;&lt; '\/' &lt;&lt; month &lt;&lt; '\/' &lt;&lt; day;\r\n    }\r\n};\r\n\r\nvoid doSomething(const Date&amp; date)\r\n{\r\n    date.print();\r\n}\r\n\r\nint main()\r\n{\r\n    Date today { 2020, 10, 14 }; \/\/ non-const\r\n    today.print();\r\n\r\n    doSomething(today);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Now in function <code>doSomething()<\/code>, <code>const date<\/code> will be able to successfully call const member function <code>print()<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Member function const and non-const overloading<\/p>\n<p>Finally, although it is not done very often, it is possible to overload a member function to have a const and non-const version of the same function.  This works because the const qualifier is considered part of the function&#8217;s signature, so two functions which differ only in their const-ness are considered distinct.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Something\r\n{\r\n    void print()\r\n    {\r\n        std::cout &lt;&lt; \"non-const\\n\";\r\n    }\r\n\r\n    void print() const\r\n    {\r\n        std::cout &lt;&lt; \"const\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Something s1{};\r\n    s1.print(); \/\/ calls print()\r\n\r\n    const Something s2{};\r\n    s2.print(); \/\/ calls print() const\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">non-const\r\nconst<\/code><\/pre>\n<p>Overloading a function with a const and non-const version is typically done when the return value needs to differ in constness.  This is pretty rare.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/public-and-private-members-and-access-specifiers\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.5<\/span>Public and private members and access specifiers\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/member-functions\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.3<\/span>Member functions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , you learned that objects of a fundamental data type (int, double, char, etc&#8230;) can be made constant via the const keyword. All const variables must be initialized at time of creation. const int x; \/\/ compile error: not initialized const int y{}; \/\/ ok: value initialized const &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/133"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=133"}],"version-history":[{"count":38,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/133\/revisions"}],"predecessor-version":[{"id":18190,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/133\/revisions\/18190"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=133"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=133"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=133"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}