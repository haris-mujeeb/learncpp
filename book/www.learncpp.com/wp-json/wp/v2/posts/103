{"id":103,"date":"2007-07-16T13:40:49","date_gmt":"2007-07-16T21:40:49","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/610-pointers-and-const\/"},"modified":"2025-02-12T11:41:28","modified_gmt":"2025-02-12T19:41:28","slug":"pointers-and-const","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/pointers-and-const\/","title":{"rendered":"12.9 &#8212; Pointers and const"},"content":{"rendered":"<p>Consider the following code snippet:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int x { 5 };\r\n    int* ptr { &amp;x }; \/\/ ptr is a normal (non-const) pointer\r\n\r\n    int y { 6 };\r\n    ptr = &amp;y; \/\/ we can point at another value\r\n\r\n    *ptr = 7; \/\/ we can change the value at the address being held\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>With normal (non-const) pointers, we can change both what the pointer is pointing at (by assigning the pointer a new address to hold) or change the value at the address being held (by assigning a new value to the dereferenced pointer).<\/p>\n<p>However, what happens if the value we want to point at is const?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    const int x { 5 }; \/\/ x is now const\r\n    int* ptr { &amp;x };   \/\/ compile error: cannot convert from const int* to int*\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The above snippet won&#8217;t compile -- we can&#8217;t set a normal pointer to point at a const variable.  This makes sense: a const variable is one whose value cannot be changed.  Allowing the programmer to set a non-const pointer to a const value would allow the programmer to dereference the pointer and change the value.  That would violate the const-ness of the variable.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Pointer to const value<\/p>\n<p>A <strong>pointer to a const value<\/strong> (sometimes called a <code>pointer to const<\/code> for short) is a (non-const) pointer that points to a constant value.<\/p>\n<p>To declare a pointer to a const value, use the <code>const<\/code> keyword before the pointer&#8217;s data type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    const int x{ 5 };\r\n    const int* ptr { &amp;x }; \/\/ okay: ptr is pointing to a \"const int\"\r\n\r\n    *ptr = 6; \/\/ not allowed: we can't change a const value\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, <code>ptr<\/code> points to a <code>const int<\/code>.  Because the data type being pointed to is const, the value being pointed to can&#8217;t be changed.<\/p>\n<p>However, because a pointer to const is not const itself (it just points to a const value), we can change what the pointer is pointing at by assigning the pointer a new address:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    const int x{ 5 };\r\n    const int* ptr { &amp;x }; \/\/ ptr points to const int x\r\n\r\n    const int y{ 6 };\r\n    ptr = &amp;y; \/\/ okay: ptr now points at const int y\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Just like a reference to const, a pointer to const can point to non-const variables too.  A pointer to const treats the value being pointed to as constant, regardless of whether the object at that address was initially defined as const or not:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int x{ 5 }; \/\/ non-const\r\n    const int* ptr { &amp;x }; \/\/ ptr points to a \"const int\"\r\n\r\n    *ptr = 6;  \/\/ not allowed: ptr points to a \"const int\" so we can't change the value through ptr\r\n    x = 6; \/\/ allowed: the value is still non-const when accessed through non-const identifier x\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Const pointers<\/p>\n<p>We can also make a pointer itself constant.  A <strong>const pointer<\/strong> is a pointer whose address can not be changed after initialization.<\/p>\n<p>To declare a const pointer, use the <code>const<\/code> keyword after the asterisk in the pointer declaration:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int x{ 5 };\r\n    int* const ptr { &amp;x }; \/\/ const after the asterisk means this is a const pointer\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above case, <code>ptr<\/code> is a const pointer to a (non-const) int value.<\/p>\n<p>Just like a normal const variable, a const pointer must be initialized upon definition, and this value can&#8217;t be changed via assignment:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int x{ 5 };\r\n    int y{ 6 };\r\n\r\n    int* const ptr { &amp;x }; \/\/ okay: the const pointer is initialized to the address of x\r\n    ptr = &amp;y; \/\/ error: once initialized, a const pointer can not be changed.\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, because the <em>value<\/em> being pointed to is non-const, it is possible to change the value being pointed to via dereferencing the const pointer:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int x{ 5 };\r\n    int* const ptr { &amp;x }; \/\/ ptr will always point to x\r\n\r\n    *ptr = 6; \/\/ okay: the value being pointed to is non-const\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Const pointer to a const value<\/p>\n<p>Finally, it is possible to declare a <strong>const pointer to a const value<\/strong> by using the <code>const<\/code> keyword both before the type and after the asterisk:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int value { 5 };\r\n    const int* const ptr { &amp;value }; \/\/ a const pointer to a const value\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>A const pointer to a const value can not have its address changed, nor can the value it is pointing to be changed through the pointer.  It can only be dereferenced to get the value it is pointing at.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Pointer and const recap<\/p>\n<p>To summarize, you only need to remember 4 rules, and they are pretty logical:<\/p>\n<ul>\n<li>A non-const pointer (e.g. <code>int* ptr<\/code>) can be assigned another address to change what it is pointing at.\n<\/li>\n<li>A const pointer (e.g. <code>int* const ptr<\/code>) always points to the same address, and this address can not be changed.\n<\/li>\n<\/ul>\n<p><!-- list break --><\/p>\n<ul>\n<li>A pointer to a non-const value (e.g. <code>int* ptr<\/code>) can change the value it is pointing to.  These can not point to a const value.\n<\/li>\n<li>A pointer to a const value (e.g. <code>const int* ptr<\/code>) treats the value as const when accessed through the pointer, and thus can not change the value it is pointing to.  These can be pointed to const or non-const l-values (but not r-values, which don&#8217;t have an address).\n<\/li>\n<\/ul>\n<p>Keeping the declaration syntax straight can be a bit challenging:<\/p>\n<ul>\n<li>A <code>const<\/code> before the asterisk (e.g. <code>const int* ptr<\/code>) is associated with the type being pointed to.  Therefore, this is a pointer to a const value, and the value cannot be modified through the pointer.\n<\/li>\n<li>A <code>const<\/code> after the asterisk (e.g. <code>int* const ptr<\/code>) is associated with the pointer itself.  Therefore, this pointer cannot be assigned a new address.\n<\/li>\n<\/ul>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int v{ 5 };\r\n   \r\n    int* ptr0 { &amp;v };             \/\/ points to an \"int\" but is not const itself.  We can modify the value or the address.\r\n    const int* ptr1 { &amp;v };       \/\/ points to a \"const int\" but is not const itself.  We can only modify the address.\r\n    int* const ptr2 { &amp;v };       \/\/ points to an \"int\" and is const itself.   We can only modify the value.\r\n    const int* const ptr3 { &amp;v }; \/\/ points to a \"const int\" and is const itself.  We can't modify the value nor the address.\r\n\r\n    \/\/ if the const is on the left side of the *, the const belongs to the value\r\n    \/\/ if the const is on the right side of the *, the const belongs to the pointer\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pass-by-address\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.10<\/span>Pass by address\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/null-pointers\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.8<\/span>Null pointers\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Consider the following code snippet: int main() { int x { 5 }; int* ptr { &amp;x }; \/\/ ptr is a normal (non-const) pointer int y { 6 }; ptr = &amp;y; \/\/ we can point at another value *ptr = 7; \/\/ we can change the value at &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/103"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=103"}],"version-history":[{"count":36,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/103\/revisions"}],"predecessor-version":[{"id":18193,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/103\/revisions\/18193"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=103"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=103"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=103"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}