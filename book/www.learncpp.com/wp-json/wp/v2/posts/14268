{"id":14268,"date":"2023-04-21T16:12:34","date_gmt":"2023-04-21T23:12:34","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=14268"},"modified":"2024-10-20T15:39:41","modified_gmt":"2024-10-20T22:39:41","slug":"non-type-template-parameters","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/non-type-template-parameters\/","title":{"rendered":"11.9 &#8212; Non-type template parameters"},"content":{"rendered":"<p>In the previous lessons, we discussed how to create function templates that use type template parameters.  A type template parameter serves as a placeholder for an actual type that is passed in as a template argument.<\/p>\n<p>While type template parameters are by far the most common type of template parameter used, there is another kind of template parameter worth knowing about: the non-type template parameter.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Non-type template parameters<\/p>\n<p>A <strong>non-type template parameter<\/strong> is a template parameter with a fixed type that serves as a placeholder for a constexpr value passed in as a template argument.<\/p>\n<p>A non-type template parameter can be any of the following types:<\/p>\n<ul>\n<li>An integral type\n<\/li>\n<li>An enumeration type\n<\/li>\n<li><code>std::nullptr_t<\/code>\n<\/li>\n<li>A floating point type (since C++20)\n<\/li>\n<li>A pointer or reference to an object\n<\/li>\n<li>A pointer or reference to a function\n<\/li>\n<li>A pointer or reference to a member function\n<\/li>\n<li>A literal class type (since C++20)\n<\/li>\n<\/ul>\n<p>We saw our first example of a non-type template parameter when we discussed <code>std::bitset<\/code> in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/bit-flags-and-bit-manipulation-via-stdbitset\/\">O.1 -- Bit flags and bit manipulation via std::bitset<\/a>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;bitset&gt;\r\n\r\nint main()\r\n{\r\n    std::bitset&lt;8&gt; bits{ 0b0000'0101 }; \/\/ The &lt;8&gt; is a non-type template parameter\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the case of <code>std::bitset<\/code>, the non-type template parameter is used to tell the <code>std::bitset<\/code> how many bits we want it to store.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Defining our own non-type template parameters<\/p>\n<p>Here&#8217;s a simple example of a function that uses an int non-type template parameter:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;int N&gt; \/\/ declare a non-type template parameter of type int named N\r\nvoid print()\r\n{\r\n    std::cout &lt;&lt; N &lt;&lt; '\\n'; \/\/ use value of N here\r\n}\r\n\r\nint main()\r\n{\r\n    print&lt;5&gt;(); \/\/ 5 is our non-type template argument\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This example prints:<\/p>\n<pre>\n5\r\n<\/pre>\n<p>On line 3, we have our template parameter declaration.  Inside the angled brackets, we&#8217;re defining a non-type template parameter named <code>N<\/code> that will be a placeholder for a value of type <code>int<\/code>.  Inside the <code>print()<\/code> function, we use the value of <code>N<\/code>.<\/p>\n<p>On line 11, we have our call to function <code>print()<\/code>, which uses int value <code>5<\/code> as the non-type template argument.  When the compiler sees this call, it will instantiate a function that looks something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;&gt;\r\nvoid print&lt;5&gt;()\r\n{\r\n    std::cout &lt;&lt; 5 &lt;&lt; '\\n';\r\n}<\/code><\/pre>\n<p>At runtime, when this function is called from <code>main()<\/code>, it prints <code>5<\/code>.<\/p>\n<p>Then the program ends.  Pretty simple, right?<\/p>\n<p>Much like <code>T<\/code> is typically used as the name for the first type template parameter, <code>N<\/code> is conventionally used as the name of an int non-type template parameter.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Use <code>N<\/code> as the name of an int non-type template parameter.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">What are non-type template parameters useful for?<\/p>\n<p>As of C++20, function parameters cannot be constexpr.  This is true for normal functions, constexpr functions (which makes sense, as they must be able to be run at runtime), and perhaps surprisingly, even consteval functions.<\/p>\n<p>So let&#8217;s say we have some function like this one:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;cmath&gt; \/\/ for std::sqrt\r\n#include &lt;iostream&gt;\r\n\r\ndouble getSqrt(double d)\r\n{\r\n    assert(d &gt;= 0.0 &amp;&amp; \"getSqrt(): d must be non-negative\");\r\n\r\n    \/\/ The assert above will probably be compiled out in non-debug builds\r\n    if (d &gt;= 0)\r\n        return std::sqrt(d);\r\n\r\n    return 0.0;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; getSqrt(5.0) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; getSqrt(-5.0) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When run, the call to <code>getSqrt(-5.0)<\/code> will runtime assert out.  While this is better than nothing, because <code>-5.0<\/code> is a literal (and implicitly constexpr), it would be better if we could static_assert so that errors such as this one would be caught at compile-time.  However, static_assert requires a constant expression, and function parameters can&#8217;t be constexpr&#8230;<\/p>\n<p>However, if we change the function parameter to a non-type template parameter instead, then we can do exactly as we want:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cmath&gt; \/\/ for std::sqrt\r\n#include &lt;iostream&gt;\r\n\r\ntemplate &lt;double D&gt; \/\/ requires C++20 for floating point non-type parameters\r\ndouble getSqrt()\r\n{\r\n    static_assert(D &gt;= 0.0, \"getSqrt(): D must be non-negative\");\r\n\r\n    if constexpr (D &gt;= 0) \/\/ ignore the constexpr here for this example\r\n        return std::sqrt(D); \/\/ strangely, std::sqrt isn't a constexpr function (until C++26)\r\n\r\n    return 0.0;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; getSqrt&lt;5.0&gt;() &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; getSqrt&lt;-5.0&gt;() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This version fails to compile.  When the compiler encounters <code>getSqrt&lt;-5.0&gt;()<\/code>, it will instantiate and call a function that looks something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;&gt;\r\ndouble getSqrt&lt;-5.0&gt;()\r\n{\r\n    static_assert(-5.0 &gt;= 0.0, \"getSqrt(): D must be non-negative\");\r\n\r\n    if constexpr (-5.0 &gt;= 0) \/\/ ignore the constexpr here for this example\r\n        return std::sqrt(-5.0);\r\n\r\n    return 0.0;\r\n}<\/code><\/pre>\n<p>The static_assert condition is false, so the compiler asserts out.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Non-type template parameters are used primarily when we need to pass constexpr values to functions (or class types) so they can be used in contexts that require a constant expression.<\/p>\n<p>The class type <code>std::bitset<\/code> uses a non-type template parameter to define the number of bits to store because the number of bits must be a constexpr value.\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>Having to use non-type template parameters to circumvent the restriction that function parameters can&#8217;t be constexpr isn&#8217;t great.  There are quite a few different proposals being evaluated to help address situations like this.  I expect that we might see a better solution to this in a future C++ language standard.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Implicit conversions for non-type template arguments <span class=\"cpp-section-pill cpp-section-optional\">Optional<\/span><\/p>\n<p>Certain non-type template arguments can be implicitly converted in order to match a non-type template parameter of a different type.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;int N&gt; \/\/ int non-type template parameter\r\nvoid print()\r\n{\r\n    std::cout &lt;&lt; N &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    print&lt;5&gt;();   \/\/ no conversion necessary\r\n    print&lt;'c'&gt;(); \/\/ 'c' converted to type int, prints 99\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n5\r\n99\r\n<\/pre>\n<p>In the above example, <code>'c'<\/code> is converted to an <code>int<\/code> in order to match the non-type template parameter of function template <code>print()<\/code>, which then prints the value as an <code>int<\/code>.<\/p>\n<p>In this context, only certain types of constexpr conversions are allowed.  The most common types of allowed conversions include:<\/p>\n<ul>\n<li>Integral promotions (e.g. <code>char<\/code> to <code>int<\/code>)\n<\/li>\n<li>Integral conversions (e.g. <code>char<\/code> to <code>long<\/code> or <code>int<\/code> to <code>char<\/code>)\n<\/li>\n<li>User-defined conversions (e.g. some program-defined class to <code>int<\/code>)\n<\/li>\n<li>Lvalue to rvalue conversions (e.g. some variable <code>x<\/code> to the value of <code>x<\/code>)\n<\/li>\n<\/ul>\n<p>Note that this list is less permissive than the type of implicit conversions allowed for list initialization.  For example, you can list initialize a variable of type <code>double<\/code> using a <code>constexpr int<\/code>, but a <code>constexpr int<\/code> non-type template argument will not convert to a <code>double<\/code> non-type template parameter.<\/p>\n<p>The full list of allowed conversions can be found <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/language\/constant_expression\">here<\/a> under the subsection &#8220;Converted constant expression&#8221;.<\/p>\n<p>Unlike with normal functions, the algorithm for matching function template calls to function template definitions is not sophisticated, and certain matches are not prioritized over others based on the type of conversion required (or lack thereof).  This means that if a function template is overloaded for different kinds of non-type template parameters, it can very easily result in an ambiguous match:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;int N&gt; \/\/ int non-type template parameter\r\nvoid print()\r\n{\r\n    std::cout &lt;&lt; N &lt;&lt; '\\n';\r\n}\r\n\r\ntemplate &lt;char N&gt; \/\/ char non-type template parameter\r\nvoid print()\r\n{\r\n    std::cout &lt;&lt; N &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    print&lt;5&gt;();   \/\/ ambiguous match with int N = 5 and char N = 5\r\n    print&lt;'c'&gt;(); \/\/ ambiguous match with int N = 99 and char N = 'c'\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Perhaps surprisingly, both of these calls to <code>print()<\/code> result in ambiguous matches.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Type deduction for non-type template parameters using <code>auto<\/code> <span class=\"cpp-section-pill cpp-section-standard\">C++17<\/span><\/p>\n<p>As of C++17, non-type template parameters may use <code>auto<\/code> to have the compiler deduce the non-type template parameter from the template argument:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;auto N&gt; \/\/ deduce non-type template parameter from template argument\r\nvoid print()\r\n{\r\n    std::cout &lt;&lt; N &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    print&lt;5&gt;();   \/\/ N deduced as int `5`\r\n    print&lt;'c'&gt;(); \/\/ N deduced as char `c`\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This compiles and produces the expected result:<\/p>\n<pre>\n5\r\nc\r\n<\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>You may be wondering why this example doesn&#8217;t produce an ambiguous match like the example in the prior section.  The compiler looks for ambiguous matches first, and then instantiates the function template if no ambiguous matches exist.  In this case, there is only one function template, so there is no possible ambiguity.<\/p>\n<p>After instantiating the function template for the above example, the program looks something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;auto N&gt;\r\nvoid print()\r\n{\r\n    std::cout &lt;&lt; N &lt;&lt; '\\n';\r\n}\r\n\r\ntemplate &lt;&gt;\r\nvoid print&lt;5&gt;() \/\/ note that this is print&lt;5&gt; and not print&lt;int&gt;\r\n{\r\n    std::cout &lt;&lt; 5 &lt;&lt; '\\n';\r\n}\r\n\r\ntemplate &lt;&gt;\r\nvoid print&lt;'c'&gt;() \/\/ note that this is print&lt;`c`&gt; and not print&lt;char&gt;\r\n{\r\n    std::cout &lt;&lt; 'c' &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    print&lt;5&gt;();   \/\/ calls print&lt;5&gt;\r\n    print&lt;'c'&gt;(); \/\/ calls print&lt;'c'&gt;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Write a constexpr function template with a non-type template parameter that returns the factorial of the template argument.  The following program should fail to compile when it reaches <code>factorial&lt;-3&gt;()<\/code>.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ define your factorial() function template here\r\n\r\nint main()\r\n{\r\n    static_assert(factorial&lt;0&gt;() == 1);\r\n    static_assert(factorial&lt;3&gt;() == 6);\r\n    static_assert(factorial&lt;5&gt;() == 120);\r\n\r\n    factorial&lt;-3&gt;(); \/\/ should fail to compile\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;int N&gt;\r\nconstexpr int factorial()\r\n{\r\n    static_assert(N &gt;= 0);\r\n\r\n    int product { 1 };\r\n    for (int i { 2 }; i &lt;= N; ++i)\r\n        product *= i;\r\n\r\n    return product;\r\n}\r\n\r\nint main()\r\n{\r\n    static_assert(factorial&lt;0&gt;() == 1);\r\n    static_assert(factorial&lt;3&gt;() == 6);\r\n    static_assert(factorial&lt;5&gt;() == 120);\r\n\r\n    factorial&lt;-3&gt;(); \/\/ should fail to compile\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/using-function-templates-in-multiple-files\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">11.10<\/span>Using function templates in multiple files\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-templates-with-multiple-template-types\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">11.8<\/span>Function templates with multiple template types\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the previous lessons, we discussed how to create function templates that use type template parameters. A type template parameter serves as a placeholder for an actual type that is passed in as a template argument. While type template parameters are by far the most common type of template parameter &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/14268"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=14268"}],"version-history":[{"count":16,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/14268\/revisions"}],"predecessor-version":[{"id":17778,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/14268\/revisions\/17778"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=14268"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=14268"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=14268"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}