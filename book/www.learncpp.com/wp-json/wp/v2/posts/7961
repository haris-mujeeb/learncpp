{"id":7961,"date":"2019-02-01T12:02:44","date_gmt":"2019-02-01T20:02:44","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=7961"},"modified":"2023-06-05T16:03:36","modified_gmt":"2023-06-05T23:03:36","slug":"using-an-integrated-debugger-the-call-stack","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/using-an-integrated-debugger-the-call-stack\/","title":{"rendered":"3.9 &#8212; Using an integrated debugger: The call stack"},"content":{"rendered":"<p>Modern debuggers contain one more debugging information window that can be very useful in debugging your program, and that is the call stack window.<\/p>\n<p>When your program calls a function, you already know that it bookmarks the current location, makes the function call, and then returns.  How does it know where to return to?  The answer is that it keeps track in the call stack.<\/p>\n<p>The <strong>call stack<\/strong> is a list of all the active functions that have been called to get to the current point of execution.  The call stack includes an entry for each function called, as well as which line of code will be returned to when the function returns.  Whenever a new function is called, that function is added to the top of the call stack.  When the current function returns to the caller, it is removed from the top of the call stack, and control returns to the function just below it.<\/p>\n<p>The <strong>call stack window<\/strong> is a debugger window that shows the current call stack.  If you don&#8217;t see the call stack window, you will need to tell the IDE to show it.<\/p>\n<div class=\"cpp-note cpp-lightyellowbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For Visual Studio users<\/p>\n<p>In Visual Studio, the call stack window can be found via <em>Debug menu &gt; Windows &gt; Call Stack<\/em>.  Note that you have to be in a debug session to activate this window.\n<\/div>\n<div class=\"cpp-note cpp-lightyellowbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For Code::Blocks users<\/p>\n<p>In Code::Blocks, the call stack window can be found via <em>Debug menu &gt; Debugging windows &gt; Call stack<\/em>.\n<\/div>\n<div class=\"cpp-note cpp-lightyellowbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For VS Code users<\/p>\n<p>In VS Code, the call stack window appears in debug mode, docked on the left.\n<\/p><\/div>\n<p>Let&#8217;s take a look at the call stack using a sample program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid a()\r\n{\r\n\tstd::cout &lt;&lt; \"a() called\\n\";\r\n}\r\n\r\nvoid b()\r\n{\r\n\tstd::cout &lt;&lt; \"b() called\\n\";\r\n\ta();\r\n}\r\n\r\nint main()\r\n{\r\n\ta();\r\n\tb();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Put breakpoints on lines 5 and 10 of this program, and then start debugging mode.  Because function <em>a<\/em> is called first, the breakpoint on line 5 will be hit first.<\/p>\n<p>At this point, you should see something like this:<\/p>\n<div class=\"cpp-image-wrapper\"><img src=\"https:\/\/www.learncpp.com\/images\/CppTutorial\/Chapter3\/VS-CallStack1-min.png\" alt=\"\" \/><\/div>\n<p>Your IDE may exhibit some differences:<\/p>\n<ul>\n<li>The format of your function names and line numbers may be different\n<\/li>\n<li>Your line numbers may be slightly different (off by 1)\n<\/li>\n<li>Instead of <em>&#091;External Code&#093;<\/em> you may see a bunch of other crazily named functions.\n<\/li>\n<\/ul>\n<p>These differences are inconsequential.<\/p>\n<p>What&#8217;s relevant here is the top two lines.  From the bottom up, we can see that function <em>main<\/em> was called first, and then that function <em>a<\/em> was called next.<\/p>\n<p>The <em>line 5<\/em> next to function <em>a<\/em> shows us where the current point of execution is (which matches the execution marker in the code window).  The <em>line 17<\/em> on the second line indicates the line that will be returned to when control returns to function <em>main<\/em>.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>The line numbers after the function names show the next line to be executed in each function.<\/p>\n<p>Since the top entry on the call stack represents the currently executing function, the line number here shows the next line that will execute when execution resumes.  The remaining entries in the call stack represent functions that will be returned to at some point, so the line number for these represent the next statement that will execute after the function is returned to.\n<\/p><\/div>\n<p>Now, choose the <em>continue<\/em> debug command to advance execution to the next breakpoint, which will be on line 10.  The call stack should update to reflect the new situation:<\/p>\n<div class=\"cpp-image-wrapper\"><img src=\"https:\/\/www.learncpp.com\/images\/CppTutorial\/Chapter3\/VS-CallStack2-min.png\" alt=\"\" \/><\/div>\n<p>You&#8217;ll notice that function <em>b<\/em> is now the top line of the call stack, reflecting the fact that function <em>b<\/em> is the function that is actively being executed.  Note that function <em>a<\/em> is no longer represented on the call stack.  This is because function <em>a<\/em> was removed from the call stack when it returned.<\/p>\n<p>Choose the <em>continue<\/em> debug command one more time, and we&#8217;ll hit the breakpoint on line 5 again (because function <em>b<\/em> calls function <em>a<\/em>).  The call stack will look like this:<\/p>\n<div class=\"cpp-image-wrapper\"><img src=\"https:\/\/www.learncpp.com\/images\/CppTutorial\/Chapter3\/VS-CallStack3-min.png\" alt=\"\" \/><\/div>\n<p>There are now three functions on the call stack: (from bottom to top) <em>main<\/em>, which called function <em>b<\/em>, which called function <em>a<\/em>.<\/p>\n<p>The call stack is useful in conjunction with breakpoints, when your breakpoint is hit and you want to know what functions were called to get to that specific point in the code.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Conclusion<\/p>\n<p>Congratulations, you now know the basics of using an integrated debugger!  Using stepping, breakpoints, watches, and the call stack window, you now have the fundamentals to be able to debug almost any problem.  Like many things, becoming good at using a debugger takes some practice and some trial and error.  But again, we&#8217;ll reiterate the point that the time devoted to learning how to use an integrated debugger effectively will be repaid many times over in time saved debugging your programs!<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/finding-issues-before-they-become-problems\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">3.10<\/span>Finding issues before they become problems\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/using-an-integrated-debugger-watching-variables\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">3.8<\/span>Using an integrated debugger: Watching variables\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Modern debuggers contain one more debugging information window that can be very useful in debugging your program, and that is the call stack window. When your program calls a function, you already know that it bookmarks the current location, makes the function call, and then returns. How does it know &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/7961"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=7961"}],"version-history":[{"count":8,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/7961\/revisions"}],"predecessor-version":[{"id":13021,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/7961\/revisions\/13021"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=7961"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=7961"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=7961"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}