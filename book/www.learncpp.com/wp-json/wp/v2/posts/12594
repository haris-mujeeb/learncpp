{"id":12594,"date":"2022-02-02T14:56:03","date_gmt":"2022-02-02T22:56:03","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=12594"},"modified":"2025-01-21T20:06:19","modified_gmt":"2025-01-22T04:06:19","slug":"type-deduction-with-pointers-references-and-const","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/type-deduction-with-pointers-references-and-const\/","title":{"rendered":"12.14 &#8212; Type deduction with pointers, references, and const"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/type-deduction-for-objects-using-the-auto-keyword\/\">10.8 -- Type deduction for objects using the auto keyword<\/a>, we discussed how the <code>auto<\/code> keyword can be used to have the compiler deduce the type of a variable from the initializer:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int a { 5 };\r\n    auto b { a }; \/\/ b deduced as an int\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>We also noted that by default, type deduction will drop <code>const<\/code> from types:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    const double a { 7.8 }; \/\/ a has type const double\r\n    auto b { a };           \/\/ b has type double (const dropped)\r\n\r\n    constexpr double c { 7.8 }; \/\/ c has type const double (constexpr implicitly applies const)\r\n    auto d { c };               \/\/ d has type double (const dropped)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Const (or constexpr) can be reapplied by adding the <code>const<\/code> (or <code>constexpr<\/code>) qualifier to the definition of the deduced type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    double a { 7.8 };    \/\/ a has type double\r\n    const auto b { a };  \/\/ b has type const double (const applied)\r\n\r\n    constexpr double c { 7.8 }; \/\/ c has type const double (constexpr implicitly applies const)\r\n    const auto d { c };         \/\/ d is const double (const dropped, const reapplied)\r\n    constexpr auto e { c };     \/\/ e is constexpr double (const dropped, constexpr reapplied)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Type deduction drops references<\/p>\n<p>In addition to dropping const, type deduction will also drop references:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n\r\nstd::string&amp; getRef(); \/\/ some function that returns a reference\r\n\r\nint main()\r\n{\r\n    auto ref { getRef() }; \/\/ type deduced as std::string (not std::string&amp;)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, variable <code>ref<\/code> is using type deduction.  Although function <code>getRef()<\/code> returns a <code>std::string&amp;<\/code>, the reference qualifier is dropped, so the type of <code>ref<\/code> is deduced as <code>std::string<\/code>.<\/p>\n<p>Just like with dropped <code>const<\/code>, if you want the deduced type to be a reference, you can reapply the reference at the point of definition:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n\r\nstd::string&amp; getRef(); \/\/ some function that returns a reference\r\n\r\nint main()\r\n{\r\n    auto ref1 { getRef() };  \/\/ std::string (reference dropped)\r\n    auto&amp; ref2 { getRef() }; \/\/ std::string&amp; (reference dropped, reference reapplied)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Top-level const and low-level const<\/p>\n<p>A <strong>top-level const<\/strong> is a const qualifier that applies to an object itself.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">const int x;    \/\/ this const applies to x, so it is top-level\r\nint* const ptr; \/\/ this const applies to ptr, so it is top-level\r\n\/\/ references don't have a top-level const syntax, as they are implicitly top-level const<\/code><\/pre>\n<p>In contrast, a <strong>low-level const<\/strong> is a const qualifier that applies to the object being referenced or pointed to:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">const int&amp; ref; \/\/ this const applies to the object being referenced, so it is low-level\r\nconst int* ptr; \/\/ this const applies to the object being pointed to, so it is low-level<\/code><\/pre>\n<p>A reference to a const value is always a low-level const.  A pointer can have a top-level, low-level, or both kinds of const:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">const int* const ptr; \/\/ the left const is low-level, the right const is top-level<\/code><\/pre>\n<p>When we say that type deduction drops const qualifiers, it only drops top-level consts.  Low-level consts are not dropped.  We&#8217;ll see examples of this in just a moment.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Type deduction and const references<\/p>\n<p>If the initializer is a reference to const, the reference is dropped first (and then reapplied if applicable), and then any top-level const is dropped from the result.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n\r\nconst std::string&amp; getConstRef(); \/\/ some function that returns a reference to const\r\n\r\nint main()\r\n{\r\n    auto ref1{ getConstRef() }; \/\/ std::string (reference dropped, then top-level const dropped from result)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, since <code>getConstRef()<\/code> returns a <code>const std::string&amp;<\/code>, the reference is dropped first, leaving us with a <code>const std::string<\/code>.  This const is now a top-level const, so it is also dropped, leaving the deduced type as <code>std::string<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Dropping a reference may change a low-level const to a top-level const: <code>const std::string&amp;<\/code> is a low-level const, but dropping the reference yields <code>const std::string<\/code>, which is a top-level const.\n<\/div>\n<p>We can reapply a reference and\/or const:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n\r\nconst std::string&amp; getConstRef(); \/\/ some function that returns a const reference\r\n\r\nint main()\r\n{\r\n    auto ref1{ getConstRef() };        \/\/ std::string (reference and top-level const dropped)\r\n    const auto ref2{ getConstRef() };  \/\/ const std::string (reference dropped, const dropped, const reapplied)\r\n\r\n    auto&amp; ref3{ getConstRef() };       \/\/ const std::string&amp; (reference dropped and reapplied, low-level const not dropped)\r\n    const auto&amp; ref4{ getConstRef() }; \/\/ const std::string&amp; (reference dropped and reapplied, low-level const not dropped)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>We covered the case for <code>ref1<\/code> in the prior example.  For <code>ref2<\/code>, this is similar to the <code>ref1<\/code> case, except we&#8217;re reapplying the <code>const<\/code> qualifier, so the deduced type is <code>const std::string<\/code>.<\/p>\n<p>Things get more interesting with <code>ref3<\/code>.  Normally the reference would be dropped first, but since we&#8217;ve reapplied the reference, it is not dropped.  That means the type is still <code>const std::string&amp;<\/code>.  And since this const is a low-level const, it is not dropped.  Thus the deduced type is <code>const std::string&amp;<\/code>.<\/p>\n<p>The <code>ref4<\/code> case works similarly to <code>ref3<\/code>, except we&#8217;ve reapplied the <code>const<\/code> qualifier as well.  Since the type is already deduced as a reference to const, us reapplying <code>const<\/code> here is redundant.  That said, using <code>const<\/code> here makes it explicitly clear that our result will be const (whereas in the <code>ref3<\/code> case, the constness of the result is implicit and not obvious).<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>If you want a const reference, reapply the <code>const<\/code> qualifier even when it&#8217;s not strictly necessary, as it makes your intent clear and helps prevent mistakes.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">What about constexpr references?<\/p>\n<p>Constexpr is not part of an expression&#8217;s type, so it is not deduced by <code>auto<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">A reminder<\/p>\n<p>When defining a const reference (e.g. <code>const int&amp;<\/code>), the const applies to the object being referenced, not the reference itself.<\/p>\n<p>When defining a constexpr reference to a const variable (e.g. <code>constexpr const int&amp;<\/code>), we need to apply both <code>constexpr<\/code> (which applies to the reference) and <code>const<\/code> (which applies to the type being referenced).<\/p>\n<p>This is covered in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/lvalue-references-to-const\/\">12.4 -- Lvalue references to const<\/a>.\n<\/p><\/div>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string_view&gt;\r\n#include &lt;iostream&gt;\r\n\r\nconstexpr std::string_view hello { \"Hello\" };   \/\/ implicitly const\r\n\r\nconstexpr const std::string_view&amp; getConstRef() \/\/ function is constexpr, returns a const std::string_view&amp;\r\n{\r\n    return hello;\r\n}\r\n\r\nint main()\r\n{\r\n    auto ref1{ getConstRef() };                  \/\/ std::string_view (reference dropped and top-level const dropped)\r\n    constexpr auto ref2{ getConstRef() };        \/\/ constexpr const std::string_view (reference dropped and top-level const dropped, constexpr applied, implicitly const)\r\n\r\n    auto&amp; ref3{ getConstRef() };                 \/\/ const std::string_view&amp; (reference reapplied, low-level const not dropped)\r\n    constexpr const auto&amp; ref4{ getConstRef() }; \/\/ constexpr const std::string_view&amp; (reference reapplied, low-level const not dropped, constexpr applied)\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Type deduction and pointers<\/p>\n<p>Unlike references, type deduction does not drop pointers:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n\r\nstd::string* getPtr(); \/\/ some function that returns a pointer\r\n\r\nint main()\r\n{\r\n    auto ptr1{ getPtr() }; \/\/ std::string*\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>We can also use an asterisk in conjunction with pointer type deduction (<code>auto*<\/code>) to make it clearer that the deduced type is a pointer:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n\r\nstd::string* getPtr(); \/\/ some function that returns a pointer\r\n\r\nint main()\r\n{\r\n    auto ptr1{ getPtr() };  \/\/ std::string*\r\n    auto* ptr2{ getPtr() }; \/\/ std::string*\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>The reason that references are dropped during type deduction but pointers are not dropped is because references and pointers have different semantics.<\/p>\n<p>When we evaluate a reference, we&#8217;re really evaluating the object being referenced.  Therefore, when deducing a type, it makes sense that we should deduce the type of the thing being referenced, not the reference itself.  Also, since we deduce a non-reference, it&#8217;s really easy to make it a reference by using <code>auto&amp;<\/code>.  If type deduction were to deduce a reference instead, the syntax for removing a reference if we didn&#8217;t want it is much more complicated.<\/p>\n<p>On the other hand, pointers hold the address of an object.  When we evaluate a pointer, we are evaluating the pointer, not the object being pointed to (if we want that, we can dereference the pointer).  Therefore, it makes sense that we should deduce the type of the pointer, not the thing being pointed to.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The difference between auto and auto* <span class=\"cpp-section-pill cpp-section-optional\">Optional<\/span><\/p>\n<p>When we use <code>auto<\/code> with a pointer type initializer, the type deduced for <code>auto<\/code> includes the pointer.  So for <code>ptr1<\/code> above, the type substituted for <code>auto<\/code> is <code>std::string*<\/code>.<\/p>\n<p>When we use <code>auto*<\/code> with a pointer type initializer, the type deduced for auto does <em>not<\/em> include the pointer -- the pointer is reapplied afterward after the type is deduced.  So for <code>ptr2<\/code> above, the type substituted for <code>auto<\/code> is <code>std::string<\/code>, and then the pointer is reapplied.<\/p>\n<p>In most cases, the practical effect is the same (<code>ptr1<\/code> and <code>ptr2<\/code> both deduce to <code>std::string*<\/code> in the above example).<\/p>\n<p>However, there are a couple of difference between <code>auto<\/code> and <code>auto*<\/code> in practice.  First, <code>auto*<\/code> must resolve to a pointer initializer, otherwise a compile error will result:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n\r\nstd::string* getPtr(); \/\/ some function that returns a pointer\r\n\r\nint main()\r\n{\r\n    auto ptr3{ *getPtr() };      \/\/ std::string (because we dereferenced getPtr())\r\n    auto* ptr4{ *getPtr() };     \/\/ does not compile (initializer not a pointer)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This makes sense: in the <code>ptr4<\/code> case, <code>auto<\/code> deduces to <code>std::string<\/code>, then the pointer is reapplied.  Thus <code>ptr4<\/code> has type <code>std::string*<\/code>, and we can&#8217;t initialize a <code>std::string*<\/code> with an initializer that is not a pointer.<\/p>\n<p>Second, there are differences in how <code>auto<\/code> and <code>auto*<\/code> behave when we introduce <code>const<\/code> into the equation.  We&#8217;ll cover this below.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Type deduction and const pointers <span class=\"cpp-section-pill cpp-section-optional\">Optional<\/span><\/p>\n<p>Since pointers aren&#8217;t dropped, we don&#8217;t have to worry about that.  But with pointers, we have both the const pointer and the pointer to const cases to think about, and we also have <code>auto<\/code> vs <code>auto*<\/code>.  Just like with references, only top-level const is dropped during pointer type deduction.<\/p>\n<p>Let&#8217;s start with a simple case:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n\r\nstd::string* getPtr(); \/\/ some function that returns a pointer\r\n\r\nint main()\r\n{\r\n    const auto ptr1{ getPtr() };  \/\/ std::string* const\r\n    auto const ptr2 { getPtr() }; \/\/ std::string* const\r\n\r\n    const auto* ptr3{ getPtr() }; \/\/ const std::string*\r\n    auto* const ptr4{ getPtr() }; \/\/ std::string* const\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When we use either <code>auto const<\/code> or <code>const auto<\/code>, we&#8217;re saying, &#8220;make the deduced pointer a const pointer&#8221;.  So in the case of <code>ptr1<\/code> and <code>ptr2<\/code>, the deduced type is <code>std::string*<\/code>, and then const is applied, making the final type <code>std::string* const<\/code>.  This is similar to how <code>const int<\/code> and <code>int const<\/code> mean the same thing.<\/p>\n<p>However, when we use <code>auto*<\/code>, the order of the const qualifier matters.  A <code>const<\/code> on the left means &#8220;make the deduced pointer a pointer to const&#8221;, whereas a <code>const<\/code> on the right means &#8220;make the deduced pointer type a const pointer&#8221;.  Thus <code>ptr3<\/code> ends up as a pointer to const, and <code>ptr4<\/code> ends up as a const pointer.<\/p>\n<p>Now let&#8217;s look at an example where the initializer is a const pointer to const.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n\r\nint main()\r\n{\r\n    std::string s{};\r\n    const std::string* const ptr { &amp;s };\r\n\r\n    auto ptr1{ ptr };  \/\/ const std::string*\r\n    auto* ptr2{ ptr }; \/\/ const std::string*\r\n\r\n    auto const ptr3{ ptr };  \/\/ const std::string* const\r\n    const auto ptr4{ ptr };  \/\/ const std::string* const\r\n\r\n    auto* const ptr5{ ptr }; \/\/ const std::string* const\r\n    const auto* ptr6{ ptr }; \/\/ const std::string*\r\n\r\n    const auto const ptr7{ ptr };  \/\/ error: const qualifer can not be applied twice\r\n    const auto* const ptr8{ ptr }; \/\/ const std::string* const\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The <code>ptr1<\/code> and <code>ptr2<\/code> cases are straightforward.  The top-level const (the const on the pointer itself) is dropped.  The low-level const on the object being pointed to is not dropped.  So in both cases, the final type is <code>const std::string*<\/code>.<\/p>\n<p>The <code>ptr3<\/code> and <code>ptr4<\/code> cases are also straightforward.  The top-level const is dropped, but we&#8217;re reapplying it.  The low-level const on the object being pointed to is not dropped.  So in both cases, the final type is <code>const std::string* const<\/code>.<\/p>\n<p>The <code>ptr5<\/code> and <code>ptr6<\/code> cases are analogous to the cases we showed in the prior example.  In both cases, the top-level const is dropped.  For <code>ptr5<\/code>, the <code>auto* const<\/code> reapplies the top-level const, so the final type is <code>const std::string* const<\/code>.  For <code>ptr6<\/code>, the <code>const auto*<\/code> applies const to the type being pointed to (which in this case was already const), so the final type is <code>const std::string*<\/code>.<\/p>\n<p>In the <code>ptr7<\/code> case, we&#8217;re applying the const qualifier twice, which is disallowed, and will cause a compile error.<\/p>\n<p>And finally, in the <code>ptr8<\/code> case, we&#8217;re applying const on both sides of the pointer (which is allowed since <code>auto*<\/code> must be a pointer type), so the resulting types is <code>const std::string* const<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>If you want a const pointer, pointer to const, or const pointer to const, reapply the <code>const<\/code> qualifier(s) even when it&#8217;s not strictly necessary, as it makes your intent clear and helps prevent mistakes.\n<\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>Consider using <code>auto*<\/code> when deducing a pointer type.  Using <code>auto*<\/code> in this case makes it clearer that we are deducing a pointer type, enlists the compiler&#8217;s help to ensure we don&#8217;t deduce a non-pointer type, and gives you more control over const.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Summary<\/p>\n<p>Sorry to hear about your headache.  Let&#8217;s recap the most important points quickly.<\/p>\n<p>Top-level vs low-level const:<\/p>\n<ul>\n<li>A top-level const applies to the object itself (e.g. <code>const int x<\/code> or <code>int* const ptr<\/code>).\n<\/li>\n<li>A low-level const applies to the object accessed through a reference or pointer (e.g. <code>const int&amp; ref<\/code>, <code>const int* ptr<\/code>).\n<\/li>\n<\/ul>\n<p>What type deduction deduces:<\/p>\n<ul>\n<li>Type deduction first drops any references (unless the deduced type is defined as a reference).  For a const reference, dropping the reference will cause the (low-level) const to become a top-level const.\n<\/li>\n<li>Type deduction then drops any top-level const (unless the deduced type is defined as <code>const<\/code> or <code>constexpr<\/code>).\n<\/li>\n<li>Constexpr is not part of the type system, so is never deduced.  It must always be explicitly applied to the deduced type.\n<\/li>\n<li>Type deduction does not drop pointers.\n<\/li>\n<li>Always explicitly define the deduced type as a reference, <code>const<\/code>, or <code>constexpr<\/code> (as applicable), and even if these qualifiers are redundant because they would be deduced.  This helps prevent errors and makes it clear what your intent is.\n<\/li>\n<\/ul>\n<p>Type deduction and pointers:<\/p>\n<ul>\n<li>When using <code>auto<\/code>, the deduced type will be a pointer only if the initializer is a pointer.  When using <code>auto*<\/code>, the deduced type is always a pointer, even if the initializer is not a pointer.\n<\/li>\n<li><code>auto const<\/code> and <code>const auto<\/code> both make the deduced pointer a const pointer.  There is no way to explicitly specify a low-level const (pointer-to-const) using <code>auto<\/code>.\n<\/li>\n<li><code>auto* const<\/code> also makes the deduced pointer a const pointer.  <code>const auto*<\/code> makes the deduced pointer a pointer-to-const.  If these are hard to remember, <code>int* const<\/code> is a const pointer (to int), so <code>auto* const<\/code> must be a const pointer.  <code>const int*<\/code> is a pointer-to-const (int), so <code>const auto*<\/code> must be a pointer-to-const)\n<\/li>\n<li>Consider using <code>auto*<\/code> over <code>auto<\/code> when deducing a pointer type, as it allows you to explicitly reapply both the top-level and low-level const, and will error if a pointer type is not deduced.\n<\/li>\n<\/ul>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdoptional\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.15<\/span>std::optional\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/in-and-out-parameters\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.13<\/span>In and out parameters\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we discussed how the auto keyword can be used to have the compiler deduce the type of a variable from the initializer: int main() { int a { 5 }; auto b { a }; \/\/ b deduced as an int return 0; } We also noted &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12594"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=12594"}],"version-history":[{"count":39,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12594\/revisions"}],"predecessor-version":[{"id":18121,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12594\/revisions\/18121"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=12594"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=12594"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=12594"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}