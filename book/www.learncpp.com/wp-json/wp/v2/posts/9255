{"id":9255,"date":"2019-12-17T10:38:30","date_gmt":"2019-12-17T18:38:30","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=9255"},"modified":"2025-02-11T19:06:56","modified_gmt":"2025-02-12T03:06:56","slug":"introduction-to-iterators","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-iterators\/","title":{"rendered":"18.2 &#8212; Introduction to iterators"},"content":{"rendered":"<p>Iterating through an array (or other structure) of data is quite a common thing to do in programming.  And so far, we&#8217;ve covered many different ways to do so: with loops and an index (<code>for-loops<\/code> and <code>while loops<\/code>), with pointers and pointer arithmetic, and with <code>range-based for-loops<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;cstddef&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    \/\/ In C++17, the type of variable arr is deduced to std::array&lt;int, 7&gt;\r\n    \/\/ If you get an error compiling this example, see the warning below\r\n    std::array arr{ 0, 1, 2, 3, 4, 5, 6 };\r\n    std::size_t length{ std::size(arr) };\r\n\r\n    \/\/ while-loop with explicit index\r\n    std::size_t index{ 0 };\r\n    while (index &lt; length)\r\n    {\r\n        std::cout &lt;&lt; arr[index] &lt;&lt; ' ';\r\n        ++index;\r\n    }\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    \/\/ for-loop with explicit index\r\n    for (index = 0; index &lt; length; ++index)\r\n    {\r\n        std::cout &lt;&lt; arr[index] &lt;&lt; ' ';\r\n    }\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    \/\/ for-loop with pointer (Note: ptr can't be const, because we increment it)\r\n    for (auto ptr{ &amp;arr[0] }; ptr != (&amp;arr[0] + length); ++ptr)\r\n    {\r\n        std::cout &lt;&lt; *ptr &lt;&lt; ' ';\r\n    }\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    \/\/ range-based for loop\r\n    for (int i : arr)\r\n    {\r\n        std::cout &lt;&lt; i &lt;&lt; ' ';\r\n    }\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>The examples in this lesson use a C++17 feature called <code>class template argument deduction<\/code> to deduce the template arguments for a template variable from its initializer.  In the example above, when the compiler sees <code>std::array arr{ 0, 1, 2, 3, 4, 5, 6 };<\/code>, it will deduce that we want <code>std::array&lt;int, 7&gt; arr { 0, 1, 2, 3, 4, 5, 6 };<\/code>.<\/p>\n<p>If your compiler is not C++17 enabled, you&#8217;ll get an error that says something like, &#8220;missing template arguments before \u2018arr\u2019&#8221;.  In that case, your best bet is to enable C++17, as per lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/configuring-your-compiler-choosing-a-language-standard\/\">0.12 -- Configuring your compiler: Choosing a language standard<\/a>.  If you can not, you can replace the lines that use class template argument deduction with lines that have explicit template arguments (e.g. replace <code>std::array arr{ 0, 1, 2, 3, 4, 5, 6 };<\/code> with <code>std::array&lt;int, 7&gt; arr { 0, 1, 2, 3, 4, 5, 6 };<\/code>\n<\/div>\n<p>Looping using indexes is more typing than needed if we only use the index to access elements.  It also only works if the container (e.g. the array) provides direct access to elements (which arrays do, but some other types of containers, such as lists, do not).<\/p>\n<p>Looping with pointers and pointer arithmetic is verbose, and can be confusing to readers who don&#8217;t know the rules of pointer arithmetic.  Pointer arithmetic also only works if elements are consecutive in memory (which is true for arrays, but not true for other types of containers, such as lists, trees, and maps).<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Pointers (without pointer arithmetic) can also be used to iterate through some non-sequential structures.  In a linked list, each element is connected to the prior element by a pointer.  We can iterate through the list by following the chain of pointers.\n<\/p><\/div>\n<p>Range-based for-loops are a little more interesting, as the mechanism for iterating through our container is hidden -- and yet, they still work for all kinds of different structures (arrays, lists, trees, maps, etc&#8230;).  How do these work?  They use iterators.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Iterators<\/p>\n<p>An <strong>iterator<\/strong> is an object designed to traverse through a container (e.g. the values in an array, or the characters in a string), providing access to each element along the way.<\/p>\n<p>A container may provide different kinds of iterators.  For example, an array container might offer a forwards iterator that walks through the array in forward order, and a reverse iterator that walks through the array in reverse order.<\/p>\n<p>Once the appropriate type of iterator is created, the programmer can then use the interface provided by the iterator to traverse and access elements without having to worry about what kind of traversal is being done or how the data is being stored in the container.  And because C++ iterators typically use the same interface for traversal (operator++ to move to the next element) and access (operator* to access the current element), we can iterate through a wide variety of different container types using a consistent method.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Pointers as an iterator<\/p>\n<p>The simplest kind of iterator is a pointer, which (using pointer arithmetic) works for data stored sequentially in memory.  Let&#8217;s revisit a simple array traversal using a pointer and pointer arithmetic:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::array arr{ 0, 1, 2, 3, 4, 5, 6 };\r\n\r\n    auto begin{ &amp;arr[0] };\r\n    \/\/ note that this points to one spot beyond the last element\r\n    auto end{ begin + std::size(arr) };\r\n\r\n    \/\/ for-loop with pointer\r\n    for (auto ptr{ begin }; ptr != end; ++ptr) \/\/ ++ to move to next element\r\n    {\r\n        std::cout &lt;&lt; *ptr &lt;&lt; ' '; \/\/ Indirection to get value of current element\r\n    }\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Output:<\/p>\n<pre>\r\n0 1 2 3 4 5 6\r\n<\/pre>\n<p>In the above, we defined two variables: <code>begin<\/code> (which points to the beginning of our container), and <code>end<\/code> (which marks an end point).  For arrays, the end marker is typically the place in memory where the last element would be if the container contained one more element.<\/p>\n<p>The pointer then iterates between <code>begin<\/code> and <code>end<\/code>, and the current element can be accessed by dereferencing the pointer.<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>You might be tempted to calculate the end marker using the address-of operator and array syntax like so:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int* end{ &amp;arr[std::size(arr)] };<\/code><\/pre>\n<p>But this causes undefined behavior, because <code>arr[std::size(arr)]<\/code> implicitly dereferences an element that is off the end of the array.<\/p>\n<p>Instead, use:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int* end{ arr.data() + std::size(arr) }; \/\/ data() returns a pointer to the first element<\/code><\/pre>\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Standard library iterators<\/p>\n<p>Iterating is such a common operation that all standard library containers offer direct support for iteration.  Instead of calculating our own begin and end points, we can simply ask the container for the begin and end points via member functions conveniently named <code>begin()<\/code> and <code>end()<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::array array{ 1, 2, 3 };\r\n\r\n    \/\/ Ask our array for the begin and end points (via the begin and end member functions).\r\n    auto begin{ array.begin() };\r\n    auto end{ array.end() };\r\n\r\n    for (auto p{ begin }; p != end; ++p) \/\/ ++ to move to next element.\r\n    {\r\n        std::cout &lt;&lt; *p &lt;&lt; ' '; \/\/ Indirection to get value of current element.\r\n    }\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\n1 2 3\r\n<\/pre>\n<p>The <code>iterator<\/code> header also contains two generic functions (<code>std::begin<\/code> and <code>std::end<\/code>) that can be used.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p><code>std::begin<\/code> and <code>std::end<\/code> for C-style arrays are defined in the &lt;iterator&gt; header.<\/p>\n<p><code>std::begin<\/code> and <code>std::end<\/code> for containers that support iterators are defined in the header files for those containers (e.g. &lt;array&gt;, &lt;vector&gt;).\n<\/div>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;    \/\/ includes &lt;iterator&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::array array{ 1, 2, 3 };\r\n\r\n    \/\/ Use std::begin and std::end to get the begin and end points.\r\n    auto begin{ std::begin(array) };\r\n    auto end{ std::end(array) };\r\n\r\n    for (auto p{ begin }; p != end; ++p) \/\/ ++ to move to next element\r\n    {\r\n        std::cout &lt;&lt; *p &lt;&lt; ' '; \/\/ Indirection to get value of current element\r\n    }\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This also prints:<\/p>\n<pre>\r\n1 2 3\r\n<\/pre>\n<p>Don&#8217;t worry about the types of the iterators for now, we&#8217;ll re-visit iterators in a later chapter.  The important thing is that the iterator takes care of the details of iterating through the container.  All we need are four things: the begin point, the end point, operator++ to move the iterator to the next element (or the end), and operator* to get the value of the current element.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><code>operator&lt;<\/code> vs <code>operator!=<\/code> for iterators<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/for-statements\/\">8.10 -- For statements<\/a>, we noted that using <code>operator&lt;<\/code> was preferred over <code>operator!=<\/code> when doing numeric comparisons in the loop condition:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    for (index = 0; index &lt; length; ++index)<\/code><\/pre>\n<p>With iterators, it is conventional to use <code>operator!=<\/code> to test whether the iterator has reached the end element:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    for (auto p{ begin }; p != end; ++p)<\/code><\/pre>\n<p>This is because some iterator types are not relationally comparable.  <code>operator!=<\/code> works with all iterator types.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Back to range-based for loops<\/p>\n<p>All types that have both <code>begin()<\/code> and <code>end()<\/code> member functions, or that can be used with <code>std::begin()<\/code> and <code>std::end()<\/code>, are usable in range-based for-loops.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::array array{ 1, 2, 3 };\r\n\r\n    \/\/ This does exactly the same as the loop we used before.\r\n    for (int i : array)\r\n    {\r\n        std::cout &lt;&lt; i &lt;&lt; ' ';\r\n    }\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Behind the scenes, the range-based for-loop calls <code>begin()<\/code> and <code>end()<\/code> of the type to iterate over. <code>std::array<\/code> has <code>begin<\/code> and <code>end<\/code> member functions, so we can use it in a range-based loop. C-style fixed arrays can be used with <code>std::begin<\/code> and <code>std::end<\/code> functions, so we can loop through them with a range-based loop as well. Dynamic C-style arrays (or decayed C-style arrays) don&#8217;t work though, because there is no <code>std::end<\/code> function for them (because the type information doesn&#8217;t contain the array&#8217;s length).<\/p>\n<p>You&#8217;ll learn how to add these functions to your types later, so that they can be used with range-based for-loops too.<\/p>\n<p>Range-based for-loops aren&#8217;t the only thing that makes use of iterators.  They&#8217;re also used in <code>std::sort<\/code> and other algorithms.  Now that you know what they are, you&#8217;ll notice they&#8217;re used quite a bit in the standard library.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Iterator invalidation (dangling iterators)<\/p>\n<p>Much like pointers and references, iterators can be left &#8220;dangling&#8221; if the elements being iterated over change address or are destroyed.  When this happens, we say the iterator has been <strong>invalidated<\/strong>.  Accessing an invalidated iterator produces undefined behavior.<\/p>\n<p>Some operations that modify containers (such as adding an element to a <code>std::vector<\/code>) can have the side effect of causing the elements in the container to change addresses.  When this happens, existing iterators to those elements will be invalidated. Good C++ reference documentation should note which container operations may or will invalidate iterators.  As an example, see the <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/container\/vector#Iterator_invalidation\">&#8220;Iterator invalidation&#8221; section of <code>std::vector<\/code> on cppreference<\/a>.<\/p>\n<p>Since range-based for-loops use iterators behind the scenes, we must be careful not to do anything that invalidates the iterators of the container we are actively traversing:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::vector v { 0, 1, 2, 3 };\r\n\r\n    for (auto num : v) \/\/ implicitly iterates over v\r\n    {\r\n        if (num % 2 == 0)\r\n            v.push_back(num + 1); \/\/ when this invalidates the iterators of v, undefined behavior will result\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Here&#8217;s another example of iterator invalidation:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n\tstd::vector v{ 1, 2, 3, 4, 5, 6, 7 };\r\n\r\n\tauto it{ v.begin() };\r\n\r\n\t++it; \/\/ move to second element\r\n\tstd::cout &lt;&lt; *it &lt;&lt; '\\n'; \/\/ ok: prints 2\r\n\r\n\tv.erase(it); \/\/ erase the element currently being iterated over\r\n\r\n\t\/\/ erase() invalidates iterators to the erased element (and subsequent elements)\r\n\t\/\/ so iterator \"it\" is now invalidated\r\n\r\n\t++it; \/\/ undefined behavior\r\n\tstd::cout &lt;&lt; *it &lt;&lt; '\\n'; \/\/ undefined behavior\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Invalidated iterators can be revalidated by assigning a valid iterator to them (e.g. <code>begin()<\/code>, <code>end()<\/code>, or the return value of some other function that returns an iterator).<\/p>\n<p>The <code>erase()<\/code> function returns an iterator to the element one past the erased element (or <code>end()<\/code> if the last element was removed).  Therefore, we can fix the above code like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n\tstd::vector v{ 1, 2, 3, 4, 5, 6, 7 };\r\n\r\n\tauto it{ v.begin() };\r\n\r\n\t++it; \/\/ move to second element\r\n\tstd::cout &lt;&lt; *it &lt;&lt; '\\n';\r\n\r\n\tit = v.erase(it); \/\/ erase the element currently being iterated over, set `it` to next element\r\n\r\n\tstd::cout &lt;&lt; *it &lt;&lt; '\\n'; \/\/ now ok, prints 3\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-standard-library-algorithms\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">18.3<\/span>Introduction to standard library algorithms\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/sorting-an-array-using-selection-sort\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">18.1<\/span>Sorting an array using selection sort\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n<p>(h\/t to nascardriver for significant contributions to this lesson)<\/p>\n","protected":false},"excerpt":{"rendered":"<p>Iterating through an array (or other structure) of data is quite a common thing to do in programming. And so far, we&#8217;ve covered many different ways to do so: with loops and an index (for-loops and while loops), with pointers and pointer arithmetic, and with range-based for-loops: #include &lt;array&gt; #include &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9255"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=9255"}],"version-history":[{"count":48,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9255\/revisions"}],"predecessor-version":[{"id":18188,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9255\/revisions\/18188"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=9255"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=9255"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=9255"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}