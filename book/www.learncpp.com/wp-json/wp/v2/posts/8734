{"id":8734,"date":"2019-08-17T11:57:12","date_gmt":"2019-08-17T19:57:12","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=8734"},"modified":"2024-12-30T19:40:39","modified_gmt":"2024-12-31T03:40:39","slug":"remainder-and-exponentiation","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/remainder-and-exponentiation\/","title":{"rendered":"6.3 &#8212; Remainder and Exponentiation"},"content":{"rendered":"<p class=\"cpp-section\">The remainder operator (<code>operator%<\/code>)<\/p>\n<p>The <strong>remainder operator<\/strong> (also commonly called the <strong>modulo operator<\/strong> or <strong>modulus operator<\/strong>) is an operator that returns the remainder after doing an integer division.  For example, 7 \/ 4 = 1 remainder 3.  Therefore, 7 % 4 = 3.  As another example, 25 \/ 7 = 3 remainder 4, thus 25 % 7 = 4.  The remainder operator only works with integer operands.<\/p>\n<p>This is most useful for testing whether a number is evenly divisible by another number (meaning that after division, there is no remainder): if <em>x % y<\/em> evaluates to 0, then we know that <em>x<\/em> is evenly divisible by <em>y<\/em>.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; \"Enter an integer: \";\r\n\tint x{};\r\n\tstd::cin &gt;&gt; x;\r\n\r\n\tstd::cout &lt;&lt; \"Enter another integer: \";\r\n\tint y{};\r\n\tstd::cin &gt;&gt; y;\r\n\r\n\tstd::cout &lt;&lt; \"The remainder is: \" &lt;&lt; x % y &lt;&lt; '\\n';\r\n\r\n\tif ((x % y) == 0)\r\n\t\tstd::cout &lt;&lt; x &lt;&lt; \" is evenly divisible by \" &lt;&lt; y &lt;&lt; '\\n';\r\n\telse\r\n\t\tstd::cout &lt;&lt; x &lt;&lt; \" is not evenly divisible by \" &lt;&lt; y &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Here are a couple runs of this program:<\/p>\n<pre>\r\nEnter an integer: 6\r\nEnter another integer: 3\r\nThe remainder is: 0\r\n6 is evenly divisible by 3\r\n<\/pre>\n<pre>\r\nEnter an integer: 6\r\nEnter another integer: 4\r\nThe remainder is: 2\r\n6 is not evenly divisible by 4\r\n<\/pre>\n<p>Now let&#8217;s try an example where the second number is bigger than the first:<\/p>\n<pre>\r\nEnter an integer: 2\r\nEnter another integer: 4\r\nThe remainder is: 2\r\n2 is not evenly divisible by 4\r\n<\/pre>\n<p>A remainder of 2 might be a little non-obvious at first, but it&#8217;s simple: 2 \/ 4 is 0 (using integer division) remainder 2.  Whenever the second number is larger than the first, the second number will divide the first 0 times, so the first number will be the remainder.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Remainder with negative numbers<\/p>\n<p>The remainder operator can also work with negative operands.  <code>x % y<\/code> always returns results with the sign of <em>x<\/em>.<\/p>\n<p>Running the above program:<\/p>\n<pre>\r\nEnter an integer: -6\r\nEnter another integer: 4\r\nThe remainder is: -2\r\n-6 is not evenly divisible by 4\r\n<\/pre>\n<pre>\r\nEnter an integer: 6\r\nEnter another integer: -4\r\nThe remainder is: 2\r\n6 is not evenly divisible by -4\r\n<\/pre>\n<p>In both cases, you can see the remainder takes the sign of the first operand.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Nomenclature<\/p>\n<p>The C++ standard does not actually give a name to <code>operator%<\/code>.  However, the C++20 standard does say, &#8220;the binary % operator yields the remainder from the division of the first expression by the second&#8221;.<\/p>\n<p>Although <code>operator%<\/code> is often called the &#8220;modulo&#8221; or &#8220;modulus&#8221; operator, this can be confusing, because modulo in mathematics is often defined in a way that yields a different result to what <code>operator%<\/code> in C++ produces when one (and only one) of the operands is negative.<\/p>\n<p>For example, in mathematics:<br \/>\n-21 modulo 4 = 3<br \/>\n-21 remainder 4 = -1<\/p>\n<p>For this reason, we believe the name &#8220;remainder&#8221; is a more accurate name for <code>operator%<\/code> than &#8220;modulo&#8221;.\n<\/div>\n<p>In cases where the first operand can be negative, one must take care to note that the remainder can also be negative.  For example, you might think to write a function that returns whether a number is odd like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">bool isOdd(int x)\r\n{\r\n    return (x % 2) == 1; \/\/ fails when x is -5\r\n}<\/code><\/pre>\n<p>However, this will fail when x is a negative odd number, such as <code>-5<\/code>, because <code>-5 % 2<\/code> is -1, and -1 != 1.<\/p>\n<p>For this reason, if you&#8217;re going to compare the result of a remainder operation, it&#8217;s better to compare against 0, which does not have positive\/negative number issues:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">bool isOdd(int x)\r\n{\r\n    return (x % 2) != 0; \/\/ could also write return (x % 2)\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Prefer to compare the result of the remainder operator (<code>operator%<\/code>) against 0 if possible.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Where&#8217;s the exponent operator?<\/p>\n<p>You&#8217;ll note that the <em>^<\/em> operator (commonly used to denote exponentiation in mathematics) is a <em>Bitwise XOR<\/em> operation in C++ (covered in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/bit-manipulation-with-bitwise-operators-and-bit-masks\/\">O.3 -- Bit manipulation with bitwise operators and bit masks<\/a>).  C++ does not include an exponent operator.<\/p>\n<p>To do exponents in C++, #include the &lt;cmath&gt; header, and use the pow() function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cmath&gt;\r\n\r\ndouble x{ std::pow(3.0, 4.0) }; \/\/ 3 to the 4th power<\/code><\/pre>\n<p>Note that the parameters (and return value) of function pow() are of type double.  Due to rounding errors in floating point numbers, the results of pow() may not be precise (even if you pass it integers or whole numbers).<\/p>\n<p>If you want to do integer exponentiation, you&#8217;re best off using your own function to do so.  The following function implements integer exponentiation (using the non-intuitive &#8220;exponentiation by squaring&#8221; algorithm for efficiency):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt; \/\/ for assert\r\n#include &lt;cstdint&gt; \/\/ for std::int64_t\r\n#include &lt;iostream&gt;\r\n\r\n\/\/ note: exp must be non-negative\r\n\/\/ note: does not perform range\/overflow checking, use with caution\r\nconstexpr std::int64_t powint(std::int64_t base, int exp)\r\n{\r\n\tassert(exp &gt;= 0 &amp;&amp; \"powint: exp parameter has negative value\");\r\n\r\n\t\/\/ Handle 0 case\r\n\tif (base == 0)\r\n\t\treturn (exp == 0) ? 1 : 0;\r\n\r\n\tstd::int64_t result{ 1 };\r\n\twhile (exp &gt; 0)\r\n\t{\r\n\t\tif (exp &amp; 1)  \/\/ if exp is odd\r\n\t\t\tresult *= base;\r\n\t\texp \/= 2;\r\n\t\tbase *= base;\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; powint(7, 12) &lt;&lt; '\\n'; \/\/ 7 to the 12th power\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Produces:<\/p>\n<pre>\r\n13841287201\r\n<\/pre>\n<p>Don&#8217;t worry if you don&#8217;t understand how this function works -- you don&#8217;t need to understand it in order to call it.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover asserts in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/assert-and-static_assert\/\">9.6 -- Assert and static_assert<\/a>, and constexpr functions in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-functions\/\">F.1 -- Constexpr functions<\/a>.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>The <code>constexpr<\/code> specifier allows a function to be evaluated at compile-time if used in a constant expression; otherwise, it behaves like a regular function and is evaluated at runtime.\n<\/div>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>In the vast majority of cases, integer exponentiation will overflow the integral type.  This is likely why such a function wasn&#8217;t included in the standard library in the first place.\n<\/p><\/div>\n<p>Here is a safer version of the exponentiation function above that checks for overflow:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt; \/\/ for assert\r\n#include &lt;cstdint&gt; \/\/ for std::int64_t\r\n#include &lt;iostream&gt;\r\n#include &lt;limits&gt; \/\/ for std::numeric_limits\r\n\r\n\/\/ A safer (but slower) version of powint() that checks for overflow\r\n\/\/ note: exp must be non-negative\r\n\/\/ Returns std::numeric_limits&lt;std::int64_t&gt;::max() if overflow occurs\r\nconstexpr std::int64_t powint_safe(std::int64_t base, int exp)\r\n{\r\n    assert(exp &gt;= 0 &amp;&amp; \"powint_safe: exp parameter has negative value\");\r\n\r\n    \/\/ Handle 0 case\r\n    if (base == 0)\r\n        return (exp == 0) ? 1 : 0;\r\n\r\n    std::int64_t result { 1 };\r\n\r\n    \/\/ To make the range checks easier, we'll ensure base is positive\r\n    \/\/ We'll flip the result at the end if needed\r\n    bool negativeResult{ false };\r\n\r\n    if (base &lt; 0)\r\n    {\r\n        base = -base;\r\n        negativeResult = (exp &amp; 1);\r\n    }\r\n\r\n    while (exp &gt; 0)\r\n    {\r\n        if (exp &amp; 1) \/\/ if exp is odd\r\n        {\r\n            \/\/ Check if result will overflow when multiplied by base\r\n            if (result &gt; std::numeric_limits&lt;std::int64_t&gt;::max() \/ base)\r\n            {\r\n                std::cerr &lt;&lt; \"powint_safe(): result overflowed\\n\";\r\n                return std::numeric_limits&lt;std::int64_t&gt;::max();\r\n            }\r\n\r\n            result *= base;\r\n        }\r\n\r\n        exp \/= 2;\r\n\r\n        \/\/ If we're done, get out here\r\n        if (exp &lt;= 0)\r\n            break;\r\n\r\n        \/\/ The following only needs to execute if we're going to iterate again\r\n\r\n        \/\/ Check if base will overflow when multiplied by base\r\n        if (base &gt; std::numeric_limits&lt;std::int64_t&gt;::max() \/ base)\r\n        {\r\n            std::cerr &lt;&lt; \"powint_safe(): base overflowed\\n\";\r\n            return std::numeric_limits&lt;std::int64_t&gt;::max();\r\n        }\r\n\r\n        base *= base;\r\n    }\r\n\r\n    if (negativeResult)\r\n        return -result;\r\n\r\n    return result;\r\n}\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; powint_safe(7, 12) &lt;&lt; '\\n'; \/\/ 7 to the 12th power\r\n\tstd::cout &lt;&lt; powint_safe(70, 12) &lt;&lt; '\\n'; \/\/ 70 to the 12th power (will return the max 64-bit int value)\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #1<\/p>\n<p>What does the following expression evaluate to?  <code>6 + 5 * 4 % 3<\/code><\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\nBecause * and % have higher precedence than +, the + will evaluate last.  We can rewrite our expression as 6 + (5 * 4 % 3).  Operators * and % have the same precedence, so we have to look at the associativity to resolve them.  The associativity for operators * and % is left to right, so we resolve the left operator first.  We can rewrite our expression like this: 6 + ((5 * 4) % 3).<\/p>\n<p>6 + ((5 * 4) % 3) = 6 + (20 % 3) = 6 + 2 = 8<\/p><\/div>\n<\/p>\n<\/div>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #2<\/p>\n<p>Write a program that asks the user to input an integer, and tells the user whether the number is even or odd.  Write a constexpr function called <code>isEven()<\/code> that returns true if an integer passed to it is even, and false otherwise.  Use the remainder operator to test whether the integer parameter is even.  Make sure <code>isEven()<\/code> works with both positive and negative numbers.<\/p>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_0'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_0\" style=\"display:none; margin-bottom: 1em\">Hint: You may need to use if-statements and the comparison operator (==) for this program.  See lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/boolean-values\/\">4.9 -- Boolean values<\/a> if you need a refresher on how to do this.<\/div>\n<p>Your program should match the following output:<\/p>\n<pre>\nEnter an integer: 5\r\n5 is odd\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nconstexpr bool isEven(int x)\r\n{\r\n    \/\/ if x % 2 == 0, 2 divides evenly into our number, which means it must be an even number\r\n    return (x % 2) == 0;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter an integer: \";\r\n    int x{};\r\n    std::cin &gt;&gt; x;\r\n\r\n    if (isEven(x))\r\n        std::cout &lt;&lt; x &lt;&lt; \" is even\\n\";\r\n    else\r\n        std::cout &lt;&lt; x &lt;&lt; \" is odd\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Note: You may have been tempted to write function isEven() like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">constexpr bool isEven(int x)\r\n{\r\n    if ((x % 2) == 0)\r\n        return true;\r\n    else\r\n        return false;\r\n}<\/code><\/pre>\n<p>While this works, it&#8217;s more complicated than it needs to be.  Let&#8217;s take a look at how we can simplify it.  First, let&#8217;s pull out the if statement conditional and assign it to a separate boolean:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">constexpr bool isEven(int x)\r\n{\r\n    bool isEven = (x % 2) == 0;\r\n    if (isEven) \/\/ isEven is true\r\n        return true;\r\n    else \/\/ isEven is false\r\n        return false;\r\n}<\/code><\/pre>\n<p>Now, note that the if statement above essentially says &#8220;if isEven is true, return true, otherwise if isEven is false, return false&#8221;.  If that&#8217;s the case, we can just return isEven:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">constexpr bool isEven(int x)\r\n{\r\n    bool isEven = (x % 2) == 0;\r\n    return isEven;\r\n}<\/code><\/pre>\n<p>And in this case, since we only use variable isEven once, we might as well eliminate the variable:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">constexpr bool isEven(int x)\r\n{\r\n    return (x % 2) == 0;\r\n}<\/code><\/pre>\n<\/div>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/increment-decrement-operators-and-side-effects\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">6.4<\/span>Increment\/decrement operators, and side effects\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/arithmetic-operators\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">6.2<\/span>Arithmetic operators\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>The (also commonly called the or ) is an operator that returns the remainder after doing an integer division. For example, 7 \/ 4 = 1 remainder 3. Therefore, 7 % 4 = 3. As another example, 25 \/ 7 = 3 remainder 4, thus 25 % 7 = 4. &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/8734"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=8734"}],"version-history":[{"count":33,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/8734\/revisions"}],"predecessor-version":[{"id":18053,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/8734\/revisions\/18053"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=8734"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=8734"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=8734"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}