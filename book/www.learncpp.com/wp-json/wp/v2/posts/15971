{"id":15971,"date":"2023-10-23T13:58:31","date_gmt":"2023-10-23T20:58:31","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15971"},"modified":"2025-02-05T17:28:04","modified_gmt":"2025-02-06T01:28:04","slug":"constexpr-variables","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-variables\/","title":{"rendered":"5.6 &#8212; Constexpr variables"},"content":{"rendered":"<p>In the previous lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constant-expressions\/#whywecare\">5.5 -- Constant expressions<\/a>, we defined what a constant expression is, discussed why constant expressions are desirable, and concluded with when constant expressions actually evaluate at compile-time.<\/p>\n<p>In this lesson, we&#8217;ll take a closer look at how we create variables that can be used in constant expressions in modern C++.  We&#8217;ll also explore our first method for ensuring that code actually executes at compile-time.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The compile-time <code>const<\/code> challenge<\/p>\n<p>In the prior lesson, we noted that one way to create a variable that can be used in a constant expression is to use the <code>const<\/code> keyword.  A <code>const<\/code> variable with an integral type and a constant expression initializer can be used in a constant expression.  All other <code>const<\/code> variables cannot be used in constant expressions.<\/p>\n<p>However, the use of <code>const<\/code> to create variables that can be used in constant expressions has a few challenges.<\/p>\n<p>First, use of <code>const<\/code> does not make it immediately clear whether the variable is usable in a constant expression or not.  In some cases, we can figure it out fairly easily:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int a { 5 };       \/\/ not const at all\r\nconst int b { a }; \/\/ clearly not a constant expression (since initializer is non-const)\r\nconst int c { 5 }; \/\/ clearly a constant expression (since initializer is a constant expression)<\/code><\/pre>\n<p>In other cases, it can be quite difficult:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">const int d { someVar };    \/\/ not obvious whether d is usable in a constant expression or not\r\nconst int e { getValue() }; \/\/ not obvious whether e is usable in a constant expression or not<\/code><\/pre>\n<p>In the above example, variables <code>d<\/code> and <code>e<\/code> may or may not be usable in a constant expressions, depending on how <code>someVar<\/code> and <code>getValue()<\/code> are defined.  That means we have to go inspect the definitions of those initializers and infer what case we&#8217;re in.  And that may not even be sufficient -- if <code>someVar<\/code> is const and initialized with a variable or a function call, we&#8217;ll have to go inspect the definition of its initializer too!<\/p>\n<p>Second, use of <code>const<\/code> does not provide a way to inform the compiler that we require a variable that is usable in a constant expression (and that it should halt compilation if it isn&#8217;t).  Instead, it will just silently create a variable that can only be used in runtime expressions.<\/p>\n<p>Third, the use of <code>const<\/code> to create compile-time constant variables does not extend to non-integral variables.  And there are many cases where we would like non-integral variables to be compile-time constants too.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The <code>constexpr<\/code> keyword<\/p>\n<p>Fortunately, we can enlist the compiler&#8217;s help to ensure we get a compile-time constant variable where we desire one.  To do so, we use the <code>constexpr<\/code> keyword (which is shorthand for &#8220;constant expression&#8221;) instead of <code>const<\/code> in a variable&#8217;s declaration.  A <strong>constexpr<\/strong> variable is always a compile-time constant.  As a result, a constexpr variable must be initialized with a constant expression, otherwise a compilation error will result.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ The return value of a non-constexpr function is not constexpr\r\nint five()\r\n{\r\n    return 5;\r\n}\r\n\r\nint main()\r\n{\r\n    constexpr double gravity { 9.8 }; \/\/ ok: 9.8 is a constant expression\r\n    constexpr int sum { 4 + 5 };      \/\/ ok: 4 + 5 is a constant expression\r\n    constexpr int something { sum };  \/\/ ok: sum is a constant expression\r\n\r\n    std::cout &lt;&lt; \"Enter your age: \";\r\n    int age{};\r\n    std::cin &gt;&gt; age;\r\n\r\n    constexpr int myAge { age };      \/\/ compile error: age is not a constant expression\r\n    constexpr int f { five() };       \/\/ compile error: return value of five() is not constexpr\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because functions normally execute at runtime, the return value of a function is not constexpr (even when the return expression is a constant expression).  This is why <code>five()<\/code> is not a legal initialization value for <code>constexpr int f<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We talk about functions whose return values can be used in constant expressions in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-functions\/\">F.1 -- Constexpr functions<\/a>.\n<\/p><\/div>\n<p>Additionally, <code>constexpr<\/code> works for variables with non-integral types:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">constexpr double d { 1.2 }; \/\/ d can be used in constant expressions!<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The meaning of const vs constexpr for variables<\/p>\n<p>For variables:<\/p>\n<ul>\n<li><code>const<\/code> means that the value of an object cannot be changed after initialization.  The value of the initializer may be known at compile-time or runtime.  The const object can be evaluated at runtime.\n<\/li>\n<li><code>constexpr<\/code> means that the object can be used in a constant expression.  The value of the initializer must be known at compile-time.  The constexpr object can be evaluated at runtime or compile-time.\n<\/li>\n<\/ul>\n<p>Constexpr variables are implicitly const.  Const variables are not implicitly constexpr (except for const integral variables with a constant expression initializer).  Although a variable can be defined as both <code>constexpr<\/code> and <code>const<\/code>, in most cases this is redundant, and we only need to use either <code>const<\/code> or <code>constexpr<\/code>.<\/p>\n<p>Unlike <code>const<\/code>, <code>constexpr<\/code> is not part of an object&#8217;s type.  Therefore a variable defined as <code>constexpr int<\/code> actually has type <code>const int<\/code> (due to the implicit <code>const<\/code> that <code>constexpr<\/code> provides for objects).<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Any constant variable whose initializer is a constant expression should be declared as <code>constexpr<\/code>.<\/p>\n<p>Any constant variable whose initializer is not a constant expression (making it a runtime constant) should be declared as <code>const<\/code>.<\/p>\n<p>Caveat: In the future we will discuss some types that are not fully compatible with <code>constexpr<\/code> (including <code>std::string<\/code>, <code>std::vector<\/code>, and other types that use dynamic memory allocation).  For constant objects of these types, either use <code>const<\/code> instead of <code>constexpr<\/code>, or pick a different type that is constexpr compatible (e.g. <code>std::string_view<\/code> or <code>std::array<\/code>).\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Nomenclature<\/p>\n<p>The term <code>constexpr<\/code> is a portmanteau of &#8220;constant expression&#8221;.  This name was picked because constexpr objects (and functions) can be used in constant expressions.<\/p>\n<p>Formally, the keyword <code>constexpr<\/code> applies only to objects and functions.  Conventionally, the term <code>constexpr<\/code> is used as shorthand for any constant expression (such as <code>1 + 2<\/code>).\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>Some of the examples on this site were written prior to the best practice to use <code>constexpr<\/code> -- as a result, you will note that some examples do not follow the above best practice.  We are currently in the process of updating non-compliant examples as we run across them.\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>In C and C++, the declaration of an array object (an object can hold multiple values) requires the length of the array (the number of values that it can hold) be known at compile-time (so the compiler can ensure the correct amount of memory is allocated for array objects).<\/p>\n<p>Since literals are known at compile-time, they can be used as an array length:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int arr[5]; \/\/ an array of 5 int values, length of 5 is known at compile-time<\/code><\/pre>\n<p>In many cases, it would be preferable to use a symbolic constant as an array length (e.g. to avoid magic numbers and make the array length easier to change if it is used in multiple places).  In C, this can be done via a preprocessor macro, or via an enumerator, but not via a const variable (excluding VLA&#8217;s, which have other downsides).  C++, looking to improve on this situation, wanted to allow the use of const variables instead of macros.  But the value of variables was generally assumed to be known only at runtime, which made them ineligible to be used as array lengths.<\/p>\n<p>To solve this problem, the C++ language standard added an exemption so that const integral types with a constant expression initializer would be treated as values known at compile-time, and thus be usable as array lengths:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">const int arrLen = 5;\r\nint arr[arrLen]; \/\/ ok: array of 5 ints<\/code><\/pre>\n<p>When C++11 introduced constant expressions, it made sense for a const int with a constant expression initializer to be grandfathered into that definition.  The committee discussed whether other types should be included as well, but ultimately decided not to.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Const and constexpr function parameters<\/p>\n<p>Normal function calls are evaluated at runtime, with the supplied arguments being used to initialize the function&#8217;s parameters.  Because the initialization of function parameters happens at runtime, this leads to two consequences:<\/p>\n<ol start=\"1\">\n<li><code>const<\/code> function parameters are treated as runtime constants (even when the supplied argument is a compile-time constant).\n<\/li>\n<li>Function parameters cannot be declared as <code>constexpr<\/code>, since their initialization value isn&#8217;t determined until runtime.\n<\/li>\n<\/ol>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We discuss functions that can be evaluated at compile-time (and thus be used in constant expressions) below.<\/p>\n<p>C++ also supports a way to pass compile-time constants to a function.  We discuss these in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/non-type-template-parameters\/\">11.9 -- Non-type template parameters<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Nomenclature recap<\/p>\n<div class=\"cpp-table-wrapper\">\n<table class=\"cpp-table\">\n<tr>\n<th> Term <\/th>\n<th> Definition <\/th>\n<\/tr>\n<tr>\n<td> Compile-time constant <\/td>\n<td> A value or non-modifiable object whose value must be known at compile time (e.g. literals and constexpr variables). <\/td>\n<\/tr>\n<tr>\n<td> Constexpr <\/td>\n<td> Keyword that declares objects as compile-time constants (and functions that can be evaluated at compile-time).  Informally, shorthand for &#8220;constant expression&#8221;. <\/td>\n<\/tr>\n<tr>\n<td> Constant expression <\/td>\n<td> An expression that contains only compile-time constants and operators\/functions that support compile-time evaluation. <\/td>\n<\/tr>\n<tr>\n<td> Runtime expression <\/td>\n<td> An expression that is not a constant expression. <\/td>\n<\/tr>\n<tr>\n<td> Runtime constant <\/td>\n<td> A value or non-modifiable object that is not a compile-time constant. <\/td>\n<\/tr>\n<\/table>\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A brief introduction to constexpr functions<\/p>\n<p>A <strong>constexpr function<\/strong> is a function that can be called in a constant expression.  A constexpr function must evaluate at compile-time when the constant expression it is part of must evaluate at compile time (e.g. in the initializer of a constexpr variable).  Otherwise, a constexpr function may be evaluated at either compile-time (if eligible) or runtime.  To be eligible for compile-time execution, all arguments must be constant expressions.<\/p>\n<p>To make a constexpr function, the <code>constexpr<\/code> keyword is placed in the function declaration before the return type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint max(int x, int y) \/\/ this is a non-constexpr function\r\n{\r\n    if (x &gt; y)\r\n        return x;\r\n    else\r\n        return y;\r\n}\r\n\r\nconstexpr int cmax(int x, int y) \/\/ this is a constexpr function\r\n{\r\n    if (x &gt; y)\r\n        return x;\r\n    else\r\n        return y;\r\n}\r\n\r\nint main()\r\n{\r\n    int m1 { max(5, 6) };            \/\/ ok\r\n    const int m2 { max(5, 6) };      \/\/ ok\r\n    constexpr int m3 { max(5, 6) };  \/\/ compile error: max(5, 6) not a constant expression\r\n\r\n    int m4 { cmax(5, 6) };           \/\/ ok: may evaluate at compile-time or runtime\r\n    const int m5 { cmax(5, 6) };     \/\/ ok: may evaluate at compile-time or runtime\r\n    constexpr int m6 { cmax(5, 6) }; \/\/ okay: must evaluate at compile-time\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>We used to discuss constexpr functions in detail in this chapter, but feedback from readers indicated that the topic was too long and nuanced to present this early in the tutorial series.  As a result, we&#8217;ve moved the full discussion back to lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-functions\/\">F.1 -- Constexpr functions<\/a>.<\/p>\n<p>The key thing to take away from this introduction is that a constexpr function may be called in constant expressions.<\/p>\n<p>You will see constexpr functions used in some future examples (where appropriate), but we will not expect you to understand them further or write your own constexpr functions until we&#8217;ve formally covered the topic.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdstring\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">5.7<\/span>Introduction to std::string\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constant-expressions\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">5.5<\/span>Constant expressions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the previous lesson , we defined what a constant expression is, discussed why constant expressions are desirable, and concluded with when constant expressions actually evaluate at compile-time. In this lesson, we&#8217;ll take a closer look at how we create variables that can be used in constant expressions in modern &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15971"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15971"}],"version-history":[{"count":24,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15971\/revisions"}],"predecessor-version":[{"id":18170,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15971\/revisions\/18170"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15971"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15971"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15971"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}