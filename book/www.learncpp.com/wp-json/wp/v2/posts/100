{"id":100,"date":"2007-07-11T18:20:35","date_gmt":"2007-07-12T02:20:35","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/68-pointers-arrays-and-pointer-arithmetic\/"},"modified":"2025-01-17T22:29:48","modified_gmt":"2025-01-18T06:29:48","slug":"c-style-array-decay","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/c-style-array-decay\/","title":{"rendered":"17.8 &#8212; C-style array decay"},"content":{"rendered":"<p class=\"cpp-section\">The C-style array passing challenge<\/p>\n<p>The designers of the C language had a problem.  Consider the following simple program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid print(int val)\r\n{\r\n    std::cout &lt;&lt; val;\r\n}\r\n\r\nint main()\r\n{\r\n    int x { 5 };\r\n    print(x);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When <code>print(x)<\/code> is called, the value of argument <code>x<\/code> (<code>5<\/code>) is copied into parameter <code>val<\/code>.  Within the body of the function, the value of <code>val<\/code> (<code>5<\/code>) is printed to the console.  Because <code>x<\/code> is cheap to copy, there&#8217;s no problem here.<\/p>\n<p>Now consider the following similar program, which uses a 1000 element C-style int array instead of a single int:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printElementZero(int arr[1000])\r\n{\r\n    std::cout &lt;&lt; arr[0]; \/\/ print the value of the first element\r\n}\r\n\r\nint main()\r\n{\r\n    int x[1000] { 5 };   \/\/ define an array with 1000 elements, x[0] is initialized to 5\r\n    printElementZero(x);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program also compiles and prints the expected value (<code>5<\/code>) to the console.<\/p>\n<p>While the code in this example is similar to the code in the prior example, mechanically it works a bit different than you might expect (we&#8217;ll explain this below).  And that is due to the solution that the C designers came up to solve for two major challenges.<\/p>\n<p>First, copying a 1000 element array every time a function is called is expensive (and even more so if the elements are an expensive-to-copy type), so we want to avoid that.  But how?  C doesn&#8217;t have references, so using pass by reference to avoid making a copy of function arguments wasn&#8217;t an option.<\/p>\n<p>Second, we want to be able to write a single function that can accept array arguments of different lengths.  Ideally, our <code>printElementZero()<\/code> function in the example above should be callable with arrays arguments of any length (since element 0 is guaranteed to exist).  We don&#8217;t want to have to write a different function for every possible array length that we want to use as an argument.  But how?  C has no syntax to specify &#8220;any length&#8221; arrays, nor does it support templates, nor can arrays of one length be converted to arrays of another length (presumably because doing so would involve making an expensive copy).<\/p>\n<p>The designers of the C language came up with a clever solution (inherited by C++ for compatibility reasons) that solves for both of these issues:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printElementZero(int arr[1000]) \/\/ doesn't make a copy\r\n{\r\n    std::cout &lt;&lt; arr[0]; \/\/ print the value of the first element\r\n}\r\n\r\nint main()\r\n{\r\n    int x[7] { 5 };      \/\/ define an array with 7 elements\r\n    printElementZero(x); \/\/ somehow works!\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Somehow, the above example passes a 7 element array to a function expecting a 1000 element array, without any copies being made.  In this lesson, we&#8217;ll explore how this works.<\/p>\n<p>We&#8217;ll also take a look at why the solution the C designers picked is dangerous, and not well suited for use in modern C++.<\/p>\n<p>But first, we need to cover two subtopics.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Array to pointer conversions (array decay)<\/p>\n<p>In most cases, when a C-style array is used in an expression, the array will be implicitly converted into a pointer to the element type, initialized with the address of the first element (with index 0).  Colloquially, this is called <strong>array decay<\/strong> (or just <strong>decay<\/strong> for short).<\/p>\n<p>You can see this in the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iomanip&gt; \/\/ for std::boolalpha\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int arr[5]{ 9, 7, 5, 3, 1 }; \/\/ our array has elements of type int\r\n\r\n    \/\/ First, let's prove that arr decays into an int* pointer\r\n\r\n    auto ptr{ arr }; \/\/ evaluation causes arr to decay, type deduction should deduce type int*\r\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; (typeid(ptr) == typeid(int*)) &lt;&lt; '\\n'; \/\/ Prints true if the type of ptr is int*\r\n\r\n    \/\/ Now let's prove that the pointer holds the address of the first element of the array\r\n\r\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; (&amp;arr[0] == ptr) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>On the author&#8217;s machine, this printed:<\/p>\n<pre>\ntrue\r\ntrue\r\n<\/pre>\n<p>There is nothing special about the pointer that an array decays into.  It is a normal pointer that holds the address of the first element.<\/p>\n<p>Similarly, a const array (e.g. <code>const int arr[5]<\/code>) decays into a pointer-to-const (<code>const int*<\/code>).<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>In C++, there are a few common cases where an C-style array doesn&#8217;t decay:<\/p>\n<ol start=\"1\">\n<li>When used as an argument to <code>sizeof()<\/code> or <code>typeid()<\/code>.\n<\/li>\n<li>When taking the address of the array using <code>operator&amp;<\/code>.\n<\/li>\n<li>When passed as a member of a class type.\n<\/li>\n<li>When passed by reference.\n<\/li>\n<\/ol>\n<\/div>\n<p>Because C-style arrays decay into a pointer in most cases, it&#8217;s a common fallacy to believe arrays <em>are<\/em> pointers.  This is not the case.  An array object is a sequence of elements, whereas a pointer object just holds an address.<\/p>\n<p>The type information of an array and a decayed array is different.  In the example above, the array <code>arr<\/code> has type <code>int[5]<\/code>, whereas the decayed array has type <code>int*<\/code>.  Notably, the array type <code>int[5]<\/code> contains length information, whereas the decayed array pointer type <code>int*<\/code> does not.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>A decayed array pointer does not know how long the array it is pointing to is.  The term &#8220;decay&#8221; indicates this loss of length type information.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Subscripting a C-style array actually applies <code>operator[]<\/code> to the decayed pointer<\/p>\n<p>Because a C-style arrays decays to a pointer when evaluated, when a C-style array is subscripted, the subscript is actually operating on the decayed array pointer:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    const int arr[] { 9, 7, 5, 3, 1 };\r\n    std::cout &lt;&lt; arr[2]; \/\/ subscript decayed array to get element 2, prints 5\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>We can also use <code>operator[]<\/code> directly on a pointer.  If that pointer is holding the address of the first element, the result will be identical:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    const int arr[] { 9, 7, 5, 3, 1 };\r\n    \r\n    const int* ptr{ arr };  \/\/ arr decays into a pointer\r\n    std::cout &lt;&lt; ptr[2];    \/\/ subscript ptr to get element 2, prints 5\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>We&#8217;ll see where this is convenient in a moment, and take a deeper look at how this actually works (as well as what happens when the pointer is holding something other than the address of the first element) in the next lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pointer-arithmetic-and-subscripting\/\">17.9 -- Pointer arithmetic and subscripting<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Array decay solves our C-style array passing issue<\/p>\n<p>Array decay solves both challenges we encountered at the top of the lesson.<\/p>\n<p>When passing a C-style array as an argument, the array decays into a pointer, and the pointer holding the address of the first element of the array is what gets passed to the function.  So although it looks like we&#8217;re passing the C-style array by value, we&#8217;re actually passing it by address!  This is how making a copy of the C-style array argument is avoided.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>C-style arrays are passed by address, even when it looks like they are passed by value.\n<\/p><\/div>\n<p>Now consider two different arrays of the same element type but different lengths (e.g. <code>int[5]<\/code> and <code>int[7]<\/code>).  These are distinct types, incompatible with each other.  However, they will both decay into the same pointer type (e.g. <code>int*<\/code>).  Their decayed versions are interchangable!  Dropping the length information from the type allows us to pass arrays of different lengths without a type mismatch.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Two C-style arrays with the same element type but different lengths will decay into the same pointer type.\n<\/p><\/div>\n<p>In the following example, we&#8217;ll illustrate two things:<\/p>\n<ul>\n<li>That we can pass arrays of different lengths to a single function (because both decay to the same pointer type).\n<\/li>\n<li>That our function parameter receiving the array can be a (const) pointer of the array&#8217;s element type.\n<\/li>\n<\/ul>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printElementZero(const int* arr) \/\/ pass by const address\r\n{\r\n    std::cout &lt;&lt; arr[0];\r\n}\r\n\r\nint main()\r\n{\r\n    const int prime[] { 2, 3, 5, 7, 11 };\r\n    const int squares[] { 1, 4, 9, 25, 36, 49, 64, 81 };\r\n\r\n    printElementZero(prime);   \/\/ prime decays to an const int* pointer\r\n    printElementZero(squares); \/\/ squares decays to an const int* pointer\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This example works just fine, and prints:<\/p>\n<pre>\n2\r\n1\r\n<\/pre>\n<p>Within <code>main()<\/code>, when we call <code>printElementZero(prime)<\/code>, the <code>prime<\/code> array decays from an array of type <code>const int[5]<\/code> to a pointer of type <code>const int*<\/code> that is holding the address of the first element of <code>prime<\/code>.  Similarly, when we call <code>printElementZero(squares)<\/code>, <code>squares<\/code> decays from an array of type <code>const int[8]<\/code> to a pointer of type <code>const int*<\/code> that is holding the address of the first element of <code>squares<\/code>.  These pointers of type <code>const int*<\/code> are what are actually passed to the function as an argument.<\/p>\n<p>Since we&#8217;re passing pointers of type <code>const int*<\/code>, our <code>printElementZero()<\/code> function needs to have a parameter of the same pointer type (<code>const int*<\/code>).<\/p>\n<p>Within this function, we&#8217;re subscripting the pointer to access the selected array element.<\/p>\n<p>Because a C-style array is passed by address, the function has direct access to the array passed in (not a copy) and can modify its elements.  For this reason, it&#8217;s a good idea to make sure your function parameter is const if your function does not intend to modify the array elements.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">C-style array function parameter syntax<\/p>\n<p>One problem with declaring the function parameter as <code>int* arr<\/code> is that it&#8217;s not obvious that <code>arr<\/code> is supposed to be a pointer to an array of values rather than a pointer to a single integer.  For this reason, when passing a C-style array, its preferable to use the alternate declaration form <code>int arr[]<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printElementZero(const int arr[]) \/\/ treated the same as const int*\r\n{\r\n    std::cout &lt;&lt; arr[0];\r\n}\r\n\r\nint main()\r\n{\r\n    const int prime[] { 2, 3, 5, 7, 11 };\r\n    const int squares[] { 1, 4, 9, 25, 36, 49, 64, 81 };\r\n\r\n    printElementZero(prime);  \/\/ prime decays to a pointer\r\n    printElementZero(squares); \/\/ squares decays to a pointer\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program behaves identically to the prior one, as the compiler will interpret function parameter <code>const int arr[]<\/code> the same as <code>const int*<\/code>.  However, this has the advantage of communicating to the caller that <code>arr<\/code> is expected to be a decayed C-style array, not a pointer to a single value.  Note that no length information is required between the square brackets (since it is not used anyway).  If a length is provided, it will be ignored.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>A function parameter expecting a C-style array type should use the array syntax (e.g. <code>int arr[]<\/code>) rather than pointer syntax (e.g. <code>int *arr<\/code>).\n<\/div>\n<p>The downside of using this syntax is that it makes it less obvious that <code>arr<\/code> has decayed (whereas it&#8217;s quite clear with the pointer syntax), so you&#8217;ll need to take extra care not to do anything that doesn&#8217;t work as expected with a decayed array (we&#8217;ll cover some of these in a moment).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The problems with array decay<\/p>\n<p>Although array decay was a clever solution to ensure C-style arrays of different lengths could be passed to a function without making expensive copies, the loss of array length information makes it easy for several types of mistakes to be made.<\/p>\n<p>First, <code>sizeof()<\/code> will return different values for arrays and decayed arrays:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printArraySize(int arr[])\r\n{\r\n    std::cout &lt;&lt; sizeof(arr) &lt;&lt; '\\n'; \/\/ prints 4 (assuming 32-bit addresses)\r\n}\r\n\r\nint main()\r\n{\r\n    int arr[]{ 3, 2, 1 };\r\n\r\n    std::cout &lt;&lt; sizeof(arr) &lt;&lt; '\\n'; \/\/ prints 12 (assuming 4 byte ints)\r\n\r\n    printArraySize(arr);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This means using <code>sizeof()<\/code> on a C-style array is potentially dangerous, as you have to ensure you are using it only when you can access the actual array object, not the decayed array or pointer.<\/p>\n<p>In the prior lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-c-style-arrays\/\">17.7 -- Introduction to C-style arrays<\/a>), we mentioned that <code>sizeof(arr)\/sizeof(*arr)<\/code> was historically used as a hack to get the size of a C-style array.  This hack is dangerous because if <code>arr<\/code> has decayed, <code>sizeof(arr)<\/code> will return the size of a pointer rather than the size of the array, producing the wrong array length as a result, likely causing the program to malfunction.<\/p>\n<p>Fortunately, C++17&#8217;s better replacement <code>std::size()<\/code> (and C++20&#8217;s <code>std::ssize()<\/code>) will fail to compile if passed a pointer value:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint printArrayLength(int arr[])\r\n{\r\n    std::cout &lt;&lt; std::size(arr) &lt;&lt; '\\n'; \/\/ compile error: std::size() won't work on a pointer\r\n}\r\n\r\nint main()\r\n{\r\n    int arr[]{ 3, 2, 1 };\r\n\r\n    std::cout &lt;&lt; std::size(arr) &lt;&lt; '\\n'; \/\/ prints 3\r\n\r\n    printArrayLength(arr);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Second, and perhaps most importantly, array decay can make refactoring (breaking long functions into shorter, more modular functions) difficult.  Code that works as expected with a non-decayed array may not compile (or worse, may silently malfunction) when the same code is using a decayed array.<\/p>\n<p>Third, not having length information creates several programmatic challenges.  Without length information, it is difficult to sanity check the length of the array.  Users can easily pass in arrays that are shorter than expected (or even pointers to a single value), which will then cause undefined behavior when they are subscripted with an invalid index.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printElement2(int arr[])\r\n{\r\n    \/\/ How do we ensure that arr has at least three elements?\r\n    std::cout &lt;&lt; arr[2] &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    int a[]{ 3, 2, 1 };\r\n    printElement2(a);  \/\/ ok\r\n\r\n    int b[]{ 7, 6 };\r\n    printElement2(b);  \/\/ compiles but produces undefined behavior\r\n\r\n    int c{ 9 };\r\n    printElement2(&amp;c); \/\/ compiles but produces undefined behavior\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Not having the array length also create challenges when traversing the array -- how do we know when we&#8217;ve reached the end?<\/p>\n<p>There are solutions to these issues, but these solutions add both complexity and fragility to a program.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Working around array length issues<\/p>\n<p>Historically, programmers have worked around the lack of array length information via one of two methods.<\/p>\n<p>First, we can pass in both the array and the array length as separate arguments:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n\r\nvoid printElement2(const int arr[], int length)\r\n{\r\n    assert(length &gt; 2 &amp;&amp; \"printElement2: Array too short\"); \/\/ can't static_assert on length\r\n\r\n    std::cout &lt;&lt; arr[2] &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    constexpr int a[]{ 3, 2, 1 };\r\n    printElement2(a, static_cast&lt;int&gt;(std::size(a)));  \/\/ ok\r\n\r\n    constexpr int b[]{ 7, 6 };\r\n    printElement2(b, static_cast&lt;int&gt;(std::size(b)));  \/\/ will trigger assert\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, this still has a number of issues:<\/p>\n<ul>\n<li>The caller needs to make sure that the array and the array length are paired -- if the wrong value for length is passed in, the function will still malfunction.\n<\/li>\n<li>There are potential sign conversion issues if you&#8217;re using <code>std::size()<\/code> or a function that returns a length as <code>std::size_t<\/code>.\n<\/li>\n<li>Runtime asserts only trigger when encountered at runtime.  If our testing path doesn&#8217;t cover all calls to the function, there&#8217;s a risk of shipping a program to the customer that will assert when they do something we didn&#8217;t explicitly test for.  In modern C++, we&#8217;d want to use <code>static_assert<\/code> for compile-time validation of the array length of constexpr arrays, but there&#8217;s no easy way to do this (as function parameters can&#8217;t be constexpr, even in constexpr or consteval functions!).\n<\/li>\n<li>This method only works if we&#8217;re making an explicit function call.  If the function call is implicit (e.g. we&#8217;re calling an operator with the array as an operand), then there&#8217;s no opportunity to pass in the length.\n<\/li>\n<\/ul>\n<p>Second, if there is an element value that is not semantically valid (e.g. a test score of <code>-1<\/code>), we can instead mark the end of the array using an element of that value.  That way, the length of the array can be calculated by counting how many elements exist between the start of the array and this terminating element.  The array can also be traversed by iterating from the start until we hit the terminating element.  The nice thing about this method is that it works even with implicit function calls.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>C-style strings (which are C-style arrays) use a null-terminator to mark the end of the string, so that they can be traversed even if they have decayed.\n<\/p><\/div>\n<p>But this method also has a number of issues:<\/p>\n<ul>\n<li>If the terminating element does not exist, traversal will walk right off the end of the array, causing undefined behavior.\n<\/li>\n<li>Functions that traverse the array need special handling for the terminating element (e.g. a C-style string print function needs to know not to print the terminating element).\n<\/li>\n<li>There is a mismatch between the actual array length and the number of semantically valid elements.  If the wrong length is used, the semantically invalid terminating element may be &#8220;processed&#8221;.\n<\/li>\n<li>This approach only works if a semantically invalid value exists, which is often not the case.\n<\/li>\n<\/ul>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">C-style arrays should be avoided in most cases<\/p>\n<p>Because of the non-standard passing semantics (pass by address is used instead of pass by value) and risks associated with decayed arrays losing their length information, C-style arrays have generally fallen out of favor.  We recommend avoiding them as much as possible.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Avoid C-style arrays whenever practical.<\/p>\n<ul>\n<li>Prefer <code>std::string_view<\/code> for read-only strings (string literal symbolic constants and string parameters).\n<\/li>\n<li>Prefer <code>std::string<\/code> for modifiable strings.\n<\/li>\n<li>Prefer <code>std::array<\/code> for non-global constexpr arrays.\n<\/li>\n<li>Prefer <code>std::vector<\/code> for non-constexpr arrays.\n<\/li>\n<\/ul>\n<p>It is okay to use C-style arrays for global constexpr arrays.  We&#8217;ll discuss this in a moment.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>In C++, arrays can be passed by reference, in which case the array argument won&#8217;t decay when passed to a function (but the reference to the array will still decay when evaluated).  However, it&#8217;s easy to forget to apply this consistently, and one missed reference will lead to decaying arguments.  Also, array reference parameters must have a fixed length, meaning the function can only handle arrays of one particular length.  If we want a function that can handle arrays of different lengths, then we also have to use function templates.  But if you&#8217;re going to do both of those things to &#8220;fix&#8221; C-style arrays, then you might as well just use <code>std::array<\/code>!\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">So when are C-style arrays used in modern C++?<\/p>\n<p>In modern C++, C-style arrays are typically used in two cases:<\/p>\n<ol start=\"1\">\n<li>To store constexpr global (or constexpr static local) program data.  Because such arrays can be accessed directly from anywhere in the program, we do not need to pass the array, which avoids decay-related issues.  The syntax for defining C-style arrays can be a little less wonky than <code>std::array<\/code>.  More importantly, indexing such arrays does not have sign conversion issues like the standard library container classes do.\n<\/li>\n<li>As parameters to functions or classes that want to handle non-constexpr C-style string arguments directly (rather than requiring a conversion to <code>std::string_view<\/code>).  There are two possible reasons for this: First, converting a non-constexpr C-style string to a <code>std::string_view<\/code> requires traversing the C-style string to determine its length.  If the function is in a performance critical section of code and the length isn&#8217;t needed (e.g. because the function is going to traverse the string anyway) then avoiding the conversion may be useful.  Second, if the function (or class) calls other functions that expect C-style strings, converting to a <code>std::string_view<\/code> just to convert back may be suboptimal (unless you have other reasons for wanting a <code>std::string_view<\/code>).\n<\/li>\n<\/ol>\n<p><p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p><p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p><\/p>\n<p>What is array decay, and why is it a problem?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>When a C-style array is evaluated, in most contexts it will be implicitly converted to a pointer to the array&#8217;s element type.<\/p>\n<p>Decayed arrays lose their length information, which makes it easier for length-related bugs to be introduced into the program.\n<\/p><\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>Why do C-style strings (which are C-style arrays) use a null terminator?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p>When a C-style array is passed to a function, it decays and loses its length information.  If the C-style string didn&#8217;t have a null terminator, the function would not be able to determine how long the string was.\n<\/p><\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #3<\/p>\n<p>Extra credit: Why do C-style strings use a null-terminator instead of requiring both the decayed C-style string and explicit length information to be passed to a function?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<p>There are probably many answers to this question, but here are some:<\/p>\n<ul>\n<li>The ergonomics would be horrible, as we&#8217;d have extra parameters and magic numbers everywhere (e.g. <code>printString(\"Hello\", 5)<\/code>).\n<\/li>\n<li>It would be very easy for the string and the provided string length to not match properly.  The string length is essentially an invariant of the string itself.  Relying on the user to maintain this invariant will invariably lead to errors (e.g. <code>printString(\"Hello\", 6)<\/code>).\n<\/li>\n<\/ul>\n<\/div>\n<p>Extra Credit #2: Even if C++ wanted to implement having to pass explicit length information, why wouldn&#8217;t it work?<\/p>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_0'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_0\" style=\"display:none; margin-bottom: 1em\">Hint: Consider the case where we are printing a string using <code>std::cout<\/code>.<\/div>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<p>Passing both the C-style string and explicit length information is only possible if a function is called explicitly.  If a function is called implicitly, there is no way to pass along the length information.<\/p>\n<p>Consider a statement like <code>std::cout &lt;&lt; cstr<\/code>.  Binary <code>operator&lt;&lt;<\/code> can only take two operands: <code>std::cout<\/code> and <code>cstr<\/code>.  There is no way to pass another argument representing the length information.  The null-terminator approach doesn&#8217;t have this issue.\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pointer-arithmetic-and-subscripting\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.9<\/span>Pointer arithmetic and subscripting\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-c-style-arrays\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.7<\/span>Introduction to C-style arrays\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>The C-style array passing challenge The designers of the C language had a problem. Consider the following simple program: #include &lt;iostream&gt; void print(int val) { std::cout &lt;&lt; val; } int main() { int x { 5 }; print(x); return 0; } When print(x) is called, the value of argument x &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/100"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=100"}],"version-history":[{"count":64,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/100\/revisions"}],"predecessor-version":[{"id":18110,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/100\/revisions\/18110"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=100"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=100"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=100"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}