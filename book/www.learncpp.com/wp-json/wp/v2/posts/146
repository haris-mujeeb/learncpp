{"id":146,"date":"2007-10-19T09:50:10","date_gmt":"2007-10-19T17:50:10","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/98-overloading-the-subscript-operator\/"},"modified":"2025-02-02T22:17:52","modified_gmt":"2025-02-03T06:17:52","slug":"overloading-the-subscript-operator","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-the-subscript-operator\/","title":{"rendered":"21.9 &#8212; Overloading the subscript operator"},"content":{"rendered":"<p>When working with arrays, we typically use the subscript operator ([]) to index specific elements of an array:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">myArray[0] = 7; \/\/ put the value 7 in the first element of the array<\/code><\/pre>\n<p>However, consider the following <code>IntList<\/code> class, which has a member variable that is an array:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class IntList\r\n{\r\nprivate:\r\n    int m_list[10]{};\r\n};\r\n\r\nint main()\r\n{\r\n    IntList list{};\r\n    \/\/ how do we access elements from m_list?\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because the m_list member variable is private, we can not access it directly from variable list.  This means we have no way to directly get or set values in the m_list array.  So how do we get or put elements into our list?<\/p>\n<p>Without operator overloading, the typical method would be to create access functions:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class IntList\r\n{\r\nprivate:\r\n    int m_list[10]{};\r\n\r\npublic:\r\n    void setItem(int index, int value) { m_list[index] = value; }\r\n    int getItem(int index) const { return m_list[index]; }\r\n};<\/code><\/pre>\n<p>While this works, it&#8217;s not particularly user friendly.  Consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    IntList list{};\r\n    list.setItem(2, 3);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Are we setting element 2 to the value 3, or element 3 to the value 2?  Without seeing the definition of <code>setItem()<\/code>, it&#8217;s simply not clear.<\/p>\n<p>You could also just return the entire list and use operator[] to access the element:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class IntList\r\n{\r\nprivate:\r\n    int m_list[10]{};\r\n\r\npublic:\r\n    int* getList() { return m_list; }\r\n};<\/code><\/pre>\n<p>While this also works, it&#8217;s syntactically odd:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    IntList list{};\r\n    list.getList()[2] = 3;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Overloading operator[]<\/p>\n<p>However, a better solution in this case is to overload the subscript operator ([]) to allow access to the elements of m_list.  The subscript operator is one of the operators that must be overloaded as a member function.  An overloaded operator[] function will always take one parameter: the subscript that the user places between the hard braces.  In our IntList case, we expect the user to pass in an integer index, and we&#8217;ll return an integer value back as a result.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass IntList\r\n{\r\nprivate:\r\n    int m_list[10]{};\r\n\r\npublic:\r\n    int&amp; operator[] (int index)\r\n    {\r\n        return m_list[index];\r\n    }\r\n};\r\n\r\n\/*\r\n\/\/ Can also be implemented outside the class definition\r\nint&amp; IntList::operator[] (int index)\r\n{\r\n    return m_list[index];\r\n}\r\n*\/\r\n\r\nint main()\r\n{\r\n    IntList list{};\r\n    list[2] = 3; \/\/ set a value\r\n    std::cout &lt;&lt; list[2] &lt;&lt; '\\n'; \/\/ get a value\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Now, whenever we use the subscript operator ([]) on an object of our class, the compiler will return the corresponding element from the m_list member variable!  This allows us to both get and set values of m_list directly.<\/p>\n<p>This is both easy syntactically and from a comprehension standpoint.  When <code>list[2]<\/code> evaluates, the compiler first checks to see if there&#8217;s an overloaded operator[] function.  If so, it passes the value inside the hard braces (in this case, 2) as an argument to the function.<\/p>\n<p>Note that although you can provide a default value for the function parameter, actually using operator[] without a subscript inside is not considered a valid syntax, so there&#8217;s no point.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>C++23 adds support for overloading operator[] with multiple subscripts.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Why operator[] returns a reference<\/p>\n<p>Let&#8217;s take a closer look at how <code>list[2] = 3<\/code> evaluates.  Because the subscript operator has a higher precedence than the assignment operator, <code>list[2]<\/code> evaluates first.  <code>list[2]<\/code> calls operator[], which we&#8217;ve defined to return a reference to <code>list.m_list[2]<\/code>.  Because operator[] is returning a reference, it returns the actual <code>list.m_list[2]<\/code> array element.  Our partially evaluated expression becomes <code>list.m_list[2] = 3<\/code>, which is a straightforward integer assignment.<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/value-categories-lvalues-and-rvalues\/\">12.2 -- Value categories (lvalues and rvalues)<\/a>, you learned that any value on the left hand side of an assignment statement must be an l-value (which is a variable that has an actual memory address).  Because the result of operator[] can be used on the left hand side of an assignment (e.g. <code>list[2] = 3<\/code>), the return value of operator[] must be an l-value.  As it turns out, references are always l-values, because you can only take a reference of variables that have memory addresses.  So by returning a reference, the compiler is satisfied that we are returning an l-value.<\/p>\n<p>Consider what would happen if operator[] returned an integer by value instead of by reference.  <code>list[2]<\/code> would call operator[], which would return the <em>value of<\/em> list.m_list[2].  For example, if m_list[2] had the value of 6, operator[] would return the value 6.  <code>list[2] = 3<\/code> would partially evaluate to <code>6 = 3<\/code>, which makes no sense!  If you try to do this, the C++ compiler will complain:<\/p>\n<pre>\r\nC:VCProjectsTest.cpp(386) : error C2106: '=' : left operand must be l-value\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Overloaded operator[] for const objects<\/p>\n<p>In the above IntList example, operator[] is non-const, and we can use it as an l-value to change the state of non-const objects.  However, what if our IntList object was const?  In this case, we wouldn&#8217;t be able to call the non-const version of operator[] because that would allow us to potentially change the state of a const object.<\/p>\n<p>The good news is that we can define a non-const and a const version of operator[] separately.  The non-const version will be used with non-const objects, and the const version with const-objects.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass IntList\r\n{\r\nprivate:\r\n    int m_list[10]{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; \/\/ give this class some initial state for this example\r\n\r\npublic:\r\n    \/\/ For non-const objects: can be used for assignment\r\n    int&amp; operator[] (int index)\r\n    {\r\n        return m_list[index];\r\n    }\r\n\r\n    \/\/ For const objects: can only be used for access\r\n    \/\/ This function could also return by value if the type is cheap to copy\r\n    const int&amp; operator[] (int index) const\r\n    {\r\n        return m_list[index];\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    IntList list{};\r\n    list[2] = 3; \/\/ okay: calls non-const version of operator[]\r\n    std::cout &lt;&lt; list[2] &lt;&lt; '\\n';\r\n\r\n    const IntList clist{};\r\n    \/\/ clist[2] = 3; \/\/ compile error: clist[2] returns const reference, which we can't assign to\r\n    std::cout &lt;&lt; clist[2] &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Removing duplicate code between const and non-const overloads<\/p>\n<p>In the above example, note that the implementations of <code>int&amp; IntList::operator[](int)<\/code> and <code>const int&amp; IntList::operator[](int) const<\/code> are identical.  The only difference is the return type of the function.<\/p>\n<p>In cases where the implementation is trivial (e.g. a single line), it&#8217;s fine (and preferred) to have both functions use an identical implementation.  The small amount of redundancy this introduces isn&#8217;t worth removing.<\/p>\n<p>But what if the implementation of these operators was complex, requiring many statements?  For example, maybe it&#8217;s important that we validate that the index is actually valid, which requires adding many redundant lines of code to each function.<\/p>\n<p>In such a case, the redundancy introduced by having many duplicate statements is more problematic, and it would be desirable to have a single implementation that we could use for both overloads.  But how?  Normally we&#8217;d simply implement one function in terms of the other (e.g. have one function call the other).  But that&#8217;s a bit tricky in this case.  The const version of the function can&#8217;t call the non-const version of the function, because that would require discarding the const of a const object.  And while the non-const version of the function can call the const version of the function, the const version of the function returns a const reference, when we need to return a non-const reference.  Fortunately, there is a way to work around this.<\/p>\n<p>The preferred solution is as follows:<\/p>\n<ul>\n<li>Implement the logic for the const version of the function.\n<\/li>\n<li>Have the non-const function call the const function and use <code>const_cast<\/code> to remove the const.\n<\/li>\n<\/ul>\n<p>The resulting solution looks something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;utility&gt; \/\/ for std::as_const\r\n\r\nclass IntList\r\n{\r\nprivate:\r\n    int m_list[10]{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; \/\/ give this class some initial state for this example\r\n\r\npublic:\r\n    int&amp; operator[] (int index)\r\n    {\r\n        \/\/ use std::as_const to get a const version of `this` (as a reference) \r\n        \/\/ so we can call the const version of operator[]\r\n        \/\/ then const_cast to discard the const on the returned reference\r\n        return const_cast&lt;int&amp;&gt;(std::as_const(*this)[index]);\r\n    }\r\n\r\n    const int&amp; operator[] (int index) const\r\n    {\r\n        return m_list[index];\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    IntList list{};\r\n    list[2] = 3; \/\/ okay: calls non-const version of operator[]\r\n    std::cout &lt;&lt; list[2] &lt;&lt; '\\n';\r\n\r\n    const IntList clist{};\r\n    \/\/ clist[2] = 3; \/\/ compile error: clist[2] returns const reference, which we can't assign to\r\n    std::cout &lt;&lt; clist[2] &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Normally using <code>const_cast<\/code> to remove const is something we want to avoid, but in this case it&#8217;s acceptable.  If the non-const overload was called, then we know we&#8217;re working with a non-const object.  It&#8217;s okay to remove the const on a const reference to a non-const object.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>In C++23, we can do even better by making use of several features we don&#8217;t yet cover in this tutorial series:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass IntList\r\n{\r\nprivate:\r\n    int m_list[10]{ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; \/\/ give this class some initial state for this example\r\n\r\npublic:\r\n    \/\/ Use an explicit object parameter (self) and auto&amp;&amp; to differentiate const vs non-const\r\n    auto&amp;&amp; operator[](this auto&amp;&amp; self, int index)\r\n    {\r\n        \/\/ Complex code goes here\r\n        return self.m_list[index];\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    IntList list{};\r\n    list[2] = 3; \/\/ okay: calls non-const version of operator[]\r\n    std::cout &lt;&lt; list[2] &lt;&lt; '\\n';\r\n\r\n    const IntList clist{};\r\n    \/\/ clist[2] = 3; \/\/ compile error: clist[2] returns const reference, which we can't assign to\r\n    std::cout &lt;&lt; clist[2] &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Detecting index validity<\/p>\n<p>One other advantage of overloading the subscript operator is that we can make it safer than accessing arrays directly.  Normally, when accessing arrays, the subscript operator does not check whether the index is valid.  For example, the compiler will not complain about the following code:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int list[5]{};\r\nlist[7] = 3; \/\/ index 7 is out of bounds!<\/code><\/pre>\n<p>However, if we know the size of our array, we can make our overloaded subscript operator check to ensure the index is within bounds:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt; \/\/ for assert()\r\n#include &lt;iterator&gt; \/\/ for std::size()\r\n\r\nclass IntList\r\n{\r\nprivate:\r\n    int m_list[10]{};\r\n\r\npublic:\r\n    int&amp; operator[] (int index)\r\n    {\r\n        assert(index &gt;= 0 &amp;&amp; static_cast&lt;std::size_t&gt;(index) &lt; std::size(m_list));\r\n\r\n        return m_list[index];\r\n    }\r\n};<\/code><\/pre>\n<p>In the above example, we have used the assert() function (included in the cassert header) to make sure our index is valid.  If the expression inside the assert evaluates to false (which means the user passed in an invalid index), the program will terminate with an error message, which is much better than the alternative (corrupting memory).  This is probably the most common method of doing error checking of this sort.<\/p>\n<p>If you don&#8217;t want to use an assert (which will be compiled out of a non-debug build) you can instead use an if-statement and your favorite error handling method (e.g. throw an exception, call <code>std::exit<\/code>, etc&#8230;):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iterator&gt; \/\/ for std::size()\r\n\r\nclass IntList\r\n{\r\nprivate:\r\n    int m_list[10]{};\r\n\r\npublic:\r\n    int&amp; operator[] (int index)\r\n    {\r\n        if (!(index &gt;= 0 &amp;&amp; static_cast&lt;std::size_t&gt;(index) &lt; std::size(m_list))\r\n        {\r\n            \/\/ handle invalid index here\r\n        }\r\n\r\n        return m_list[index];\r\n    }\r\n};<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Pointers to objects and overloaded operator[] don&#8217;t mix<\/p>\n<p>If you try to call operator[] on a pointer to an object, C++ will assume you&#8217;re trying to index an array of objects of that type.<\/p>\n<p>Consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt; \/\/ for assert()\r\n#include &lt;iterator&gt; \/\/ for std::size()\r\n\r\nclass IntList\r\n{\r\nprivate:\r\n    int m_list[10]{};\r\n\r\npublic:\r\n    int&amp; operator[] (int index)\r\n    {\r\n        return m_list[index];\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    IntList* list{ new IntList{} };\r\n    list [2] = 3; \/\/ error: this will assume we're accessing index 2 of an array of IntLists\r\n    delete list;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because we can&#8217;t assign an integer to an IntList, this won&#8217;t compile.  However, if assigning an integer was valid, this would compile and run, with undefined results.<\/p>\n<div class=\"cpp-note cpp-lightpurplebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Rule<\/p>\n<p>Make sure you&#8217;re not trying to call an overloaded operator[] on a pointer to an object.\n<\/p><\/div>\n<p>The proper syntax would be to dereference the pointer first (making sure to use parenthesis since operator[] has higher precedence than operator*), then call operator[]:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    IntList* list{ new IntList{} };\r\n    (*list)[2] = 3; \/\/ get our IntList object, then call overloaded operator[]\r\n    delete list;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This is ugly and error prone.  Better yet, don&#8217;t set pointers to your objects if you don&#8217;t have to.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The function parameter does not need to be an integral type<\/p>\n<p>As mentioned above, C++ passes what the user types between the hard braces as an argument to the overloaded function.  In most cases, this will be an integral value.  However, this is not required -- and in fact, you can define that your overloaded operator[] take a value of any type you desire.  You could define your overloaded operator[] to take a double, a std::string, or whatever else you like.<\/p>\n<p>As a ridiculous example, just so you can see that it works:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt; \/\/ C++17\r\n\r\nclass Stupid\r\n{\r\nprivate:\r\n\r\npublic:\r\n\tvoid operator[] (std::string_view index);\r\n};\r\n\r\n\/\/ It doesn't make sense to overload operator[] to print something\r\n\/\/ but it is the easiest way to show that the function parameter can be a non-integer\r\nvoid Stupid::operator[] (std::string_view index)\r\n{\r\n\tstd::cout &lt;&lt; index;\r\n}\r\n\r\nint main()\r\n{\r\n\tStupid stupid{};\r\n\tstupid[\"Hello, world!\"];\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>As you would expect, this prints:<\/p>\n<pre>\r\nHello, world!\r\n<\/pre>\n<p>Overloading operator[] to take a std::string parameter can be useful when writing certain kinds of classes, such as those that use words as indices.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>A map is a class that stores elements as a key-value pair.  The key must be unique, and is used to access the associated pair.  In this quiz, we&#8217;re going to write an application that lets us assign grades to students by name, using a simple map class.  The student&#8217;s name will be the key, and the grade (as a char) will be the value.<\/p>\n<p>a) First, write a struct named <code>StudentGrade<\/code> that contains the student&#8217;s name (as a <code>std::string<\/code>) and grade (as a <code>char<\/code>).<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n\r\nstruct StudentGrade\r\n{\r\n    std::string name{};\r\n    char grade{};\r\n};<\/code><\/pre>\n<\/div>\n<p>b) Add a class named <code>GradeMap<\/code> that contains a <code>std::vector<\/code> of <code>StudentGrade<\/code> named <code>m_map<\/code>.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n#include &lt;vector&gt;\r\n\r\nstruct StudentGrade\r\n{\r\n\tstd::string name{};\r\n\tchar grade{};\r\n};\r\n\r\nclass GradeMap\r\n{\r\nprivate:\r\n\tstd::vector&lt;StudentGrade&gt; m_map{};\r\n};<\/code><\/pre>\n<\/div>\n<p>c) Write an overloaded <code>operator[]<\/code> for this class.  This function should take a <code>std::string<\/code> parameter, and return a reference to a char.  In the body of the function, first see if the student&#8217;s name already exists (You can use <code>std::find_if<\/code> from &lt;algorithm&gt;).  If the student exists, return a reference to the grade and you&#8217;re done.  Otherwise, use the <code>std::vector::emplace_back()<\/code> or <code>std::vector::push_back()<\/code> function to add a <code>StudentGrade<\/code> for this new student.  When you do this, <code>std::vector<\/code> will add a copy of your <code>StudentGrade<\/code> to itself (resizing if needed, invalidating all previously returned references).  Finally, we need to return a reference to the grade for the student we just added to the <code>std::vector<\/code>.  We can access the student we just added using the <code>std::vector::back()<\/code> function.<\/p>\n<p>The following program should run:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ ...\r\n\r\nint main()\r\n{\r\n\tGradeMap grades{};\r\n\r\n\tgrades[\"Joe\"] = 'A';\r\n\tgrades[\"Frank\"] = 'B';\r\n\r\n\tstd::cout &lt;&lt; \"Joe has a grade of \" &lt;&lt; grades[\"Joe\"] &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; \"Frank has a grade of \" &lt;&lt; grades[\"Frank\"] &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n#include &lt;vector&gt;\r\n\r\nstruct StudentGrade\r\n{\r\n\tstd::string name{};\r\n\tchar grade{};\r\n};\r\n\r\nclass GradeMap\r\n{\r\nprivate:\r\n\tstd::vector&lt;StudentGrade&gt; m_map{};\r\n\r\npublic:\r\n\tchar&amp; operator[](std::string_view name);\r\n};\r\n\r\nchar&amp; GradeMap::operator[](std::string_view name)\r\n{\r\n\tauto found{ std::find_if(m_map.begin(), m_map.end(),\r\n\t\t\t\t[name](const auto&amp; student) { \/\/ this is a lambda that captures name from the surrounding scope\r\n\t\t\t\t\treturn (student.name == name); \/\/ so we can use name here\r\n\t\t\t\t}) };\r\n\r\n\tif (found != m_map.end())\r\n\t{\r\n\t\treturn found-&gt;grade;\r\n\t}\r\n\r\n\t\/\/ otherwise create a new StudentGrade for this student and add\r\n\t\/\/ it to the end of our vector.  Then return the grade.\r\n\r\n\t\/\/ emplace_back version (C++20 onward)\r\n\t\/\/ StudentGrade is an aggregate and emplace_back only works with aggregates as of C++20\r\n\treturn m_map.emplace_back(std::string{name}).grade;\r\n\r\n\t\/\/ push_back version (C++17 or older)\r\n\t\/\/ m_map.push_back(StudentGrade{std::string{name}});\r\n\t\/\/ return m_map.back().grade;\r\n}\r\n\r\nint main()\r\n{\r\n\tGradeMap grades{};\r\n\r\n\tgrades[\"Joe\"] = 'A';\r\n\tgrades[\"Frank\"] = 'B';\r\n\r\n\tstd::cout &lt;&lt; \"Joe has a grade of \" &lt;&lt; grades[\"Joe\"] &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; \"Frank has a grade of \" &lt;&lt; grades[\"Frank\"] &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">A reminder<\/p>\n<p>See <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-lambdas-anonymous-functions\/\">20.6 -- Introduction to lambdas (anonymous functions)<\/a> for more information on lambdas.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>Since maps are common, the standard library offers <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/container\/map\"><code>std::map<\/code><\/code><\/a>, which is not currently covered on learncpp. Using <code>std::map<\/code>, we can simplify our code to<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;map&gt; \/\/ std::map\r\n#include &lt;string&gt;\r\n\r\nint main()\r\n{\r\n\t\/\/ std::map can be initialized\r\n\tstd::map&lt;std::string, char&gt; grades{\r\n\t\t{ \"Joe\", 'A' },\r\n\t\t{ \"Frank\", 'B' }\r\n\t};\r\n\r\n\t\/\/ and assigned\r\n\tgrades[\"Susan\"] = 'C';\r\n\tgrades[\"Tom\"] = 'D';\r\n\r\n\tstd::cout &lt;&lt; \"Joe has a grade of \" &lt;&lt; grades[\"Joe\"] &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; \"Frank has a grade of \" &lt;&lt; grades[\"Frank\"] &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Prefer using <code>std::map<\/code> over writing your own implementation.\n<\/div>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>Extra credit #1: The <code>GradeMap<\/code> class and sample program we wrote is inefficient for many reasons.  Describe one way that the <code>GradeMap<\/code> class could be improved.  <\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<p><code>std::vector<\/code> is unsorted by nature.  This means every time we call <code>operator[]<\/code>, we&#8217;re potentially traversing the entire <code>std::vector<\/code> to find our element.  With a few elements, this isn&#8217;t a problem, but as we continue to add names, this will become increasingly slow.  We could optimize this by keeping our <code>m_map<\/code> sorted and using a binary search, so we minimize the number of elements we have to look through to find the ones we&#8217;re interested in.\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #3<\/p>\n<p>Extra credit #2: Why does this program potentially not work as expected?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tGradeMap grades{};\r\n\r\n\tchar&amp; gradeJoe{ grades[\"Joe\"] }; \/\/ does an emplace_back\r\n\tgradeJoe = 'A';\r\n\r\n\tchar&amp; gradeFrank{ grades[\"Frank\"] }; \/\/ does a emplace_back\r\n\tgradeFrank = 'B';\r\n\r\n\tstd::cout &lt;&lt; \"Joe has a grade of \" &lt;&lt; gradeJoe &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; \"Frank has a grade of \" &lt;&lt; gradeFrank &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\n<p>When Frank is added, the <code>std::vector<\/code> may need to grow to hold it.  This requires dynamically allocating a new block of memory, copying the elements in the array to that new block, and deleting the old block.  When this happens, any references to existing elements in the std::vector are invalidated (meaning they are left as dangling references to deleted memory).<\/p>\n<p>In other words, after we <code>emplace_back(\"Frank\")<\/code>, if the std::vector had to grow to make room for Frank, the <code>gradeJoe<\/code> reference would be invalidated.  Accessing <code>gradeJoe<\/code> to print Joe&#8217;s grade would then lead to undefined results.<\/p>\n<p>How a std::vector grows is a compiler-specific detail, so we can expect the above program to work fine when compiled with some compilers and not others.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-the-parenthesis-operator\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.10<\/span>Overloading the parenthesis operator\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-the-increment-and-decrement-operators\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.8<\/span>Overloading the increment and decrement operators\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>When working with arrays, we typically use the subscript operator ([]) to index specific elements of an array: myArray[0] = 7; \/\/ put the value 7 in the first element of the array However, consider the following IntList class, which has a member variable that is an array: class IntList &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/146"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=146"}],"version-history":[{"count":52,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/146\/revisions"}],"predecessor-version":[{"id":18158,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/146\/revisions\/18158"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=146"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=146"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=146"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}