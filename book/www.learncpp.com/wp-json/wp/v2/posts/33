{"id":33,"date":"2007-06-03T12:57:50","date_gmt":"2007-06-03T20:57:50","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=33"},"modified":"2025-03-05T15:33:49","modified_gmt":"2025-03-05T23:33:49","slug":"introduction-to-the-preprocessor","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-the-preprocessor\/","title":{"rendered":"2.10 &#8212; Introduction to the preprocessor"},"content":{"rendered":"<p>When you compile your project, you might expect that the compiler compiles each code file exactly as you&#8217;ve written it.  This actually isn&#8217;t the case.<\/p>\n<p>Instead, prior to compilation, each code (.cpp) file goes through a <strong>preprocessing<\/strong> phase.  In this phase, a program called the <strong>preprocessor<\/strong> makes various changes to the text of the code file. The preprocessor does not actually modify the original code files in any way -- rather, all changes made by the preprocessor happen either temporarily in-memory or using temporary files.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>Historically, the preprocessor was a separate program from the compiler, but in modern compilers, the preprocessor may be built right into the compiler itself.\n<\/p><\/div>\n<p>Most of what the preprocessor does is fairly uninteresting.  For example, it strips out comments, and ensures each code file ends in a newline.  However, the preprocessor does have one very important role: it is what processes <code>#include<\/code> directives (which we&#8217;ll discuss more in a moment).<\/p>\n<p>When the preprocessor has finished processing a code file, the result is called a <strong>translation unit<\/strong>.  This translation unit is what is then compiled by the compiler.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>The entire process of preprocessing, compiling, and linking is called <strong>translation<\/strong>.<\/p>\n<p>If you&#8217;re curious, here is a list of <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/language\/translation_phases\">translation phases<\/a>.  As of the time of writing, preprocessing encompasses phases 1 through 4, and compilation is phases 5 through 7.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Preprocessor directives<\/p>\n<p>When the preprocessor runs, it scans through the code file (from top to bottom), looking for preprocessor directives.  <strong>Preprocessor directives<\/strong> (often just called <em>directives<\/em>) are instructions that start with a <em>#<\/em> symbol and end with a newline (NOT a semicolon).  These directives tell the preprocessor to perform certain text manipulation tasks.  Note that the preprocessor does not understand C++ syntax -- instead, the directives have their own syntax (which in some cases resembles C++ syntax, and in other cases, not so much).<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>The final output of the preprocessor contains no directives -- only the output of the processed directive is passed to the compiler.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p><code>Using directives<\/code> (introduced in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/naming-collisions-and-an-introduction-to-namespaces\/\">2.9 -- Naming collisions and an introduction to namespaces<\/a>) are not preprocessor directives (and thus are not processed by the preprocessor).  So while the term <code>directive<\/code> <em>usually<\/em> means a <code>preprocessor directive<\/code>, this is not always the case.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">#Include<\/p>\n<p>You&#8217;ve already seen the <em>#include<\/em> directive in action (generally to #include &lt;iostream&gt;).  When you <em>#include<\/em> a file, the preprocessor replaces the #include directive with the contents of the included file.  The included contents are then preprocessed (which may result in additional #includes being preprocessed recursively), then the rest of the file is preprocessed.<\/p>\n<p>Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Hello, world!\\n\";\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When the preprocessor runs on this program, the preprocessor will replace <code>#include &lt;iostream&gt;<\/code> with the contents of the file named &#8220;iostream&#8221; and then preprocess the included content and the rest of the file.<\/p>\n<p>Since <em>#include<\/em> is almost exclusively used to include header files, we&#8217;ll discuss <em>#include<\/em> in more detail in the next lesson (when we discuss header files).<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Each translation unit typically consists of a single code (.cpp) file and all header files it #includes (applied recursively, since header files can #include other header files).\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Macro defines<\/p>\n<p>The <em>#define<\/em> directive can be used to create a macro.  In C++, a <strong>macro<\/strong> is a rule that defines how input text is converted into replacement output text.<\/p>\n<p>There are two basic types of macros: <em>object-like macros<\/em>, and <em>function-like macros<\/em>.<\/p>\n<p><em>Function-like macros<\/em> act like functions, and serve a similar purpose.  Their use is generally considered unsafe, and almost anything they can do can be done by a normal function.<\/p>\n<p><em>Object-like macros<\/em> can be defined in one of two ways:<\/p>\n<pre>\r\n#define IDENTIFIER\r\n#define IDENTIFIER substitution_text\r\n<\/pre>\n<p>The top definition has no substitution text, whereas the bottom one does.  Because these are preprocessor directives (not statements), note that neither form ends with a semicolon.<\/p>\n<p>The identifier for a macro uses the same naming rules as normal identifiers: they can use letters, numbers, and underscores, cannot start with a number, and should not start with an underscore.  By convention, macro names are typically all uppercase, separated by underscores.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Macro names should be written in all uppercase letters, with words separated by underscores.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Object-like macros with substitution text<\/p>\n<p>When the preprocessor encounters this directive, an association is made between the macro identifier and <em>substitution_text<\/em>.  All further occurrences of the macro identifier (outside of use in other preprocessor commands) are replaced by the <em>substitution_text<\/em>.<\/p>\n<p>Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n#define MY_NAME \"Alex\"\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"My name is: \" &lt;&lt; MY_NAME &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The preprocessor converts the above into the following:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ The contents of iostream are inserted here\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"My name is: \" &lt;&lt; \"Alex\" &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Which, when run, prints the output <code>My name is: Alex<\/code>.<\/p>\n<p>Object-like macros with substitution text were used (in C) as a way to assign names to literals.  This is no longer necessary, as better methods are available in C++ (see <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/sharing-global-constants-across-multiple-files-using-inline-variables\/\">7.10 -- Sharing global constants across multiple files (using inline variables)<\/a>).  Object-like macros with substitution text are now mostly seen in legacy code, and we recommend avoiding them whenever possible.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Avoid macros with substitution text unless no viable alternatives exist.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Object-like macros without substitution text<\/p>\n<p><em>Object-like macros<\/em> can also be defined without substitution text.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#define USE_YEN<\/code><\/pre>\n<p>Macros of this form work like you might expect: most further occurrences of the identifier is removed and replaced by nothing!<\/p>\n<p>This might seem pretty useless, and it <em>is useless<\/em> for doing text substitution.  However, that&#8217;s not what this form of the directive is generally used for.  We&#8217;ll discuss the uses of this form in just a moment.<\/p>\n<p>Unlike object-like macros with substitution text, macros of this form are generally considered acceptable to use.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Conditional compilation<\/p>\n<p>The <em>conditional compilation<\/em> preprocessor directives allow you to specify under what conditions something will or won&#8217;t compile.  There are quite a few different conditional compilation directives, but we&#8217;ll only cover a few that are used the most often: <em>#ifdef<\/em>, <em>#ifndef<\/em>, and <em>#endif<\/em>.<\/p>\n<p>The <em>#ifdef<\/em> preprocessor directive allows the preprocessor to check whether an identifier has been previously defined via #define.  If so, the code between the <em>#ifdef<\/em> and matching <em>#endif<\/em> is compiled.  If not, the code is ignored.<\/p>\n<p>Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n#define PRINT_JOE\r\n\r\nint main()\r\n{\r\n#ifdef PRINT_JOE\r\n    std::cout &lt;&lt; \"Joe\\n\"; \/\/ will be compiled since PRINT_JOE is defined\r\n#endif\r\n\r\n#ifdef PRINT_BOB\r\n    std::cout &lt;&lt; \"Bob\\n\"; \/\/ will be excluded since PRINT_BOB is not defined\r\n#endif\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because PRINT_JOE has been #defined, the line <code>std::cout &lt;&lt; \"Joe\\n\"<\/code> will be compiled.  Because PRINT_BOB has not been #defined, the line <code>std::cout &lt;&lt; \"Bob\\n\"<\/code> will be ignored.<\/p>\n<p><em>#ifndef<\/em> is the opposite of <em>#ifdef<\/em>, in that it allows you to check whether an identifier has <em>NOT<\/em> been <em>#define<\/em>d yet.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n#ifndef PRINT_BOB\r\n    std::cout &lt;&lt; \"Bob\\n\";\r\n#endif\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program prints &#8220;Bob&#8221;, because PRINT_BOB was never <em>#define<\/em>d.<\/p>\n<p>In place of <code>#ifdef PRINT_BOB<\/code> and <code>#ifndef PRINT_BOB<\/code>, you&#8217;ll also see <code>#if defined(PRINT_BOB)<\/code> and <code>#if !defined(PRINT_BOB)<\/code>. These do the same, but use a slightly more C++-style syntax.<\/p>\n<p>You can see a practical use of this feature in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/what-language-standard-is-my-compiler-using\/\">0.13 -- What language standard is my compiler using?<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><a name=\"if0\"><\/a>#if 0 <a href=\"#if0\"><i class=\"fa fa-link\" style=\"font-size: 0.8em;\"><\/i><\/a><\/p>\n<p>One more common use of conditional compilation involves using <em>#if 0<\/em> to exclude a block of code from being compiled (as if it were inside a comment block):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Joe\\n\";\r\n\r\n#if 0 \/\/ Don't compile anything starting here\r\n    std::cout &lt;&lt; \"Bob\\n\";\r\n    std::cout &lt;&lt; \"Steve\\n\";\r\n#endif \/\/ until this point\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The above code only prints &#8220;Joe&#8221;, because &#8220;Bob&#8221; and &#8220;Steve&#8221; are excluded from compilation by the <em>#if 0<\/em> preprocessor directive.<\/p>\n<p>This provides a convenient way to &#8220;comment out&#8221; code that contains multi-line comments (which can&#8217;t be commented out using another multi-line comment due to multi-line comments being non-nestable):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Joe\\n\";\r\n\r\n#if 0 \/\/ Don't compile anything starting here\r\n    std::cout &lt;&lt; \"Bob\\n\";\r\n    \/* Some\r\n     * multi-line\r\n     * comment here\r\n     *\/\r\n    std::cout &lt;&lt; \"Steve\\n\";\r\n#endif \/\/ until this point\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>To temporarily re-enable code that has been wrapped in an <code>#if 0<\/code>, you can change the <code>#if 0<\/code> to <code>#if 1<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Joe\\n\";\r\n\r\n#if 1 \/\/ always true, so the following code will be compiled\r\n    std::cout &lt;&lt; \"Bob\\n\";\r\n    \/* Some\r\n     * multi-line\r\n     * comment here\r\n     *\/\r\n    std::cout &lt;&lt; \"Steve\\n\";\r\n#endif\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Macro substitution within other preprocessor commands<\/p>\n<p>Now you might be wondering, given the following code:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#define PRINT_JOE\r\n\r\nint main()\r\n{\r\n#ifdef PRINT_JOE\r\n    std::cout &lt;&lt; \"Joe\\n\"; \/\/ will be compiled since PRINT_JOE is defined\r\n#endif\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Since we defined <em>PRINT_JOE<\/em> to be nothing, how come the preprocessor didn&#8217;t replace <em>PRINT_JOE<\/em> in <em>#ifdef PRINT_JOE<\/em> with nothing and exclude the output statement from compilation?<\/p>\n<p>In most cases, macro substitution does not occur when a macro identifier is used within another preprocessor command.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>There is at least one exception to this rule: most forms of <code>#if<\/code> and <code>#elif<\/code> do macro substitution within the preprocessor command.\n<\/div>\n<p>As another example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#define FOO 9 \/\/ Here's a macro substitution\r\n\r\n#ifdef FOO \/\/ This FOO does not get replaced with 9 because it\u2019s part of another preprocessor directive\r\n    std::cout &lt;&lt; FOO &lt;&lt; '\\n'; \/\/ This FOO gets replaced with 9 because it's part of the normal code\r\n#endif<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The scope of #defines<\/p>\n<p>Directives are resolved before compilation, from top to bottom on a file-by-file basis.<\/p>\n<p>Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid foo()\r\n{\r\n#define MY_NAME \"Alex\"\r\n}\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; \"My name is: \" &lt;&lt; MY_NAME &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Even though it looks like <em>#define MY_NAME &#8220;Alex&#8221;<\/em> is defined inside function <em>foo<\/em>, the preprocessor doesn&#8217;t understand C++ concepts like functions.  Therefore, this program behaves identically to one where <em>#define MY_NAME &#8220;Alex&#8221;<\/em> was defined either before or immediately after function <em>foo<\/em>.  To avoid confusion, you&#8217;ll generally want to #define identifiers outside of functions.<\/p>\n<p>Because an #include directive replaces the #include directive with the content of the included file, an #include can copy directives from the included file into the current file.  These directives will then be processed in order.<\/p>\n<p>For example, the following also behaves identically to the prior examples:<\/p>\n<p>Alex.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#define MY_NAME \"Alex\"<\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"Alex.h\" \/\/ copies #define MY_NAME from Alex.h here\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; \"My name is: \" &lt;&lt; MY_NAME &lt;&lt; '\\n'; \/\/ preprocessor replaces MY_NAME with \"Alex\"\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Once the preprocessor has finished, all defined identifiers from that file are discarded.  This means that directives are only valid from the point of definition to the end of the file in which they are defined.  Directives defined in one file do not have any impact on other files (unless they are #included into another file).  For example:<\/p>\n<p>function.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid doSomething()\r\n{\r\n#ifdef PRINT\r\n    std::cout &lt;&lt; \"Printing!\\n\";\r\n#endif\r\n#ifndef PRINT\r\n    std::cout &lt;&lt; \"Not printing!\\n\";\r\n#endif\r\n}<\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void doSomething(); \/\/ forward declaration for function doSomething()\r\n\r\n#define PRINT\r\n\r\nint main()\r\n{\r\n    doSomething();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The above program will print:<\/p>\n<pre>\r\nNot printing!\r\n<\/pre>\n<p>Even though PRINT was defined in <em>main.cpp<\/em>, that doesn&#8217;t have any impact on any of the code in <em>function.cpp<\/em> (PRINT is only #defined from the point of definition to the end of main.cpp).  This will be of consequence when we discuss header guards in a future lesson.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/header-files\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">2.11<\/span>Header files\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/naming-collisions-and-an-introduction-to-namespaces\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">2.9<\/span>Naming collisions and an introduction to namespaces\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>When you compile your project, you might expect that the compiler compiles each code file exactly as you&#8217;ve written it. This actually isn&#8217;t the case. Instead, prior to compilation, each code (.cpp) file goes through a phase. In this phase, a program called the makes various changes to the text &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/33"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=33"}],"version-history":[{"count":87,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/33\/revisions"}],"predecessor-version":[{"id":18239,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/33\/revisions\/18239"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=33"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=33"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=33"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}