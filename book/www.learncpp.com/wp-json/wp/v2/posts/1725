{"id":1725,"date":"2015-05-08T07:59:31","date_gmt":"2015-05-08T15:59:31","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=1725"},"modified":"2025-01-03T12:39:53","modified_gmt":"2025-01-03T20:39:53","slug":"introduction-to-stdstring","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdstring\/","title":{"rendered":"5.7 &#8212; Introduction to std::string"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/literals\/\">5.2 -- Literals<\/a>, we introduced C-style string literals:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n \r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Hello, world!\"; \/\/ \"Hello world!\" is a C-style string literal.\r\n    return 0;\r\n}<\/code><\/pre>\n<p>While C-style string literals are fine to use, C-style string variables behave oddly, are hard to work with (e.g. you can&#8217;t use assignment to assign a C-style string variable a new value), and are dangerous (e.g. if you copy a larger C-style string into the space allocated for a shorter C-style string, undefined behavior will result).  In modern C++, C-style string variables are best avoided.<\/p>\n<p>Fortunately, C++ has introduced two additional string types into the language that are much easier and safer to work with: <code>std::string<\/code> and <code>std::string_view<\/code> (C++17).  Unlike the types we&#8217;ve introduced previously, <code>std::string<\/code> and <code>std::string_view<\/code> aren&#8217;t fundamental types (they&#8217;re class types, which we&#8217;ll cover in the future).  However, basic usage of each is straightforward and useful enough that we&#8217;ll introduce them here.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Introducing <code>std::string<\/code><\/p>\n<p>The easiest way to work with strings and string objects in C++ is via the <code>std::string<\/code> type, which lives in the &lt;string&gt; header.<\/p>\n<p>We can create objects of type <code>std::string<\/code> just like other objects:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt; \/\/ allows use of std::string\r\n\r\nint main()\r\n{\r\n    std::string name {}; \/\/ empty string\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Just like normal variables, you can initialize or assign values to std::string objects as you would expect:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n\r\nint main()\r\n{\r\n    std::string name { \"Alex\" }; \/\/ initialize name with string literal \"Alex\"\r\n    name = \"John\";               \/\/ change name to \"John\"\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Note that strings can be composed of numeric characters as well:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::string myID{ \"45\" }; \/\/ \"45\" is not the same as integer 45!<\/code><\/pre>\n<p>In string form, numbers are treated as text, not as numbers, and thus they can not be manipulated as numbers (e.g. you can&#8217;t multiply them).  C++ will not automatically convert strings to integer or floating point values or vice-versa (though there are ways to do so that we&#8217;ll cover in a future lesson).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">String output with <code>std::cout<\/code><\/p>\n<p><code>std::string<\/code> objects can be output as expected using <code>std::cout<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nint main()\r\n{\r\n    std::string name { \"Alex\" };\r\n    std::cout &lt;&lt; \"My name is: \" &lt;&lt; name &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nMy name is: Alex\r\n<\/pre>\n<p>Empty strings will print nothing:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nint main()\r\n{\r\n    std::string empty{ };\r\n    std::cout &lt;&lt; '[' &lt;&lt; empty &lt;&lt; ']';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Which prints:<\/p>\n<pre>\n[]\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><code>std::string<\/code> can handle strings of different lengths<\/p>\n<p>One of the neatest things that <code>std::string<\/code> can do is store strings of different lengths:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nint main()\r\n{\r\n    std::string name { \"Alex\" }; \/\/ initialize name with string literal \"Alex\"\r\n    std::cout &lt;&lt; name &lt;&lt; '\\n';\r\n\r\n    name = \"Jason\";              \/\/ change name to a longer string\r\n    std::cout &lt;&lt; name &lt;&lt; '\\n';\r\n\r\n    name = \"Jay\";                \/\/ change name to a shorter string\r\n    std::cout &lt;&lt; name &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nAlex\r\nJason\r\nJay\r\n<\/pre>\n<p>In the above example, <code>name<\/code> is initialized with the string <code>\"Alex\"<\/code>, which contains five characters (four explicit characters and a null-terminator).  We then set <code>name<\/code> to a larger string, and then a smaller string.  <code>std::string<\/code> has no problem handling this!  You can even store really long strings in a <code>std::string<\/code>.<\/p>\n<p>This is one of the reasons that <code>std::string<\/code> is so powerful.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>If <code>std::string<\/code> doesn&#8217;t have enough memory to store a string, it will request additional memory (at runtime) using a form of memory allocation known as dynamic memory allocation.  This ability to acquire additional memory is part of what makes <code>std::string<\/code> so flexible, but also comparatively slow.<\/p>\n<p>We cover dynamic memory allocation in a future chapter.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">String input with <code>std::cin<\/code><\/p>\n<p>Using <code>std::string<\/code> with <code>std::cin<\/code> may yield some surprises!  Consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter your full name: \";\r\n    std::string name{};\r\n    std::cin &gt;&gt; name; \/\/ this won't work as expected since std::cin breaks on whitespace\r\n\r\n    std::cout &lt;&lt; \"Enter your favorite color: \";\r\n    std::string color{};\r\n    std::cin &gt;&gt; color;\r\n\r\n    std::cout &lt;&lt; \"Your name is \" &lt;&lt; name &lt;&lt; \" and your favorite color is \" &lt;&lt; color &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Here&#8217;s the results from a sample run of this program:<\/p>\n<pre>\nEnter your full name: John Doe\r\nEnter your favorite color: Your name is John and your favorite color is Doe\r\n<\/pre>\n<p>Hmmm, that isn&#8217;t right!  What happened?  It turns out that when using <code>operator&gt;&gt;<\/code> to extract a string from <code>std::cin<\/code>, <code>operator&gt;&gt;<\/code> only returns characters up to the first whitespace it encounters.  Any other characters are left inside <code>std::cin<\/code>, waiting for the next extraction.<\/p>\n<p>So when we used <code>operator&gt;&gt;<\/code> to extract input into variable <code>name<\/code>, only <code>\"John\"<\/code> was extracted, leaving <code>\" Doe\"<\/code> inside <code>std::cin<\/code>.  When we then used <code>operator&gt;&gt;<\/code> to get extract input into variable <code>color<\/code>, it extracted <code>\"Doe\"<\/code> instead of waiting for us to input an color.  Then the program ends.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Use <code>std::getline()<\/code> to input text<\/p>\n<p>To read a full line of input into a string, you&#8217;re better off using the <code>std::getline()<\/code> function instead.  <code>std::getline()<\/code> requires two arguments: the first is <code>std::cin<\/code>, and the second is your string variable.<\/p>\n<p>Here&#8217;s the same program as above using <code>std::getline()<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt; \/\/ For std::string and std::getline\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter your full name: \";\r\n    std::string name{};\r\n    std::getline(std::cin &gt;&gt; std::ws, name); \/\/ read a full line of text into name\r\n\r\n    std::cout &lt;&lt; \"Enter your favorite color: \";\r\n    std::string color{};\r\n    std::getline(std::cin &gt;&gt; std::ws, color); \/\/ read a full line of text into color\r\n\r\n    std::cout &lt;&lt; \"Your name is \" &lt;&lt; name &lt;&lt; \" and your favorite color is \" &lt;&lt; color &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Now our program works as expected:<\/p>\n<pre>\nEnter your full name: John Doe\r\nEnter your favorite color: blue\r\nYour name is John Doe and your favorite color is blue\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">What the heck is <code>std::ws<\/code>?<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/floating-point-numbers\/\">4.8 -- Floating point numbers<\/a>, we discussed output manipulators, which allow us to alter the way output is displayed.  In that lesson, we used the output manipulator function <code>std::setprecision()<\/code> to change the number of digits of precision that <code>std::cout<\/code> displayed.<\/p>\n<p>C++ also supports <strong><\/strong>input manipulators<strong><\/strong>, which alter the way that input is accepted.  The <code>std::ws<\/code> input manipulator tells <code>std::cin<\/code> to ignore any leading whitespace before extraction.  Leading whitespace is any whitespace character (spaces, tabs, newlines) that occur at the start of the string.<\/p>\n<p>Let&#8217;s explore why this is useful.  Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Pick 1 or 2: \";\r\n    int choice{};\r\n    std::cin &gt;&gt; choice;\r\n\r\n    std::cout &lt;&lt; \"Now enter your name: \";\r\n    std::string name{};\r\n    std::getline(std::cin, name); \/\/ note: no std::ws here\r\n\r\n    std::cout &lt;&lt; \"Hello, \" &lt;&lt; name &lt;&lt; \", you picked \" &lt;&lt; choice &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Here&#8217;s some output from this program:<\/p>\n<pre>\nPick 1 or 2: 2\r\nNow enter your name: Hello, , you picked 2\r\n<\/pre>\n<p>This program first asks you to enter 1 or 2, and waits for you to do so.  All good so far.  Then it will ask you to enter your name.  However, it won&#8217;t actually wait for you to enter your name!  Instead, it prints the &#8220;Hello&#8221; string, and then exits.<\/p>\n<p>When you enter a value using <code>operator&gt;&gt;<\/code>, <code>std::cin<\/code> not only captures the value, it also captures the newline character (<code>'\\n'<\/code>) that occurs when you hit the enter key.  So when we type <code>2<\/code> and then hit enter, <code>std::cin<\/code> captures the string <code>\"2\\n\"<\/code> as input.  It then extracts the value <code>2<\/code> to variable <code>choice<\/code>, leaving the newline character behind for later.  Then, when <code>std::getline()<\/code> goes to extract text to <code>name<\/code>, it sees <code>\"\\n\"<\/code> is already waiting in <code>std::cin<\/code>, and figures we must have previously entered an empty string!  Definitely not what was intended.<\/p>\n<p>We can amend the above program to use the <code>std::ws<\/code> input manipulator, to tell <code>std::getline()<\/code> to ignore any leading whitespace characters:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Pick 1 or 2: \";\r\n    int choice{};\r\n    std::cin &gt;&gt; choice;\r\n\r\n    std::cout &lt;&lt; \"Now enter your name: \";\r\n    std::string name{};\r\n    std::getline(std::cin &gt;&gt; std::ws, name); \/\/ note: added std::ws here\r\n\r\n    std::cout &lt;&lt; \"Hello, \" &lt;&lt; name &lt;&lt; \", you picked \" &lt;&lt; choice &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Now this program will function as intended.<\/p>\n<pre>\nPick 1 or 2: 2\r\nNow enter your name: Alex\r\nHello, Alex, you picked 2\r\n<\/pre>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>If using <code>std::getline()<\/code> to read strings, use <code>std::cin &gt;&gt; std::ws<\/code> input manipulator to ignore leading whitespace.  This needs to be done for each <code>std::getline()<\/code> call, as <code>std::ws<\/code> is not preserved across calls.\n<\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>When extracting to a variable, the extraction operator (<code>&gt;&gt;<\/code>) ignores leading whitespace.  It stops extracting when encountering non-leading whitespace.<\/p>\n<p><code>std::getline()<\/code> does not ignore leading whitespace.  If you want it to ignore leading whitespace, pass <code>std::cin &gt;&gt; std::ws<\/code> as the first argument.  It stops extracting when encountering a newline.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The length of a <code>std::string<\/code><\/p>\n<p>If we want to know how many characters are in a <code>std::string<\/code>, we can ask a <code>std::string<\/code> object for its length.  The syntax for doing this is different than you&#8217;ve seen before, but is pretty straightforward:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nint main()\r\n{\r\n    std::string name{ \"Alex\" };\r\n    std::cout &lt;&lt; name &lt;&lt; \" has \" &lt;&lt; name.length() &lt;&lt; \" characters\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nAlex has 4 characters\r\n<\/pre>\n<p>Although <code>std::string<\/code> is required to be null-terminated (as of C++11), the returned length of a <code>std::string<\/code> does not include the implicit null-terminator character.<\/p>\n<p>Note that instead of asking for the string length as <code>length(name)<\/code>, we say <code>name.length()<\/code>.  The <code>length()<\/code> function isn&#8217;t a normal standalone function -- it&#8217;s a special type of function that is nested within <code>std::string<\/code> called a <em>member function<\/em>.  Because the <code>length()<\/code> member function is declared inside of <code>std::string<\/code>, it is sometimes written as <code>std::string::length()<\/code> in documentation.<\/p>\n<p>We&#8217;ll cover member functions, including how to write your own, in more detail later.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>With normal functions, we call <code>function(object)<\/code>.  With member functions, we call <code>object.function()<\/code>.\n<\/div>\n<p>Also note that <code>std::string::length()<\/code> returns an unsigned integral value (most likely of type <code>size_t<\/code>).  If you want to assign the length to an <code>int<\/code> variable, you should <code>static_cast<\/code> it to avoid compiler warnings about signed\/unsigned conversions:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int length { static_cast&lt;int&gt;(name.length()) };<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>In C++20, you can also use the <code>std::ssize()<\/code> function to get the length of a <code>std::string<\/code> as a large signed integral type (usually <code>std::ptrdiff_t<\/code>):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nint main()\r\n{\r\n    std::string name{ \"Alex\" };\r\n    std::cout &lt;&lt; name &lt;&lt; \" has \" &lt;&lt; std::ssize(name) &lt;&lt; \" characters\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Since a <code>ptrdiff_t<\/code> may be larger than an <code>int<\/code>, if you want to store the result of <code>std::ssize()<\/code> in an <code>int<\/code> variable, you should <code>static_cast<\/code> the result to an <code>int<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int len { static_cast&lt;int&gt;(std::ssize(name)) };<\/code><\/pre>\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Initializing a <code>std::string<\/code> is expensive<\/p>\n<p>Whenever a std::string is initialized, a copy of the string used to initialize it is made.  Making copies of strings is expensive, so care should be taken to minimize the number of copies made.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Do not pass <code>std::string<\/code> by value<\/p>\n<p>When a <code>std::string<\/code> is passed to a function by value, the <code>std::string<\/code> function parameter must be instantiated and initialized with the argument.  This results in an expensive copy.  We&#8217;ll discuss what to do instead (use <code>std::string_view<\/code>) in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdstring_view\/\">5.8 -- Introduction to std::string_view<\/a>.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Do not pass <code>std::string<\/code> by value, as it makes an expensive copy.\n<\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>In most cases, use a <code>std::string_view<\/code> parameter instead (covered in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdstring_view\/\">5.8 -- Introduction to std::string_view<\/a>).\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Returning a <code>std::string<\/code><\/p>\n<p>When a function returns by value to the caller, the return value is normally copied from the function back to the caller.  So you might expect that you should not return <code>std::string<\/code> by value, as doing so would return an expensive copy of a <code>std::string<\/code>.<\/p>\n<p>However, as a rule of thumb, it is okay to return a <code>std::string<\/code> by value when the expression of the return statement resolves to any of the following:<\/p>\n<ul>\n<li>A local variable of type <code>std::string<\/code>.\n<\/li>\n<li>A <code>std::string<\/code> that has been returned by value from another function call or operator.\n<\/li>\n<li>A <code>std::string<\/code> temporary that is created as part of the return statement.\n<\/li>\n<\/ul>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p><code>std::string<\/code> supports a capability called move semantics, which allows an object that will be destroyed at the end of the function to instead be returned by value without making a copy.  How move semantics works is beyond the scope of this introductory article, but is something we introduce in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/returning-stdvector-and-an-introduction-to-move-semantics\/\">16.5 -- Returning std::vector, and an introduction to move semantics<\/a>.\n<\/div>\n<p>In most other cases, prefer to avoid returning a <code>std::string<\/code> by value, as doing so will make an expensive copy.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>If returning a C-style string literal, use a <code>std::string_view<\/code> return type instead (covered in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdstring_view-part-2\/\">5.9 -- std::string_view (part 2)<\/a>).\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>In certain cases, <code>std::string<\/code> may also be returned by (const) reference, which is another way to avoid making a copy.  We discuss this further in lessons <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/return-by-reference-and-return-by-address\/\">12.12 -- Return by reference and return by address<\/a> and <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/access-functions\/\">14.6 -- Access functions<\/a>.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Literals for <code>std::string<\/code><\/p>\n<p>Double-quoted string literals (like &#8220;Hello, world!&#8221;) are C-style strings by default (and thus, have a strange type).<\/p>\n<p>We can create string literals with type <code>std::string<\/code> by using a <code>s<\/code> suffix after the double-quoted string literal.  The <code>s<\/code> must be lower case.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt; \/\/ for std::string\r\n\r\nint main()\r\n{\r\n    using namespace std::string_literals; \/\/ easy access to the s suffix\r\n\r\n    std::cout &lt;&lt; \"foo\\n\";   \/\/ no suffix is a C-style string literal\r\n    std::cout &lt;&lt; \"goo\\n\"s;  \/\/ s suffix is a std::string literal\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>The &#8220;s&#8221; suffix lives in the namespace <code>std::literals::string_literals<\/code>.<\/p>\n<p>The most concise way to access the literal suffixes is via using-directive <code>using namespace std::literals<\/code>.  However, this imports <em>all<\/em> of the standard library literals into the scope of the using-directive, which brings in a bunch of stuff you probably aren&#8217;t going to use.<\/p>\n<p>We recommend <code>using namespace std::string_literals<\/code>, which imports only the literals for <code>std::string<\/code>.<\/p>\n<p>We discuss using-directives in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/using-declarations-and-using-directives\/\">7.13 -- Using declarations and using directives<\/a>.  This is one of the exception cases where <code>using<\/code> an entire namespace is generally okay, because the suffixes defined within are unlikely to collide with any of your code.  Avoid such using-directives outside of functions in header files.\n<\/div>\n<p>You probably won&#8217;t need to use <code>std::string<\/code> literals very often (as it&#8217;s fine to initialize a <code>std::string<\/code> object with a C-style string literal), but we&#8217;ll see a few cases in future lessons (involving type deduction) where using <code>std::string<\/code> literals instead of C-style string literals makes things easier (see <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/type-deduction-for-objects-using-the-auto-keyword\/\">10.8 -- Type deduction for objects using the auto keyword<\/a> for an example).<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p><code>\"Hello\"s<\/code> resolves to <code>std::string { \"Hello\", 5 }<\/code> which creates a temporary <code>std::string<\/code> initialized with C-style string literal &#8220;Hello&#8221; (which has a length of 5, excluding the implicit null-terminator).\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><a name=\"constexprStrings\"><\/a>Constexpr strings <a href=\"#constexprStrings\"><i class=\"fa fa-link\" style=\"font-size: 0.8em;\"><\/i><\/a><\/p>\n<p>If you try to define a <code>constexpr std::string<\/code>, your compiler will probably generate an error:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nint main()\r\n{\r\n    using namespace std::string_literals;\r\n\r\n    constexpr std::string name{ \"Alex\"s }; \/\/ compile error\r\n\r\n    std::cout &lt;&lt; \"My name is: \" &lt;&lt; name;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This happens because <code>constexpr std::string<\/code> isn&#8217;t supported at all in C++17 or earlier, and only works in very limited cases in C++20\/23.  If you need constexpr strings, use <code>std::string_view<\/code> instead (discussed in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdstring_view\/\">5.8 -- Introduction to std::string_view<\/a>).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Conclusion<\/p>\n<p><code>std::string<\/code> is complex, leveraging many language features that we haven&#8217;t covered yet.  Fortunately, you don&#8217;t need to understand these complexities to use <code>std::string<\/code> for simple tasks, like basic string input and output.  We encourage you to start experimenting with strings now, and we&#8217;ll cover additional string capabilities later.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Write a program that asks the user to enter their full name and their age.  As output, tell the user the sum of their age and the number of characters in their name (use the <code>std::string::length()<\/code> member function to get the length of the string).  For simplicity, count any spaces in the name as a character.<\/p>\n<p>Sample output:<\/p>\n<pre>\r\nEnter your full name: John Doe\r\nEnter your age: 32\r\nYour age + length of name is: 40\r\n<\/pre>\n<p>Reminder: We need to be careful not to mix signed and unsigned values.  <code>std::string::length()<\/code> returns an unsigned value.  If you&#8217;re C++20 capable, use <code>std::ssize()<\/code> to get the length as a signed value.  Otherwise, static_cast the return value of <code>std::string::length()<\/code> to an int.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter your full name: \";\r\n    std::string name{};\r\n    std::getline(std::cin &gt;&gt; std::ws, name); \/\/ read a full line of text into name\r\n\r\n    std::cout &lt;&lt; \"Enter your age: \";\r\n    int age{}; \/\/ age needs to be an integer, not a string, so we can do math with it\r\n    std::cin &gt;&gt; age;\r\n\r\n    \/\/ age is signed, and name.length() is unsigned -- we shouldn't mix these\r\n    \/\/ We'll convert name.length() to a signed value\r\n    int nameLen { static_cast&lt;int&gt;(name.length()) }; \/\/ get number of chars in name (including spaces)\r\n    std::cout &lt;&lt; \"Your age + length of name is: \" &lt;&lt; age + nameLen &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdstring_view\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">5.8<\/span>Introduction to std::string_view\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-variables\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">5.6<\/span>Constexpr variables\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we introduced C-style string literals: #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &#8220;Hello, world!&#8221;; \/\/ &#8220;Hello world!&#8221; is a C-style string literal. return 0; } While C-style string literals are fine to use, C-style string variables behave oddly, are hard to work with (e.g. you can&#8217;t use &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1725"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=1725"}],"version-history":[{"count":94,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1725\/revisions"}],"predecessor-version":[{"id":18070,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1725\/revisions\/18070"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=1725"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=1725"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=1725"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}