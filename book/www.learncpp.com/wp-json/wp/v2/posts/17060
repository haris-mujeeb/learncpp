{"id":17060,"date":"2024-05-22T16:43:21","date_gmt":"2024-05-22T23:43:21","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=17060"},"modified":"2025-01-29T23:45:58","modified_gmt":"2025-01-30T07:45:58","slug":"constexpr-aggregates-and-classes","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-aggregates-and-classes\/","title":{"rendered":"14.17 &#8212; Constexpr aggregates and classes"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-functions\/\">F.1 -- Constexpr functions<\/a>, we covered constexpr functions, which are functions that may be evaluated at either compile-time or runtime.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nconstexpr int greater(int x, int y)\r\n{\r\n    return (x &gt; y ? x : y);\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; greater(5, 6) &lt;&lt; '\\n'; \/\/ greater(5, 6) may be evaluated at compile-time or runtime\r\n\r\n    constexpr int g { greater(5, 6) };  \/\/ greater(5, 6) must be evaluated at compile-time\r\n    std::cout &lt;&lt; g &lt;&lt; '\\n';             \/\/ prints 6\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this example, <code>greater()<\/code> is a constexpr function, and <code>greater(5, 6)<\/code> is a constant expression, which may be evaluated at either compile-time or runtime.  Because <code>std::cout &lt;&lt; greater(5, 6)<\/code> calls <code>greater(5, 6)<\/code> in a non-constexpr context, the compiler is free to choose whether to evaluate <code>greater(5, 6<\/code>) at compile-time or runtime.  When <code>greater(5, 6)<\/code> is used to initialize constexpr variable <code>g<\/code>, <code>greater(5, 6)<\/code> is called in a constexpr context, and must be evaluated at compile-time.<\/p>\n<p>Now consider the following similar example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Pair\r\n{\r\n    int m_x {};\r\n    int m_y {};\r\n\r\n    int greater() const\r\n    {\r\n        return (m_x &gt; m_y  ? m_x : m_y);\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Pair p { 5, 6 };                  \/\/ inputs are constexpr values\r\n    std::cout &lt;&lt; p.greater() &lt;&lt; '\\n'; \/\/ p.greater() evaluates at runtime\r\n\r\n    constexpr int g { p.greater() };  \/\/ compile error: greater() not constexpr\r\n    std::cout &lt;&lt; g &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this version, we have an aggregate struct named <code>Pair<\/code>, and <code>greater()<\/code> is now a member function.  However, because member function <code>greater()<\/code> is not constexpr, <code>p.greater()<\/code> is not a constant expression.  When <code>std::cout &lt;&lt; p.greater()<\/code> calls <code>p.greater()<\/code> (in a non-constexpr context), <code>p.greater()<\/code> will be evaluated at runtime.  However, when we try to use <code>p.greater()<\/code> to initialize constexpr variable <code>g<\/code>, we get a compile error, as <code>p.greater()<\/code> cannot be evaluated at compile-time.<\/p>\n<p>Since the inputs to <code>p<\/code> are constexpr values (<code>5<\/code> and <code>6<\/code>), it seems like <code>p.greater()<\/code> should be capable of being evaluated at compile-time.  But how do we do that?<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constexpr member functions<\/p>\n<p>Just like non-member functions, member functions can be made constexpr via use of the <code>constexpr<\/code> keyword.  Constexpr member functions can be evaluated at either compile-time or runtime.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Pair\r\n{\r\n    int m_x {};\r\n    int m_y {};\r\n\r\n    constexpr int greater() const \/\/ can evaluate at either compile-time or runtime\r\n    {\r\n        return (m_x &gt; m_y  ? m_x : m_y);\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Pair p { 5, 6 };\r\n    std::cout &lt;&lt; p.greater() &lt;&lt; '\\n'; \/\/ okay: p.greater() evaluates at runtime\r\n\r\n    constexpr int g { p.greater() };  \/\/ compile error: p not constexpr\r\n    std::cout &lt;&lt; g &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this example, we&#8217;ve made <code>greater()<\/code> a constexpr function, so the compiler can evaluate it at either runtime or compile-time.<\/p>\n<p>When we call <code>p.greater()<\/code> in runtime expression <code>std::cout &lt;&lt; p.greater()<\/code>, it evaluates at runtime.<\/p>\n<p>However, when <code>p.greater()<\/code> is used to initialize constexpr variable <code>g<\/code>, we get a compiler error.  Although <code>greater()<\/code> is now constexpr, <code>p<\/code> is still not constexpr, therefore <code>p.greater()<\/code> is not a constant expression.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constexpr aggregates<\/p>\n<p>Okay, so if we need <code>p<\/code> to be constexpr, let&#8217;s just make it constexpr:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Pair \/\/ Pair is an aggregate\r\n{\r\n    int m_x {};\r\n    int m_y {};\r\n\r\n    constexpr int greater() const\r\n    {\r\n        return (m_x &gt; m_y  ? m_x : m_y);\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    constexpr Pair p { 5, 6 };        \/\/ now constexpr\r\n    std::cout &lt;&lt; p.greater() &lt;&lt; '\\n'; \/\/ p.greater() evaluates at runtime or compile-time\r\n\r\n    constexpr int g { p.greater() };  \/\/ p.greater() must evaluate at compile-time\r\n    std::cout &lt;&lt; g &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Since <code>Pair<\/code> is an aggregate, and aggregates implicitly support constexpr, we&#8217;re done.  This works!  Since <code>p<\/code> is a constexpr type, and <code>greater()<\/code> is a constexpr member function, <code>p.greater()<\/code> is a constant expression and can be used in places where only constant expressions are allowed.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We covered aggregates in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/struct-aggregate-initialization\/\">13.8 -- Struct aggregate initialization<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constexpr class objects and constexpr constructors<\/p>\n<p>Now let&#8217;s make our <code>Pair<\/code> a non-aggregate:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Pair \/\/ Pair is no longer an aggregate\r\n{\r\nprivate:\r\n    int m_x {};\r\n    int m_y {};\r\n\r\npublic:\r\n    Pair(int x, int y): m_x { x }, m_y { y } {}\r\n\r\n    constexpr int greater() const\r\n    {\r\n        return (m_x &gt; m_y  ? m_x : m_y);\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    constexpr Pair p { 5, 6 };       \/\/ compile error: p is not a literal type\r\n    std::cout &lt;&lt; p.greater() &lt;&lt; '\\n';\r\n\r\n    constexpr int g { p.greater() };\r\n    std::cout &lt;&lt; g &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This example is almost identical to the prior one, except <code>Pair<\/code> is no longer an aggregate (due to having private data members and a constructor).<\/p>\n<p>When we compile this program, we get a compiler error about <code>Pair<\/code> not being a &#8220;literal type&#8221;.  Say what?<\/p>\n<p>In C++, a <strong>literal type<\/strong> is any type for which it might be possible to create an object within a constant expression.  Put another way, an object can&#8217;t be constexpr unless the type qualifies as a literal type.  And our non-aggregate <code>Pair<\/code> does not qualify.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Nomenclature<\/p>\n<p>A literal and a literal type are distinct (but related) things.  A literal is a constexpr value that is inserted into the source code.  A literal type is a type that can be used as the type of a constexpr value.  A literal always has a literal type.  However, a value or object with a literal type need not be a literal.\n<\/p><\/div>\n<p>The definition of a literal type is complex, and a summary can be found on <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/named_req\/LiteralType\">cppreference<\/a>.  However, it&#8217;s worth noting that literal types include:<\/p>\n<ul>\n<li>Scalar types (those holding a single value, such as fundamental types and pointers)\n<\/li>\n<li>Reference types\n<\/li>\n<li>Most aggregates\n<\/li>\n<li>Classes that have a constexpr constructor\n<\/li>\n<\/ul>\n<p>And now we see why our <code>Pair<\/code> isn&#8217;t a literal type.  When a class object is instantiated, the compiler will call the constructor function to initialize the object.  And the constructor function in our <code>Pair<\/code> class is not constexpr, so it can&#8217;t be invoked at compile-time.  Therefore, <code>Pair<\/code> objects cannot be constexpr.<\/p>\n<p>The fix for this is simple: we just make our constructor <code>constexpr<\/code> as well:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Pair\r\n{\r\nprivate:\r\n    int m_x {};\r\n    int m_y {};\r\n\r\npublic:\r\n    constexpr Pair(int x, int y): m_x { x }, m_y { y } {} \/\/ now constexpr\r\n\r\n    constexpr int greater() const\r\n    {\r\n        return (m_x &gt; m_y  ? m_x : m_y);\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    constexpr Pair p { 5, 6 };\r\n    std::cout &lt;&lt; p.greater() &lt;&lt; '\\n';\r\n\r\n    constexpr int g { p.greater() };\r\n    std::cout &lt;&lt; g &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This works as expected, just like our aggregate version of <code>Pair<\/code> did.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>If you want your class to be able to be evaluated at compile-time, make your member functions and constructor constexpr.\n<\/p><\/div>\n<p>Implicitly defined constructors are constexpr if they can be defined as such.  Explicitly defaulted constructors must be explicitly defined as constexpr.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>Constexpr is part of the interface of the class, and removing it later will break callers who are calling the function in a constant context.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constexpr members may be needed with non-constexpr\/non-const objects<\/p>\n<p>In the above example, since the initializer of constexpr variable <code>g<\/code> must be a constant expression, it&#8217;s clear that <code>p.greater()<\/code> must be a constant expression, and therefore <code>p<\/code>, the <code>Pair<\/code> constructor, and <code>greater()<\/code> must all be constexpr.<\/p>\n<p>However, if we replace <code>p.greater()<\/code> with a constexpr function, things get a little less obvious:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Pair\r\n{\r\nprivate:\r\n    int m_x {};\r\n    int m_y {};\r\n\r\npublic:\r\n    constexpr Pair(int x, int y): m_x { x }, m_y { y } {}\r\n\r\n    constexpr int greater() const\r\n    {\r\n        return (m_x &gt; m_y  ? m_x : m_y);\r\n    }\r\n};\r\n\r\nconstexpr int init()\r\n{\r\n    Pair p { 5, 6 };    \/\/ requires constructor to be constexpr when evaluated at compile-time\r\n    return p.greater(); \/\/ requires greater() to be constexpr when evaluated at compile-time\r\n}\r\n\r\nint main()\r\n{\r\n    constexpr int g { init() }; \/\/ init() evaluated in compile-time context\r\n    std::cout &lt;&lt; g &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Remember that a constexpr function can evaluate at either runtime or compile-time.  And when a constexpr function evaluates at compile-time, it can only call functions capable of evaluating at compile-time.  In the case of a class type, that means constexpr member functions.<\/p>\n<p>Since <code>g<\/code> is constexpr, <code>init()<\/code> must be evaluated at compile-time.  Within the <code>init()<\/code> function, we define <code>p<\/code> as non-constexpr\/non-const (because we can, not because we should).  Even though <code>p<\/code> is not defined as constexpr, <code>p<\/code> still needs to be created at compile-time, and therefore requires a constexpr <code>Pair<\/code> constructor.  Similarly, in order for <code>p.greater()<\/code> to evaluate at compile-time, <code>greater()<\/code> must be a constexpr member function.  If either the <code>Pair<\/code> constructor or <code>greater()<\/code> were not constexpr, the compiler would error.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>When a constexpr function is evaluating in a compile-time context, only constexpr functions can be called.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constexpr member functions may be const or non-const <span class=\"cpp-section-pill cpp-section-standard\">C++14<\/span><\/p>\n<p>In C++11, non-static constexpr member functions are implicitly const (except constructors).<\/p>\n<p>However, as of C++14, constexpr member functions are no longer implicitly const.  This means that if you want a constexpr function to be a const function, you must explicitly mark it as such.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constexpr non-const member functions can change data members <span class=\"cpp-section-pill cpp-section-optional\">Optional<\/span><\/p>\n<p>A constexpr non-const member function can change data members of the class, so long as the implicit object isn&#8217;t const.  This is true even if the function is evaluating at compile-time.<\/p>\n<p>Here&#8217;s a contrived example of this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Pair\r\n{\r\nprivate:\r\n    int m_x {};\r\n    int m_y {};\r\n\r\npublic:\r\n    constexpr Pair(int x, int y): m_x { x }, m_y { y } {}\r\n\r\n    constexpr int greater() const \/\/ constexpr and const\r\n    {\r\n        return (m_x &gt; m_y  ? m_x : m_y);\r\n    }\r\n\r\n    constexpr void reset() \/\/ constexpr but non-const\r\n    {\r\n        m_x = m_y = 0; \/\/ non-const member function can change members\r\n    }\r\n\r\n    constexpr const int&amp; getX() const { return m_x; }\r\n};\r\n\r\n\/\/ This function is constexpr\r\nconstexpr Pair zero()\r\n{\r\n    Pair p { 1, 2 }; \/\/ p is non-const\r\n    p.reset();       \/\/ okay to call non-const member function on non-const object\r\n    return p;\r\n}\r\n\r\nint main()\r\n{\r\n    Pair p1 { 3, 4 };\r\n    p1.reset();                     \/\/ okay to call non-const member function on non-const object\r\n    std::cout &lt;&lt; p1.getX() &lt;&lt; '\\n'; \/\/ prints 0\r\n    \r\n    Pair p2 { zero() };             \/\/ zero() will be evaluated at runtime\r\n    p2.reset();                     \/\/ okay to call non-const member function on non-const object\r\n    std::cout &lt;&lt; p2.getX() &lt;&lt; '\\n'; \/\/ prints 0\r\n\r\n    constexpr Pair p3 { zero() };   \/\/ zero() will be evaluated at compile-time\r\n\/\/    p3.reset();                   \/\/ Compile error: can't call non-const member function on const object\r\n    std::cout &lt;&lt; p3.getX() &lt;&lt; '\\n'; \/\/ prints 0\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>As we work through this example, remember:<\/p>\n<ul>\n<li>A non-const member function can modify members of non-const objects.\n<\/li>\n<li>A constexpr member function can be called in either runtime contexts or compile-time contexts.\n<\/li>\n<\/ul>\n<p>These two things work independently.<\/p>\n<p>In the case of <code>p1<\/code>, <code>p1<\/code> is non-const.  Therefore, we are allowed to call non-const member function <code>p1.reset()<\/code> to modify <code>p1<\/code>.  The fact that <code>reset()<\/code> is constexpr doesn&#8217;t matter here because nothing we&#8217;re doing requires compile-time evaluation.<\/p>\n<p>The <code>p2<\/code> case is similar.  In this case, the initializer to <code>p2<\/code> is a function call to <code>zero()<\/code>.  Even though <code>zero()<\/code> is a constexpr function, in this case it is invoked in a runtime context, and acts just like a normal function.  Within <code>zero()<\/code>, we instantiate non-const <code>p<\/code>, call non-const member function <code>p.reset()<\/code> on it, and then return <code>p<\/code>.  The returned <code>Pair<\/code> is used as the initializer for <code>p2<\/code>.  The fact that <code>zero()<\/code> and <code>reset()<\/code> are constexpr don&#8217;t matter in this case, because nothing we&#8217;re doing requires compile-time evaluation.<\/p>\n<p>The <code>p3<\/code> case is the interesting one.  Because <code>p3<\/code> is constexpr, it must have a constant expression initializer.  Therefore, this call to <code>zero()<\/code> must evaluate at compile-time.  And because we&#8217;re evaluating in a compile-time context, we can only call constexpr functions.  Inside <code>zero()<\/code>, <code>p<\/code> is non-const (which is allowed, even though we&#8217;re evaluating at compile-time).  However, because we&#8217;re in a compile-time context, the constructor used to create <code>p<\/code> must be constexpr.  And just like the <code>p2<\/code> case, we&#8217;re allowed to call non-const member function <code>p.reset()<\/code> on non-const object <code>p<\/code>.  But because we&#8217;re in a compile-time context, the <code>reset()<\/code> member function must be constexpr.  The function then returns <code>p<\/code>, which is used to initialize <code>p3<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>Yes, we used a non-const object to initialize a constexpr object.  If this breaks your brain, it&#8217;s probably because you haven&#8217;t fully separated const from constexpr.<\/p>\n<p>There is no requirement that a constexpr variable be initialized with a const value.  It may seem that way because most of the time we initialize constexpr variable using literals (which are const) or other constexpr variables (which are implicitly const), and because the terms <code>const<\/code> and <code>constexpr<\/code> have similar names.<\/p>\n<p>The requirement is actually that a constexpr variable be initialized with a constant expression.  For functions (and operators), constexpr does not imply const, and constexpr functions (and operators) can make use of non-const objects and even return them.<\/p>\n<p>The important thing isn&#8217;t the const, its that the compiler can determine the value of the object at compile-time.  And in the case of constexpr functions, that&#8217;s possible even when they return a non-const object!\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constexpr functions that return const references (or pointers) <span class=\"cpp-section-pill cpp-section-optional\">Optional<\/span><\/p>\n<p>Normally you won&#8217;t see <code>constexpr<\/code> and <code>const<\/code> used right next to each other, but one case where this does happen is when you have a constexpr member function that returns a const reference (or (const) pointer-to-const).<\/p>\n<p>In our <code>Pair<\/code> class above, <code>getX()<\/code> is a constexpr member function that returns a const reference:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    constexpr const int&amp; getX() const { return m_x; }<\/code><\/pre>\n<p>That&#8217;s a lot of const-ing!<\/p>\n<p>The <code>constexpr<\/code> indicates that the member function can be evaluated at compile-time.  The <code>const int&amp;<\/code> is the return type of the function.  The rightmost <code>const<\/code> means the member-function itself is const so it can be called on const objects.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>A member function that returned a const pointer to const instead might look something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">constexpr const int* const getXPtr() const { return &amp;m_x; }<\/code><\/pre>\n<p>Isn&#8217;t it beautiful?  No?  Okay, fine.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-14-summary-and-quiz\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.x<\/span>Chapter 14 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/converting-constructors-and-the-explicit-keyword\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.16<\/span>Converting constructors and the explicit keyword\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we covered constexpr functions, which are functions that may be evaluated at either compile-time or runtime. For example: #include &lt;iostream&gt; constexpr int greater(int x, int y) { return (x &gt; y ? x : y); } int main() { std::cout &lt;&lt; greater(5, 6) &lt;&lt; &#8216;\\n&#8217;; \/\/ greater(5, &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/17060"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=17060"}],"version-history":[{"count":15,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/17060\/revisions"}],"predecessor-version":[{"id":18149,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/17060\/revisions\/18149"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=17060"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=17060"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=17060"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}