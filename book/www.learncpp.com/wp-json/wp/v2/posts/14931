{"id":14931,"date":"2023-07-21T16:09:27","date_gmt":"2023-07-21T23:09:27","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=14931"},"modified":"2024-09-25T13:54:52","modified_gmt":"2024-09-25T20:54:52","slug":"struct-miscellany","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/struct-miscellany\/","title":{"rendered":"13.11 &#8212; Struct miscellany"},"content":{"rendered":"<p class=\"cpp-section\">Structs with program-defined members<\/p>\n<p>In C++, structs (and classes) can have members that are other program-defined types.  There are two ways to do this.<\/p>\n<p>First, we can define one program-defined type (in the global scope) and then use it as a member of another program-defined type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Employee\r\n{\r\n    int id {};\r\n    int age {};\r\n    double wage {};\r\n};\r\n\r\nstruct Company\r\n{\r\n    int numberOfEmployees {};\r\n    Employee CEO {}; \/\/ Employee is a struct within the Company struct\r\n};\r\n\r\nint main()\r\n{\r\n    Company myCompany{ 7, { 1, 32, 55000.0 } }; \/\/ Nested initialization list to initialize Employee\r\n    std::cout &lt;&lt; myCompany.CEO.wage &lt;&lt; '\\n'; \/\/ print the CEO's wage\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above case, we&#8217;ve defined an <code>Employee<\/code> struct, and then used that as a member in a <code>Company<\/code> struct.  When we initialize our <code>Company<\/code>, we can also initialize our <code>Employee<\/code> by using a nested initialization list.  And if we want to know what the CEO&#8217;s salary was, we simply use the member selection operator twice: <code>myCompany.CEO.wage;<\/code><\/p>\n<p>Second, types can also be nested inside other types, so if an Employee only existed as part of a Company, the Employee type could be nested inside the Company struct:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Company\r\n{\r\n    struct Employee \/\/ accessed via Company::Employee\r\n    {\r\n        int id{};\r\n        int age{};\r\n        double wage{};\r\n    };\r\n\r\n    int numberOfEmployees{};\r\n    Employee CEO{}; \/\/ Employee is a struct within the Company struct\r\n};\r\n\r\nint main()\r\n{\r\n    Company myCompany{ 7, { 1, 32, 55000.0 } }; \/\/ Nested initialization list to initialize Employee\r\n    std::cout &lt;&lt; myCompany.CEO.wage &lt;&lt; '\\n'; \/\/ print the CEO's wage\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This is more often done with classes, so we&#8217;ll talk more about this in a future lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/nested-types-member-types\/\">15.3 -- Nested types (member types)<\/a>).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Structs that are owners should have data members that are owners<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdstring_view-part-2\/\">5.9 -- std::string_view (part 2)<\/a>, we introduced the dual concepts of owners and viewers.  Owners manage their own data, and control when it is destroyed.  Viewers view someone else&#8217;s data, and do not control when it is altered or destroyed.<\/p>\n<p>In most cases, we want our structs (and classes) to be owners of the data they contain.  This provides a few useful benefits:<\/p>\n<ul>\n<li>The data members will be valid for as long as the struct (or class) is.\n<\/li>\n<li>The value of those data members won&#8217;t change unexpectedly.\n<\/li>\n<\/ul>\n<p>The easiest way to make a struct (or class) an owner is to give each data member a type that is an owner (e.g. not a viewer, pointer, or reference).  If a struct or class has data members that are all owners, then the struct or class itself is automatically an owner.<\/p>\n<p>If a struct (or class) has a data member that is a viewer, it is possible that the object being viewed by that member will be destroyed before the data member that is viewing it.  If this happens, the struct will be left with a dangling member, and accessing that member will lead to undefined behavior.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>In most cases, we want our structs (and classes) to be owners.  The easiest way to enable this is to ensure each data member has an owning type (e.g. not a viewer, pointer, or reference).\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>Practice safe structs.  Don&#8217;t let your member dangle.\n<\/p><\/div>\n<p>This is why string data members are almost always of type <code>std::string<\/code> (which is an owner), and not of type <code>std::string_view<\/code> (which is a viewer).  The following example illustrates a case where this matters:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nstruct Owner\r\n{\r\n    std::string name{}; \/\/ std::string is an owner\r\n};\r\n\r\nstruct Viewer\r\n{\r\n    std::string_view name {}; \/\/ std::string_view is a viewer\r\n};\r\n\r\n\/\/ getName() returns the user-entered string as a temporary std::string\r\n\/\/ This temporary std::string will be destroyed at the end of the full expression\r\n\/\/ containing the function call.\r\nstd::string getName()\r\n{\r\n    std::cout &lt;&lt; \"Enter a name: \";\r\n    std::string name{};\r\n    std::cin &gt;&gt; name;\r\n    return name;\r\n}\r\n\r\nint main()\r\n{\r\n    Owner o { getName() };  \/\/ The return value of getName() is destroyed just after initialization\r\n    std::cout &lt;&lt; \"The owners name is \" &lt;&lt; o.name &lt;&lt; '\\n';  \/\/ ok\r\n\r\n    Viewer v { getName() }; \/\/ The return value of getName() is destroyed just after initialization\r\n    std::cout &lt;&lt; \"The viewers name is \" &lt;&lt; v.name &lt;&lt; '\\n'; \/\/ undefined behavior\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The <code>getName()<\/code> function returns the name the user entered as a temporary <code>std::string<\/code>.  This temporary return value is destroyed at the end of the full expression in which the function is called.<\/p>\n<p>In the case of <code>o<\/code>, this temporary <code>std::string<\/code> is used to initialize <code>o.name<\/code>.  Since <code>o.name<\/code> is a <code>std::string<\/code>, <code>o.name<\/code> makes a copy of the temporary <code>std::string<\/code>.  The temporary <code>std::string<\/code> then dies, but <code>o.name<\/code> is not affected since it&#8217;s a copy.  When we print <code>o.name<\/code> in the subsequent statement, it works as we expect.<\/p>\n<p>In the case of <code>v<\/code>, this temporary <code>std::string<\/code> is used to initialize <code>v.name<\/code>.  Since <code>v.name<\/code> is a <code>std::string_view<\/code>, <code>v.name<\/code> is just a view of the temporary <code>std::string<\/code>, not a copy.  The temporary <code>std::string<\/code> then dies, leaving <code>v.name<\/code> dangling.  When we print <code>v.name<\/code> in the subsequent statement, we get undefined behavior.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Struct size and data structure alignment<\/p>\n<p>Typically, the size of a struct is the sum of the size of all its members, but not always!<\/p>\n<p>Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Foo\r\n{\r\n    short a {};\r\n    int b {};\r\n    double c {};\r\n};\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"The size of short is \" &lt;&lt; sizeof(short) &lt;&lt; \" bytes\\n\";\r\n    std::cout &lt;&lt; \"The size of int is \" &lt;&lt; sizeof(int) &lt;&lt; \" bytes\\n\";\r\n    std::cout &lt;&lt; \"The size of double is \" &lt;&lt; sizeof(double) &lt;&lt; \" bytes\\n\";\r\n\r\n    std::cout &lt;&lt; \"The size of Foo is \" &lt;&lt; sizeof(Foo) &lt;&lt; \" bytes\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>On the author&#8217;s machine, this printed:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">The size of short is 2 bytes\r\nThe size of int is 4 bytes\r\nThe size of double is 8 bytes\r\nThe size of Foo is 16 bytes<\/code><\/pre>\n<p>Note that the size of <code>short<\/code> + <code>int<\/code> + <code>double<\/code> is 14 bytes, but the size of <code>Foo<\/code> is 16 bytes!<\/p>\n<p>It turns out, we can only say that the size of a struct will be <em>at least<\/em> as large as the size of all the variables it contains.  But it could be larger!  For performance reasons, the compiler will sometimes add gaps into structures (this is called <strong>padding<\/strong>).<\/p>\n<p>In the <code>Foo<\/code> struct above, the compiler is invisibly adding 2 bytes of padding after member <code>a<\/code>, making the size of the structure 16 bytes instead of 14.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>The reason compilers may add padding is beyond the scope of this tutorial, but readers who want to learn more can read about <a href=\"http:\/\/en.wikipedia.org\/wiki\/Data_structure_alignment\">data structure alignment<\/a> on Wikipedia.  This is optional reading and not required to understand structures or C++!\n<\/div>\n<p>This can actually have a pretty significant impact on the size of the struct, as the following program demonstrates:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Foo1\r\n{\r\n    short a{}; \/\/ will have 2 bytes of padding after a\r\n    int b{};\r\n    short c{}; \/\/ will have 2 bytes of padding after c\r\n};\r\n\r\nstruct Foo2\r\n{\r\n    int b{};\r\n    short a{};\r\n    short c{};\r\n};\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; sizeof(Foo1) &lt;&lt; '\\n'; \/\/ prints 12\r\n    std::cout &lt;&lt; sizeof(Foo2) &lt;&lt; '\\n'; \/\/ prints 8\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\n12\r\n8\r\n<\/pre>\n<p>Note that <code>Foo1<\/code> and <code>Foo2<\/code> have the same members, the only difference being the declaration order.  Yet <code>Foo1<\/code> is 50% larger due to the added padding.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>You can minimize padding by defining your members in decreasing order of size.<\/p>\n<p>The C++ compiler is not allowed to reorder members, so this has to be done manually.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/member-selection-with-pointers-and-references\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.12<\/span>Member selection with pointers and references\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/passing-and-returning-structs\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.10<\/span>Passing and returning structs\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Structs with program-defined members In C++, structs (and classes) can have members that are other program-defined types. There are two ways to do this. First, we can define one program-defined type (in the global scope) and then use it as a member of another program-defined type: #include &lt;iostream&gt; struct Employee &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/14931"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=14931"}],"version-history":[{"count":10,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/14931\/revisions"}],"predecessor-version":[{"id":17664,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/14931\/revisions\/17664"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=14931"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=14931"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=14931"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}