{"id":1256,"date":"2015-02-23T17:13:13","date_gmt":"2015-02-24T01:13:13","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=1256"},"modified":"2024-10-17T12:05:13","modified_gmt":"2024-10-17T19:05:13","slug":"constant-variables-named-constants","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/constant-variables-named-constants\/","title":{"rendered":"5.1 &#8212; Constant variables (named constants)"},"content":{"rendered":"<p class=\"cpp-section\">Introduction to constants<\/p>\n<p>In programming, a <strong>constant<\/strong> is a value that may not be changed during the program&#8217;s execution.<\/p>\n<p>C++ supports two different kinds of constants:<\/p>\n<ul>\n<li><strong>Named constants<\/strong> are constant values that are associated with an identifier.  These are also sometimes called <strong>symbolic constants<\/strong>.\n<\/li>\n<li><strong>Literal constants<\/strong> are constant values that are not associated with an identifier.\n<\/li>\n<\/ul>\n<p>We&#8217;ll start our coverage of constants by looking at named constants.  We will then cover literal constants (in upcoming lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/literals\/\">5.2 -- Literals<\/a>).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Types of named constants<\/p>\n<p>There are three ways to define a named constant in C++:<\/p>\n<ul>\n<li>Constant variables (covered in this lesson).\n<\/li>\n<li>Object-like macros with substitution text (introduced in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-the-preprocessor\/\">2.10 -- Introduction to the preprocessor<\/a>, with additional coverage in this lesson).\n<\/li>\n<li>Enumerated constants (covered in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/unscoped-enumerations\/\">13.2 -- Unscoped enumerations<\/a>).\n<\/li>\n<\/ul>\n<p>Constant variables are the most common type of named constant, so we&#8217;ll start there.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constant variables<\/p>\n<p>So far, all of the variables we&#8217;ve seen have been non-constant -- that is, their values can be changed at any time (typically by assigning a new value).  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int x { 4 }; \/\/ x is a non-constant variable\r\n    x = 5; \/\/ change value of x to 5 using assignment operator\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, there are many cases where it is useful to define variables with values that can not be changed.  For example, consider the gravity of Earth (near the surface): 9.8 meters\/second<sup>2<\/sup>.  This isn&#8217;t likely to change any time soon (and if it does, you&#8217;ve likely got bigger problems than learning C++).  Defining this value as a constant helps ensure that this value isn&#8217;t accidentally changed.  Constants also have other benefits that we&#8217;ll explore in subsequent lessons.<\/p>\n<p>Although it is a well-known oxymoron, a variable whose value cannot be changed after initialization is called a <strong>constant variable<\/strong>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Declaring a const variable<\/p>\n<p>To declare a constant variable, we place the <code>const<\/code> keyword (called a &#8220;const qualifier&#8221;) adjacent to the object&#8217;s type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">const double gravity { 9.8 };  \/\/ preferred use of const before type\r\nint const sidesInSquare { 4 }; \/\/ \"east const\" style, okay but not preferred<\/code><\/pre>\n<p>Although C++ will accept the const qualifier either before or after the type, it&#8217;s much more common to use <code>const<\/code> before the type because it better follows standard English language convention where modifiers come before the object being modified (e.g. a &#8220;a green ball&#8221;, not a &#8220;a ball green&#8221;).<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>Due to the way that the compiler parses more complex declarations, some developers prefer placing the <code>const<\/code> after the type (because it is slightly more consistent).  This style is called &#8220;east const&#8221;.  While this style has some advocates (and some reasonable points), it has not caught on significantly.\n<\/div>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Place <code>const<\/code> before the type (because it is more conventional to do so).\n<\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>The type of an object includes the const qualifier, so when we define <code>const double gravity { 9.8 };<\/code> the type of <code>gravity<\/code> is <code>const double<\/code>.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Const variables must be initialized<\/p>\n<p>Const variables <em>must<\/em> be initialized when you define them, and then that value can not be changed via assignment:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    const double gravity; \/\/ error: const variables must be initialized\r\n    gravity = 9.9;        \/\/ error: const variables can not be changed\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Note that const variables can be initialized from other variables (including non-const ones):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{ \r\n    std::cout &lt;&lt; \"Enter your age: \";\r\n    int age{};\r\n    std::cin &gt;&gt; age;\r\n\r\n    const int constAge { age }; \/\/ initialize const variable using non-const value\r\n\r\n    age = 5;      \/\/ ok: age is non-const, so we can change its value\r\n    constAge = 6; \/\/ error: constAge is const, so we cannot change its value\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, we initialize const variable <code>constAge<\/code> with non-const variable <code>age<\/code>.  Because <code>age<\/code> is still non-const, we can change its value.  However, because <code>constAge<\/code> is const, we cannot change the value it has after initialization.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>The initializer of a const variable can be a non-constant value.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Naming your const variables<\/p>\n<p>There are a number of different naming conventions that are used for const variables.<\/p>\n<p>Programmers who have transitioned from C often prefer underscored, upper-case names for const variables (e.g. <code>EARTH_GRAVITY<\/code>).  More common in C++ is to use intercapped names with a &#8216;k&#8217; prefix (e.g. <code>kEarthGravity<\/code>).<\/p>\n<p>However, because const variables act like normal variables (except they can not be assigned to), there is no reason that they need a special naming convention.  For this reason, we prefer using the same naming convention that we use for non-const variables (e.g. <code>earthGravity<\/code>).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Const function parameters<\/p>\n<p>Function parameters can be made constants via the <code>const<\/code> keyword:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printInt(const int x)\r\n{\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    printInt(5); \/\/ 5 will be used as the initializer for x\r\n    printInt(6); \/\/ 6 will be used as the initializer for x\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Note that we did not provide an explicit initializer for our const parameter <code>x<\/code> -- the value of the argument in the function call will be used as the initializer for <code>x<\/code>.<\/p>\n<p>Making a function parameter constant enlists the compiler&#8217;s help to ensure that the parameter&#8217;s value is not changed inside the function.  However, in modern C++ we don&#8217;t make value parameters <code>const<\/code> because we generally don&#8217;t care if the function changes the value of the parameter (since it&#8217;s just a copy that will be destroyed at the end of the function anyway).  The <code>const<\/code> keyword also adds a small amount of unnecessary clutter to the function prototype.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Don&#8217;t use <code>const<\/code> for value parameters.\n<\/div>\n<p>Later in this tutorial series, we&#8217;ll talk about two other ways to pass arguments to functions: pass by reference, and pass by address.  When using either of these methods, proper use of <code>const<\/code> is important.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Const return values<\/p>\n<p>A function&#8217;s return value may also be made const:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nconst int getValue()\r\n{\r\n    return 5;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; getValue() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>For fundamental types, the <code>const<\/code> qualifier on a return type is simply ignored (your compiler may generate a warning).<\/p>\n<p>For other types (which we&#8217;ll cover later), there is typically little point in returning const objects by value, because they are temporary copies that will be destroyed anyway.  Returning a const value can also impede certain kinds of compiler optimizations (involving move semantics), which can result in lower performance.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Don&#8217;t use <code>const<\/code> when returning by value.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Why variables should be made constant<\/p>\n<p>If a variable can be made constant, it generally should be made constant.  This is important for a number of reasons:<\/p>\n<ul>\n<li>It reduces the chance of bugs.  By making a variable constant, you ensure that the value can&#8217;t be changed accidentally.\n<\/li>\n<li>It provides more opportunity for the compiler to optimize programs.  When the compiler can assume a value isn&#8217;t changing, it is able to leverage more techniques to optimize the program, resulting in a compiled program that is smaller and faster.  We&#8217;ll discuss this further later in this chapter.\n<\/li>\n<li>Most importantly, it reduces the overall complexity of our programs.  When trying to determine what a section of code is doing or trying to debug an issue, we know that a const variable can&#8217;t have its value changed, so we don&#8217;t have to worry about whether its value is actually changing, what value it is changing to, and whether that new value is correct.\n<\/li>\n<\/ul>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Every moving part in a system increases complexity and the risk of defect or failure.  Non-constant variables are moving parts, while constant variables are not.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Make variables constant whenever possible.  Exception cases include by-value function parameters and by-value return types, which should generally not be made constant.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Object-like macros with substitution text<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-the-preprocessor\/\">2.10 -- Introduction to the preprocessor<\/a>, we discussed object-like macros with substitution text.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n#define MY_NAME \"Alex\"\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"My name is: \" &lt;&lt; MY_NAME &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When the preprocessor processes the file containing this code, it will replace <code>MY_NAME<\/code> (on line 7) with <code>\"Alex\"<\/code>.  Note that <code>MY_NAME<\/code> is a name, and the substitution text is a constant value, so object-like macros with substitution text are also named constants.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Prefer constant variables to preprocessor macros<\/p>\n<p>So why not use preprocessor macros for named constants?  There are (at least) three major problems.<\/p>\n<p>The biggest issue is that macros don&#8217;t follow normal C++ scoping rules.  Once a macro is #defined, all subsequent occurrences of the macro&#8217;s name in the current file will be replaced.  If that name is used elsewhere, you&#8217;ll get macro substitution where you didn&#8217;t want it.  This will most likely lead to strange compilation errors.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid someFcn()\r\n{\r\n\/\/ Even though gravity is defined inside this function\r\n\/\/ the preprocessor will replace all subsequent occurrences of gravity in the rest of the file\r\n#define gravity 9.8\r\n}\r\n\r\nvoid printGravity(double gravity) \/\/ including this one, causing a compilation error\r\n{\r\n    std::cout &lt;&lt; \"gravity: \" &lt;&lt; gravity &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    printGravity(3.71);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When compiled, GCC produced this confusing error:<\/p>\n<pre>\nprog.cc:7:17: error: expected ',' or '...' before numeric constant\r\n    5 | #define gravity 9.8\r\n      |                 ^~~\r\nprog.cc:10:26: note: in expansion of macro 'gravity'\r\n<\/pre>\n<p>Second, it is often harder to debug code using macros.  Although your source code will have the macro&#8217;s name, the compiler and debugger never see the macro because it has already been replaced before they run.  Many debuggers are unable to inspect a macro&#8217;s value, and often have limited capabilities when working with macros.<\/p>\n<p>Third, macro substitution behaves differently than everything else in C++.  Inadvertent mistakes can be easily made as a result.<\/p>\n<p>Constant variables have none of these problems: they follow normal scoping rules, can be seen by the compiler and debugger, and behave consistently.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Prefer constant variables over object-like macros with substitution text.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using constant variables throughout a multi-file program<\/p>\n<p>In many applications, a given named constant needs to be used throughout your code (not just in one file).  These can include physics or mathematical constants that don&#8217;t change (e.g. pi or Avogadro&#8217;s number), or application-specific &#8220;tuning&#8221; values (e.g. friction or gravity coefficients).  Instead of redefining these every time they are needed, it&#8217;s better to declare them once in a central location and use them wherever needed.  That way, if you ever need to change them, you only need to change them in one place.<\/p>\n<p>There are multiple ways to facilitate this within C++ -- we cover this topic in full detail in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/sharing-global-constants-across-multiple-files-using-inline-variables\/\">7.10 -- Sharing global constants across multiple files (using inline variables)<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Nomenclature: type qualifiers<\/p>\n<p>A <strong>type qualifier<\/strong> (sometimes called a <strong>qualifier<\/strong> for short) is a keyword that is applied to a type that modifies how that type behaves.  The <code>const<\/code> used to declare a constant variable is called a <strong>const type qualifier<\/strong> (or <strong>const qualifier<\/strong> for short).<\/p>\n<p>As of C++23, C++ only has two type qualifiers: <code>const<\/code> and <code>volatile<\/code>.  <\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Optional reading<\/p>\n<p>The <code>volatile<\/code> qualifier is used to tell the compiler that an object may have its value changed at any time.  This rarely-used qualifier disables certain types of optimizations.<\/p>\n<p>In technical documentation, the <code>const<\/code> and <code>volatile<\/code> qualifiers are often referred to as <strong>cv-qualifiers<\/strong>.  The following terms are also used in the C++ standard:<\/p>\n<ul>\n<li>A <strong>cv-unqualified<\/strong> type is a type with no type qualifiers (e.g. <code>int<\/code>).\n<\/li>\n<li>A <strong>cv-qualified<\/strong> type is a type with one or more type qualifiers applied (e.g. <code>const int<\/code>).\n<\/li>\n<li>A <strong>possibly cv-qualified<\/strong> type is a type that may be cv-unqualified or cv-qualified.\n<\/li>\n<\/ul>\n<p>These terms are not used much outside of technical documentation, so they are listed here for reference, not as something you need to remember.<\/p>\n<p>But at least now you can appreciate this joke from <a href=\"https:\/\/x.com\/jfbastien\/status\/1017819242815631360\">JF Bastien<\/a>:<\/p>\n<ul>\n<li>Q: How do you know if a C++ developer is qualified?\n<\/li>\n<li>A: You look at their CV.\n<\/li>\n<\/ul>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/literals\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">5.2<\/span>Literals\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-4-summary-and-quiz\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">4.x<\/span>Chapter 4 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Introduction to constants In programming, a constant is a value that may not be changed during the program&#8217;s execution. C++ supports two different kinds of constants: Named constants are constant values that are associated with an identifier. These are also sometimes called symbolic constants. Literal constants are constant values that &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1256"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=1256"}],"version-history":[{"count":83,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1256\/revisions"}],"predecessor-version":[{"id":1258,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1256\/revisions\/1258"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=1256"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=1256"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=1256"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}