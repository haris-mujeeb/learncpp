{"id":11964,"date":"2021-10-21T14:27:36","date_gmt":"2021-10-21T21:27:36","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=11964"},"modified":"2025-03-03T13:45:24","modified_gmt":"2025-03-03T21:45:24","slug":"introduction-to-type-conversion-and-static_cast","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-type-conversion-and-static_cast\/","title":{"rendered":"4.12 &#8212; Introduction to type conversion and static_cast"},"content":{"rendered":"<p class=\"cpp-section\">Implicit type conversion<\/p>\n<p>Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid print(double x) \/\/ print takes a double parameter\r\n{\r\n\tstd::cout &lt;&lt; x &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n\tprint(5); \/\/ what happens when we pass an int value?\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In the above example, the <code>print()<\/code> function has a parameter of type <code>double<\/code> but the caller is passing in the value <code>5<\/code> which is of type <code>int<\/code>.  What happens in this case?<\/p>\n<p>In most cases, C++ will allow us to convert values of one fundamental type to another fundamental type.  The process of converting data from one type to another type is called <strong>type conversion<\/strong>.  Thus, the int argument <code>5<\/code> will be converted to double value <code>5.0<\/code> and then copied into parameter <code>x<\/code>.  The <code>print()<\/code> function will print this value, resulting in the following output:<\/p>\n<pre>\n5\r\n<\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">A reminder<\/p>\n<p>By default, floating point values whose decimal part is 0 print without the decimal places (e.g. <code>5.0<\/code> prints as <code>5<\/code>).\n<\/div>\n<p>When the compiler does type conversion on our behalf without us explicitly asking, we call this <strong>implicit type conversion<\/strong>.  The above example illustrates this -- nowhere do we explicitly tell the compiler to convert integer value <code>5<\/code> to double value <code>5.0<\/code>.  Rather, the function is expecting a double value, and we pass in an integer argument.  The compiler will notice the mismatch and implicitly convert the integer to a double.<\/p>\n<p>Here&#8217;s a similar example where our argument is an int variable instead of an int literal:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid print(double x) \/\/ print takes a double parameter\r\n{\r\n\tstd::cout &lt;&lt; x &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n\tint y { 5 };\r\n\tprint(y); \/\/ y is of type int\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This works identically to the above.  The value held by int variable <code>y<\/code> (<code>5<\/code>) will be converted to double value <code>5.0<\/code>, and then copied into parameter <code>x<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Type conversion of a value produces a new value<\/p>\n<p>The type conversion process does not modify the value (or object) supplying the data to be converted.  Instead, the conversion process uses that data as input, and produces the converted result.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>The type conversion of a value to another type of value behaves much like a call to a function whose return type matches the target type of the conversion.  The data to be converted is passed in as an argument, and the converted result is returned (in a temporary object) to be used by the caller.\n<\/p><\/div>\n<p>In the above example, the conversion does not change variable <code>y<\/code> from type <code>int<\/code> to <code>double<\/code> or the value of <code>y<\/code> from <code>5<\/code> to <code>5.0<\/code>.  Instead, the conversion uses the value of <code>y<\/code> (<code>5<\/code>) as input, and returns a temporary object of type <code>double<\/code> with value <code>5.0<\/code>.  This temporary object is then passed to function <code>print<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Some advanced type conversions (e.g. those involving <code>const_cast<\/code> or <code>reinterpret_cast<\/code>) do not return temporary objects, but instead reinterpret the type of an existing value or object.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Implicit type conversion warnings<\/p>\n<p>Although implicit type conversion is sufficient for most cases where type conversion is needed, there are a few cases where it is not.  Consider the following program, which is similar to the example above:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid print(int x) \/\/ print now takes an int parameter\r\n{\r\n\tstd::cout &lt;&lt; x &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n\tprint(5.5); \/\/ warning: we're passing in a double value\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In this program, we&#8217;ve changed <code>print()<\/code> to take an <code>int<\/code> parameter, and the function call to <code>print()<\/code> is now passing in <code>double<\/code> value <code>5.5<\/code>.  Similar to the above, the compiler will use implicit type conversion in order to convert double value <code>5.5<\/code> into a value of type <code>int<\/code>, so that it can be passed to function <code>print()<\/code>.<\/p>\n<p>Unlike the initial example, when this program is compiled, your compiler will generate some kind of a warning about a possible loss of data.  And because you have &#8220;treat warnings as errors&#8221; turned on (you do, right?), your compiler will abort the compilation process.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>You&#8217;ll need to disable &#8220;treat warnings as errors&#8221; temporarily if you want to compile this example.  See lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/configuring-your-compiler-warning-and-error-levels\/\">0.11 -- Configuring your compiler: Warning and error levels<\/a> for more information about this setting.\n<\/p><\/div>\n<p>When compiled and run, this program prints the following:<\/p>\n<pre>\n5\r\n<\/pre>\n<p>Note that although we passed in value <code>5.5<\/code>, the program printed <code>5<\/code>.  Because integral values can&#8217;t hold fractions, when double value <code>5.5<\/code> is implicitly converted to an <code>int<\/code>, the fractional component is dropped, and only the integral value is retained.<\/p>\n<p>Because converting a floating point value to an integral value results in any fractional component being dropped, the compiler will warn us when it does an implicit type conversion from a floating point to an integral value.  This happens even if we were to pass in a floating point value with no fractional component, like <code>5.0<\/code> -- no actual loss of value occurs during the conversion to integral value <code>5<\/code> in this specific case, but the compiler may still warn us that the conversion is unsafe.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Some type conversions (such as a <code>char<\/code> to an <code>int<\/code>) always preserve the value being converted, whereas others (such as <code>double<\/code> to <code>int<\/code>) may result in the value being changed during conversion.  Unsafe implicit conversions will typically either generate a compiler warning, or (in the case of brace initialization) an error.<\/p>\n<p>This is one of the primary reasons brace initialization is the preferred initialization form.  Brace initialization will ensure we don&#8217;t try to initialize a variable with an initializer that will lose value when it is implicitly type converted:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    double d { 5 }; \/\/ okay: int to double is safe\r\n    int x { 5.5 }; \/\/ error: double to int not safe\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>Implicit type conversion is a meaty topic.  We dig into this topic in more depth in future lessons, starting with lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/implicit-type-conversion\/\">10.1 -- Implicit type conversion<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">An introduction to explicit type conversion via the static_cast operator<\/p>\n<p>Back to our most recent <code>print()<\/code> example, what if we <em>intentionally<\/em> wanted to pass a double value to a function taking an integer (knowing that the converted value would drop any fractional component?)  Turning off &#8220;treat warnings as errors&#8221; just to make our program compile is a bad idea, because then we&#8217;ll have warnings every time we compile (which we will quickly learn to ignore), and we risk overlooking warnings about more serious issues.<\/p>\n<p>C++ supports a second method of type conversion, called explicit type conversion.  <strong>Explicit type conversion<\/strong> allow us (the programmer) to explicitly tell the compiler to convert a value from one type to another type, and that we take full responsibility for the result of that conversion.  If such a conversion results in the loss of value, the compiler will not warn us.<\/p>\n<p>To perform an explicit type conversion, in most cases we&#8217;ll use the <code>static_cast<\/code> operator.  The syntax for the <code>static cast<\/code> looks a little funny:<\/p>\n<pre>\nstatic_cast&lt;new_type&gt;(expression)\r\n<\/pre>\n<p>static_cast takes the value from an expression as input, and returns that value converted into the type specified by <em>new_type<\/em> (e.g. int, bool, char, double).<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Whenever you see C++ syntax (excluding the preprocessor) that makes use of angled brackets (&lt;&gt;), the thing between the angled brackets will most likely be a type.  This is typically how C++ deals with code that need a parameterized type.\n<\/p><\/div>\n<p>Let&#8217;s update our prior program using <code>static_cast<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid print(int x)\r\n{\r\n\tstd::cout &lt;&lt; x &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n\tprint( static_cast&lt;int&gt;(5.5) ); \/\/ explicitly convert double value 5.5 to an int\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Because we&#8217;re now explicitly requesting that double value <code>5.5<\/code> be converted to an <code>int<\/code> value, the compiler will not generate a warning about a possible loss of data upon compilation (meaning we can leave &#8220;treat warnings as errors&#8221; enabled).<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>C++ supports other types of casts.  We talk more about the different types of casts in future lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/explicit-type-conversion-casting-and-static-cast\/\">10.6 -- Explicit type conversion (casting) and static_cast<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using static_cast to convert char to int<\/p>\n<p>In the lesson on chars <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chars\/\">4.11 -- Chars<\/a>, we saw that printing a char value using <code>std::cout<\/code> results in the value being printed as a char:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    char ch{ 97 }; \/\/ 97 is ASCII code for 'a'\r\n    std::cout &lt;&lt; ch &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\na\r\n<\/pre>\n<p>If we want to print the integral value instead of the char, we can do this by using <code>static_cast<\/code> to cast the value from a <code>char<\/code> to an <code>int<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    char ch{ 97 }; \/\/ 97 is ASCII code for 'a'\r\n    \/\/ print value of variable ch as an int\r\n    std::cout &lt;&lt; ch &lt;&lt; \" has value \" &lt;&lt; static_cast&lt;int&gt;(ch) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\na has value 97\r\n<\/pre>\n<p>It&#8217;s worth noting that the argument to <em>static_cast<\/em> evaluates as an expression.  When we pass in a variable, that variable is evaluated to produce its value, and that value is then converted to the new type.  The variable itself is <em>not<\/em> affected by casting its value to a new type.  In the above case, variable <code>ch<\/code> is still a char, and still holds the same value even after we&#8217;ve cast its value to an <code>int<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Sign conversions using static_cast<\/p>\n<p>Signed integral values can be converted to unsigned integral values, and vice-versa, using a static cast.<\/p>\n<p>If the value being converted can be represented in the destination type, the converted value will remain unchanged (only the type will change).  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    unsigned int u1 { 5 };\r\n    \/\/ Convert value of u1 to a signed int \r\n    int s1 { static_cast&lt;int&gt;(u1) };\r\n    std::cout &lt;&lt; s1 &lt;&lt; '\\n'; \/\/ prints 5\r\n\r\n    int s2 { 5 };\r\n    \/\/ Convert value of s2 to an unsigned int\r\n    unsigned int u2 { static_cast&lt;unsigned int&gt;(s2) };\r\n    std::cout &lt;&lt; u2 &lt;&lt; '\\n'; \/\/ prints 5\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n5\r\n5\r\n<\/pre>\n<p>Since the value <code>5<\/code> is in the range of both a signed int and an unsigned int, the value <code>5<\/code> can be converted to either type without issue.<\/p>\n<p>If the value being converted cannot be represented in the destination type:<\/p>\n<ul>\n<li>If the destination type is unsigned, the value will be modulo wrapped.  We cover modulo wrapping in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/unsigned-integers-and-why-to-avoid-them\/\">4.5 -- Unsigned integers, and why to avoid them<\/a>.\n<\/li>\n<li>If the destination type is signed, the value is implementation-defined prior to C++20, and will be modulo wrapped as of C++20.\n<\/li>\n<\/ul>\n<p>Here&#8217;s an example of converting two values that are not representable in the destination type (assuming 32-bit integers):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int s { -1 };\r\n    std::cout &lt;&lt; static_cast&lt;unsigned int&gt;(s) &lt;&lt; '\\n'; \/\/ prints 4294967295 \r\n\r\n    unsigned int u { 4294967295 }; \/\/ largest 32-bit unsigned int\r\n    std::cout &lt;&lt; static_cast&lt;int&gt;(u) &lt;&lt; '\\n'; \/\/ implementation-defined prior to C++20, -1 as of C++20\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>As of C++20, this produces the result:<\/p>\n<pre>\n4294967295\r\n-1\r\n<\/pre>\n<p>Signed int value <code>-1<\/code> cannot be represented as an unsigned int.  The result modulo wraps to unsigned int value <code>4294967295<\/code>.<\/p>\n<p>Unsigned int value <code>4294967295<\/code> cannot be represented as a signed int.  Prior to C++20, the result is implementation defined (but will probably be <code>-1<\/code>).  As of C++20, the result will modulo wrap to <code>-1<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Converting an unsigned integral value to a signed integral value will result in implementation-defined behavior prior to C++20 if the value being converted can not be represented in the signed type.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">std::int8_t and std::uint8_t likely behave like chars instead of integers<\/p>\n<p>As noted in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/fixed-width-integers-and-size-t\/\">4.6 -- Fixed-width integers and size_t<\/a>, most compilers define and treat <code>std::int8_t<\/code> and <code>std::uint8_t<\/code> (and the corresponding fast and least fixed-width types) identically to types <code>signed char<\/code> and <code>unsigned char<\/code> respectively.  Now that we&#8217;ve covered what chars are, we can demonstrate where this can be problematic:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cstdint&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::int8_t myInt{65};      \/\/ initialize myInt with value 65\r\n    std::cout &lt;&lt; myInt &lt;&lt; '\\n'; \/\/ you're probably expecting this to print 65\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because <code>std::int8_t<\/code> describes itself as an int, you might be tricked into believing that the above program will print the integral value <code>65<\/code>.  However, on most systems, this program will print <code>A<\/code> instead (treating <code>myInt<\/code> as a <code>signed char<\/code>).  However, this is not guaranteed (on some systems, it may actually print <code>65<\/code>).<\/p>\n<p>If you want to ensure that a <code>std::int8_t<\/code> or <code>std::uint8_t<\/code> object is treated as an integer, you can convert the value to an integer using <code>static_cast<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cstdint&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::int8_t myInt{65};\r\n    std::cout &lt;&lt; static_cast&lt;int&gt;(myInt) &lt;&lt; '\\n'; \/\/ will always print 65\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In cases where <code>std::int8_t<\/code> is treated as a char, input from the console can also cause problems:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cstdint&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter a number between 0 and 127: \";\r\n    std::int8_t myInt{};\r\n    std::cin &gt;&gt; myInt;\r\n\r\n    std::cout &lt;&lt; \"You entered: \" &lt;&lt; static_cast&lt;int&gt;(myInt) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>A sample run of this program:<\/p>\n<pre>\nEnter a number between 0 and 127: 35\r\nYou entered: 51\r\n<\/pre>\n<p>Here&#8217;s what&#8217;s happening.  When <code>std::int8_t<\/code> is treated as a char, the input routines interpret our input as a sequence of characters, not as an integer.  So when we enter <code>35<\/code>, we&#8217;re actually entering two chars, <code>'3'<\/code> and <code>'5'<\/code>.  Because a char object can only hold one character, the <code>'3'<\/code> is extracted (the <code>'5'<\/code> is left in the input stream for possible extraction later).  Because the char <code>'3'<\/code> has ASCII code point 51, the value <code>51<\/code> is stored in <code>myInt<\/code>, which we then print later as an int.<\/p>\n<p>In contrast, the other fixed-width types will always print and input as integral values.<\/p>\n<p><p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p><p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p><\/p>\n<p>Write a short program where the user is asked to enter a single character.  Print the value of the character and its ASCII code, using <code>static_cast<\/code>.<\/p>\n<p>The program&#8217;s output should match the following:<\/p>\n<pre>\nEnter a single character: a\r\nYou entered 'a', which has ASCII code 97.\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; \"Enter a single character: \";\r\n\tchar c{};\r\n\tstd::cin &gt;&gt; c;\r\n\tstd::cout &lt;&lt; \"You entered '\" &lt;&lt; c &lt;&lt; \"', which has ASCII code \" &lt;&lt; static_cast&lt;int&gt;(c) &lt;&lt; \".\\n\";\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>Modify the program you wrote for quiz #1 to use implicit type conversion instead of <code>static_cast<\/code>.  How many different ways can you think of to do this?<\/p>\n<p>Note: You should favor explicit conversions over implicit conversions, so don&#8217;t actually do this in real programs -- this is just to test your understanding of where implicit conversions can occur.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p>There are a few easy ways to do this.<\/p>\n<p>First, we can create an <code>int<\/code> variable, and initialize it with our <code>char<\/code> value.  This will do the implicit conversion on initialization.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; \"Enter a single character: \";\r\n\tchar c{};\r\n\tstd::cin &gt;&gt; c;\r\n\r\n\tint ascii{ c };\r\n\tstd::cout &lt;&lt; \"You entered '\" &lt;&lt; c &lt;&lt; \"', which has ASCII code \" &lt;&lt; ascii &lt;&lt; \".\\n\";\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Alternatively, we can use a function to return the <code>char<\/code> value as an <code>int<\/code>.  This will do the implicit conversion at the point of return.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint charAsInt(char c)\r\n{\r\n\treturn c;\r\n}\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; \"Enter a single character: \";\r\n\tchar c{};\r\n\tstd::cin &gt;&gt; c;\r\n\r\n\tstd::cout &lt;&lt; \"You entered '\" &lt;&lt; c &lt;&lt; \"', which has ASCII code \" &lt;&lt; charAsInt(c) &lt;&lt; \".\\n\";\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>We can also use a function and have the implicit conversion happen at the point where the argument is copied into the function parameter:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint getInt(int c)\r\n{\r\n\treturn c;\r\n}\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; \"Enter a single character: \";\r\n\tchar c{};\r\n\tstd::cin &gt;&gt; c;\r\n\r\n\tstd::cout &lt;&lt; \"You entered '\" &lt;&lt; c &lt;&lt; \"', which has ASCII code \" &lt;&lt; getInt(c) &lt;&lt; \".\\n\";\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-4-summary-and-quiz\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">4.x<\/span>Chapter 4 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chars\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">4.11<\/span>Chars\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Implicit type conversion Consider the following program: #include &lt;iostream&gt; void print(double x) \/\/ print takes a double parameter { std::cout &lt;&lt; x &lt;&lt; &#8216;\\n&#8217;; } int main() { print(5); \/\/ what happens when we pass an int value? return 0; } In the above example, the print() function has a &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/11964"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=11964"}],"version-history":[{"count":57,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/11964\/revisions"}],"predecessor-version":[{"id":18234,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/11964\/revisions\/18234"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=11964"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=11964"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=11964"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}