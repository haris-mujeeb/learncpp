{"id":166,"date":"2008-01-04T12:28:57","date_gmt":"2008-01-04T20:28:57","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/112-basic-inheritance-in-c\/"},"modified":"2023-09-11T11:08:30","modified_gmt":"2023-09-11T18:08:30","slug":"basic-inheritance-in-c","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/basic-inheritance-in-c\/","title":{"rendered":"24.2 &#8212; Basic inheritance in C++"},"content":{"rendered":"<p>Now that we&#8217;ve talked about what inheritance is in an abstract sense, let&#8217;s talk about how it&#8217;s used within C++.<\/p>\n<p>Inheritance in C++ takes place between classes.  In an inheritance (is-a) relationship, the class being inherited from is called the <strong>parent class<\/strong>, <strong>base class<\/strong>, or <strong>superclass<\/strong>, and the class doing the inheriting is called the <strong>child class<\/strong>, <strong>derived class<\/strong>, or <strong>subclass<\/strong>.<\/p>\n<p><img src=\"http:\/\/learncpp.com\/images\/CppTutorial\/Section11\/FruitInheritance.gif\"><\/p>\n<p>In the above diagram, Fruit is the parent, and both Apple and Banana are children.<\/p>\n<p><img src=\"http:\/\/learncpp.com\/images\/CppTutorial\/Section11\/ShapesInheritance.gif\"><\/p>\n<p>In this diagram, Triangle is both a child (to Shape) and a parent (to Right Triangle).<\/p>\n<p>A child class inherits both behaviors (member functions) and properties (member variables) from the parent (subject to some access restrictions that we&#8217;ll cover in a future lesson).<br \/>\n These variables and functions become members of the derived class.<\/p>\n<p>Because child classes are full-fledged classes, they can (of course) have their own members that are specific to that class.  We&#8217;ll see an example of this in a moment.<\/p>\n<p><strong>A Person class<\/strong><\/p>\n<p>Here&#8217;s a simple class to represent a generic person:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Person\r\n{\r\n\/\/ In this example, we're making our members public for simplicity\r\npublic: \r\n    std::string m_name{};\r\n    int m_age{};\r\n\r\n    Person(std::string_view name = \"\", int age = 0)\r\n        : m_name{ name }, m_age{ age }\r\n    {\r\n    }\r\n\r\n    const std::string&amp; getName() const { return m_name; }\r\n    int getAge() const { return m_age; }\r\n\r\n};<\/code><\/pre>\n<p>Because this Person class is designed to represent a generic person, we&#8217;ve only defined members that would be common to any type of person.  Every person (regardless of gender, profession, etc&#8230;) has a name and age, so those are represented here.<\/p>\n<p>Note that in this example, we&#8217;ve made all of our variables and functions public.  This is purely for the sake of keeping these examples simple right now.  Normally we would make the variables private.  We will talk about access controls and how those interact with inheritance later in this chapter.<\/p>\n<p><strong>A BaseballPlayer class<\/strong><\/p>\n<p>Let&#8217;s say we wanted to write a program that keeps track of information about some baseball players.  Baseball players need to contain information that is specific to baseball players -- for example, we might want to store a player&#8217;s batting average, and the number of home runs they&#8217;ve hit.<\/p>\n<p>Here&#8217;s our incomplete Baseball player class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class BaseballPlayer\r\n{\r\n\/\/ In this example, we're making our members public for simplicity\r\npublic:\r\n    double m_battingAverage{};\r\n    int m_homeRuns{};\r\n\r\n    BaseballPlayer(double battingAverage = 0.0, int homeRuns = 0)\r\n       : m_battingAverage{battingAverage}, m_homeRuns{homeRuns}\r\n    {\r\n    }\r\n};<\/code><\/pre>\n<p>Now, we also want to keep track of a baseball player&#8217;s name and age, and we already have that information as part of our Person class.<\/p>\n<p>We have three choices for how to add name and age to BaseballPlayer:<\/p>\n<ol start=\"1\">\n<li>Add name and age to the BaseballPlayer class directly as members.  This is probably the worst choice, as we&#8217;re duplicating code that already exists in our Person class.  Any updates to Person will have to be made in BaseballPlayer too.\n<\/li>\n<li>Add Person as a member of BaseballPlayer using composition.  But we have to ask ourselves, &#8220;does a BaseballPlayer have a Person&#8221;?  No, it doesn&#8217;t.  So this isn&#8217;t the right paradigm.\n<\/li>\n<li>Have BaseballPlayer inherit those attributes from Person.  Remember that inheritance represents an is-a relationship.  Is a BaseballPlayer a Person?  Yes, it is.  So inheritance is a good choice here.\n<\/li>\n<\/ol>\n<p><strong>Making BaseballPlayer a derived class<\/strong><\/p>\n<p>To have BaseballPlayer inherit from our Person class, the syntax is fairly simple.  After the <code>class BaseballPlayer<\/code> declaration, we use a colon, the word &#8220;public&#8221;, and the name of the class we wish to inherit.  This is called <em>public inheritance<\/em>.  We&#8217;ll talk more about what public inheritance means in a future lesson.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ BaseballPlayer publicly inheriting Person\r\nclass BaseballPlayer : public Person\r\n{\r\npublic:\r\n    double m_battingAverage{};\r\n    int m_homeRuns{};\r\n\r\n    BaseballPlayer(double battingAverage = 0.0, int homeRuns = 0)\r\n       : m_battingAverage{battingAverage}, m_homeRuns{homeRuns}\r\n    {\r\n    }\r\n};<\/code><\/pre>\n<p>Using a derivation diagram, our inheritance looks like this:<\/p>\n<p><img src=\"http:\/\/www.learncpp.com\/images\/CppTutorial\/Section11\/BaseballPlayerInheritance.gif\"><\/p>\n<p>When BaseballPlayer inherits from Person, BaseballPlayer acquires the member functions and variables from Person.  Additionally, BaseballPlayer defines two members of its own: m_battingAverage and m_homeRuns.  This makes sense, since these properties are specific to a BaseballPlayer, not to any Person.<\/p>\n<p>Thus, BaseballPlayer objects will have 4 member variables: m_battingAverage and m_homeRuns from BaseballPlayer, and m_name and m_age from Person.<\/p>\n<p>This is easy to prove:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Person\r\n{\r\npublic:\r\n    std::string m_name{};\r\n    int m_age{};\r\n\r\n    Person(std::string_view name = \"\", int age = 0)\r\n        : m_name{name}, m_age{age}\r\n    {\r\n    }\r\n\r\n    const std::string&amp; getName() const { return m_name; }\r\n    int getAge() const { return m_age; }\r\n\r\n};\r\n\r\n\/\/ BaseballPlayer publicly inheriting Person\r\nclass BaseballPlayer : public Person\r\n{\r\npublic:\r\n    double m_battingAverage{};\r\n    int m_homeRuns{};\r\n\r\n    BaseballPlayer(double battingAverage = 0.0, int homeRuns = 0)\r\n       : m_battingAverage{battingAverage}, m_homeRuns{homeRuns}\r\n    {\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    \/\/ Create a new BaseballPlayer object\r\n    BaseballPlayer joe{};\r\n    \/\/ Assign it a name (we can do this directly because m_name is public)\r\n    joe.m_name = \"Joe\";\r\n    \/\/ Print out the name\r\n    std::cout &lt;&lt; joe.getName() &lt;&lt; '\\n'; \/\/ use the getName() function we've acquired from the Person base class\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Which prints the value:<\/p>\n<pre>\r\nJoe\r\n<\/pre>\n<p>This compiles and runs because joe is a BaseballPlayer, and all BaseballPlayer objects have a m_name member variable and a getName() member function inherited from the Person class.<\/p>\n<p><strong>An Employee derived class<\/strong><\/p>\n<p>Now let&#8217;s write another class that also inherits from Person.  This time, we&#8217;ll write an Employee class.  An employee &#8220;is a&#8221; person, so using inheritance is appropriate:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Employee publicly inherits from Person\r\nclass Employee: public Person\r\n{\r\npublic:\r\n    double m_hourlySalary{};\r\n    long m_employeeID{};\r\n\r\n    Employee(double hourlySalary = 0.0, long employeeID = 0)\r\n        : m_hourlySalary{hourlySalary}, m_employeeID{employeeID}\r\n    {\r\n    }\r\n\r\n    void printNameAndSalary() const\r\n    {\r\n        std::cout &lt;&lt; m_name &lt;&lt; \": \" &lt;&lt; m_hourlySalary &lt;&lt; '\\n';\r\n    }\r\n};<\/code><\/pre>\n<p>Employee inherits m_name and m_age from Person (as well as the two access functions), and adds two more member variables and a member function of its own.  Note that printNameAndSalary() uses variables both from the class it belongs to (Employee::m_hourlySalary) and the parent class (Person::m_name).<\/p>\n<p>This gives us a derivation chart that looks like this:<\/p>\n<p><img src=\"http:\/\/www.learncpp.com\/images\/CppTutorial\/Section11\/EmployeeInheritance.gif\"><\/p>\n<p>Note that Employee and BaseballPlayer don&#8217;t have any direct relationship, even though they both inherit from Person.<\/p>\n<p>Here&#8217;s a full example using Employee:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Person\r\n{\r\npublic:\r\n    std::string m_name{};\r\n    int m_age{};\r\n\r\n    Person(std::string_view name = \"\", int age = 0)\r\n        : m_name{name}, m_age{age}\r\n    {\r\n    }\r\n\r\n    const std::string&amp; getName() const { return m_name; }\r\n    int getAge() const { return m_age; }\r\n\r\n};\r\n\r\n\/\/ Employee publicly inherits from Person\r\nclass Employee: public Person\r\n{\r\npublic:\r\n    double m_hourlySalary{};\r\n    long m_employeeID{};\r\n\r\n    Employee(double hourlySalary = 0.0, long employeeID = 0)\r\n        : m_hourlySalary{hourlySalary}, m_employeeID{employeeID}\r\n    {\r\n    }\r\n\r\n    void printNameAndSalary() const\r\n    {\r\n        std::cout &lt;&lt; m_name &lt;&lt; \": \" &lt;&lt; m_hourlySalary &lt;&lt; '\\n';\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Employee frank{20.25, 12345};\r\n    frank.m_name = \"Frank\"; \/\/ we can do this because m_name is public\r\n\r\n    frank.printNameAndSalary();\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\nFrank: 20.25\r\n<\/pre>\n<p><strong>Inheritance chains<\/strong><\/p>\n<p>It&#8217;s possible to inherit from a class that is itself derived from another class.  There is nothing noteworthy or special when doing so -- everything proceeds as in the examples above.<\/p>\n<p>For example, let&#8217;s write a Supervisor class.  A Supervisor is an Employee, which is a Person.  We&#8217;ve already written an Employee class, so let&#8217;s use that as the base class from which to derive Supervisor:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Supervisor: public Employee\r\n{\r\npublic:\r\n    \/\/ This Supervisor can oversee a max of 5 employees\r\n    long m_overseesIDs[5]{};\r\n};<\/code><\/pre>\n<p>Now our derivation chart looks like this:<\/p>\n<p><img src=\"http:\/\/www.learncpp.com\/images\/CppTutorial\/Section11\/SupervisorInheritance.gif\"><\/p>\n<p>All Supervisor objects inherit the functions and variables from both Employee and Person, and add their own m_overseesIDs member variable.  <\/p>\n<p>By constructing such inheritance chains, we can create a set of reusable classes that are very general (at the top) and become progressively more specific at each level of inheritance.<\/p>\n<p><strong>Why is this kind of inheritance useful?<\/strong><\/p>\n<p>Inheriting from a base class means we don&#8217;t have to redefine the information from the base class in our derived classes.  We automatically receive the member functions and member variables of the base class through inheritance, and then simply add the additional functions or member variables we want.  This not only saves work, but also means that if we ever update or modify the base class (e.g. add new functions, or fix a bug), all of our derived classes will automatically inherit the changes!<\/p>\n<p>For example, if we ever added a new function to Person, then Employee, Supervisor, and BaseballPlayer would automatically gain access to it.  If we added a new variable to Employee, then Supervisor would also gain access to it.  This allows us to construct new classes in an easy, intuitive, and low-maintenance way!<\/p>\n<p><strong>Conclusion<\/strong><\/p>\n<p>Inheritance allows us to reuse classes by having other classes inherit their members.  In future lessons, we&#8217;ll continue to explore how this works.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/order-of-construction-of-derived-classes\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">24.3<\/span>Order of construction of derived classes\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-inheritance\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">24.1<\/span>Introduction to inheritance\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Now that we&#8217;ve talked about what inheritance is in an abstract sense, let&#8217;s talk about how it&#8217;s used within C++. Inheritance in C++ takes place between classes. In an inheritance (is-a) relationship, the class being inherited from is called the parent class, base class, or superclass, and the class doing &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/166"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=166"}],"version-history":[{"count":26,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/166\/revisions"}],"predecessor-version":[{"id":15268,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/166\/revisions\/15268"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=166"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=166"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=166"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}