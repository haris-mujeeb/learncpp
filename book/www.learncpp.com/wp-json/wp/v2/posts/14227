{"id":14227,"date":"2023-03-30T13:02:10","date_gmt":"2023-03-30T20:02:10","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=14227"},"modified":"2024-09-13T10:30:17","modified_gmt":"2024-09-13T17:30:17","slug":"chapter-21-project","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-21-project\/","title":{"rendered":"21.y &#8212; Chapter 21 project"},"content":{"rendered":"<p>A tip o&#8217; the hat to reader Avtem for conceiving of and collaborating on this project.<\/p>\n<p class=\"cpp-section\">Project time<\/p>\n<p>Let&#8217;s implement the classic game <a href=\"https:\/\/en.wikipedia.org\/wiki\/15_puzzle\">15 Puzzle<\/a>!  <\/p>\n<p>In 15 Puzzle, you begin with a randomized 4&#215;4 grid of tiles.  15 of the tiles have numbers 1 through 15.  One tile is missing.<\/p>\n<p>For example:<\/p>\n<pre>\n     15   1   4\r\n  2   5   9  12\r\n  7   8  11  14\r\n 10  13   6   3\r\n<\/pre>\n<p>In this puzzle, the missing tile is in the upper-left corner.<\/p>\n<p>Each turn of the game, you pick one of the tiles that is adjacent to the missing tile, and slide it into the spot occupied by the missing tile.<\/p>\n<p>The goal of the game is to slide tiles around until they are in numerical order, with the missing tile in the bottom right corner:<\/p>\n<pre>\n  1   2   3   4\r\n  5   6   7   8\r\n  9  10  11  12\r\n 13  14  15   \r\n<\/pre>\n<p>You can play a few rounds <a href=\"https:\/\/15puzzle.netlify.app\/\">on this site<\/a>. It will help you to understand how this game works and how it should be implemented.<\/p>\n<p>In our version of the game, each turn the user will enter a single letter command.  There are 5 valid commands:<\/p>\n<ul>\n<li>w - slide tile up\n<\/li>\n<li>a - slide tile left\n<\/li>\n<li>s - slide tile down\n<\/li>\n<li>d - slide tile right\n<\/li>\n<li>q - quit game\n<\/li>\n<\/ul>\n<p>Because this is going to be a longer program, we&#8217;ll develop it in stages.<\/p>\n<p>One more thing: at each step, we&#8217;ll present two things: a <em>goal<\/em> and <em>tasks<\/em>.  The goal defines the outcome that the step is trying to achieve, along with any additional relevant information.  The tasks provide detail and hints about how to implement the goal.<\/p>\n<p>The tasks will initially be hidden from view, to encourage you to see if you can complete each step using just the goal and sample output or sample program.  If you are unsure how to start, or are feeling stuck, you can unhide the tasks.  They should help get you moving forward.<\/p>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #1<\/p>\n<p>Because this is going to be a bigger program, let&#8217;s start with a design exercise.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>If you don&#8217;t have much experience designing programs up-front, you may find this a bit difficult.  That&#8217;s expected.  It&#8217;s less important that you get it right, and more important that you participate and learn.<\/p>\n<p>We will go into more detail on all of these items in subsequent steps, so if you are feeling completely lost, feel free to skip this step.\n<\/p><\/div>\n<p>Goal: Document the key requirements for this program, and plan how your program will be structured at a high level.  We will do this in three parts.<\/p>\n<p>A) What are the top-level things that your program needs to do?  Here are a few to get you started:<\/p>\n<p>Board things:<\/p>\n<ul>\n<li>Display the game board\n<\/li>\n<li>&#8230;\n<\/li>\n<\/ul>\n<p>User things:<\/p>\n<ul>\n<li>Get commands from user\n<\/li>\n<li>&#8230;\n<\/li>\n<\/ul>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>Board things:<\/p>\n<ul>\n<li>Display the game board\n<\/li>\n<li>Display an individual tile\n<\/li>\n<li>Randomize the starting state\n<\/li>\n<li>Slide tiles\n<\/li>\n<li>Determine if win condition reached\n<\/li>\n<\/ul>\n<p>User things:<\/p>\n<ul>\n<li>Get commands from user\n<\/li>\n<li>Handle invalid input\n<\/li>\n<li>Allow the user to quit before winning\n<\/li>\n<\/ul>\n<\/div>\n<p>B) What primary classes or namespaces will you use to implement the items outlined in Step 1?  Also, what will your main() function do?<\/p>\n<p>You can create a diagram, or use two tables like this:<\/p>\n<div class=\"cpp-table-wrapper\">\n<table class=\"cpp-table\">\n<tr>\n<th> Primary class\/namespace\/main <\/th>\n<th> Implements top-level items <\/th>\n<th> Members <\/th>\n<\/tr>\n<tr>\n<td> class Board <\/td>\n<td> Display the game board<br \/>&#8230; <\/td>\n<td> &#8230; <\/td>\n<\/tr>\n<tr>\n<td> function main <\/td>\n<td> Main game logic loop<br \/>&#8230; <\/td>\n<td> &#8230; <\/td>\n<\/tr>\n<\/table>\n<\/div>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<div class=\"cpp-table-wrapper\">\n<table class=\"cpp-table\">\n<tr>\n<th> Primary class\/Namespace\/main <\/th>\n<th> Implements top-level items <\/th>\n<th> Members (type) <\/th>\n<\/tr>\n<tr>\n<td> class Board <\/td>\n<td> Display the game board<br \/>Randomize the starting state<br \/>Slide tiles<br \/>Determine if win condition reached <\/td>\n<td> 2d array of Tile <\/td>\n<\/tr>\n<tr>\n<td> class Tile <\/td>\n<td> Display an individual tile <\/td>\n<td> int display number <\/td>\n<\/tr>\n<tr>\n<td> namespace UserInput <\/td>\n<td> Get commands from user<br \/>Handle invalid input <\/td>\n<td> none <\/td>\n<\/tr>\n<tr>\n<td> function main() <\/td>\n<td> Main game logic loop<br \/>Allow user to quit before winning <\/td>\n<td> none <\/td>\n<\/tr>\n<\/table>\n<\/div>\n<p>\nHere is some rationale behind the choices above.<\/p>\n<ul>\n<li><code>class Board<\/code>: Our game is a 4&#215;4 grid of tiles.  The main purpose of this class is to store and manage the 2-dimensional array of tiles. This class is also responsible for randomizing, moving tiles, displaying the board, and checking whether our board is solved.\n<\/li>\n<li><code>class Tile<\/code>: This class represents a single tile within the game board.  Using a class here allows us to overload the output operator to output a tile in the format we desire.  It also allows us to have well-named member functions that will increase the readability of code related to a single tile.\n<\/li>\n<li><code>namespace UserInput<\/code>: This namespace has functions to get input from the user, to check whether the user input is valid, and to handle invalid input.  Because this doesn&#8217;t have any state, we don&#8217;t need a class here.\n<\/li>\n<li><code>function main()<\/code>: This is where our main game loop will be written.  This will handle setup of the game board, coordinate retrieving user input and command processing, and handle exit conditions (when the user wins or enters the quit command).\n<\/li>\n<\/ul>\n<p>We also will make use of two helper classes.  The need for these classes may not be obvious at first glance, so don&#8217;t worry if you didn&#8217;t come up with anything similar.  Often the need for (or benefit of) helper classes isn&#8217;t apparent into you get further into the implementation of your program.<\/p>\n<\/div>\n<p>C) (extra credit) Can you think of any helper classes or capabilities that will make implementing the above easier or more cohesive?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<div class=\"cpp-table-wrapper\">\n<table class=\"cpp-table\">\n<tr>\n<th> Helper class\/Namespace <\/th>\n<th> What does this help with? <\/th>\n<th> Members (type) <\/th>\n<\/tr>\n<tr>\n<td> class Point <\/td>\n<td> Indexing the game board tiles <\/td>\n<td> int x-axis and y-axis coordinates <\/td>\n<\/tr>\n<tr>\n<td> class Direction <\/td>\n<td> Make working with Directional commands easier and more intuitive  <\/td>\n<td> enum direction <\/td>\n<\/tr>\n<\/table>\n<\/div>\n<ul>\n<li><code>class Point<\/code>: Accessing a specific tile in our 2d array of tiles will require 2 indices.  We can think of these as { x-axis, y-axis } index pairs.  This Point class implements such an index pair, to make it easy to pass or return a pair of indices.\n<\/li>\n<li><code>class Direction<\/code>: The user will be entering single-letter (char) commands on the keyboard to slide tiles in cardinal directions (e.g. <code>'w'<\/code>=up, <code>'a'<\/code>=left).  Converting these char commands into a Direction object (representing a cardinal direction) will make our code more intuitive and prevent our code from being littered with char literals (<code>Direction::left<\/code> is more meaningful than <code>'a'<\/code>).\n<\/li>\n<\/ul>\n<\/div>\n<p>If you had a hard time with this exercise, that&#8217;s okay.  The goal here was mainly to get you thinking about what you&#8217;re going to do before you start doing it.<\/p>\n<p>Now, it&#8217;s time to get implementing!<\/p>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #2<\/p>\n<p>Goal: Be able to display individual tiles on the screen.<\/p>\n<p>Our game board is a 4&#215;4 grid of tiles that can slide around.  Therefore, it will be useful to have a <code>Tile<\/code> class that represents one of the numbered tiles on our 4&#215;4 grid or the missing tile.  Each tile should be able to:<\/p>\n<ul>\n<li>Be given a number or be set as the missing tile\n<\/li>\n<li>Determine whether it is the missing tile.\n<\/li>\n<li>Draw to the console with the appropriate spacing (so the tiles will line up when the board is displayed).  See the sample output below for an example indicating how tiles should be spaced.\n<\/li>\n<\/ul>\n<p><a class=\"tasks_link_show\" href=\"javascript:void(0)\" onclick=\"cppTasksToggle(document.getElementById('cpp_tasks_id_0'), this, 'Show Tasks', 'Hide Tasks')\">Show Tasks<\/a><\/p>\n<div class=\"wptasks\" id=\"cpp_tasks_id_0\" style=\"display:none\">\n<p>Our <code>Tile<\/code> class should have this functionality:<\/p>\n<ul>\n<li>A default constructor.\n<\/li>\n<li>A constructor that lets us create a Tile with a display value.  Because we are not using <code>0<\/code> as a display value, we can use value <code>0<\/code> to identify our missing tile.\n<\/li>\n<li>A <code>getNum()<\/code> access function that returns the value held by the tile.\n<\/li>\n<li>An <code>isEmpty()<\/code> member function that returns a bool indicating whether the current tile is the missing tile.\n<\/li>\n<li>An overloaded <code>operator&lt;&lt;<\/code> that will display the value held by the tile.\n<\/li>\n<\/ul>\n<\/div>\n<p>The following code should compile and produce the output result you can see below the code:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    Tile tile1{ 10 };\r\n    Tile tile2{ 8 };\r\n    Tile tile3{ 0 }; \/\/ the missing tile\r\n    Tile tile4{ 1 };\r\n\r\n    std::cout &lt;&lt; \"0123456789ABCDEF\\n\"; \/\/ to make it easy to see how many spaces are in the next line\r\n    std::cout &lt;&lt; tile1 &lt;&lt; tile2 &lt;&lt; tile3 &lt;&lt; tile4 &lt;&lt; '\\n';\r\n    \r\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; tile1.isEmpty() &lt;&lt; ' ' &lt;&lt; tile3.isEmpty() &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"Tile 2 has number: \" &lt;&lt; tile2.getNum() &lt;&lt; \"\\nTile 4 has number: \" &lt;&lt; tile4.getNum() &lt;&lt; '\\n';\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>Expected output (pay attention to the white spaces):<\/p>\n<pre>\n0123456789ABCDEF\r\n 10   8       1 \r\nfalse true\r\nTile 2 has number: 8\r\nTile 4 has number: 1\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Tile\r\n{\r\npublic:\r\n    Tile() = default;\r\n    explicit Tile(int number)\r\n        :m_num(number)\r\n    {\r\n    }\r\n\r\n    bool isEmpty() const\r\n    {\r\n        return m_num == 0;\r\n    }\r\n\r\n    int getNum() const { return m_num; }\r\n\r\nprivate:\r\n    int m_num { 0 };\r\n};\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, Tile tile)\r\n{\r\n    if (tile.getNum() &gt; 9) \/\/ if two digit number\r\n        stream &lt;&lt; \" \" &lt;&lt; tile.getNum() &lt;&lt; \" \";\r\n    else if (tile.getNum() &gt; 0) \/\/ if one digit number\r\n        stream &lt;&lt; \"  \" &lt;&lt; tile.getNum() &lt;&lt; \" \";\r\n    else if (tile.getNum() == 0) \/\/ if empty spot\r\n        stream &lt;&lt; \"    \";\r\n    return stream;\r\n}\r\n\r\nint main()\r\n{\r\n    Tile tile1{ 10 };\r\n    Tile tile2{ 8 };\r\n    Tile tile3{ 0 }; \/\/ the missing tile\r\n    Tile tile4{ 1 };\r\n\r\n    std::cout &lt;&lt; \"0123456789ABCDEF\\n\"; \/\/ to make it easy to see how many spaces are in the next line\r\n    std::cout &lt;&lt; tile1 &lt;&lt; tile2 &lt;&lt; tile3 &lt;&lt; tile4 &lt;&lt; '\\n';\r\n\r\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; tile1.isEmpty() &lt;&lt; ' ' &lt;&lt; tile3.isEmpty() &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"Tile 2 has number: \" &lt;&lt; tile2.getNum() &lt;&lt; \"\\nTile 4 has number: \" &lt;&lt; tile4.getNum() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #3<\/p>\n<p>Goal: Create a solved board (4&#215;4 grid of tiles) and display it on the screen.<\/p>\n<p>Define a <code>Board<\/code> class that will represent 4&#215;4 grid of tiles. A newly created <code>Board<\/code> object should be in the solved state.  To display the board, first print <code>g_consoleLines<\/code> (defined in code snippet below) empty lines and then print the board itself.  Doing so will ensure that any prior output is pushed out of view so that only the current board is visible on the console.<\/p>\n<p>Why initiate the board in the solved state?  When you buy a physical version of these puzzles, the puzzles typically start in the solved state -- you have to manually mix them up (by sliding tiles around) before trying to solve them.  We will mimic that process in our program (we&#8217;ll do the mixing up in a future step).<\/p>\n<p><a class=\"tasks_link_show\" href=\"javascript:void(0)\" onclick=\"cppTasksToggle(document.getElementById('cpp_tasks_id_1'), this, 'Show Tasks', 'Hide Tasks')\">Show Tasks<\/a><\/p>\n<div class=\"wptasks\" id=\"cpp_tasks_id_1\" style=\"display:none\">\n<p>The <code>Board<\/code> class should have the following functionality:<\/p>\n<ul>\n<li>A <code>constexpr<\/code> symbolic constant, set to the size of the grid (you can assume the grid is square).\n<\/li>\n<li>A two-dimentional array of <code>Tile<\/code> objects, which will hold our 16 numbers.  These should start in the solved state.\n<\/li>\n<li>A default constructor.\n<\/li>\n<li>An overloaded <code>operator&lt;&lt;<\/code> which will print N blank lines (where N = the value of <code>g_consoleLines<\/code>) and then draw the board to the console.\n<\/li>\n<\/ul>\n<\/div>\n<p>The following program should run:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Increase amount of new lines if your board isn't\r\n\/\/ at the very bottom of the console\r\nconstexpr int g_consoleLines{ 25 };\r\n\r\n\/\/ Your code goes here\r\n\r\nint main()\r\n{\r\n    Board board{};\r\n    std::cout &lt;&lt; board;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>and output the following:<\/p>\n<pre>\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  1   2   3   4\r\n  5   6   7   8\r\n  9  10  11  12\r\n 13  14  15\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ Increase amount of new lines if your board isn't\r\n\/\/ at the very bottom of the console\r\nconstexpr int g_consoleLines{ 25 };\r\n\r\nclass Tile\r\n{\r\npublic:\r\n    Tile() = default;\r\n    explicit Tile(int number)\r\n        :m_num(number)\r\n    {\r\n    }\r\n    \r\n    bool isEmpty() const\r\n    {\r\n        return m_num == 0;\r\n    }\r\n\r\n    int getNum() const { return m_num; }\r\n\r\nprivate:\r\n    int m_num { 0 };\r\n};\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, Tile tile)\r\n{\r\n    if (tile.getNum() &gt; 9) \/\/ if two digit number\r\n        stream &lt;&lt; \" \" &lt;&lt; tile.getNum() &lt;&lt; \" \";\r\n    else if (tile.getNum() &gt; 0) \/\/ if one digit number\r\n        stream &lt;&lt; \"  \" &lt;&lt; tile.getNum() &lt;&lt; \" \";\r\n    else if (tile.getNum() == 0) \/\/ if empty spot\r\n        stream &lt;&lt; \"    \";\r\n    return stream;\r\n}\r\n\r\nclass Board\r\n{\r\npublic:\r\n\r\n    Board() = default;\r\n\r\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const Board&amp; board)\r\n    {\r\n        \/\/ Before drawing always print some empty lines\r\n        \/\/ so that only one board appears at a time\r\n        \/\/ and it's always shown at the bottom of the window\r\n        \/\/ because console window scrolls automatically when there is no\r\n        \/\/ enough space. \r\n        for (int i = 0; i &lt; g_consoleLines; ++i)\r\n            std::cout &lt;&lt; '\\n';\r\n\r\n        for (int y = 0; y &lt; s_size; ++y)\r\n        {\r\n            for (int x = 0; x &lt; s_size; ++x)\r\n                stream &lt;&lt; board.m_tiles[y][x];\r\n            stream &lt;&lt; '\\n';\r\n        }\r\n\r\n        return stream;\r\n    }\r\n\r\nprivate:\r\n    static constexpr int s_size { 4 };\r\n    Tile m_tiles[s_size][s_size]{\r\n        Tile{ 1 }, Tile { 2 }, Tile { 3 } , Tile { 4 },\r\n        Tile { 5 } , Tile { 6 }, Tile { 7 }, Tile { 8 },\r\n        Tile { 9 }, Tile { 10 }, Tile { 11 }, Tile { 12 },\r\n        Tile { 13 }, Tile { 14 }, Tile { 15 }, Tile { 0 } };\r\n};\r\n\r\nint main()\r\n{\r\n    Board board{};\r\n    std::cout &lt;&lt; board;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #4<\/p>\n<p>Goal: In this step, we&#8217;ll allow the user to repeatedly input game commands, handle invalid input, and implement the quit game command.<\/p>\n<p>These are the 5 commands our game will support (each of which will be input as a single character):<\/p>\n<ul>\n<li>&#8216;w&#8217; - slide tile up\n<\/li>\n<li>&#8216;a&#8217; - slide tile left\n<\/li>\n<li>&#8216;s&#8217; - slide tile down\n<\/li>\n<li>&#8216;d&#8217; - slide tile right\n<\/li>\n<li>&#8216;q&#8217; - quit game\n<\/li>\n<\/ul>\n<p>When the user runs the game, the following should occur:<\/p>\n<ul>\n<li>The (solved) board should be printed to the console.\n<\/li>\n<li>The program should repeatedly get valid game commands from the user.  If the user enters an invalid command or extraneous input, ignore it.\n<\/li>\n<\/ul>\n<p>For each valid game command:<\/p>\n<ul>\n<li>Print <code>\"Valid command: \"<\/code> and the character the user input.\n<\/li>\n<li>If the command is the quit command, also print <code>\"\\n\\nBye!\\n\\n\"<\/code> and then quit the app.\n<\/li>\n<\/ul>\n<p>Because our user input routines do not need to maintain any state, implement them inside a namespace named <code>UserInput<\/code>.<\/p>\n<p><a class=\"tasks_link_show\" href=\"javascript:void(0)\" onclick=\"cppTasksToggle(document.getElementById('cpp_tasks_id_2'), this, 'Show Tasks', 'Hide Tasks')\">Show Tasks<\/a><\/p>\n<div class=\"wptasks\" id=\"cpp_tasks_id_2\" style=\"display:none\">\n<p>Implement the <code>UserInput<\/code> namespace:<\/p>\n<ul>\n<li>Create a function named <code>getCommandFromUser()<\/code>.  Read in a single character from the user.  If the character is not a valid game command, clear any additional extraneous input, and read in another character from the user.  Repeat until a valid game command is entered.  Return the valid command to the caller.\n<\/li>\n<li>Create as many helper functions as you need.\n<\/li>\n<\/ul>\n<p>In main():<\/p>\n<ul>\n<li>Implement an infinite loop.  Inside the loop, fetch a valid game command, and then handle the commands per the above requirements.\n<\/li>\n<\/ul>\n<\/div>\n<p>The output of the program should match the following:<\/p>\n<pre>\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  1   2   3   4\r\n  5   6   7   8\r\n  9  10  11  12\r\n 13  14  15\r\nw\r\nValid command: w\r\na\r\nValid command: a\r\ns\r\nValid command: s\r\nd\r\nValid command: d\r\nf\r\ng\r\nh\r\nValid command: q\r\n\r\n\r\nBye!\r\n\r\n\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_5'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_5\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;limits&gt;\r\n\r\n\/\/ Increase amount of new lines if your board isn't\r\n\/\/ at the very bottom of the console\r\nconstexpr int g_consoleLines{ 25 };\r\n\r\nnamespace UserInput\r\n{\r\n    bool isValidCommand(char ch)\r\n    {\r\n        return ch == 'w'\r\n            || ch == 'a'\r\n            || ch == 's'\r\n            || ch == 'd'\r\n            || ch == 'q';\r\n    }\r\n\r\n    void ignoreLine()\r\n    {\r\n        std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\r\n    }\r\n\r\n    char getCharacter()\r\n    {\r\n        char operation{};\r\n        std::cin &gt;&gt; operation;\r\n        ignoreLine(); \/\/ remove any extraneous input\r\n        return operation;\r\n    }\r\n\r\n    char getCommandFromUser()\r\n    {\r\n        char ch{};\r\n        while (!isValidCommand(ch))\r\n            ch = getCharacter();\r\n\r\n        return ch;\r\n    }\r\n};\r\n\r\nclass Tile\r\n{\r\npublic:\r\n    Tile() = default;\r\n    explicit Tile(int number)\r\n        :m_num(number)\r\n    {\r\n    }\r\n    \r\n    bool isEmpty() const\r\n    {\r\n        return m_num == 0;\r\n    }\r\n\r\n    int getNum() const { return m_num; }\r\n\r\nprivate:\r\n    int m_num { 0 };\r\n};\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, Tile tile)\r\n{\r\n    if (tile.getNum() &gt; 9) \/\/ if two digit number\r\n        stream &lt;&lt; \" \" &lt;&lt; tile.getNum() &lt;&lt; \" \";\r\n    else if (tile.getNum() &gt; 0) \/\/ if one digit number\r\n        stream &lt;&lt; \"  \" &lt;&lt; tile.getNum() &lt;&lt; \" \";\r\n    else if (tile.getNum() == 0) \/\/ if empty spot\r\n        stream &lt;&lt; \"    \";\r\n    return stream;\r\n}\r\n\r\nclass Board\r\n{\r\npublic:\r\n\r\n    Board() = default;\r\n\r\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const Board&amp; board)\r\n    {\r\n        \/\/ Before drawing always print some empty lines\r\n        \/\/ so that only one board appears at a time\r\n        \/\/ and it's always shown at the bottom of the window\r\n        \/\/ because console window scrolls automatically when there is no\r\n        \/\/ enough space. \r\n        for (int i = 0; i &lt; g_consoleLines; ++i)\r\n            std::cout &lt;&lt; '\\n';\r\n\r\n        for (int y = 0; y &lt; s_size; ++y)\r\n        {\r\n            for (int x = 0; x &lt; s_size; ++x)\r\n                stream &lt;&lt; board.m_tiles[y][x];\r\n            stream &lt;&lt; '\\n';\r\n        }\r\n\r\n        return stream;\r\n    }\r\n\r\nprivate:\r\n    static constexpr int s_size { 4 };\r\n    Tile m_tiles[s_size][s_size]{\r\n        Tile{ 1 }, Tile { 2 }, Tile { 3 } , Tile { 4 },\r\n        Tile { 5 } , Tile { 6 }, Tile { 7 }, Tile { 8 },\r\n        Tile { 9 }, Tile { 10 }, Tile { 11 }, Tile { 12 },\r\n        Tile { 13 }, Tile { 14 }, Tile { 15 }, Tile { 0 } };\r\n};\r\n\r\nint main()\r\n{\r\n    Board board{};\r\n    std::cout &lt;&lt; board;\r\n\r\n    while (true)\r\n    {\r\n        char ch{ UserInput::getCommandFromUser() };\r\n\r\n        \/\/ If we reach the line below, \"ch\" will ALWAYS be a correct command!\r\n        std::cout &lt;&lt; \"Valid command: \" &lt;&lt; ch &lt;&lt; '\\n';\r\n        \r\n        \/\/ Handle non-direction commands\r\n        if (ch == 'q')\r\n        {\r\n            std::cout &lt;&lt; \"\\n\\nBye!\\n\\n\";\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #5<\/p>\n<p>Goal: Implement a helper class that will make it easier for us to handle directional commands.<\/p>\n<p>After implementing the prior step, we can accept commands from the user (as characters &#8216;w&#8217;, &#8216;a&#8217;, &#8216;s&#8217;, &#8216;d&#8217;, and &#8216;q&#8217;).  These characters are essentially magic numbers in our code.  While it&#8217;s fine to handle these commands in our <code>UserInput<\/code> namespace and function <code>main()<\/code>, we don&#8217;t want to propagate them throughout our whole program.  For example, the <code>Board<\/code> class should have no knowledge of what &#8216;s&#8217; means.<\/p>\n<p>Implement a helper class named <code>Direction<\/code>, which will allow us to create objects that represent the cardinal directions (up, left, down, or right).  <code>operator-<\/code> should return the opposite direction, and <code>operator&lt;&lt;<\/code> should print the direction to the console.  We will also need a member function that will return a Direction object containing a random direction. Lastly, add a function to namespace <code>UserInput<\/code> that converts a directional game command (&#8216;w&#8217;, &#8216;a&#8217;, &#8216;s&#8217;, or &#8216;d&#8217;) to a Direction object.<\/p>\n<p>The more we can use <code>Direction<\/code> instead of directional game commands, the easier our code will be to read and understand.<\/p>\n<p><a class=\"tasks_link_show\" href=\"javascript:void(0)\" onclick=\"cppTasksToggle(document.getElementById('cpp_tasks_id_3'), this, 'Show Tasks', 'Hide Tasks')\">Show Tasks<\/a><\/p>\n<div class=\"wptasks\" id=\"cpp_tasks_id_3\" style=\"display:none\">\n<p>Implement the class <code>Direction<\/code>, which has:<\/p>\n<ul>\n<li>A public nested enum named <code>Type<\/code> with enumerators <code>up<\/code>, <code>down<\/code>, <code>left<\/code>, <code>right<\/code>, and <code>maxDirections<\/code>.\n<\/li>\n<li>A private member that stores the actual direction.\n<\/li>\n<li>A single argument constructor which allows us to initialize a <code>Direction<\/code> with a <code>Type<\/code> initializer.\n<\/li>\n<li>An overloaded <code>operator-<\/code>, which takes a Direction and returns the opposite Direction.\n<\/li>\n<li>An overloaded <code>operator&lt;&lt;<\/code>, which outputs the Direction name to the console.\n<\/li>\n<li>A static function that returns a Direction with a randomized <code>Type<\/code>.  You can use the <code>Random::get()<\/code> function from the <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/global-random-numbers-random-h\/\">&#8220;Random.h&#8221;<\/a> header to generate a random number.\n<\/li>\n<\/ul>\n<p>Also, in the <code>UserInput<\/code> namespace, add the following:<\/p>\n<ul>\n<li>A function that will convert a directional game command (character) to a Direction object.\n<\/li>\n<\/ul>\n<\/div>\n<p>Finally, modify the program you wrote in the prior step so that the output matches the following:<\/p>\n<pre>\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n  1   2   3   4\r\n  5   6   7   8\r\n  9  10  11  12\r\n 13  14  15\r\nGenerating random direction... up\r\nGenerating random direction... down\r\nGenerating random direction... up\r\nGenerating random direction... left\r\n\r\nEnter a command: w\r\nYou entered direction: up\r\na\r\nYou entered direction: left\r\ns\r\nYou entered direction: down\r\nd\r\nYou entered direction: right\r\nq\r\n\r\n\r\nBye!\r\n\r\n\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_6'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_6\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;limits&gt;\r\n#include \"Random.h\"\r\n\r\n\/\/ Increase amount of new lines if your board isn't\r\n\/\/ at the very bottom of the console\r\nconstexpr int g_consoleLines{ 25 };\r\n\r\nclass Direction\r\n{\r\npublic:\r\n    enum Type\r\n    {\r\n        up,\r\n        down,\r\n        left,\r\n        right,\r\n        maxDirections,\r\n    };\r\n\r\n    Direction(Type type)\r\n        :m_type(type)\r\n    {\r\n    }\r\n\r\n    Type getType() const\r\n    {\r\n        return m_type;\r\n    }\r\n\r\n    Direction operator-() const\r\n    {\r\n        switch (m_type)\r\n        {\r\n        case up:    return Direction{ down };\r\n        case down:  return Direction{ up };\r\n        case left:  return Direction{ right };\r\n        case right: return Direction{ left };\r\n        default:    break;\r\n        }\r\n\r\n        assert(0 &amp;&amp; \"Unsupported direction was passed!\");\r\n        return Direction{ up };\r\n    }\r\n \r\n    static Direction getRandomDirection()\r\n    {\r\n        Type random{ static_cast&lt;Type&gt;(Random::get(0, Type::maxDirections - 1)) };\r\n        return Direction{ random };\r\n    }\r\n\r\nprivate:\r\n    Type m_type{};\r\n};\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, Direction dir)\r\n{\r\n    switch (dir.getType())\r\n    {\r\n    case Direction::up:     return (stream &lt;&lt; \"up\");\r\n    case Direction::down:   return (stream &lt;&lt; \"down\");\r\n    case Direction::left:   return (stream &lt;&lt; \"left\");\r\n    case Direction::right:  return (stream &lt;&lt; \"right\");\r\n    default:                break;\r\n    }\r\n\r\n    assert(0 &amp;&amp; \"Unsupported direction was passed!\");\r\n    return (stream &lt;&lt; \"unknown direction\");\r\n}\r\n\r\nnamespace UserInput\r\n{\r\n    bool isValidCommand(char ch)\r\n    {\r\n        return ch == 'w'\r\n            || ch == 'a'\r\n            || ch == 's'\r\n            || ch == 'd'\r\n            || ch == 'q';\r\n    }\r\n\r\n    void ignoreLine()\r\n    {\r\n        std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\r\n    }\r\n\r\n    char getCharacter()\r\n    {\r\n        char operation{};\r\n        std::cin &gt;&gt; operation;\r\n        ignoreLine(); \/\/ remove any extraneous input\r\n        return operation;\r\n    }\r\n\r\n    char getCommandFromUser()\r\n    {\r\n        char ch{};\r\n        while (!isValidCommand(ch))\r\n            ch = getCharacter();\r\n\r\n        return ch;\r\n    }\r\n\r\n    Direction charToDirection(char ch)\r\n    {\r\n        switch (ch)\r\n        {\r\n        case 'w': return Direction{ Direction::up };\r\n        case 's': return Direction{ Direction::down };\r\n        case 'a': return Direction{ Direction::left };\r\n        case 'd': return Direction{ Direction::right };\r\n        }\r\n\r\n        assert(0 &amp;&amp; \"Unsupported direction was passed!\");\r\n        return Direction{ Direction::up };\r\n    }\r\n};\r\n\r\nclass Tile\r\n{\r\npublic:\r\n    Tile() = default;\r\n    explicit Tile(int number)\r\n        :m_num(number)\r\n    {\r\n    }\r\n    \r\n    bool isEmpty() const\r\n    {\r\n        return m_num == 0;\r\n    }\r\n\r\n    int getNum() const { return m_num; }\r\n\r\nprivate:\r\n    int m_num { 0 };\r\n};\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, Tile tile)\r\n{\r\n    if (tile.getNum() &gt; 9) \/\/ if two digit number\r\n        stream &lt;&lt; \" \" &lt;&lt; tile.getNum() &lt;&lt; \" \";\r\n    else if (tile.getNum() &gt; 0) \/\/ if one digit number\r\n        stream &lt;&lt; \"  \" &lt;&lt; tile.getNum() &lt;&lt; \" \";\r\n    else if (tile.getNum() == 0) \/\/ if empty spot\r\n        stream &lt;&lt; \"    \";\r\n    return stream;\r\n}\r\n\r\nclass Board\r\n{\r\npublic:\r\n\r\n    Board() = default;\r\n\r\n    static void printEmptyLines(int count)\r\n    {\r\n        for (int i = 0; i &lt; count; ++i)\r\n            std::cout &lt;&lt; '\\n';\r\n    }\r\n\r\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const Board&amp; board)\r\n    {\r\n        \/\/ Before drawing always print some empty lines\r\n        \/\/ so that only one board appears at a time\r\n        \/\/ and it's always shown at the bottom of the window\r\n        \/\/ because console window scrolls automatically when there is no\r\n        \/\/ enough space. \r\n        for (int i = 0; i &lt; g_consoleLines; ++i)\r\n            std::cout &lt;&lt; '\\n';\r\n\r\n        for (int y = 0; y &lt; s_size; ++y)\r\n        {\r\n            for (int x = 0; x &lt; s_size; ++x)\r\n                stream &lt;&lt; board.m_tiles[y][x];\r\n            stream &lt;&lt; '\\n';\r\n        }\r\n\r\n        return stream;\r\n    }\r\n\r\nprivate:\r\n    static constexpr int s_size { 4 };\r\n    Tile m_tiles[s_size][s_size]{\r\n        Tile{ 1 }, Tile { 2 }, Tile { 3 } , Tile { 4 },\r\n        Tile { 5 } , Tile { 6 }, Tile { 7 }, Tile { 8 },\r\n        Tile { 9 }, Tile { 10 }, Tile { 11 }, Tile { 12 },\r\n        Tile { 13 }, Tile { 14 }, Tile { 15 }, Tile { 0 } };\r\n};\r\n\r\nint main()\r\n{\r\n    Board board{};\r\n    std::cout &lt;&lt; board;\r\n\r\n    std::cout &lt;&lt; \"Generating random direction... \" &lt;&lt; Direction::getRandomDirection() &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"Generating random direction... \" &lt;&lt; Direction::getRandomDirection() &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"Generating random direction... \" &lt;&lt; Direction::getRandomDirection() &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"Generating random direction... \" &lt;&lt; Direction::getRandomDirection() &lt;&lt; \"\\n\\n\";\r\n\r\n    std::cout &lt;&lt; \"Enter a command: \";\r\n    while (true)\r\n    {\r\n        char ch{ UserInput::getCommandFromUser() };\r\n\r\n        \/\/ Handle non-direction commands\r\n        if (ch == 'q')\r\n        {\r\n            std::cout &lt;&lt; \"\\n\\nBye!\\n\\n\";\r\n            return 0;\r\n        }\r\n\r\n        \/\/ Handle direction commands\r\n        Direction dir{ UserInput::charToDirection(ch) };\r\n\r\n        std::cout &lt;&lt; \"You entered direction: \" &lt;&lt; dir &lt;&lt; '\\n';\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #6<\/p>\n<p>Goal: Implement a helper class that will make it easier for us to index the tiles in our game board.<\/p>\n<p>Our game board is a 4&#215;4 grid of <code>Tile<\/code>, which we store in two-dimensional array member <code>m_tiles<\/code> of the <code>Board<\/code> class.  We will access a given tile using its {x, y} coordinates.  For example, the top left tile has coordinate {0, 0}.  The tile to the right of that has coordinate {1, 0} (x becomes 1, y stays 0).  The tile one down from that has coordinate {1, 1}.<\/p>\n<p>Since we&#8217;ll be working with coordinates a lot, create a helper class named <code>Point<\/code> that stores an {x, y} pair of coordinates.  We should be able to compare two Point objects for equality and inequality.  Also implement a member function named <code>getAdjacentPoint<\/code> that takes a Direction object as a parameter and returns the Point in that direction.  For example, <code>Point{1, 1}.getAdjacentPoint(Direction::right)<\/code> == <code>Point{2, 1}<\/code>.<\/p>\n<p><a class=\"tasks_link_show\" href=\"javascript:void(0)\" onclick=\"cppTasksToggle(document.getElementById('cpp_tasks_id_4'), this, 'Show Tasks', 'Hide Tasks')\">Show Tasks<\/a><\/p>\n<div class=\"wptasks\" id=\"cpp_tasks_id_4\" style=\"display:none\">\n<p>Implement a struct named <code>Point<\/code>.  This should contain:<\/p>\n<ul>\n<li>Two public data members to store the x-axis and y-axis coordinates.\n<\/li>\n<li>An overloaded <code>operator==<\/code> and <code>operator!=<\/code> to compare two sets of coordinates.\n<\/li>\n<li>A const member function <code>Point getAdjacentPoint(Direction)<\/code> that returns the Point in the direction of the Direction parameter.  We do not need to do any validity checking here.\n<\/li>\n<\/ul>\n<p>We&#8217;re using a struct instead of a class here because Point is simple bundle of data that would benefit little from being encapsulated.\n<\/p><\/div>\n<p>Save your <code>main()<\/code> function from the prior step, as you&#8217;ll need it again in the next step.<\/p>\n<p>The following code should run and print <code>true<\/code> for every test-case:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Your code goes here\r\n\r\n\/\/ Note: save your main() from the prior step, as you'll need it again in the next step\r\nint main()\r\n{\r\n    std::cout &lt;&lt; std::boolalpha;\r\n    std::cout &lt;&lt; (Point{ 1, 1 }.getAdjacentPoint(Direction::up)    == Point{ 1, 0 }) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; (Point{ 1, 1 }.getAdjacentPoint(Direction::down)  == Point{ 1, 2 }) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; (Point{ 1, 1 }.getAdjacentPoint(Direction::left)  == Point{ 0, 1 }) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; (Point{ 1, 1 }.getAdjacentPoint(Direction::right) == Point{ 2, 1 }) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; (Point{ 1, 1 } != Point{ 2, 1 }) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; (Point{ 1, 1 } != Point{ 1, 2 }) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; !(Point{ 1, 1 } != Point{ 1, 1 }) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_7'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_7\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;limits&gt;\r\n#include \"Random.h\"\r\n\r\n\/\/ Increase amount of new lines if your board isn't\r\n\/\/ at the very bottom of the console\r\nconstexpr int g_consoleLines{ 25 };\r\n\r\nclass Direction\r\n{\r\npublic:\r\n    enum Type\r\n    {\r\n        up,\r\n        down,\r\n        left,\r\n        right,\r\n        maxDirections,\r\n    };\r\n\r\n    Direction(Type type)\r\n        :m_type(type)\r\n    {\r\n    }\r\n\r\n    Type getType() const\r\n    {\r\n        return m_type;\r\n    }\r\n\r\n    Direction operator-() const\r\n    {\r\n        switch (m_type)\r\n        {\r\n        case up:    return Direction{ down };\r\n        case down:  return Direction{ up };\r\n        case left:  return Direction{ right };\r\n        case right: return Direction{ left };\r\n        default:    break;\r\n        }\r\n\r\n        assert(0 &amp;&amp; \"Unsupported direction was passed!\");\r\n        return Direction{ up };\r\n    }\r\n\r\n    static Direction getRandomDirection()\r\n    {\r\n        Type random{ static_cast&lt;Type&gt;(Random::get(0, Type::maxDirections - 1)) };\r\n        return Direction{ random };\r\n    }\r\n\r\nprivate:\r\n    Type m_type{};\r\n};\r\n\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, Direction dir)\r\n{\r\n    switch (dir.getType())\r\n    {\r\n    case Direction::up:     return (stream &lt;&lt; \"up\");\r\n    case Direction::down:   return (stream &lt;&lt; \"down\");\r\n    case Direction::left:   return (stream &lt;&lt; \"left\");\r\n    case Direction::right:  return (stream &lt;&lt; \"right\");\r\n    default:                break;\r\n    }\r\n\r\n    assert(0 &amp;&amp; \"Unsupported direction was passed!\");\r\n    return (stream &lt;&lt; \"unknown direction\");\r\n}\r\n\r\nstruct Point\r\n{\r\n    int x{};\r\n    int y{};\r\n\r\n    friend bool operator==(Point p1, Point p2)\r\n    {\r\n        return p1.x == p2.x &amp;&amp; p1.y == p2.y;\r\n    }\r\n\r\n    friend bool operator!=(Point p1, Point p2)\r\n    {\r\n        return !(p1 == p2);\r\n    }\r\n\r\n    Point getAdjacentPoint(Direction dir) const\r\n    {\r\n        switch (dir.getType())\r\n        {\r\n        case Direction::up:     return Point{ x,     y - 1 };\r\n        case Direction::down:   return Point{ x,     y + 1 };\r\n        case Direction::left:   return Point{ x - 1, y };\r\n        case Direction::right:  return Point{ x + 1, y };\r\n        default:                break;\r\n        }\r\n\r\n        assert(0 &amp;&amp; \"Unsupported direction was passed!\");\r\n        return *this;\r\n    }\r\n};\r\n\r\nnamespace UserInput\r\n{\r\n    bool isValidCommand(char ch)\r\n    {\r\n        return ch == 'w'\r\n            || ch == 'a'\r\n            || ch == 's'\r\n            || ch == 'd'\r\n            || ch == 'q';\r\n    }\r\n\r\n    void ignoreLine()\r\n    {\r\n        std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\r\n    }\r\n\r\n    char getCharacter()\r\n    {\r\n        char operation{};\r\n        std::cin &gt;&gt; operation;\r\n        ignoreLine(); \/\/ remove any extraneous input\r\n        return operation;\r\n    }\r\n\r\n    char getCommandFromUser()\r\n    {\r\n        char ch{};\r\n        while (!isValidCommand(ch))\r\n            ch = getCharacter();\r\n\r\n        return ch;\r\n    }\r\n\r\n    Direction charToDirection(char ch)\r\n    {\r\n        switch (ch)\r\n        {\r\n        case 'w': return Direction{ Direction::up };\r\n        case 's': return Direction{ Direction::down };\r\n        case 'a': return Direction{ Direction::left };\r\n        case 'd': return Direction{ Direction::right };\r\n        }\r\n\r\n        assert(0 &amp;&amp; \"Unsupported direction was passed!\");\r\n        return Direction{ Direction::up };\r\n    }\r\n};\r\n\r\nclass Tile\r\n{\r\npublic:\r\n    Tile() = default;\r\n    explicit Tile(int number)\r\n        :m_num(number)\r\n    {\r\n    }\r\n    \r\n    bool isEmpty() const\r\n    {\r\n        return m_num == 0;\r\n    }\r\n\r\n    int getNum() const { return m_num; }\r\n\r\nprivate:\r\n    int m_num { 0 };\r\n};\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, Tile tile)\r\n{\r\n    if (tile.getNum() &gt; 9) \/\/ if two digit number\r\n        stream &lt;&lt; \" \" &lt;&lt; tile.getNum() &lt;&lt; \" \";\r\n    else if (tile.getNum() &gt; 0) \/\/ if one digit number\r\n        stream &lt;&lt; \"  \" &lt;&lt; tile.getNum() &lt;&lt; \" \";\r\n    else if (tile.getNum() == 0) \/\/ if empty spot\r\n        stream &lt;&lt; \"    \";\r\n    return stream;\r\n}\r\n\r\nclass Board\r\n{\r\npublic:\r\n\r\n    Board() = default;\r\n\r\n    static void printEmptyLines(int count)\r\n    {\r\n        for (int i = 0; i &lt; count; ++i)\r\n            std::cout &lt;&lt; '\\n';\r\n    }\r\n\r\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const Board&amp; board)\r\n    {\r\n        \/\/ Before drawing always print some empty lines\r\n        \/\/ so that only one board appears at a time\r\n        \/\/ and it's always shown at the bottom of the window\r\n        \/\/ because console window scrolls automatically when there is no\r\n        \/\/ enough space. \r\n        for (int i = 0; i &lt; g_consoleLines; ++i)\r\n            std::cout &lt;&lt; '\\n';\r\n\r\n        for (int y = 0; y &lt; s_size; ++y)\r\n        {\r\n            for (int x = 0; x &lt; s_size; ++x)\r\n                stream &lt;&lt; board.m_tiles[y][x];\r\n            stream &lt;&lt; '\\n';\r\n        }\r\n\r\n        return stream;\r\n    }\r\n\r\nprivate:\r\n    static constexpr int s_size { 4 };\r\n    Tile m_tiles[s_size][s_size]{\r\n        Tile{ 1 }, Tile { 2 }, Tile { 3 } , Tile { 4 },\r\n        Tile { 5 } , Tile { 6 }, Tile { 7 }, Tile { 8 },\r\n        Tile { 9 }, Tile { 10 }, Tile { 11 }, Tile { 12 },\r\n        Tile { 13 }, Tile { 14 }, Tile { 15 }, Tile { 0 } };\r\n};\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; std::boolalpha;\r\n    std::cout &lt;&lt; (Point{ 1, 1 }.getAdjacentPoint(Direction::up)    == Point{ 1, 0 }) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; (Point{ 1, 1 }.getAdjacentPoint(Direction::down)  == Point{ 1, 2 }) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; (Point{ 1, 1 }.getAdjacentPoint(Direction::left)  == Point{ 0, 1 }) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; (Point{ 1, 1 }.getAdjacentPoint(Direction::right) == Point{ 2, 1 }) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; (Point{ 1, 1 } != Point{ 2, 1 }) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; (Point{ 1, 1 } != Point{ 1, 2 }) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; !(Point{ 1, 1 } != Point{ 1, 1 }) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #7<\/p>\n<p>Goal: Add the ability for players to slide the tiles on the board.<\/p>\n<p>First, we should take a closer look at how sliding tiles actually works:<\/p>\n<p>Given a puzzle state that looks like this:<\/p>\n<pre>\n     15   1   4\r\n  2   5   9  12\r\n  7   8  11  14\r\n 10  13   6   3\r\n<\/pre>\n<p>When the user enters &#8216;w&#8217; on the keyboard, the only tile that can go up is tile <code>2<\/code>.<\/p>\n<p>After moving the tile, the board looks like this:<\/p>\n<pre>\n  2  15   1   4\r\n      5   9  12\r\n  7   8  11  14\r\n 10  13   6   3\r\n<\/pre>\n<p>So, essentially what happened is we swapped the empty tile with tile <code>2<\/code>.<\/p>\n<p>Let&#8217;s generalize this procedure.  When the user enters a directional command, we need to:<\/p>\n<ul>\n<li>Locate the empty tile.\n<\/li>\n<li>From the empty tile, find the adjacent tile that is in the direction opposite of the direction the user entered.\n<\/li>\n<li>If the adjacent tile is valid (it&#8217;s not off the grid), swap the empty tile and adjacent tile.\n<\/li>\n<li>If the adjacent tile is not valid, do nothing.\n<\/li>\n<\/ul>\n<p>Implement this by adding a member function <code>moveTile(Direction)<\/code> to the class <code>Board<\/code>.  Add this to your game loop from step 5.  If the user successfully slides a tile, the game should redraw the updated board.<\/p>\n<p><a class=\"tasks_link_show\" href=\"javascript:void(0)\" onclick=\"cppTasksToggle(document.getElementById('cpp_tasks_id_5'), this, 'Show Tasks', 'Hide Tasks')\">Show Tasks<\/a><\/p>\n<div class=\"wptasks\" id=\"cpp_tasks_id_5\" style=\"display:none\">\n<p>Implement the following member functions in our <code>Board<\/code> class:<\/p>\n<ul>\n<li>A function which returns a bool indicating whether a given Point is valid (within our Board).\n<\/li>\n<li>A function that finds and returns the position of empty tile as a <code>Point<\/code>.  We could just keep track of where the empty tile is, but that introduces a class invariant, and finding the empty tile whenever we need it isn&#8217;t that expensive.\n<\/li>\n<li>A function that will swap two tiles given their Point indices.\n<\/li>\n<li>A <code>moveTile(Direction dir)<\/code> function that will try to move a tile in a given direction and will return <code>true<\/code> if it succeeds.  This function should implement the procedure outlined above.\n<\/li>\n<\/ul>\n<p>Modify the <code>main()<\/code> from step 5 so that <code>moveTile()<\/code> is called if a directional command is entered.  If the move was successful, redraw the board.<\/p>\n<\/div>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_8'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_8\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;limits&gt;\r\n#include \"Random.h\"\r\n\r\n\/\/ Increase amount of new lines if your board isn't\r\n\/\/ at the very bottom of the console\r\nconstexpr int g_consoleLines{ 25 };\r\n\r\nclass Direction\r\n{\r\npublic:\r\n    enum Type\r\n    {\r\n        up,\r\n        down,\r\n        left,\r\n        right,\r\n        maxDirections,\r\n    };\r\n\r\n    Direction(Type type)\r\n        :m_type(type)\r\n    {\r\n    }\r\n\r\n    Type getType() const\r\n    {\r\n        return m_type;\r\n    }\r\n\r\n    Direction operator-() const\r\n    {\r\n        switch (m_type)\r\n        {\r\n        case up:    return Direction{ down };\r\n        case down:  return Direction{ up };\r\n        case left:  return Direction{ right };\r\n        case right: return Direction{ left };\r\n        default:    break;\r\n        }\r\n\r\n        assert(0 &amp;&amp; \"Unsupported direction was passed!\");\r\n        return Direction{ up };\r\n    }\r\n\r\n    static Direction getRandomDirection()\r\n    {\r\n        Type random{ static_cast&lt;Type&gt;(Random::get(0, Type::maxDirections - 1)) };\r\n        return Direction{ random };\r\n    }\r\n\r\nprivate:\r\n    Type m_type{};\r\n};\r\n\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, Direction dir)\r\n{\r\n    switch (dir.getType())\r\n    {\r\n    case Direction::up:     return (stream &lt;&lt; \"up\");\r\n    case Direction::down:   return (stream &lt;&lt; \"down\");\r\n    case Direction::left:   return (stream &lt;&lt; \"left\");\r\n    case Direction::right:  return (stream &lt;&lt; \"right\");\r\n    default:                break;\r\n    }\r\n\r\n    assert(0 &amp;&amp; \"Unsupported direction was passed!\");\r\n    return (stream &lt;&lt; \"unknown direction\");\r\n}\r\n\r\nstruct Point\r\n{\r\n    int x{};\r\n    int y{};\r\n\r\n    friend bool operator==(Point p1, Point p2)\r\n    {\r\n        return p1.x == p2.x &amp;&amp; p1.y == p2.y;\r\n    }\r\n\r\n    friend bool operator!=(Point p1, Point p2)\r\n    {\r\n        return !(p1 == p2);\r\n    }\r\n\r\n    Point getAdjacentPoint(Direction dir) const\r\n    {\r\n        switch (dir.getType())\r\n        {\r\n        case Direction::up:     return Point{ x,     y - 1 };\r\n        case Direction::down:   return Point{ x,     y + 1 };\r\n        case Direction::left:   return Point{ x - 1, y };\r\n        case Direction::right:  return Point{ x + 1, y };\r\n        default:                break;\r\n        }\r\n\r\n        assert(0 &amp;&amp; \"Unsupported direction was passed!\");\r\n        return *this;\r\n    }\r\n};\r\n\r\nnamespace UserInput\r\n{\r\n    bool isValidCommand(char ch)\r\n    {\r\n        return ch == 'w'\r\n            || ch == 'a'\r\n            || ch == 's'\r\n            || ch == 'd'\r\n            || ch == 'q';\r\n    }\r\n\r\n    void ignoreLine()\r\n    {\r\n        std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\r\n    }\r\n\r\n    char getCharacter()\r\n    {\r\n        char operation{};\r\n        std::cin &gt;&gt; operation;\r\n        ignoreLine(); \/\/ remove any extraneous input\r\n        return operation;\r\n    }\r\n\r\n    char getCommandFromUser()\r\n    {\r\n        char ch{};\r\n        while (!isValidCommand(ch))\r\n            ch = getCharacter();\r\n\r\n        return ch;\r\n    }\r\n\r\n    Direction charToDirection(char ch)\r\n    {\r\n        switch (ch)\r\n        {\r\n        case 'w': return Direction{ Direction::up };\r\n        case 's': return Direction{ Direction::down };\r\n        case 'a': return Direction{ Direction::left };\r\n        case 'd': return Direction{ Direction::right };\r\n        }\r\n\r\n        assert(0 &amp;&amp; \"Unsupported direction was passed!\");\r\n        return Direction{ Direction::up };\r\n    }\r\n};\r\n\r\nclass Tile\r\n{\r\npublic:\r\n    Tile() = default;\r\n    explicit Tile(int number)\r\n        :m_num(number)\r\n    {\r\n    }\r\n\r\n    bool isEmpty() const\r\n    {\r\n        return m_num == 0;\r\n    }\r\n\r\n    int getNum() const { return m_num; }\r\n\r\nprivate:\r\n    int m_num { 0 };\r\n};\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, Tile tile)\r\n{\r\n    if (tile.getNum() &gt; 9) \/\/ if two digit number\r\n        stream &lt;&lt; \" \" &lt;&lt; tile.getNum() &lt;&lt; \" \";\r\n    else if (tile.getNum() &gt; 0) \/\/ if one digit number\r\n        stream &lt;&lt; \"  \" &lt;&lt; tile.getNum() &lt;&lt; \" \";\r\n    else if (tile.getNum() == 0) \/\/ if empty spot\r\n        stream &lt;&lt; \"    \";\r\n    return stream;\r\n}\r\n\r\nclass Board\r\n{\r\npublic:\r\n\r\n    Board() = default;\r\n\r\n    static void printEmptyLines(int count)\r\n    {\r\n        for (int i = 0; i &lt; count; ++i)\r\n            std::cout &lt;&lt; '\\n';\r\n    }\r\n\r\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const Board&amp; board)\r\n    {\r\n        \/\/ Before drawing always print some empty lines\r\n        \/\/ so that only one board appears at a time\r\n        \/\/ and it's always shown at the bottom of the window\r\n        \/\/ because console window scrolls automatically when there is no\r\n        \/\/ enough space. \r\n        for (int i = 0; i &lt; g_consoleLines; ++i)\r\n            std::cout &lt;&lt; '\\n';\r\n\r\n        for (int y = 0; y &lt; s_size; ++y)\r\n        {\r\n            for (int x = 0; x &lt; s_size; ++x)\r\n                stream &lt;&lt; board.m_tiles[y][x];\r\n            stream &lt;&lt; '\\n';\r\n        }\r\n\r\n        return stream;\r\n    }\r\n\r\n    Point getEmptyTilePos() const\r\n    {\r\n        for (int y = 0; y &lt; s_size; ++y)\r\n            for (int x = 0; x &lt; s_size; ++x)\r\n                if (m_tiles[y][x].isEmpty())\r\n                    return { x,y };\r\n\r\n        assert(0 &amp;&amp; \"There is no empty tile in the board!!!\");\r\n        return { -1,-1 };\r\n    }\r\n\r\n    static bool isValidTilePos(Point pt)\r\n    {\r\n        return (pt.x &gt;= 0 &amp;&amp; pt.x &lt; s_size)\r\n            &amp;&amp; (pt.y &gt;= 0 &amp;&amp; pt.y &lt; s_size);\r\n    }\r\n\r\n    void swapTiles(Point pt1, Point pt2)\r\n    {\r\n        std::swap(m_tiles[pt1.y][pt1.x], m_tiles[pt2.y][pt2.x]);\r\n    }\r\n\r\n    \/\/ returns true if user moved successfully\r\n    bool moveTile(Direction dir)\r\n    {\r\n        Point emptyTile{ getEmptyTilePos() };\r\n        Point adj{ emptyTile.getAdjacentPoint(-dir) };\r\n\r\n        if (!isValidTilePos(adj))\r\n            return false;\r\n\r\n        swapTiles(adj, emptyTile);\r\n        return true;\r\n    }\r\n\r\nprivate:\r\n    static const int s_size { 4 };\r\n    Tile m_tiles[s_size][s_size]{\r\n        Tile{ 1 }, Tile { 2 }, Tile { 3 } , Tile { 4 },\r\n        Tile { 5 } , Tile { 6 }, Tile { 7 }, Tile { 8 },\r\n        Tile { 9 }, Tile { 10 }, Tile { 11 }, Tile { 12 },\r\n        Tile { 13 }, Tile { 14 }, Tile { 15 }, Tile { 0 } };\r\n};\r\n\r\nint main()\r\n{\r\n    Board board{};\r\n    std::cout &lt;&lt; board;\r\n\r\n    std::cout &lt;&lt; \"Enter a command: \";\r\n    while (true)\r\n    {\r\n        char ch{ UserInput::getCommandFromUser() };\r\n\r\n        \/\/ Handle non-direction commands\r\n        if (ch == 'q')\r\n        {\r\n            std::cout &lt;&lt; \"\\n\\nBye!\\n\\n\";\r\n            return 0;\r\n        }\r\n\r\n        \/\/ Handle direction commands\r\n        Direction dir{ UserInput::charToDirection(ch) };\r\n\r\n        bool userMoved { board.moveTile(dir) };\r\n        if (userMoved)\r\n            std::cout &lt;&lt; board;\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #8<\/p>\n<p>Goal: In this step, we&#8217;ll finish our game. Randomize the initial state of the game board. Also, detect when user wins, so after that we can print a win message and quit the game.<\/p>\n<p>We need to be careful about <em>how<\/em> we randomize our puzzle, because not every puzzle is solvable.  For example, there is no way to solve this puzzle:<\/p>\n<pre>\n  1   2   3   4 \r\n  5   6   7   8\r\n  9  10  11  12\r\n 13  15  14\r\n<\/pre>\n<p>If we just blindly randomize the numbers in the puzzle, there is a chance that we will generate such an unsolvable puzzle.  With a physical version of the puzzle, we&#8217;d randomize the puzzle by sliding tiles in random directions until the tiles were sufficiently mixed.  The solution for such a randomized puzzle is to slide each tile in the opposite direction that it was slid to randomize it in the first place.  Thus, randomizing puzzles this way always generates a solvable puzzle.<\/p>\n<p>We can have our program randomize the board in the same way.<\/p>\n<p>Once the user has solved the puzzle, the program should print <code>\"\\n\\nYou won!\\n\\n\"<\/code> and then exit normally.<\/p>\n<p><a class=\"tasks_link_show\" href=\"javascript:void(0)\" onclick=\"cppTasksToggle(document.getElementById('cpp_tasks_id_6'), this, 'Show Tasks', 'Hide Tasks')\">Show Tasks<\/a><\/p>\n<div class=\"wptasks\" id=\"cpp_tasks_id_6\" style=\"display:none\">\n<ul>\n<li>Add a <code>randomize()<\/code> member function to the <code>Board<\/code> class which randomizes the tiles in the game board.  Pick a random direction and if the adjacent point is valid, then slide a tile in that direction.  Doing this 1000 times should be sufficient to mix up the board.\n<\/li>\n<li>Implement operator== in <code>Board<\/code> class which will compare if tiles of two given boards are identical.\n<\/li>\n<li>Add <code>playerWon()<\/code> member function to the <code>Board<\/code> class that will return true if the current game board is solved.  You can use the <code>operator==<\/code> you implemented to compare the current game board against a solved game board.  Remember that <code>Board<\/code> objects start in the solved state, so if you need a solved game board, just value initialize a <code>Board<\/code> object!\n<\/li>\n<li>Update your main() function to integrate randomize() and playerWon().\n<\/li>\n<\/ul>\n<\/div>\n<p>Here is the full solution for our 15 puzzle game:<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_9'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_9\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;limits&gt;\r\n#include \"Random.h\"\r\n\r\n\/\/ Increase amount of new lines if your board isn't\r\n\/\/ at the very bottom of the console\r\nconstexpr int g_consoleLines{ 25 };\r\n\r\nclass Direction\r\n{\r\npublic:\r\n    enum Type\r\n    {\r\n        up,\r\n        down,\r\n        left,\r\n        right,\r\n        maxDirections,\r\n    };\r\n\r\n    Direction(Type type)\r\n        :m_type(type)\r\n    {\r\n    }\r\n    Type getType() const\r\n    {\r\n        return m_type;\r\n    }\r\n\r\n    Direction operator-() const\r\n    {\r\n        switch (m_type)\r\n        {\r\n        case up:    return Direction{ down };\r\n        case down:  return Direction{ up };\r\n        case left:  return Direction{ right };\r\n        case right: return Direction{ left };\r\n        default:    break;\r\n        }\r\n\r\n        assert(0 &amp;&amp; \"Unsupported direction was passed!\");\r\n        return Direction{ up };\r\n    }\r\n\r\n    static Direction getRandomDirection()\r\n    {\r\n        Type random{ static_cast&lt;Type&gt;(Random::get(0, Type::maxDirections - 1)) };\r\n        return Direction{ random };\r\n    }\r\n\r\nprivate:\r\n    Type m_type{};\r\n};\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, Direction dir)\r\n{\r\n    switch (dir.getType())\r\n    {\r\n    case Direction::up:     return (stream &lt;&lt; \"up\");\r\n    case Direction::down:   return (stream &lt;&lt; \"down\");\r\n    case Direction::left:   return (stream &lt;&lt; \"left\");\r\n    case Direction::right:  return (stream &lt;&lt; \"right\");\r\n    default:                break;\r\n    }\r\n\r\n    assert(0 &amp;&amp; \"Unsupported direction was passed!\");\r\n    return (stream &lt;&lt; \"unknown direction\");\r\n}\r\n\r\nstruct Point\r\n{\r\n    int x{};\r\n    int y{};\r\n\r\n    friend bool operator==(Point p1, Point p2)\r\n    {\r\n        return p1.x == p2.x &amp;&amp; p1.y == p2.y;\r\n    }\r\n\r\n    friend bool operator!=(Point p1, Point p2)\r\n    {\r\n        return !(p1 == p2);\r\n    }\r\n\r\n    Point getAdjacentPoint(Direction dir) const\r\n    {\r\n        switch (dir.getType())\r\n        {\r\n        case Direction::up:     return Point{ x,     y - 1 };\r\n        case Direction::down:   return Point{ x,     y + 1 };\r\n        case Direction::left:   return Point{ x - 1, y };\r\n        case Direction::right:  return Point{ x + 1, y };\r\n        default:                break;\r\n        }\r\n\r\n        assert(0 &amp;&amp; \"Unsupported direction was passed!\");\r\n        return *this;\r\n    }\r\n};\r\n\r\nnamespace UserInput\r\n{\r\n    bool isValidCommand(char ch)\r\n    {\r\n        return ch == 'w'\r\n            || ch == 'a'\r\n            || ch == 's'\r\n            || ch == 'd'\r\n            || ch == 'q';\r\n    }\r\n\r\n    void ignoreLine()\r\n    {\r\n        std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\r\n    }\r\n\r\n    char getCharacter()\r\n    {\r\n        char operation{};\r\n        std::cin &gt;&gt; operation;\r\n        ignoreLine(); \/\/ remove any extraneous input\r\n        return operation;\r\n    }\r\n\r\n    char getCommandFromUser()\r\n    {\r\n        char ch{};\r\n        while (!isValidCommand(ch))\r\n            ch = getCharacter();\r\n\r\n        return ch;\r\n    }\r\n\r\n    Direction charToDirection(char ch)\r\n    {\r\n        switch (ch)\r\n        {\r\n        case 'w': return Direction{ Direction::up };\r\n        case 's': return Direction{ Direction::down };\r\n        case 'a': return Direction{ Direction::left };\r\n        case 'd': return Direction{ Direction::right };\r\n        }\r\n\r\n        assert(0 &amp;&amp; \"Unsupported direction was passed!\");\r\n        return Direction{ Direction::up };\r\n    }\r\n};\r\n\r\nclass Tile\r\n{\r\npublic:\r\n    Tile() = default;\r\n    explicit Tile(int number)\r\n        :m_num(number)\r\n    {\r\n    }\r\n\r\n    bool isEmpty() const\r\n    {\r\n        return m_num == 0;\r\n    }\r\n\r\n    int getNum() const { return m_num; }\r\n\r\nprivate:\r\n    int m_num { 0 };\r\n};\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, Tile tile)\r\n{\r\n    if (tile.getNum() &gt; 9) \/\/ if two digit number\r\n        stream &lt;&lt; \" \" &lt;&lt; tile.getNum() &lt;&lt; \" \";\r\n    else if (tile.getNum() &gt; 0) \/\/ if one digit number\r\n        stream &lt;&lt; \"  \" &lt;&lt; tile.getNum() &lt;&lt; \" \";\r\n    else if (tile.getNum() == 0) \/\/ if empty spot\r\n        stream &lt;&lt; \"    \";\r\n    return stream;\r\n}\r\n\r\nclass Board\r\n{\r\npublic:\r\n\r\n    Board() = default;\r\n\r\n    static void printEmptyLines(int count)\r\n    {\r\n        for (int i = 0; i &lt; count; ++i)\r\n            std::cout &lt;&lt; '\\n';\r\n    }\r\n\r\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const Board&amp; board)\r\n    {\r\n        \/\/ Before drawing always print some empty lines\r\n        \/\/ so that only one board appears at a time\r\n        \/\/ and it's always shown at the bottom of the window\r\n        \/\/ because console window scrolls automatically when there is no\r\n        \/\/ enough space. \r\n        for (int i = 0; i &lt; g_consoleLines; ++i)\r\n            std::cout &lt;&lt; '\\n';\r\n\r\n        for (int y = 0; y &lt; s_size; ++y)\r\n        {\r\n            for (int x = 0; x &lt; s_size; ++x)\r\n                stream &lt;&lt; board.m_tiles[y][x];\r\n            stream &lt;&lt; '\\n';\r\n        }\r\n\r\n        return stream;\r\n    }\r\n\r\n    Point getEmptyTilePos() const\r\n    {\r\n        for (int y = 0; y &lt; s_size; ++y)\r\n            for (int x = 0; x &lt; s_size; ++x)\r\n                if (m_tiles[y][x].isEmpty())\r\n                    return { x,y };\r\n\r\n        assert(0 &amp;&amp; \"There is no empty tile in the board!!!\");\r\n        return { -1,-1 };\r\n    }\r\n\r\n    static bool isValidTilePos(Point pt)\r\n    {\r\n        return (pt.x &gt;= 0 &amp;&amp; pt.x &lt; s_size)\r\n            &amp;&amp; (pt.y &gt;= 0 &amp;&amp; pt.y &lt; s_size);\r\n    }\r\n\r\n    void swapTiles(Point pt1, Point pt2)\r\n    {\r\n        std::swap(m_tiles[pt1.y][pt1.x], m_tiles[pt2.y][pt2.x]);\r\n    }\r\n\r\n    \/\/ Compare two boards to see if they are equal\r\n    friend bool operator==(const Board&amp; f1, const Board&amp; f2)\r\n    {\r\n        for (int y = 0; y &lt; s_size; ++y)\r\n            for (int x = 0; x &lt; s_size; ++x)\r\n                if (f1.m_tiles[y][x].getNum() != f2.m_tiles[y][x].getNum())\r\n                    return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    \/\/ returns true if user moved successfully\r\n    bool moveTile(Direction dir)\r\n    {\r\n        Point emptyTile{ getEmptyTilePos() };\r\n        Point adj{ emptyTile.getAdjacentPoint(-dir) };\r\n\r\n        if (!isValidTilePos(adj))\r\n            return false;\r\n\r\n        swapTiles(adj, emptyTile);\r\n        return true;\r\n    }\r\n\r\n    bool playerWon() const\r\n    {\r\n        static Board s_solved{};  \/\/ generate a solved board\r\n        return s_solved == *this; \/\/ player wins if current board == solved board\r\n    }\r\n\r\n    void randomize()\r\n    {\r\n        \/\/ Move empty tile randomly 1000 times\r\n        \/\/ (just like you would do in real life)\r\n        for (int i = 0; i &lt; 1000; )\r\n        {\r\n            \/\/ If we are able to successfully move a tile, count this\r\n            if (moveTile(Direction::getRandomDirection()))\r\n                ++i;\r\n        }\r\n    }\r\n\r\nprivate:\r\n    static const int s_size { 4 };\r\n    Tile m_tiles[s_size][s_size]{\r\n        Tile{ 1 }, Tile { 2 }, Tile { 3 } , Tile { 4 },\r\n        Tile { 5 } , Tile { 6 }, Tile { 7 }, Tile { 8 },\r\n        Tile { 9 }, Tile { 10 }, Tile { 11 }, Tile { 12 },\r\n        Tile { 13 }, Tile { 14 }, Tile { 15 }, Tile { 0 } };\r\n};\r\n\r\nint main()\r\n{\r\n    Board board{};\r\n    board.randomize();\r\n    std::cout &lt;&lt; board;\r\n\r\n    while (!board.playerWon())\r\n    {\r\n        char ch{ UserInput::getCommandFromUser() };\r\n\r\n        \/\/ Handle non-direction commands\r\n        if (ch == 'q')\r\n        {\r\n            std::cout &lt;&lt; \"\\n\\nBye!\\n\\n\";\r\n            return 0;\r\n        }\r\n\r\n        \/\/ Handle direction commands\r\n        Direction dir{ UserInput::charToDirection(ch) };\r\n\r\n        bool userMoved{ board.moveTile(dir) };\r\n        if (userMoved)\r\n            std::cout &lt;&lt; board;\r\n    }\r\n\r\n    std::cout &lt;&lt; \"\\n\\nYou won!\\n\\n\";\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-smart-pointers-move-semantics\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">22.1<\/span>Introduction to smart pointers and move semantics\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-21-summary-and-quiz\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.x<\/span>Chapter 21 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>A tip o&#8217; the hat to reader Avtem for conceiving of and collaborating on this project. Project time Let&#8217;s implement the classic game 15 Puzzle! In 15 Puzzle, you begin with a randomized 4&#215;4 grid of tiles. 15 of the tiles have numbers 1 through 15. One tile is missing. &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/14227"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=14227"}],"version-history":[{"count":17,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/14227\/revisions"}],"predecessor-version":[{"id":17599,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/14227\/revisions\/17599"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=14227"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=14227"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=14227"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}