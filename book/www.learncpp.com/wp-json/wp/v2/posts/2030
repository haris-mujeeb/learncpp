{"id":2030,"date":"2015-07-16T14:29:25","date_gmt":"2015-07-16T22:29:25","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=2030"},"modified":"2025-02-04T21:09:29","modified_gmt":"2025-02-05T05:09:29","slug":"chapter-8-summary-and-quiz","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-8-summary-and-quiz\/","title":{"rendered":"8.x &#8212; Chapter 8 summary and quiz"},"content":{"rendered":"<p class=\"cpp-section\">Chapter Review<\/p>\n<p>The specific sequence of statements that the CPU executes in a program is called the program&#8217;s <strong>execution path<\/strong>.  A <strong>straight-line program<\/strong> takes the same path every time it is run.<\/p>\n<p><strong>Control flow statements<\/strong> (also called <strong>Flow control statements<\/strong>) allow the programmer to change the normal path of execution.  When a control flow statement causes the program to begin executing some non-sequential instruction sequence, this is called a <strong>branch<\/strong>.<\/p>\n<p>A <strong>conditional statement<\/strong> is a statement that specifies whether some associated statement(s) should be executed or not.<\/p>\n<p><strong>If statements<\/strong> allow us to execute an associated statement based on whether some condition is <code>true<\/code>.  <strong>Else statements<\/strong> execute if the associated condition is <code>false<\/code>.  You can chain together multiple if and else statements.<\/p>\n<p>A <strong>dangling else<\/strong> occurs when it is ambiguous which <code>if statement<\/code> an <code>else statement<\/code> is connected to.  <code>Dangling else<\/code> statements are matched up with the last unmatched <code>if statement<\/code> in the same block.  Thus, we trivially avoid <code>dangling else<\/code> statements by ensuring the body of an <code>if statement<\/code> is placed in a block.<\/p>\n<p>A <strong>null statement<\/strong> is a statement that consists of just a semicolon.  It does nothing, and is used when the language requires a statement to exist but the programmer does not need the statement to do anything.<\/p>\n<p><strong>Switch statements<\/strong> provide a cleaner and faster method for selecting between a number of matching items.  Switch statements only work with integral types.  <strong>Case labels<\/strong> are used to identify the values for the evaluated condition to match.  The statements beneath a <strong>default label<\/strong> are executed if no matching case label can be found.<\/p>\n<p>When execution flows from a statement underneath a label into statements underneath a subsequent label, this is called <strong>fallthrough<\/strong>.  A <code>break statement<\/code> (or <code>return statement<\/code>) can be used to prevent fallthrough. The [[fallthrough]] attribute can be used to document intentional fallthrough. <\/p>\n<p><strong>Goto statements<\/strong> allow the program to jump to somewhere else in the code, either forward or backwards.  These should generally be avoided, as they can create <strong>spaghetti code<\/strong>, which occurs when a program has a path of execution that resembles a bowl of spaghetti.<\/p>\n<p><strong>While loops<\/strong> allow the program to loop as long as a given condition evaluates to <code>true<\/code>.  The condition is evaluated before the loop executes.<\/p>\n<p>An <strong>infinite loop<\/strong> is a loop that has a condition that always evaluates to <code>true<\/code>.  These loops will loop forever unless another control flow statement is used to stop them.<\/p>\n<p>A <strong>loop variable<\/strong> (also called a <strong>counter<\/strong>) is an integer variable used to count how many times a loop has executed.  Each execution of a loop is called an <strong>iteration<\/strong>.<\/p>\n<p><strong>Do while loops<\/strong> are similar to while loops, but the condition is evaluated after the loop executes instead of before.<\/p>\n<p><strong>For loops<\/strong> are the most used loop, and are ideal when you need to loop a specific number of times.  An <strong>off-by-one error<\/strong> occurs when the loop iterates one too many or one too few times.<\/p>\n<p><strong>Break statements<\/strong> allow us to break out of a switch, while, do while, or for loop (also <code>range-based for loops<\/code>, which we haven&#8217;t covered yet).  <strong>Continue statements<\/strong> allow us to move immediately to the next loop iteration.<\/p>\n<p><strong>Halts<\/strong> allow us to terminate our program.  <strong>Normal termination<\/strong> means the program has exited in an expected way (and the <code>status code<\/code> will indicate whether it succeeded or not<\/code>).  <strong>std::exit()<\/strong> is automatically called at the end of <code>main<\/code>, or it can be called explicitly to terminate the program.  It does some cleanup, but does not cleanup any local variables, or unwind the call stack.<\/p>\n<p><strong>Abnormal termination<\/strong> occurs when the program encountered some kind of unexpected error and had to be shut down.  <strong>std::abort<\/strong> can be called for an abnormal termination.<\/p>\n<p>An <strong>algorithm<\/strong> is a finite sequence of instructions that can be followed to solve some problem or produce some useful result.  An algorithm is considered to be <strong>stateful<\/strong> if it retains some information across calls.  Conversely, a <strong>stateless<\/strong> algorithm does not store any information (and must be given all the information it needs to work with when it is called).  When applied to algorithms, the term <strong>state<\/strong> refers to the current values held in stateful variables.<\/p>\n<p>An algorithm is considered <strong>deterministic<\/strong> if for a given input (the value provided for <code>start<\/code>) it will always produce the same output sequence.<\/p>\n<p>A <strong>pseudo-random number generator (PRNG)<\/strong> is an algorithm that generates a sequence of numbers whose properties simulate a sequence of random numbers.  When a PRNG is instantiated, an initial value (or set of values) called a <strong>random seed<\/strong> (or <strong>seed<\/strong> for short) can be provided to initialize the state of the PRNG.  When a PRNG has been initialized with a seed, we say it has been <strong>seeded<\/strong>.  The size of the seed value can be smaller than the size of the state of the PRNG.  When this happens, we say the PRNG has been <strong>underseeded<\/strong>.  The length of the sequence before a PRNG begins to repeat itself is known as the <strong>period<\/strong>.<\/p>\n<p>A <strong>random number distribution<\/strong> converts the output of a PRNG into some other distribution of numbers.  A <strong>uniform distribution<\/strong> is a random number distribution that produces outputs between two numbers X and Y (inclusive) with equal probability.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p>Warning: The quizzes start getting harder from this point forward, but you can do it.  Let&#8217;s rock these quizzes!<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-4-summary-and-quiz\/\">4.x -- Chapter 4 summary and quiz<\/a>, we wrote a program to simulate a ball falling off of a tower.  Because we didn&#8217;t have loops yet, the ball could only fall for 5 seconds.<\/p>\n<p>Take the program below and modify it so that the ball falls for as many seconds as needed until it reaches the ground.  Update the program to use all covered best practices (namespaces, constexpr, etc&#8230;).<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ Gets tower height from user and returns it\r\ndouble getTowerHeight()\r\n{\r\n\tstd::cout &lt;&lt; \"Enter the height of the tower in meters: \";\r\n\tdouble towerHeight{};\r\n\tstd::cin &gt;&gt; towerHeight;\r\n\treturn towerHeight;\r\n}\r\n\r\n\/\/ Returns the current ball height after \"seconds\" seconds\r\ndouble calculateBallHeight(double towerHeight, int seconds)\r\n{\r\n\tconst double gravity { 9.8 };\r\n    \r\n\t\/\/ Using formula: s = (u * t) + (a * t^2) \/ 2\r\n\t\/\/ here u (initial velocity) = 0, so (u * t) = 0\r\n\tconst double fallDistance { gravity * (seconds * seconds) \/ 2.0 };\r\n\tconst double ballHeight { towerHeight - fallDistance };\r\n\r\n\t\/\/ If the ball would be under the ground, place it on the ground\r\n\tif (ballHeight &lt; 0.0)\r\n\t\treturn 0.0;\r\n    \r\n\treturn ballHeight;\r\n}\r\n\r\n\/\/ Prints ball height above ground\r\nvoid printBallHeight(double ballHeight, int seconds)\r\n{\r\n\tif (ballHeight &gt; 0.0)\r\n\t\tstd::cout &lt;&lt; \"At \" &lt;&lt; seconds &lt;&lt; \" seconds, the ball is at height: \" &lt;&lt; ballHeight &lt;&lt; \" meters\\n\";\r\n\telse\r\n\t\tstd::cout &lt;&lt; \"At \" &lt;&lt; seconds &lt;&lt; \" seconds, the ball is on the ground.\\n\";\r\n}\r\n\r\n\/\/ Calculates the current ball height and then prints it\r\n\/\/ This is a helper function to make it easier to do this\r\nvoid calculateAndPrintBallHeight(double towerHeight, int seconds)\r\n{\r\n\tconst double ballHeight{ calculateBallHeight(towerHeight, seconds) };\r\n\tprintBallHeight(ballHeight, seconds);\r\n}\r\n\r\nint main()\r\n{\r\n\tconst double towerHeight{ getTowerHeight() };\r\n\r\n\tcalculateAndPrintBallHeight(towerHeight, 0);\r\n\tcalculateAndPrintBallHeight(towerHeight, 1);\r\n\tcalculateAndPrintBallHeight(towerHeight, 2);\r\n\tcalculateAndPrintBallHeight(towerHeight, 3);\r\n\tcalculateAndPrintBallHeight(towerHeight, 4);\r\n\tcalculateAndPrintBallHeight(towerHeight, 5);\r\n       \r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nnamespace Constants\r\n{\r\n\tconstexpr double gravity { 9.8 };\r\n}\r\n\r\n\/\/ Gets tower height from user and returns it\r\ndouble getTowerHeight()\r\n{\r\n\tstd::cout &lt;&lt; \"Enter the height of the tower in meters: \";\r\n\tdouble towerHeight{};\r\n\tstd::cin &gt;&gt; towerHeight;\r\n\treturn towerHeight;\r\n}\r\n\r\n\/\/ Returns the current ball height after \"seconds\" seconds\r\n\/\/ note: this function could be constexpr, but we haven't covered constexpr functions yet\r\ndouble calculateBallHeight(double towerHeight, int seconds)\r\n{\r\n\t\/\/ Using formula: s = (u * t) + (a * t^2) \/ 2\r\n\t\/\/ here u (initial velocity) = 0, so (u * t) = 0\r\n\tconst double fallDistance { Constants::gravity * (seconds * seconds) \/ 2.0 };\r\n\tconst double ballHeight { towerHeight - fallDistance };\r\n\r\n\tif (ballHeight &lt; 0.0)\r\n\t\treturn 0.0;\r\n    \r\n\treturn ballHeight;\r\n}\r\n\r\n\/\/ Prints ball height above ground\r\nvoid printBallHeight(double ballHeight, int seconds)\r\n{\r\n\tif (ballHeight &gt; 0.0)\r\n\t\tstd::cout &lt;&lt; \"At \" &lt;&lt; seconds &lt;&lt; \" seconds, the ball is at height: \" &lt;&lt; ballHeight &lt;&lt; \" meters\\n\";\r\n\telse\r\n\t\tstd::cout &lt;&lt; \"At \" &lt;&lt; seconds &lt;&lt; \" seconds, the ball is on the ground.\\n\";\r\n}\r\n\r\n\/\/ Calculates the current ball height and then prints it\r\n\/\/ This is a helper function to make it easier to do this\r\ndouble calculateAndPrintBallHeight(double towerHeight, int seconds)\r\n{\r\n\tconst double ballHeight{ calculateBallHeight(towerHeight, seconds) };\r\n\tprintBallHeight(ballHeight, seconds);\r\n\r\n\treturn ballHeight;\r\n}\r\n\r\nint main()\r\n{\r\n\tconst double towerHeight{ getTowerHeight() };\r\n\r\n\tint seconds { 0 };\r\n\twhile (calculateAndPrintBallHeight(towerHeight, seconds) &gt; 0.0)\r\n\t{\r\n\t\t++seconds;\r\n\t}\r\n       \r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>A prime number is a natural number greater than 1 that is evenly divisible (with no remainder) only by 1 and itself.<\/p>\n<p>Complete the following program by writing the <code>isPrime()<\/code> function using a for-loop.  When successful, the program will print &#8220;Success!&#8221;.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Make sure that assert triggers even if we compile in release mode\r\n#undef NDEBUG\r\n\r\n#include &lt;cassert&gt; \/\/ for assert\r\n#include &lt;iostream&gt;\r\n\r\nbool isPrime(int x)\r\n{\r\n    return false;\r\n    \/\/ write this function using a for loop\r\n}\r\n\r\nint main()\r\n{\r\n    assert(!isPrime(0)); \/\/ terminate program if isPrime(0) is true\r\n    assert(!isPrime(1));\r\n    assert(isPrime(2));  \/\/ terminate program if isPrime(2) is false\r\n    assert(isPrime(3));\r\n    assert(!isPrime(4));\r\n    assert(isPrime(5));\r\n    assert(isPrime(7));\r\n    assert(!isPrime(9));\r\n    assert(isPrime(11));\r\n    assert(isPrime(13));\r\n    assert(!isPrime(15));\r\n    assert(!isPrime(16));\r\n    assert(isPrime(17));\r\n    assert(isPrime(19));\r\n    assert(isPrime(97));\r\n    assert(!isPrime(99));\r\n    assert(isPrime(13417));\r\n\r\n    std::cout &lt;&lt; \"Success!\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p><code>assert<\/code> is a preprocessor macro that terminates the program if the associated argument evaluates to false.  So when we write <code>assert(!isPrime(0))<\/code>, we&#8217;re meaning &#8220;if isPrime(0) is true, then terminate the program&#8221;.  We cover assert in more detail in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/assert-and-static_assert\/\">9.6 -- Assert and static_assert<\/a>.\n<\/div>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Make sure that assert triggers even if we compile in release mode\r\n#undef NDEBUG\r\n\r\n#include &lt;cassert&gt; \/\/ for assert\r\n#include &lt;iostream&gt;\r\n\r\n\/\/ Non-optimized version\r\nbool isPrime(int x)\r\n{\r\n    if (x &lt;= 1) \/\/ if x is negative, 0, or 1 then the number is not prime\r\n        return false;\r\n\r\n    for (int test{ 2 }; test &lt; x; ++test)\r\n    {\r\n        if (x % test == 0) \/\/ if x is evenly divisible\r\n            return false;  \/\/ then this number isn't prime\r\n    }\r\n\r\n    return true; \/\/ if we didn't find any divisors, then x must be prime\r\n}\r\n\r\nint main()\r\n{\r\n    assert(!isPrime(0));\r\n    assert(!isPrime(1));\r\n    assert(isPrime(2));\r\n    assert(isPrime(3));\r\n    assert(!isPrime(4));\r\n    assert(isPrime(5));\r\n    assert(isPrime(7));\r\n    assert(!isPrime(9));\r\n    assert(isPrime(11));\r\n    assert(isPrime(13));\r\n    assert(!isPrime(15));\r\n    assert(!isPrime(16));\r\n    assert(isPrime(17));\r\n    assert(isPrime(19));\r\n    assert(isPrime(97));\r\n    assert(!isPrime(99));\r\n    assert(isPrime(13417));\r\n\r\n    std::cout &lt;&lt; \"Success!\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>Extra credit:<\/p>\n<p>The for-loop in the above solution is suboptimal for two reasons:<\/p>\n<ul>\n<li>It checks even divisors.  We don&#8217;t need to test these (except for 2).\n<\/li>\n<li>It checks every number up to <code>x<\/code> to see if it is a divisor.  A non-prime number (a composite number) must have at least one divisor less than or equal to its square root, so checking for divisors beyond the square root of <code>x<\/code> is unnecessary.   <code>std::sqrt(x)<\/code> (in the &lt;cmath&gt; header) returns the square root of <code>x<\/code>.\n<\/li>\n<\/ul>\n<p>For the latter, we have two options: calculate <code>std::sqrt(x)<\/code> prior to the loop, then test our loop variable against that value.  Alternately, we can optimize <code>std::sqrt(x)<\/code> out of the comparison entirely by squaring both sides of the comparison (h\/t to reader JJag for suggesting this) (see the hint if you need additional help with this).  We&#8217;ll use this latter option in the quiz solution.<\/p>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_0'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_0\" style=\"display:none; margin-bottom: 1em\">Hint: Given two variables <code>a &gt;= 0<\/code> and <code>b &gt;= 0<\/code>, we can square both sides of the comparison <code>a &lt;= sqrt(b)<\/code> and the comparison will still hold.  This gives us <code>a * a &lt;= sqrt(b) * sqrt(b)<\/code>, which is equivalent to <code>a * a &lt;= b<\/code>.<\/div>\n<p>Update the above solution to implement both of these optimizations.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;cmath&gt; \/\/ for std::sqrt\r\n#include &lt;iostream&gt;\r\n\r\n\/\/ optimized version\r\nbool isPrime(int x)\r\n{\r\n    if (x &lt;= 1)     \/\/ if x is negative, 0, or 1 then the number is not prime\r\n        return false;\r\n    if (x == 2)     \/\/ the number 2 is the only even prime\r\n        return true;\r\n    if (x % 2 == 0) \/\/ any other even number is not prime\r\n        return false;\r\n\r\n    \/\/ For any number 3 or greater, test odd values (this is why we add 2)\r\n    \/\/ between 3 and sqrt(x) to see if they are a divisor\r\n    \/\/ Also see https:\/\/stackoverflow.com\/questions\/5811151\/why-do-we-check-up-to-the-square-root-of-a-number-to-determine-if-the-number-is\r\n    \/\/ Since test &gt;= 0 and x &gt;=0, we can optimize test &lt; std::sqrt(x) to test * text &lt; x\r\n    for (int test{ 3 }; test * test &lt;= x; test += 2)\r\n    {\r\n        if (x % test == 0) \/\/ if x is evenly divisible\r\n            return false;  \/\/ then this number isn't prime\r\n    }\r\n\r\n    return true; \/\/ if we didn't find any divisors, then x must be prime\r\n}\r\n\r\nint main()\r\n{\r\n    assert(!isPrime(0));\r\n    assert(!isPrime(1));\r\n    assert(isPrime(2));\r\n    assert(isPrime(3));\r\n    assert(!isPrime(4));\r\n    assert(isPrime(5));\r\n    assert(isPrime(7));\r\n    assert(!isPrime(9));\r\n    assert(isPrime(11));\r\n    assert(isPrime(13));\r\n    assert(!isPrime(15));\r\n    assert(!isPrime(16));\r\n    assert(isPrime(17));\r\n    assert(isPrime(19));\r\n    assert(isPrime(97));\r\n    assert(!isPrime(99));\r\n    assert(isPrime(13417));\r\n\r\n    std::cout &lt;&lt; \"Success!\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #3<\/p>\n<p>Implement a game of Hi-Lo.  First, your program should pick a random integer between 1 and 100. The user is given 7 tries to guess the number.<\/p>\n<p>If the user does not guess the correct number, the program should tell them whether they guessed too high or too low. If the user guesses the right number, the program should tell them they won. If they run out of guesses, the program should tell them they lost, and what the correct number is. At the end of the game, the user should be asked if they want to play again. If the user doesn&#8217;t enter &#8216;y&#8217; or &#8216;n&#8217;, ask them again.<\/p>\n<p>For this quiz, assume the user enters a valid number.<\/p>\n<p>Use the Random.h header from <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/global-random-numbers-random-h\/#RandomH\">8.15 -- Global random numbers (Random.h)<\/a>.<\/p>\n<p>Here&#8217;s what your output should look like:<\/p>\n<pre>\nLet's play a game. I'm thinking of a number between 1 and 100. You have 7 tries to guess what it is.\r\nGuess #1: 64\r\nYour guess is too high.\r\nGuess #2: 32\r\nYour guess is too low.\r\nGuess #3: 54\r\nYour guess is too high.\r\nGuess #4: 51\r\nCorrect! You win!\r\nWould you like to play again (y\/n)? y\r\nLet's play a game. I'm thinking of a number between 1 and 100. You have 7 tries to guess what it is.\r\nGuess #1: 64\r\nYour guess is too high.\r\nGuess #2: 32\r\nYour guess is too low.\r\nGuess #3: 54\r\nYour guess is too high.\r\nGuess #4: 51\r\nYour guess is too high.\r\nGuess #5: 36\r\nYour guess is too low.\r\nGuess #6: 45\r\nYour guess is too low.\r\nGuess #7: 48\r\nYour guess is too low.\r\nSorry, you lose. The correct number was 49.\r\nWould you like to play again (y\/n)? q\r\nWould you like to play again (y\/n)? n\r\nThank you for playing.\r\n<\/pre>\n<p>For extra credit: make the minimum and maximum values and the number of guesses a configurable parameter.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include \"Random.h\" \/\/ https:\/\/www.learncpp.com\/cpp-tutorial\/global-random-numbers-random-h\/\r\n\r\n\/\/ Returns true if the user won, false if they lost\r\n\/\/ We don't use the return value in this program, but it doesn't add complexity to have it, and may be useful in a future update\r\n\/\/ (e.g. if we wanted to move the won\/lost messages out of the function, or conditionalize other behavior based on won\/lost)\r\nbool playHiLo(int guesses, int min, int max)\r\n{\r\n\tstd::cout &lt;&lt; \"Let's play a game. I'm thinking of a number between \" &lt;&lt; min &lt;&lt; \" and \" &lt;&lt; max &lt;&lt; \". You have \" &lt;&lt; guesses &lt;&lt; \" tries to guess what it is.\\n\";\r\n\tconst int number { Random::get(min, max) }; \/\/ this is the number the user needs to guess\r\n\r\n\t\/\/ Loop through all of the guesses\r\n\tfor (int count{ 1 }; count &lt;= guesses; ++count)\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Guess #\" &lt;&lt; count &lt;&lt; \": \";\r\n\r\n\t\tint guess{};\r\n\t\tstd::cin &gt;&gt; guess;\r\n\r\n\t\tif (guess &gt; number)\r\n\t\t\tstd::cout &lt;&lt; \"Your guess is too high.\\n\";\r\n\t\telse if (guess &lt; number)\r\n\t\t\tstd::cout &lt;&lt; \"Your guess is too low.\\n\";\r\n\t\telse \/\/ guess == number, so the user won\r\n\t\t{\r\n\t\t\tstd::cout &lt;&lt; \"Correct! You win!\\n\";\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n\t\/\/ The user lost\r\n\tstd::cout &lt;&lt; \"Sorry, you lose. The correct number was \" &lt;&lt; number &lt;&lt; '\\n';\r\n\treturn false;\r\n}\r\n\r\nbool playAgain()\r\n{\r\n\t\/\/ Keep asking the user if they want to play again until they pick y or n.\r\n\twhile (true)\r\n\t{\r\n\t\tchar ch{};\r\n\t\tstd::cout &lt;&lt; \"Would you like to play again (y\/n)? \";\r\n\t\tstd::cin &gt;&gt; ch;\r\n\r\n\t\tswitch (ch)\r\n\t\t{\r\n\t\tcase 'y': return true;\r\n\t\tcase 'n': return false;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nint main()\r\n{\r\n\tconstexpr int guesses { 7 }; \/\/ the user has this many guesses\r\n\tconstexpr int min     { 1 };\r\n\tconstexpr int max     { 100 };\r\n\r\n\tdo\r\n\t{\r\n\t\tplayHiLo(guesses, min, max);\r\n\t} while (playAgain());\r\n\r\n\tstd::cout &lt;&lt; \"Thank you for playing.\\n\";\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>We&#8217;ll add error handling to this solution in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-9-summary-and-quiz\/\">9.x -- Chapter 9 summary and quiz<\/a>.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-testing-your-code\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">9.1<\/span>Introduction to testing your code\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/global-random-numbers-random-h\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">8.15<\/span>Global random numbers (Random.h)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Chapter Review The specific sequence of statements that the CPU executes in a program is called the program&#8217;s . A takes the same path every time it is run. (also called ) allow the programmer to change the normal path of execution. When a control flow statement causes the program &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/2030"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=2030"}],"version-history":[{"count":79,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/2030\/revisions"}],"predecessor-version":[{"id":18162,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/2030\/revisions\/18162"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=2030"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=2030"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=2030"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}