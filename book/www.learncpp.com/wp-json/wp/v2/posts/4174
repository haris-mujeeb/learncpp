{"id":4174,"date":"2016-06-05T10:49:38","date_gmt":"2016-06-05T18:49:38","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=4174"},"modified":"2024-11-14T14:28:07","modified_gmt":"2024-11-14T22:28:07","slug":"class-initialization-and-copy-elision","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/class-initialization-and-copy-elision\/","title":{"rendered":"14.15 &#8212; Class initialization and copy elision"},"content":{"rendered":"<p>Way back in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/variable-assignment-and-initialization\/\">1.4 -- Variable assignment and initialization<\/a>, we discuss 6 basic types of initialization for objects with fundamental types:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int a;         \/\/ no initializer (default initialization)\r\nint b = 5;     \/\/ initializer after equals sign (copy initialization)\r\nint c( 6 );    \/\/ initializer in parentheses (direct initialization)\r\n\r\n\/\/ List initialization methods (C++11)\r\nint d { 7 };   \/\/ initializer in braces (direct list initialization)\r\nint e = { 8 }; \/\/ initializer in braces after equals sign (copy list initialization)\r\nint f {};      \/\/ initializer is empty braces (value initialization)<\/code><\/pre>\n<p>All of these initialization types are valid for object with class types:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Foo\r\n{\r\npublic:\r\n    \r\n    \/\/ Default constructor\r\n    Foo()\r\n    {\r\n        std::cout &lt;&lt; \"Foo()\\n\";\r\n    }\r\n\r\n    \/\/ Normal constructor\r\n    Foo(int x)\r\n    {\r\n        std::cout &lt;&lt; \"Foo(int) \" &lt;&lt; x &lt;&lt; '\\n';\r\n    }\r\n\r\n    \/\/ Copy constructor\r\n    Foo(const Foo&amp;)\r\n    {\r\n        std::cout &lt;&lt; \"Foo(const Foo&amp;)\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    \/\/ Calls Foo() default constructor\r\n    Foo f1;           \/\/ default initialization\r\n    Foo f2{};         \/\/ value initialization (preferred)\r\n    \r\n    \/\/ Calls foo(int) normal constructor\r\n    Foo f3 = 3;       \/\/ copy initialization (non-explicit constructors only)\r\n    Foo f4(4);        \/\/ direct initialization\r\n    Foo f5{ 5 };      \/\/ direct list initialization (preferred)\r\n    Foo f6 = { 6 };   \/\/ copy list initialization (non-explicit constructors only)\r\n\r\n    \/\/ Calls foo(const Foo&amp;) copy constructor\r\n    Foo f7 = f3;      \/\/ copy initialization\r\n    Foo f8(f3);       \/\/ direct initialization\r\n    Foo f9{ f3 };     \/\/ direct list initialization (preferred)\r\n    Foo f10 = { f3 }; \/\/ copy list initialization\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In modern C++, copy initialization, direct initialization, and list initialization essentially do the same thing -- they initialize an object.<\/p>\n<p>For all types of initialization:<\/p>\n<ul>\n<li>When initializing a class type, the set of constructors for that class are examined, and overload resolution is used to determine the best matching constructor.  This may involve implicit conversion of arguments.\n<\/li>\n<li>When initializing a non-class type, the implicit conversion rules are used to determine whether an implicit conversion exists.\n<\/li>\n<\/ul>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>There are three key differences between the initialization forms:<\/p>\n<ul>\n<li>List initialization disallows narrowing conversions.\n<\/li>\n<li>Copy initialization only considers non-explicit constructors\/conversion functions.  We&#8217;ll cover this in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/converting-constructors-and-the-explicit-keyword\/\">14.16 -- Converting constructors and the explicit keyword<\/a>.\n<\/li>\n<li>List initialization prioritizes matching list constructors over other matching constructors.  We&#8217;ll cover this in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdvector-and-list-constructors\/\">16.2 -- Introduction to std::vector and list constructors<\/a>.\n<\/li>\n<\/ul>\n<\/div>\n<p>It is also worth noting that in some circumstances, certain forms of initialization are disallowed (e.g. in a constructor member initializer list, we can only use direct forms of initialization, not copy initialization).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Unnecessary copies<\/p>\n<p>Consider this simple program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Something\r\n{\r\n    int m_x{};\r\n\r\npublic:\r\n    Something(int x)\r\n        : m_x{ x }\r\n    {\r\n        std::cout &lt;&lt; \"Normal constructor\\n\";\r\n    }\r\n\r\n    Something(const Something&amp; s)\r\n        : m_x { s.m_x }\r\n    {\r\n        std::cout &lt;&lt; \"Copy constructor\\n\";\r\n    }\r\n\r\n    void print() const { std::cout &lt;&lt; \"Something(\" &lt;&lt; m_x &lt;&lt; \")\\n\"; }\r\n};\r\n\r\nint main()\r\n{\r\n    Something s { Something { 5 } }; \/\/ focus on this line\r\n    s.print();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the initialization of variable <code>s<\/code> above, we first construct a temporary <code>Something<\/code>, initialized with value <code>5<\/code> (which uses the <code>Something(int)<\/code> constructor).  This temporary is then used to initialize <code>s<\/code>.  Because the temporary and <code>s<\/code> have the same type (they are both <code>Something<\/code> objects), the <code>Something(const Something&amp;)<\/code> copy constructor would normally be called here to copy the values in the temporary into <code>s<\/code>.  The end result is that <code>s<\/code> is initialized with value <code>5<\/code>.<\/p>\n<p>Without any optimizations, the above program would print:<\/p>\n<pre>\nNormal constructor\r\nCopy constructor\r\nSomething(5)\r\n<\/pre>\n<p>However, this program is needlessly inefficient, as we&#8217;ve had to make two constructor calls: one to <code>Something(int)<\/code>, and one to <code>Something(const Something&amp;)<\/code>.  Note that the end result of the above is the same as if we had written the following instead:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">Something s { 5 }; \/\/ only invokes Something(int), no copy constructor<\/code><\/pre>\n<p>This version produces the same result, but is more efficient, as it only makes a call to <code>Something(int)<\/code> (no copy constructor is needed).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Copy elision<\/p>\n<p>Since the compiler is free to rewrite statements to optimize them, one might wonder if the compiler can optimize away the unnecessary copy and treat <code>Something s { Something{5} };<\/code> as if we had written <code>Something s { 5 }<\/code> in the first place.<\/p>\n<p>The answer is yes, and the process of doing so is called <em>copy elision<\/em>.  <strong>Copy elision<\/strong> is a compiler optimization technique that allows the compiler to remove unnecessary copying of objects.  In other words, in cases where the compiler would normally call a copy constructor, the compiler is free to rewrite the code to avoid the call to the copy constructor altogether.  When the compiler optimizes away a call to the copy constructor, we say the constructor has been <strong>elided<\/strong>.<\/p>\n<p>Unlike other types of optimization, copy elision is exempt from the &#8220;as-if&#8221; rule.  That is, copy elision is allowed to elide the copy constructor even if the copy constructor has side effects (such as printing text to the console)!  This is why copy constructors should not have side effects other than copying -- if the compiler elides the call to the copy constructor, the side effects won&#8217;t execute, and the observable behavior of the program will change!<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We discussed the as-if rule in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/the-as-if-rule-and-compile-time-optimization\/\">5.4 -- The as-if rule and compile-time optimization<\/a>.\n<\/p><\/div>\n<p>We can see this in the above example.  If you run the program on a C++17 compiler, it will produce the following result:<\/p>\n<pre>\nNormal constructor\r\nSomething(5)\r\n<\/pre>\n<p>The compiler has elided the copy constructor to avoid an unnecessary copy, and as a result, the statement that prints &#8220;Copy constructor&#8221; does not execute!  Our program&#8217;s observable behavior has changed due to copy elision!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Copy elision in pass by value and return by value<\/p>\n<p>The copy constructor is normally called when an argument of the same type as the parameter is passed by value or return by value is used.  However, in certain cases, these copies may be elided.  The following program demonstrates some of these cases:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Something\r\n{\r\npublic:\r\n\tSomething() = default;\r\n\tSomething(const Something&amp;)\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Copy constructor called\\n\";\r\n\t}\r\n};\r\n\r\nSomething rvo()\r\n{\r\n\treturn Something{}; \/\/ calls Something() and copy constructor\r\n}\r\n\r\nSomething nrvo()\r\n{\r\n\tSomething s{}; \/\/ calls Something()\r\n\treturn s;      \/\/ calls copy constructor\r\n}\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; \"Initializing s1\\n\";\r\n\tSomething s1 { rvo() }; \/\/ calls copy constructor\r\n\r\n\tstd::cout &lt;&lt; \"Initializing s2\\n\";\r\n\tSomething s2 { nrvo() }; \/\/ calls copy constructor\r\n\r\n        return 0;\r\n}<\/code><\/pre>\n<p>In C++14 or older, with copy elision disabled, the above program would call the copy constructor 4 times:<\/p>\n<ul>\n<li>Once when <code>rvo<\/code> returns <code>Something<\/code> to <code>main<\/code>.\n<\/li>\n<li>Once when the return value of <code>rvo()<\/code> is used to initialize <code>s1<\/code>.\n<\/li>\n<li>Once when <code>nrvo<\/code> returns <code>s<\/code> to <code>main<\/code>.\n<\/li>\n<li>Once when the return value of <code>nrvo()<\/code> is used to initialize <code>s2<\/code>.\n<\/li>\n<\/ul>\n<p>However, due to copy elision, it&#8217;s likely that your compiler will elide most or all of these copy constructor calls.  Visual Studio 2022 elides 3 cases (it doesn&#8217;t elide the case where <code>nrvo()<\/code> returns by value), and GCC elides all 4.<\/p>\n<p>It&#8217;s not important to memorize when the compiler does \/ doesn&#8217;t do copy elision.  Just know that it is an optimization that your compiler will perform if it can.  If you expect to see your copy constructor called and it isn&#8217;t, copy elision is probably why.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Mandatory copy elision in C++17 <span class=\"cpp-section-pill cpp-section-standard\">C++17<\/span><\/p>\n<p>Prior to C++17, copy elision was strictly an optional optimization that compilers could make.  In C++17, copy elision became mandatory in some cases.  In these cases, copy elision will be performed automatically (even if you tell your compiler not to perform copy elision).<\/p>\n<p>Running the same example as above in C++17 or newer, the copy constructor calls that would otherwise occur when <code>rvo()<\/code> returns and when <code>s1<\/code> is initialized with that value are required to be elided.  The initialization of <code>s2<\/code> with <code>nvro()<\/code> is not a mandatory elision case, and thus the 2 copy constructor calls that occur here may or may not be elided depending on your compiler and optimization settings.<\/p>\n<p>In optional elision cases, an accessible copy constructor must be available (e.g. not deleted), even if the actual call to the copy constructor is elided.<\/p>\n<p>In mandatory elision cases, an accessible copy constructor need not be available (in other words, mandatory elision can happen even if the copy constructor is deleted).<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>In cases where optional copy elision isn&#8217;t performed, move semantics may still allow an object to be moved instead of copied.  We introduce move semantics in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/returning-stdvector-and-an-introduction-to-move-semantics\/\">16.5 -- Returning std::vector, and an introduction to move semantics<\/a>.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/converting-constructors-and-the-explicit-keyword\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.16<\/span>Converting constructors and the explicit keyword\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-the-copy-constructor\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.14<\/span>Introduction to the copy constructor\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Way back in lesson , we discuss 6 basic types of initialization for objects with fundamental types: int a; \/\/ no initializer (default initialization) int b = 5; \/\/ initializer after equals sign (copy initialization) int c( 6 ); \/\/ initializer in parentheses (direct initialization) \/\/ List initialization methods (C++11) &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4174"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=4174"}],"version-history":[{"count":38,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4174\/revisions"}],"predecessor-version":[{"id":17858,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4174\/revisions\/17858"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=4174"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=4174"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=4174"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}