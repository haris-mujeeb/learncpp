{"id":15865,"date":"2023-10-05T12:59:28","date_gmt":"2023-10-05T19:59:28","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15865"},"modified":"2024-09-25T14:09:11","modified_gmt":"2024-09-25T21:09:11","slug":"ref-qualifiers","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/ref-qualifiers\/","title":{"rendered":"15.10 &#8212; Ref qualifiers"},"content":{"rendered":"<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>This is an optional lesson.  We recommend having a light read-through to familiarize yourself with the material, but comprehensive understanding is not required to proceed with future lessons.\n<\/p><\/div>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/member-functions-returning-references-to-data-members\/\">14.7 -- Member functions returning references to data members<\/a>, we discussed how calling access functions that return references to data members can be dangerous when the implicit object is an rvalue.  Here&#8217;s a quick recap:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Employee\r\n{\r\nprivate:\r\n\tstd::string m_name{};\r\n\r\npublic:\r\n\tEmployee(std::string_view name): m_name { name } {}\r\n\tconst std::string&amp; getName() const { return m_name; } \/\/  getter returns by const reference\r\n};\r\n\r\n\/\/ createEmployee() returns an Employee by value (which means the returned value is an rvalue)\r\nEmployee createEmployee(std::string_view name)\r\n{\r\n\tEmployee e { name };\r\n\treturn e;\r\n}\r\n\r\nint main()\r\n{\r\n\t\/\/ Case 1: okay: use returned reference to member of rvalue class object in same expression\r\n\tstd::cout &lt;&lt; createEmployee(\"Frank\").getName() &lt;&lt; '\\n';\r\n\r\n\t\/\/ Case 2: bad: save returned reference to member of rvalue class object for use later\r\n\tconst std::string&amp; ref { createEmployee(\"Garbo\").getName() }; \/\/ reference becomes dangling when return value of createEmployee() is destroyed\r\n\tstd::cout &lt;&lt; ref &lt;&lt; '\\n'; \/\/ undefined behavior\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In case 2, the rvalue object returned from <code>createEmployee(\"Garbo\")<\/code> is destroyed after initializing <code>ref<\/code>, leaving <code>ref<\/code> referencing a data member that was just destroyed.  Subsequent use of <code>ref<\/code> exhibits undefined behavior.<\/p>\n<p>This presents somewhat of a conundrum.<\/p>\n<ul>\n<li>If our <code>getName()<\/code> function returns by value, this is safe when our implicit object is an rvalue, but makes an expensive and unnecessary copy when our implicit object is an lvalue (which is the most common case).\n<\/li>\n<li>If our <code>getName()<\/code> function returns by const reference, this is efficient (as no copy of the <code>std::string<\/code> is made), but can be misused when the implicit object is an rvalue (resulting in undefined behavior).\n<\/li>\n<\/ul>\n<p>Since member functions are typically called on lvalue implicit objects, the conventional choice is to return by const reference and simply avoid misusing the returned reference in cases where the implicit object is an rvalue.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Ref qualifiers<\/p>\n<p>The root of the challenge illustrated above is that we only want one function to service two different cases (one where our implicit object is an lvalue, and one where our implicit object is an rvalue).  What&#8217;s optimal for one case isn&#8217;t ideal for the other case.<\/p>\n<p>To help address such issues, C++11 introduced a little known feature called a <strong>ref-qualifier<\/strong> that allows us to overload a member function based on whether it is being called on an lvalue or an rvalue implicit object.  Using this feature, we can create two versions of <code>getName()<\/code> -- one for the case where our implicit object is an lvalue, and one for the case where our implicit object is an rvalue.<\/p>\n<p>First, let&#8217;s start with our non-ref-qualified version of <code>getName()<\/code><\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">const std::string&amp; getName() const { return m_name; } \/\/ callable with both lvalue and rvalue implicit objects<\/code><\/pre>\n<p>To ref-qualify this function, we add a <code>&amp;<\/code> qualifier to the overload that will match only lvalue implicit objects, and a <code>&amp;&amp;<\/code> qualifier to the overload that will match only rvalue implicit objects:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">const std::string&amp; getName() const &amp;  { return m_name; } \/\/  &amp; qualifier overloads function to match only lvalue implicit objects, returns by reference\r\nstd::string        getName() const &amp;&amp; { return m_name; } \/\/ &amp;&amp; qualifier overloads function to match only rvalue implicit objects, returns by value<\/code><\/pre>\n<p>Because these functions are distinct overloads, they can have different return types!  Our lvalue-qualified overload returns by const reference, whereas our rvalue-qualified overload returns by value.<\/p>\n<p>Here&#8217;s a full-example of the above:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Employee\r\n{\r\nprivate:\r\n\tstd::string m_name{};\r\n\r\npublic:\r\n\tEmployee(std::string_view name): m_name { name } {}\r\n\r\n\tconst std::string&amp; getName() const &amp;  { return m_name; } \/\/  &amp; qualifier overloads function to match only lvalue implicit objects\r\n\tstd::string        getName() const &amp;&amp; { return m_name; } \/\/ &amp;&amp; qualifier overloads function to match only rvalue implicit objects\r\n};\r\n\r\n\/\/ createEmployee() returns an Employee by value (which means the returned value is an rvalue)\r\nEmployee createEmployee(std::string_view name)\r\n{\r\n\tEmployee e { name };\r\n\treturn e;\r\n}\r\n\r\nint main()\r\n{\r\n\tEmployee joe { \"Joe\" };\r\n\tstd::cout &lt;&lt; joe.getName() &lt;&lt; '\\n'; \/\/ Joe is an lvalue, so this calls std::string&amp; getName() &amp; (returns a reference)\r\n    \r\n\tstd::cout &lt;&lt; createEmployee(\"Frank\").getName() &lt;&lt; '\\n'; \/\/ Frank is an rvalue, so this calls std::string getName() &amp;&amp; (makes a copy)\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This allows us to do the performant thing when our implicit object is an lvalue, and the safe thing when our implicit object is an rvalue.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>The above rvalue overload of <code>getName()<\/code> above is potentially suboptimal from a performance perspective when the implicit object is a non-const temporary.  In such cases, the implicit object is going to die at the end of the expression anyway.  So instead of having the rvalue getter return a (possibly expensive) copy of the member, we can have it try to move the member (using <code>std::move<\/code>).<\/p>\n<p>This can be facilitated by adding the following overloaded getter for non-const rvalues:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">        \/\/ If the implicit object is a non-const rvalue, use std::move to try to move m_name\r\n\tstd::string getName() &amp;&amp; { return std::move(m_name); }<\/code><\/pre>\n<p>This can either coexist with the const rvalue getter, or you can just use this instead (since const rvalues are fairly uncommon).<\/p>\n<p>We cover <code>std::move<\/code> in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdmove\/\">22.4 -- std::move<\/a>.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Some notes about ref-qualified member functions<\/p>\n<p>First, for a given function, non-ref-qualified overloads and ref-qualified overloads cannot coexist.  Use one or the other.<\/p>\n<p>Second, similar to how a const lvalue reference can bind to an rvalue, if only a const lvalue-qualified function exists, it will accept either lvalue or rvalue implicit objects.<\/p>\n<p>Third, either qualified overload can be explicitly deleted (using <code>= delete<\/code>), which prevents calls to that function.  For example, deleting the rvalue-qualified version prevents use of the function with rvalue implicit objects.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">So why don&#8217;t we recommend using ref-qualifiers?<\/p>\n<p>While ref-qualifiers are neat, there are some downsides to using them in this way.<\/p>\n<ul>\n<li>Adding rvalue overloads to every getter that returns a reference adds clutter to the class, to mitigate against a case that isn&#8217;t that common and is easily avoidable with good habits.\n<\/li>\n<li>Having an rvalue overload return by value means we have to pay for the cost of a copy (or move) even in cases where we could have used a reference safely (e.g. in case 1 of the example at the top of the lesson).\n<\/li>\n<\/ul>\n<p>Additionally:<\/p>\n<ul>\n<li>Most C++ developers are not aware of this feature (which can lead to errors or inefficiencies in use).\n<\/li>\n<li>The standard library typically does not make use of this feature.\n<\/li>\n<\/ul>\n<p>Based on all of the above, we are not recommending the use of ref-qualifiers as a best practice.  Instead, we recommend always using the result of an access function immediately and not saving returned references for use later.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-15-summary-and-quiz\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">15.x<\/span>Chapter 15 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/friend-classes-and-friend-member-functions\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">15.9<\/span>Friend classes and friend member functions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Author&#8217;s note This is an optional lesson. We recommend having a light read-through to familiarize yourself with the material, but comprehensive understanding is not required to proceed with future lessons. In lesson , we discussed how calling access functions that return references to data members can be dangerous when the &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15865"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15865"}],"version-history":[{"count":15,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15865\/revisions"}],"predecessor-version":[{"id":17666,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15865\/revisions\/17666"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15865"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15865"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15865"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}