{"id":66,"date":"2007-06-19T17:46:40","date_gmt":"2007-06-20T01:46:40","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/43-file-scope-and-the-static-keyword\/"},"modified":"2024-12-26T12:39:19","modified_gmt":"2024-12-26T20:39:19","slug":"static-local-variables","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/static-local-variables\/","title":{"rendered":"7.11 &#8212; Static local variables"},"content":{"rendered":"<p>The term <code>static<\/code> is one of the most confusing terms in the C++ language, in large part because <code>static<\/code> has different meanings in different contexts.<\/p>\n<p>In prior lessons, we covered that global variables have static duration, which means they are created when the program starts and destroyed when the program ends.<\/p>\n<p>We also discussed how the <code>static<\/code> keyword gives a global identifier internal-linkage, which means the identifier can only be used in the file in which it is defined.<\/p>\n<p>In this lesson, we&#8217;ll explore the use of the <code>static<\/code> keyword when applied to a local variable.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Static local variables<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-local-scope\/\">2.5 -- Introduction to local scope<\/a>, you learned that local variables have automatic duration by default, which means they are created at the point of definition, and destroyed when the block is exited.<\/p>\n<p>Using the <code>static<\/code> keyword on a local variable changes its duration from automatic duration to static duration.  This means the variable is now created at the start of the program, and destroyed at the end of the program (just like a global variable).  As a result, the static variable will retain its value even after it goes out of scope!<\/p>\n<p>The easiest way to show the difference between automatic duration and static duration local variables is by example.<\/p>\n<p>Automatic duration (default):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid incrementAndPrint()\r\n{\r\n    int value{ 1 }; \/\/ automatic duration by default\r\n    ++value;\r\n    std::cout &lt;&lt; value &lt;&lt; '\\n';\r\n} \/\/ value is destroyed here\r\n\r\nint main()\r\n{\r\n    incrementAndPrint();\r\n    incrementAndPrint();\r\n    incrementAndPrint();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Each time <code>incrementAndPrint()<\/code> is called, a variable named value is created and assigned the value of <code>1<\/code>.  <code>incrementAndPrint()<\/code> increments value to <code>2<\/code>, and then prints the value of <code>2<\/code>.  When <code>incrementAndPrint()<\/code> is finished running, the variable goes out of scope and is destroyed.  Consequently, this program outputs:<\/p>\n<pre>\n2\r\n2\r\n2\r\n<\/pre>\n<p>Now consider a version of this program that uses a static local variable.  The only difference between this and the above program is that we&#8217;ve changed the local variable from automatic duration to static duration by using the <code>static<\/code> keyword.<\/p>\n<p>Static duration (using static keyword):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid incrementAndPrint()\r\n{\r\n    static int s_value{ 1 }; \/\/ static duration via static keyword.  This initializer is only executed once.\r\n    ++s_value;\r\n    std::cout &lt;&lt; s_value &lt;&lt; '\\n';\r\n} \/\/ s_value is not destroyed here, but becomes inaccessible because it goes out of scope\r\n\r\nint main()\r\n{\r\n    incrementAndPrint();\r\n    incrementAndPrint();\r\n    incrementAndPrint();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this program, because <code>s_value<\/code> has been declared as <code>static<\/code>, it is created at the program start.<\/p>\n<p>Static local variables that are zero-initialized or have a constexpr initializer can be initialized at program start.<\/p>\n<p>Static local variables that have no initializer or a non-constexpr initializer are zero-initialized at program start.  Static local variables with a non-constexpr initializer are reinitialized the first time the variable definition is encountered.  The definition is skipped on subsequent calls, so no futher reinitialization happens.  Because they have static duration, static local variables that are not explicitly initialized will be zero-initialized by default.<\/p>\n<p>Because <code>s_value<\/code> has constexpr initializer <code>1<\/code>, <code>s_value<\/code> will be initialized at program start.<\/p>\n<p>When <code>s_value<\/code> goes out of scope at the end of the function, it is not destroyed.  Each time the function <code>incrementAndPrint()<\/code> is called, the value of <code>s_value<\/code> remains at whatever we left it at previously.  Consequently, this program outputs:<\/p>\n<pre>\n2\r\n3\r\n4\r\n<\/pre>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Static local variables are used when you need a local variable to remember its value across function calls.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Initialize your static local variables.  Static local variables are only initialized the first time the code is executed, not on subsequent calls.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>Just like we use &#8220;g_&#8221; to prefix global variables, it&#8217;s common to use &#8220;s_&#8221; to prefix static (static duration) local variables.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">ID generation<\/p>\n<p>One of the most common uses for static duration local variables is for unique ID generators.  Imagine a program where you have many similar objects (e.g. a game where you&#8217;re being attacked by many zombies, or a simulation where you&#8217;re displaying many triangles).  If you notice a defect, it can be near impossible to distinguish which object is having problems.  However, if each object is given a unique identifier upon creation, then it can be easier to differentiate the objects for further debugging.<\/p>\n<p>Generating a unique ID number is very easy to do with a static duration local variable:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int generateID()\r\n{\r\n    static int s_itemID{ 0 };\r\n    return s_itemID++; \/\/ makes copy of s_itemID, increments the real s_itemID, then returns the value in the copy\r\n}<\/code><\/pre>\n<p>The first time this function is called, it returns <code>0<\/code>.  The second time, it returns <code>1<\/code>.  Each time it is called, it returns a number one higher than the previous time it was called.  You can assign these numbers as unique IDs for your objects.  Because <code>s_itemID<\/code> is a local variable, it can not be &#8220;tampered with&#8221; by other functions.<\/p>\n<p>Static variables offer some of the benefit of global variables (they don&#8217;t get destroyed until the end of the program) while limiting their visibility to block scope.  This makes them easier to understand and safer to use.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>A static local variable has block scope like a local variable, but its lifetime is until the end of the program like a global variable.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Static local constants<\/p>\n<p>Static local variables can be made const (or constexpr).  One good use for a const static local variable is when you have a function that needs to use a const value, but creating or initializing the object is expensive (e.g. you need to read the value from a database).  If you used a normal local variable, the variable would be created and initialized every time the function was executed.  With a const\/constexpr static local variable, you can create and initialize the expensive object once, and then reuse it whenever the function is called.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Static local variables are best used to avoid expensive local object initialization each time a function is called.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Don&#8217;t use static local variables to alter flow<\/p>\n<p>Consider the following code:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint getInteger()\r\n{\r\n\tstatic bool s_isFirstCall{ true };\r\n\r\n\tif (s_isFirstCall)\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Enter an integer: \";\r\n\t\ts_isFirstCall = false;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Enter another integer: \";\r\n\t}\r\n\r\n\tint i{};\r\n\tstd::cin &gt;&gt; i;\r\n\treturn i;\r\n}\r\n\r\nint main()\r\n{\r\n\tint a{ getInteger() };\r\n\tint b{ getInteger() };\r\n\r\n\tstd::cout &lt;&lt; a &lt;&lt; \" + \" &lt;&lt; b &lt;&lt; \" = \" &lt;&lt; (a + b) &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Sample output<\/p>\n<pre>\nEnter an integer: 5\r\nEnter another integer: 9\r\n5 + 9 = 14\r\n<\/pre>\n<p>This code does what it&#8217;s supposed to do, but because we used a static local variable, we made the code harder to understand. If someone reads the code in <code>main()<\/code> without reading the implementation of <code>getInteger()<\/code>, they&#8217;d have no reason to assume that the two calls to <code>getInteger()<\/code> do something different. But the two calls do something different, which can be very confusing if the difference is more than a changed prompt.<\/p>\n<p>Say you press the +1 button on your microwave and the microwave adds 1 minute to the remaining time. Your meal is warm and you&#8217;re happy. Before you take your meal out of the microwave, you see a cat outside your window and watch it for a moment, because cats are cool. The moment turned out to be longer than you expected and when you take the first bite of your meal, it&#8217;s cold again. No problem, just put it back into the microwave and press +1 to run it for a minute. But this time the microwave adds only 1 second and not 1 minute. That&#8217;s when you go &#8220;I changed nothing and now it&#8217;s broken&#8221; or &#8220;It worked last time&#8221;. If you do the same thing again, you&#8217;d expect the same behavior as last time. The same goes for functions.<\/p>\n<p>Suppose we want to add subtraction to the calculator such that the output looks like the following:<\/p>\n<pre>\nAddition\r\nEnter an integer: 5\r\nEnter another integer: 9\r\n5 + 9 = 14\r\nSubtraction\r\nEnter an integer: 12\r\nEnter another integer: 3\r\n12 - 3 = 9\r\n<\/pre>\n<p>We might try to use <code>getInteger()<\/code> to read in the next two integers like we did for addition.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n  std::cout &lt;&lt; \"Addition\\n\";\r\n\r\n  int a{ getInteger() };\r\n  int b{ getInteger() };\r\n\r\n  std::cout &lt;&lt; a &lt;&lt; \" + \" &lt;&lt; b &lt;&lt; \" = \" &lt;&lt; (a + b) &lt;&lt; '\\n';\r\n\r\n  std::cout &lt;&lt; \"Subtraction\\n\";\r\n\r\n  int c{ getInteger() };\r\n  int d{ getInteger() };\r\n\r\n  std::cout &lt;&lt; c &lt;&lt; \" - \" &lt;&lt; d &lt;&lt; \" = \" &lt;&lt; (c - d) &lt;&lt; '\\n';\r\n\r\n  return 0;\r\n}<\/code><\/pre>\n<p>But this won&#8217;t do as we want, as the output is:<\/p>\n<pre>\nAddition\r\nEnter an integer: 5\r\nEnter another integer: 9\r\n5 + 9 = 14\r\nSubtraction\r\nEnter another integer: 12\r\nEnter another integer: 3\r\n12 - 3 = 9\r\n<\/pre>\n<p>(The third-to-last line is &#8220;Enter another integer&#8221; instead of &#8220;Enter an integer&#8221;)<\/p>\n<p><code>getInteger()<\/code> is not reusable, because it has an internal state (The static local variable <code>s_isFirstCall<\/code>) which cannot be reset from the outside. <code>s_isFirstCall<\/code> is not a variable that should be unique in the entire program. Although our program worked great when we first wrote it, the static local variable prevents us from reusing the function later on.<\/p>\n<p>One better way of implementing <code>getInteger<\/code> is to pass <code>s_isFirstCall<\/code> as a parameter. This allows the caller to choose which prompt will be printed:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ We'll define a symbolic constant with a nice name\r\nconstexpr bool g_firstCall { true };\r\n\r\nint getInteger(bool bFirstCall)\r\n{\r\n\tif (bFirstCall)\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Enter an integer: \";\r\n\t}\r\n\telse\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Enter another integer: \";\r\n\t}\r\n\r\n\tint i{};\r\n\tstd::cin &gt;&gt; i;\r\n\treturn i;\r\n}\r\n\r\nint main()\r\n{\r\n\tint a{ getInteger(g_firstCall) };  \/\/ so that it's clearer what the argument represents here\r\n\tint b{ getInteger(!g_firstCall) };\r\n\r\n\tstd::cout &lt;&lt; a &lt;&lt; \" + \" &lt;&lt; b &lt;&lt; \" = \" &lt;&lt; (a + b) &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Non-const static local variables should only be used if in your entire program and in the foreseeable future of your program, the variable is unique and it wouldn&#8217;t make sense to reset the variable.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Const static local variables are generally okay to use.<\/p>\n<p>Non-const static local variables should generally be avoided.  If you do use them, ensure the variable never needs to be reset, and isn&#8217;t used to alter program flow.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>An even more reusable solution would be to change the <code>bool<\/code> parameter to <code>std::string_view<\/code> and let the caller pass in the text prompt that will be used!\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>In cases where you need multiple instances of a non-const variable that remembers its value (e.g. to have multiple ID generators), a functor is a good solution (see lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-the-parenthesis-operator\/\">21.10 -- Overloading the parenthesis operator<\/a>).\n<\/p><\/div>\n<p><p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p><p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p><\/p>\n<p>What effect does using keyword <code>static<\/code> have on a global variable?  What effect does it have on a local variable?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>When applied to a global variable, the static keyword defines the global variable as having internal linkage, meaning the variable cannot be exported to other files.<\/p>\n<p>When applied to a local variable, the static keyword defines the local variable as having static duration, meaning the variable will only be created once, and will not be destroyed until the end of the program.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/scope-duration-and-linkage-summary\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.12<\/span>Scope, duration, and linkage summary\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/sharing-global-constants-across-multiple-files-using-inline-variables\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.10<\/span>Sharing global constants across multiple files (using inline variables)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>The term static is one of the most confusing terms in the C++ language, in large part because static has different meanings in different contexts. In prior lessons, we covered that global variables have static duration, which means they are created when the program starts and destroyed when the program &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/66"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=66"}],"version-history":[{"count":41,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/66\/revisions"}],"predecessor-version":[{"id":18016,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/66\/revisions\/18016"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=66"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=66"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=66"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}