{"id":9367,"date":"2020-01-03T05:19:35","date_gmt":"2020-01-03T13:19:35","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=9367"},"modified":"2024-06-14T14:42:02","modified_gmt":"2024-06-14T21:42:02","slug":"introduction-to-lambdas-anonymous-functions","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-lambdas-anonymous-functions\/","title":{"rendered":"20.6 &#8212; Introduction to lambdas (anonymous functions)"},"content":{"rendered":"<p>Consider this snippet of code that we introduced in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-standard-library-algorithms\/\">18.3 -- Introduction to standard library algorithms<\/a>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt;\r\n#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\n\/\/ Our function will return true if the element matches\r\nbool containsNut(std::string_view str)\r\n{\r\n    \/\/ std::string_view::find returns std::string_view::npos if it doesn't find\r\n    \/\/ the substring. Otherwise it returns the index where the substring occurs\r\n    \/\/ in str.\r\n    return str.find(\"nut\") != std::string_view::npos;\r\n}\r\n\r\nint main()\r\n{\r\n    constexpr std::array&lt;std::string_view, 4&gt; arr{ \"apple\", \"banana\", \"walnut\", \"lemon\" };\r\n\r\n    \/\/ Scan our array to see if any elements contain the \"nut\" substring\r\n    auto found{ std::find_if(arr.begin(), arr.end(), containsNut) };\r\n\r\n    if (found == arr.end())\r\n    {\r\n        std::cout &lt;&lt; \"No nuts\\n\";\r\n    }\r\n    else\r\n    {\r\n        std::cout &lt;&lt; \"Found \" &lt;&lt; *found &lt;&lt; '\\n';\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This code searches through an array of strings looking for the first element that contains the substring &#8220;nut&#8221;.  Thus, it produces the result:<\/p>\n<pre>\r\nFound walnut\r\n<\/pre>\n<p>And while it works, it could be improved.<\/p>\n<p>The root of the issue here is that <code>std::find_if<\/code> requires that we pass it a function pointer.  Because of that, we are forced to define a function that&#8217;s only going to be used once, that must be given a name, and that must be put in the global scope (because functions can&#8217;t be nested!).  The function is also so short, it&#8217;s almost easier to discern what it does from the one line of code than from the name and comments.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Lambdas are anonymous functions<\/p>\n<p>A <strong>lambda expression<\/strong> (also called a <strong>lambda<\/strong> or <strong>closure<\/strong>) allows us to define an anonymous function inside another function.  The nesting is important, as it allows us both to avoid namespace naming pollution, and to define the function as close to where it is used as possible (providing additional context).<\/p>\n<p>The syntax for lambdas is one of the weirder things in C++, and takes a bit of getting used to.  Lambdas take the form:<\/p>\n<pre>\r\n[ captureClause ] ( parameters ) -&gt; returnType\r\n{\r\n    statements;\r\n}\r\n<\/pre>\n<ul>\n<li>The capture clause can be empty if no captures are needed.\n<\/li>\n<li>The parameter list can be empty if no parameters are required.  It can also be omitted entirely unless a return type is specified.\n<\/li>\n<li>The return type is optional, and if omitted, <code>auto<\/code> will be assumed (thus using type deduction used to determine the return type).  While we previously noted that type deduction for function return types should be avoided, in this context, it&#8217;s fine to use (because these functions are typically so trivial).\n<\/li>\n<\/ul>\n<p>Also note that lambdas (being anonymous) have no name, so we don&#8217;t need to provide one.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>This means a trivial lambda definition looks like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n  [] {}; \/\/ a lambda with an omitted return type, no captures, and omitted parameters.\r\n\r\n  return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>Let&#8217;s rewrite the above example using a lambda:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt;\r\n#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nint main()\r\n{\r\n  constexpr std::array&lt;std::string_view, 4&gt; arr{ \"apple\", \"banana\", \"walnut\", \"lemon\" };\r\n\r\n  \/\/ Define the function right where we use it.\r\n  auto found{ std::find_if(arr.begin(), arr.end(),\r\n                           [](std::string_view str) \/\/ here's our lambda, no capture clause\r\n                           {\r\n                             return str.find(\"nut\") != std::string_view::npos;\r\n                           }) };\r\n\r\n  if (found == arr.end())\r\n  {\r\n    std::cout &lt;&lt; \"No nuts\\n\";\r\n  }\r\n  else\r\n  {\r\n    std::cout &lt;&lt; \"Found \" &lt;&lt; *found &lt;&lt; '\\n';\r\n  }\r\n\r\n  return 0;\r\n}<\/code><\/pre>\n<p>This works just like the function pointer case, and produces an identical result:<\/p>\n<pre>\r\nFound walnut\r\n<\/pre>\n<p>Note how similar our lambda is to our <code>containsNut<\/code> function.  They both have identical parameters and function bodies.  The lambda has no capture clause (we&#8217;ll explain what a capture clause is in the next lesson) because it doesn&#8217;t need one.  And we&#8217;ve omitted the trailing return type in the lambda (for conciseness), but since <code>operator!=<\/code> returns a <code>bool<\/code>, our lambda will return a <code>bool<\/code> too.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Following the best practice of defining things in the smallest scope and closest to first use, lambdas are preferred over normal functions when we need a trivial, one-off function to pass as an argument to some other function.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Type of a lambda<\/p>\n<p>In the above example, we defined a lambda right where it was needed.  This use of a lambda is sometimes called a <strong>function literal<\/strong>.<\/p>\n<p>However, writing a lambda in the same line as it&#8217;s used can sometimes make code harder to read.  Much like we can initialize a variable with a literal value (or a function pointer) for use later, we can also initialize a lambda variable with a lambda definition and then use it later.  A named lambda along with a good function name can make code easier to read.<\/p>\n<p>For example, in the following snippet, we&#8217;re using <code>std::all_of<\/code> to check if all elements of an array are even:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Bad: We have to read the lambda to understand what's happening.\r\nreturn std::all_of(array.begin(), array.end(), [](int i){ return ((i % 2) == 0); });<\/code><\/pre>\n<p>We can improve the readability of this as follows:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Good: Instead, we can store the lambda in a named variable and pass it to the function.\r\nauto isEven{\r\n  [](int i)\r\n  {\r\n    return (i % 2) == 0;\r\n  }\r\n};\r\n\r\nreturn std::all_of(array.begin(), array.end(), isEven);<\/code><\/pre>\n<p>Note how well the last line reads: &#8220;return whether <em>all of<\/em> the elements in the <em>array<\/em> are <em>even<\/em>&#8221;<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Storing a lambda in a variable provides a way for us to give the lambda a useful name, which can help make our code more readable.<\/p>\n<p>Storing a lambda in a variable also provides us with a way to use that lambda more than once.\n<\/p><\/div>\n<p>But what is the type of lambda <code>isEven<\/code>?<\/p>\n<p>As it turns out, lambdas don&#8217;t have a type that we can explicitly use.  When we write a lambda, the compiler generates a unique type just for the lambda that is not exposed to us.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>In actuality, lambdas aren&#8217;t functions (which is part of how they avoid the limitation of C++ not supporting nested functions).  They&#8217;re a special kind of object called a functor.  Functors are objects that contain an overloaded <code>operator()<\/code> that make them callable like a function.\n<\/div>\n<p>Although we don&#8217;t know the type of a lambda, there are several ways of storing a lambda for use post-definition. If the lambda has an empty capture clause (nothing between the hard brackets []), we can use a regular function pointer.  <code>std::function<\/code> or type deduction via the <code>auto<\/code> keyword will also work (even if the lambda has a non-empty capture clause).<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;functional&gt;\r\n\r\nint main()\r\n{\r\n  \/\/ A regular function pointer. Only works with an empty capture clause (empty []).\r\n  double (*addNumbers1)(double, double){\r\n    [](double a, double b) {\r\n      return a + b;\r\n    }\r\n  };\r\n\r\n  addNumbers1(1, 2);\r\n\r\n  \/\/ Using std::function. The lambda could have a non-empty capture clause (discussed next lesson).\r\n  std::function addNumbers2{ \/\/ note: pre-C++17, use std::function&lt;double(double, double)&gt; instead\r\n    [](double a, double b) {\r\n      return a + b;\r\n    }\r\n  };\r\n\r\n  addNumbers2(3, 4);\r\n\r\n  \/\/ Using auto. Stores the lambda with its real type.\r\n  auto addNumbers3{\r\n    [](double a, double b) {\r\n      return a + b;\r\n    }\r\n  };\r\n\r\n  addNumbers3(5, 6);\r\n\r\n  return 0;\r\n}<\/code><\/pre>\n<p>The only way of using the lambda&#8217;s actual type is by means of <code>auto<\/code>. <code>auto<\/code> also has the benefit of having no overhead compared to <code>std::function<\/code>.<\/p>\n<p>What if we want to pass a lambda to a function?  There are 4 options:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;functional&gt;\r\n#include &lt;iostream&gt;\r\n\r\n\/\/ Case 1: use a `std::function` parameter\r\nvoid repeat1(int repetitions, const std::function&lt;void(int)&gt;&amp; fn)\r\n{\r\n    for (int i{ 0 }; i &lt; repetitions; ++i)\r\n        fn(i);\r\n}\r\n\r\n\/\/ Case 2: use a function template with a type template parameter\r\ntemplate &lt;typename T&gt;\r\nvoid repeat2(int repetitions, const T&amp; fn)\r\n{\r\n    for (int i{ 0 }; i &lt; repetitions; ++i)\r\n        fn(i);\r\n}\r\n\r\n\/\/ Case 3: use the abbreviated function template syntax (C++20)\r\nvoid repeat3(int repetitions, const auto&amp; fn)\r\n{\r\n    for (int i{ 0 }; i &lt; repetitions; ++i)\r\n        fn(i);\r\n}\r\n\r\n\/\/ Case 4: use function pointer (only for lambda with no captures)\r\nvoid repeat4(int repetitions, void (*fn)(int))\r\n{\r\n    for (int i{ 0 }; i &lt; repetitions; ++i)\r\n        fn(i);   \r\n}\r\n\r\nint main()\r\n{\r\n    auto lambda = [](int i)\r\n    {\r\n        std::cout &lt;&lt; i &lt;&lt; '\\n';\r\n    };\r\n\r\n    repeat1(3, lambda);\r\n    repeat2(3, lambda);\r\n    repeat3(3, lambda);\r\n    repeat4(3, lambda);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In case 1, our function parameter is a <code>std::function<\/code>.  This is nice because we can explicitly see what the parameters and return type of the <code>std::function<\/code> are.  However, this requires the lambda to be implicitly converted whenever the function is called, which adds some overhead.  This method also has the benefit of being separable into a declaration (in a header) and a definition (in a .cpp file) if that&#8217;s desirable.<\/p>\n<p>In case 2, we&#8217;re using a function template with type template parameter <code>T<\/code>.  When the function is called, a function will be instantiated where <code>T<\/code> matches the actual type of the lambda.  This is more efficient, but the parameters and return type of <code>T<\/code> are not obvious.<\/p>\n<p>In case 3, we use C++20&#8217;s <code>auto<\/code> to invoke the abbreviated function template syntax.  This generates a function template identical to case 2. <\/p>\n<p>In case 4, the function parameter is a function pointer.  Since a lambda with no captures will implicitly convert to a function pointer, we can pass a lambda with no captures to this function.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>When storing a lambda in a variable, use <code>auto<\/code> as the variable&#8217;s type.<\/p>\n<p>When passing a lambda to a function:<\/p>\n<ul>\n<li>If C++20 capable, use <code>auto<\/code> as the parameter&#8217;s type.\n<\/li>\n<li>Otherwise, use a function with a type template parameter or <code>std::function<\/code> parameter (or a function pointer if the lambda has no captures).\n<\/li>\n<\/ul>\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Generic lambdas<\/p>\n<p>For the most part, lambda parameters work by the same rules as regular function parameters.<\/p>\n<p>One notable exception is that since C++14 we&#8217;re allowed to use <code>auto<\/code> for parameters (note: in C++20, regular functions are able to use <code>auto<\/code> for parameters too).  When a lambda has one or more <code>auto<\/code> parameter, the compiler will infer what parameter types are needed from the calls to the lambda.<\/p>\n<p>Because lambdas with one or more <code>auto<\/code> parameter can potentially work with a wide variety of types, they are called <strong>generic lambdas<\/strong>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>When used in the context of a lambda, <code>auto<\/code> is just a shorthand for a template parameter.\n<\/div>\n<p>Let&#8217;s take a look at a generic lambda:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt;\r\n#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nint main()\r\n{\r\n  constexpr std::array months{ \/\/ pre-C++17 use std::array&lt;const char*, 12&gt;\r\n    \"January\",\r\n    \"February\",\r\n    \"March\",\r\n    \"April\",\r\n    \"May\",\r\n    \"June\",\r\n    \"July\",\r\n    \"August\",\r\n    \"September\",\r\n    \"October\",\r\n    \"November\",\r\n    \"December\"\r\n  };\r\n\r\n  \/\/ Search for two consecutive months that start with the same letter.\r\n  const auto sameLetter{ std::adjacent_find(months.begin(), months.end(),\r\n                                      [](const auto&amp; a, const auto&amp; b) {\r\n                                        return a[0] == b[0];\r\n                                      }) };\r\n\r\n  \/\/ Make sure that two months were found.\r\n  if (sameLetter != months.end())\r\n  {\r\n    \/\/ std::next returns the next iterator after sameLetter\r\n    std::cout &lt;&lt; *sameLetter &lt;&lt; \" and \" &lt;&lt; *std::next(sameLetter)\r\n              &lt;&lt; \" start with the same letter\\n\";\r\n  }\r\n\r\n  return 0;\r\n}<\/code><\/pre>\n<p>Output:<\/p>\n<pre>\r\nJune and July start with the same letter\r\n<\/pre>\n<p>In the above example, we use <code>auto<\/code> parameters to capture our strings by <code>const<\/code> reference.  Because all string types allow access to their individual characters via <code>operator[]<\/code>, we don&#8217;t need to care whether the user is passing in a <code>std::string<\/code>, C-style string, or something else.  This allows us to write a lambda that could accept any of these, meaning if we change the type of <code>months<\/code> later, we won&#8217;t have to rewrite the lambda.<\/p>\n<p>However, <code>auto<\/code> isn&#8217;t always the best choice.  Consider:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt;\r\n#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nint main()\r\n{\r\n  constexpr std::array months{ \/\/ pre-C++17 use std::array&lt;const char*, 12&gt;\r\n    \"January\",\r\n    \"February\",\r\n    \"March\",\r\n    \"April\",\r\n    \"May\",\r\n    \"June\",\r\n    \"July\",\r\n    \"August\",\r\n    \"September\",\r\n    \"October\",\r\n    \"November\",\r\n    \"December\"\r\n  };\r\n\r\n  \/\/ Count how many months consist of 5 letters\r\n  const auto fiveLetterMonths{ std::count_if(months.begin(), months.end(),\r\n                                       [](std::string_view str) {\r\n                                         return str.length() == 5;\r\n                                       }) };\r\n\r\n  std::cout &lt;&lt; \"There are \" &lt;&lt; fiveLetterMonths &lt;&lt; \" months with 5 letters\\n\";\r\n\r\n  return 0;\r\n}<\/code><\/pre>\n<p>Output:<\/p>\n<pre>\r\nThere are 2 months with 5 letters\r\n<\/pre>\n<p>In this example, using <code>auto<\/code> would infer a type of <code>const char*<\/code>.  C-style strings aren&#8217;t easy to work with (apart from using <code>operator[]<\/code>).  In this case, we prefer to explicitly define the parameter as a <code>std::string_view<\/code>, which allows us to work with the underlying data much more easily (e.g. we can ask the string view for its length, even if the user passed in a C-style array).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constexpr lambdas<\/p>\n<p>As of C++17, lambdas are implicitly constexpr if the result satisfies the requirements of a constant expression.  This generally requires two things:<\/p>\n<ul>\n<li>The lambda must either have no captures, or all captures must be constexpr.\n<\/li>\n<li>The functions called by the lambda must be constexpr.  Note that many standard library algorithms and math functions weren&#8217;t made constexpr until C++20 or C++23.\n<\/li>\n<\/ul>\n<p>In the above example, our lambda would not be implicitly constexpr in C++17 but it would be in C++20 (as <code>std::count_if<\/code> was made constexpr in C++20).  This means in C++20 we can make <code>fiveLetterMonths<\/code> constexpr:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">  constexpr auto fiveLetterMonths{ std::count_if(months.begin(), months.end(),\r\n                                       [](std::string_view str) {\r\n                                         return str.length() == 5;\r\n                                       }) };<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Generic lambdas and static variables<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-template-instantiation\/\">11.7 -- Function template instantiation<\/a>, we discussed that when a function template contains a static local variable, each function instantiated from that template will receive its own independent static local variable.  This may cause issues if that is not expected.<\/p>\n<p>Generic lambdas work the same way: a unique lambda will be generated for each different type that <code>auto<\/code> resolves to.<\/p>\n<p>The following example shows how one generic lambda turns into two distinct lambdas:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt;\r\n#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nint main()\r\n{\r\n  \/\/ Print a value and count how many times @print has been called.\r\n  auto print{\r\n    [](auto value) {\r\n      static int callCount{ 0 };\r\n      std::cout &lt;&lt; callCount++ &lt;&lt; \": \" &lt;&lt; value &lt;&lt; '\\n';\r\n    }\r\n  };\r\n\r\n  print(\"hello\"); \/\/ 0: hello\r\n  print(\"world\"); \/\/ 1: world\r\n\r\n  print(1); \/\/ 0: 1\r\n  print(2); \/\/ 1: 2\r\n\r\n  print(\"ding dong\"); \/\/ 2: ding dong\r\n\r\n  return 0;\r\n}<\/code><\/pre>\n<p>Output<\/p>\n<pre>\r\n0: hello\r\n1: world\r\n0: 1\r\n1: 2\r\n2: ding dong\r\n<\/pre>\n<p>In the above example, we define a lambda and then call it with two different parameters (a string literal parameter, and an integer parameter).  This generates two different versions of the lambda (one with a string literal parameter, and one with an integer parameter).<\/p>\n<p>Most of the time, this is inconsequential.  However, note that if the generic lambda uses static duration variables, those variables are not shared between the generated lambdas. <\/p>\n<p>We can see this in the example above, where each type (string literals and integers) has its own unique count!  Although we only wrote the lambda once, two lambdas were generated -- and each has its own version of <code>callCount<\/code>. To have a shared counter between the two generated lambdas, we&#8217;d have to define a global variable or a <code>static<\/code> local variable outside of the lambda. As you know from previous lessons, both global- and static local variables can cause problems and make it more difficult to understand code. We&#8217;ll be able to avoid those variables after talking about lambda captures in the next lesson.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Return type deduction and trailing return types<\/p>\n<p>If return type deduction is used, a lambda&#8217;s return type is deduced from the <code>return<\/code>-statements inside the lambda, and all return statements in the lambda must return the same type (otherwise the compiler won&#8217;t know which one to prefer).<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n  auto divide{ [](int x, int y, bool intDivision) { \/\/ note: no specified return type\r\n    if (intDivision)\r\n      return x \/ y; \/\/ return type is int\r\n    else\r\n      return static_cast&lt;double&gt;(x) \/ y; \/\/ ERROR: return type doesn't match previous return type\r\n  } };\r\n\r\n  std::cout &lt;&lt; divide(3, 2, true) &lt;&lt; '\\n';\r\n  std::cout &lt;&lt; divide(3, 2, false) &lt;&lt; '\\n';\r\n\r\n  return 0;\r\n}<\/code><\/pre>\n<p>This produces a compile error because the return type of the first return statement (int) doesn&#8217;t match the return type of the second return statement (double).<\/p>\n<p>In the case where we&#8217;re returning different types, we have two options:<\/p>\n<ol start=\"1\">\n<li>Do explicit casts to make all the return types match, or\n<\/li>\n<li>explicitly specify a return type for the lambda, and let the compiler do implicit conversions.\n<\/li>\n<\/ol>\n<p>The second case is usually the better choice:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n  \/\/ note: explicitly specifying this returns a double\r\n  auto divide{ [](int x, int y, bool intDivision) -&gt; double {\r\n    if (intDivision)\r\n      return x \/ y; \/\/ will do an implicit conversion of result to double\r\n    else\r\n      return static_cast&lt;double&gt;(x) \/ y;\r\n  } };\r\n\r\n  std::cout &lt;&lt; divide(3, 2, true) &lt;&lt; '\\n';\r\n  std::cout &lt;&lt; divide(3, 2, false) &lt;&lt; '\\n';\r\n\r\n  return 0;\r\n}<\/code><\/pre>\n<p>That way, if you ever decide to change the return type, you (usually) only need to change the lambda&#8217;s return type, and not touch the lambda body.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Standard library function objects<\/p>\n<p>For common operations (e.g. addition, negation, or comparison) you don&#8217;t need to write your own lambdas, because the standard library comes with many basic callable objects that can be used instead.  These are defined in the <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/utility\/functional#Operator_function_objects\">&lt;functional&gt;<\/a> header.<\/p>\n<p>In the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt;\r\n#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nbool greater(int a, int b)\r\n{\r\n  \/\/ Order @a before @b if @a is greater than @b.\r\n  return a &gt; b;\r\n}\r\n\r\nint main()\r\n{\r\n  std::array arr{ 13, 90, 99, 5, 40, 80 };\r\n\r\n  \/\/ Pass greater to std::sort\r\n  std::sort(arr.begin(), arr.end(), greater);\r\n\r\n  for (int i : arr)\r\n  {\r\n    std::cout &lt;&lt; i &lt;&lt; ' ';\r\n  }\r\n\r\n  std::cout &lt;&lt; '\\n';\r\n\r\n  return 0;\r\n}<\/code><\/pre>\n<p>Output<\/p>\n<pre>\r\n99 90 80 40 13 5\r\n<\/pre>\n<p>Instead of converting our <code>greater<\/code> function to a lambda (which would obscure its meaning a bit), we can instead use <code>std::greater<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt;\r\n#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;functional&gt; \/\/ for std::greater\r\n\r\nint main()\r\n{\r\n  std::array arr{ 13, 90, 99, 5, 40, 80 };\r\n\r\n  \/\/ Pass std::greater to std::sort\r\n  std::sort(arr.begin(), arr.end(), std::greater{}); \/\/ note: need curly braces to instantiate object\r\n\r\n  for (int i : arr)\r\n  {\r\n    std::cout &lt;&lt; i &lt;&lt; ' ';\r\n  }\r\n\r\n  std::cout &lt;&lt; '\\n';\r\n\r\n  return 0;\r\n}<\/code><\/pre>\n<p>Output<\/p>\n<pre>\r\n99 90 80 40 13 5\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Conclusion<\/p>\n<p>Lambdas and the algorithm library may seem unnecessarily complicated when compared to a solution that uses a loop.  However, this combination can allow some very powerful operations in just a few lines of code, and can be more readable than writing your own loops.  On top of that, the algorithm library features powerful and easy-to-use parallelism, which you won&#8217;t get with loops. Upgrading source code that uses library functions is easier than upgrading code that uses loops.<\/p>\n<p>Lambdas are great, but they don&#8217;t replace regular functions for all cases.  Prefer regular functions for non-trivial and reusable cases.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #1<\/p>\n<p>\nCreate a <code>struct Student<\/code> that stores the name and points of a student. Create an array of students and use <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/algorithm\/max_element\"><code>std::max_element<\/code><\/a> to find the student with the most points, then print that student&#8217;s name. <code>std::max_element<\/code> takes the <code>begin<\/code> and <code>end<\/code> of a list, and a function that takes 2 parameters and returns <code>true<\/code> if the first argument is less than the second.<\/p>\n<p>Given the following array<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::array&lt;Student, 8&gt; arr{\r\n  { { \"Albert\", 3 },\r\n    { \"Ben\", 5 },\r\n    { \"Christine\", 2 },\r\n    { \"Dan\", 8 }, \/\/ Dan has the most points (8).\r\n    { \"Enchilada\", 4 },\r\n    { \"Francis\", 1 },\r\n    { \"Greg\", 3 },\r\n    { \"Hagrid\", 5 } }\r\n};<\/code><\/pre>\n<p>your program should print<\/p>\n<pre>\r\nDan is the best student\r\n<\/pre>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_0'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_0\" style=\"display:none; margin-bottom: 1em\">Hint: <\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt;\r\n#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nstruct Student\r\n{\r\n  std::string_view name{};\r\n  int points{};\r\n};\r\n\r\nint main()\r\n{\r\n  constexpr std::array&lt;Student, 8&gt; arr{\r\n    { { \"Albert\", 3 },\r\n      { \"Ben\", 5 },\r\n      { \"Christine\", 2 },\r\n      { \"Dan\", 8 },\r\n      { \"Enchilada\", 4 },\r\n      { \"Francis\", 1 },\r\n      { \"Greg\", 3 },\r\n      { \"Hagrid\", 5 } }\r\n  };\r\n\r\n  const auto best{\r\n    std::max_element(arr.begin(), arr.end(), \/* lambda *\/) \/\/ returns an iterator\r\n  };\r\n\r\n  std::cout &lt;&lt; best-&gt;name &lt;&lt; \" is the best student\\n\"; \/\/ must dereference iterator to get element\r\n\r\n  return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt;\r\n#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nstruct Student\r\n{\r\n  std::string_view name{};\r\n  int points{};\r\n};\r\n\r\nint main()\r\n{\r\n  constexpr std::array&lt;Student, 8&gt; arr{\r\n    { { \"Albert\", 3 },\r\n      { \"Ben\", 5 },\r\n      { \"Christine\", 2 },\r\n      { \"Dan\", 8 },\r\n      { \"Enchilada\", 4 },\r\n      { \"Francis\", 1 },\r\n      { \"Greg\", 3 },\r\n      { \"Hagrid\", 5 } }\r\n  };\r\n\r\n  const auto best { \/\/ returns an iterator\r\n    std::max_element(arr.begin(), arr.end(), [](const auto&amp; a, const auto&amp; b) {\r\n      return a.points &lt; b.points;\r\n    })\r\n  };\r\n\r\n  std::cout &lt;&lt; best-&gt;name &lt;&lt; \" is the best student\\n\"; \/\/ must dereference iterator to get element\r\n\r\n  return 0;\r\n}<\/code><\/pre>\n<\/div>\n<\/div>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #2<\/p>\n<p>Use <code>std::sort<\/code> and a lambda in the following code to sort the seasons by ascending average temperature.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt;\r\n#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nstruct Season\r\n{\r\n  std::string_view name{};\r\n  double averageTemperature{};\r\n};\r\n\r\nint main()\r\n{\r\n  std::array&lt;Season, 4&gt; seasons{\r\n    { { \"Spring\", 285.0 },\r\n      { \"Summer\", 296.0 },\r\n      { \"Fall\", 288.0 },\r\n      { \"Winter\", 263.0 } }\r\n  };\r\n\r\n  \/*\r\n   * Use std::sort here\r\n   *\/\r\n\r\n  for (const auto&amp; season : seasons)\r\n  {\r\n    std::cout &lt;&lt; season.name &lt;&lt; '\\n';\r\n  }\r\n\r\n  return 0;\r\n}<\/code><\/pre>\n<p>The program should print<\/p>\n<pre>\r\nWinter\r\nSpring\r\nFall\r\nSummer\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt;\r\n#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nstruct Season\r\n{\r\n  std::string_view name{};\r\n  double averageTemperature{};\r\n};\r\n\r\nint main()\r\n{\r\n  std::array&lt;Season, 4&gt; seasons{\r\n    { { \"Spring\", 285.0 },\r\n      { \"Summer\", 296.0 },\r\n      { \"Fall\", 288.0 },\r\n      { \"Winter\", 263.0 } }\r\n  };\r\n\r\n  \/\/ We can compare averageTemperature of the two arguments to\r\n  \/\/ sort the array.\r\n  std::sort(seasons.begin(), seasons.end(),\r\n            [](const auto&amp; a, const auto&amp; b) {\r\n              return a.averageTemperature &lt; b.averageTemperature;\r\n            });\r\n\r\n  for (const auto&amp; season : seasons)\r\n  {\r\n    std::cout &lt;&lt; season.name &lt;&lt; '\\n';\r\n  }\r\n\r\n  return 0;\r\n}<\/code><\/pre>\n<\/div>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/lambda-captures\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">20.7<\/span>Lambda captures\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/ellipsis-and-why-to-avoid-them\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">20.5<\/span>Ellipsis (and why to avoid them)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Consider this snippet of code that we introduced in lesson : #include &lt;algorithm&gt; #include &lt;array&gt; #include &lt;iostream&gt; #include &lt;string_view&gt; \/\/ Our function will return true if the element matches bool containsNut(std::string_view str) { \/\/ std::string_view::find returns std::string_view::npos if it doesn&#8217;t find \/\/ the substring. Otherwise it returns the index where &hellip;<\/p>\n","protected":false},"author":4,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9367"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=9367"}],"version-history":[{"count":48,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9367\/revisions"}],"predecessor-version":[{"id":12617,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9367\/revisions\/12617"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=9367"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=9367"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=9367"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}