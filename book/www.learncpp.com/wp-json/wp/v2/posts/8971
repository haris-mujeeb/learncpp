{"id":8971,"date":"2019-11-02T07:17:24","date_gmt":"2019-11-02T15:17:24","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=8971"},"modified":"2024-11-26T16:53:44","modified_gmt":"2024-11-27T00:53:44","slug":"introduction-to-stdstring_view","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdstring_view\/","title":{"rendered":"5.8 &#8212; Introduction to std::string_view"},"content":{"rendered":"<p>Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 5 }; \/\/ x makes a copy of its initializer\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When the definition for <code>x<\/code> is executed, the initialization value <code>5<\/code> is copied into the memory allocated for variable <code>int x<\/code>.  For fundamental types, initializing and copying a variable is fast.<\/p>\n<p>Now consider this similar program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nint main()\r\n{\r\n    std::string s{ \"Hello, world!\" }; \/\/ s makes a copy of its initializer\r\n    std::cout &lt;&lt; s &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When <code>s<\/code> is initialized, the C-style string literal <code>\"Hello, world!\"<\/code> is copied into memory allocated for <code>std::string s<\/code>.  Unlike fundamental types, initializing and copying a <code>std::string<\/code> is slow.<\/p>\n<p>In the above program, all we do with <code>s<\/code> is print the value to the console, and then <code>s<\/code> is destroyed.  We&#8217;ve essentially made a copy of &#8220;Hello, world!&#8221; just to print and then destroy that copy.  That&#8217;s inefficient.<\/p>\n<p>We see something similar in this example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nvoid printString(std::string str) \/\/ str makes a copy of its initializer\r\n{\r\n    std::cout &lt;&lt; str &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::string s{ \"Hello, world!\" }; \/\/ s makes a copy of its initializer\r\n    printString(s);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This example makes two copies of the C-style string &#8220;Hello, world!&#8221;: one when we initialize <code>s<\/code> in <code>main()<\/code>, and another when we initialize parameter <code>str<\/code> in <code>printString()<\/code>.  That&#8217;s a lot of needless copying just to print a string!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">std::string_view <span class=\"cpp-section-pill cpp-section-standard\">C++17<\/span><\/p>\n<p>To address the issue with <code>std::string<\/code> being expensive to initialize (or copy), C++17 introduced <code>std::string_view<\/code> (which lives in the &lt;string_view&gt; header).  <code>std::string_view<\/code> provides read-only access to an <em>existing<\/em> string (a C-style string, a <code>std::string<\/code>, or another <code>std::string_view<\/code>) without making a copy.  <strong>Read-only<\/strong> means that we can access and use the value being viewed, but we can not modify it.<\/p>\n<p>The following example is identical to the prior one, except we&#8217;ve replaced <code>std::string<\/code> with <code>std::string_view<\/code>.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt; \/\/ C++17\r\n\r\n\/\/ str provides read-only access to whatever argument is passed in\r\nvoid printSV(std::string_view str) \/\/ now a std::string_view\r\n{\r\n    std::cout &lt;&lt; str &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::string_view s{ \"Hello, world!\" }; \/\/ now a std::string_view\r\n    printSV(s);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program produces the same output as the prior one, but no copies of the string &#8220;Hello, world!&#8221; are made.<\/p>\n<p>When we initialize <code>std::string_view s<\/code> with C-style string literal <code>\"Hello, world!\"<\/code>, <code>s<\/code> provides read-only access to &#8220;Hello, world!&#8221; without making a copy of the string.  When we pass <code>s<\/code> to <code>printSV()<\/code>, parameter <code>str<\/code> is initialized from <code>s<\/code>.  This allows us to access &#8220;Hello, world!&#8221; through <code>str<\/code>, again without making a copy of the string.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Prefer <code>std::string_view<\/code> over <code>std::string<\/code> when you need a read-only string, especially for function parameters.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><code>std::string_view<\/code> can be initialized with many different types of strings<\/p>\n<p>One of the neat things about a <code>std::string_view<\/code> is how flexible it is.  A <code>std::string_view<\/code> object can be initialized with a C-style string, a <code>std::string<\/code>, or another <code>std::string_view<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nint main()\r\n{\r\n    std::string_view s1 { \"Hello, world!\" }; \/\/ initialize with C-style string literal\r\n    std::cout &lt;&lt; s1 &lt;&lt; '\\n';\r\n\r\n    std::string s{ \"Hello, world!\" };\r\n    std::string_view s2 { s };  \/\/ initialize with std::string\r\n    std::cout &lt;&lt; s2 &lt;&lt; '\\n';\r\n\r\n    std::string_view s3 { s2 }; \/\/ initialize with std::string_view\r\n    std::cout &lt;&lt; s3 &lt;&lt; '\\n';\r\n       \r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><code>std::string_view<\/code> parameters will accept many different types of string arguments<\/p>\n<p>Both a C-style string and a <code>std::string<\/code> will implicitly convert to a <code>std::string_view<\/code>.  Therefore, a <code>std::string_view<\/code> parameter will accept arguments of type C-style string, a <code>std::string<\/code>, or <code>std::string_view<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nvoid printSV(std::string_view str)\r\n{\r\n    std::cout &lt;&lt; str &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    printSV(\"Hello, world!\"); \/\/ call with C-style string literal\r\n\r\n    std::string s2{ \"Hello, world!\" };\r\n    printSV(s2); \/\/ call with std::string\r\n\r\n    std::string_view s3 { s2 };\r\n    printSV(s3); \/\/ call with std::string_view\r\n       \r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><code>std::string_view<\/code> will not implicitly convert to <code>std::string<\/code><\/p>\n<p>Because <code>std::string<\/code> makes a copy of its initializer (which is expensive), C++ won&#8217;t allow implicit conversion of a <code>std::string_view<\/code> to a <code>std::string<\/code>.  This is to prevent accidentally passing a <code>std::string_view<\/code> argument to a <code>std::string<\/code> parameter, and inadvertently making an expensive copy where such a copy may not be required.<\/p>\n<p>However, if this is desired, we have two options:<\/p>\n<ol start=\"1\">\n<li>Explicitly create a <code>std::string<\/code> with a <code>std::string_view<\/code> initializer (which is allowed, since this will rarely be done unintentionally)\n<\/li>\n<li>Convert an existing <code>std::string_view<\/code> to a <code>std::string<\/code> using <code>static_cast<\/code>\n<\/li>\n<\/ol>\n<p>The following example shows both options:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nvoid printString(std::string str)\r\n{\r\n\tstd::cout &lt;&lt; str &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n\tstd::string_view sv{ \"Hello, world!\" };\r\n\r\n\t\/\/ printString(sv);   \/\/ compile error: won't implicitly convert std::string_view to a std::string\r\n\r\n\tstd::string s{ sv }; \/\/ okay: we can create std::string using std::string_view initializer\r\n\tprintString(s);      \/\/ and call the function with the std::string\r\n\r\n\tprintString(static_cast&lt;std::string&gt;(sv)); \/\/ okay: we can explicitly cast a std::string_view to a std::string\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Assignment changes what the <code>std::string_view<\/code> is viewing<\/p>\n<p>Assigning a new string to a <code>std::string_view<\/code> causes the <code>std::string_view<\/code> to view the new string.  It does not modify the prior string being viewed in any way.<\/p>\n<p>The following example illustrates this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nint main()\r\n{\r\n    std::string name { \"Alex\" };\r\n    std::string_view sv { name }; \/\/ sv is now viewing name\r\n    std::cout &lt;&lt; sv &lt;&lt; '\\n'; \/\/ prints Alex\r\n\r\n    sv = \"John\"; \/\/ sv is now viewing \"John\" (does not change name)\r\n    std::cout &lt;&lt; sv &lt;&lt; '\\n'; \/\/ prints John\r\n\r\n    std::cout &lt;&lt; name &lt;&lt; '\\n'; \/\/ prints Alex\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, <code>sv = \"John\"<\/code> causes <code>sv<\/code> to now view the string <code>\"John\"<\/code>.  It does not change the value held by <code>name<\/code> (which is still <code>\"Alex\"<\/code>).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Literals for <code>std::string_view<\/code><\/p>\n<p>Double-quoted string literals are C-style string literals by default.  We can create string literals with type <code>std::string_view<\/code> by using a <code>sv<\/code> suffix after the double-quoted string literal.  The <code>sv<\/code> must be lower case.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;      \/\/ for std::string\r\n#include &lt;string_view&gt; \/\/ for std::string_view\r\n\r\nint main()\r\n{\r\n    using namespace std::string_literals;      \/\/ access the s suffix\r\n    using namespace std::string_view_literals; \/\/ access the sv suffix\r\n\r\n    std::cout &lt;&lt; \"foo\\n\";   \/\/ no suffix is a C-style string literal\r\n    std::cout &lt;&lt; \"goo\\n\"s;  \/\/ s suffix is a std::string literal\r\n    std::cout &lt;&lt; \"moo\\n\"sv; \/\/ sv suffix is a std::string_view literal\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We discuss this use of <code>using namespace<\/code> in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdstring\/\">5.7 -- Introduction to std::string<\/a>.  The same advice applies here.\n<\/div>\n<p>It\u2019s fine to initialize a <code>std::string_view<\/code> object with a C-style string literal (you don&#8217;t need to initialize it with a <code>std::string_view<\/code> literal).<\/p>\n<p>That said, initializing a <code>std::string_view<\/code> using a <code>std::string_view<\/code> literal won&#8217;t cause problems (as such literals are actually C-style string literals in disguise).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">constexpr <code>std::string_view<\/code><\/p>\n<p>Unlike <code>std::string<\/code>, <code>std::string_view<\/code> has full support for constexpr:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nint main()\r\n{\r\n    constexpr std::string_view s{ \"Hello, world!\" }; \/\/ s is a string symbolic constant\r\n    std::cout &lt;&lt; s &lt;&lt; '\\n'; \/\/ s will be replaced with \"Hello, world!\" at compile-time\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This makes <code>constexpr std::string_view<\/code> the preferred choice when string symbolic constants are needed.<\/p>\n<p>We will continue discussing <code>std::string_view<\/code> in the next lesson.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdstring_view-part-2\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">5.9<\/span>std::string_view (part 2)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdstring\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">5.7<\/span>Introduction to std::string\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Consider the following program: #include &lt;iostream&gt; int main() { int x { 5 }; \/\/ x makes a copy of its initializer std::cout &lt;&lt; x &lt;&lt; &#8216;\\n&#8217;; return 0; } When the definition for x is executed, the initialization value 5 is copied into the memory allocated for variable int &hellip;<\/p>\n","protected":false},"author":4,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/8971"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/4"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=8971"}],"version-history":[{"count":55,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/8971\/revisions"}],"predecessor-version":[{"id":17913,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/8971\/revisions\/17913"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=8971"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=8971"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=8971"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}