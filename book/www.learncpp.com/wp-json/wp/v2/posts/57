{"id":57,"date":"2007-06-13T20:23:31","date_gmt":"2007-06-14T04:23:31","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/33-incrementdecrement-operators-and-side-effects\/"},"modified":"2024-12-29T15:34:43","modified_gmt":"2024-12-29T23:34:43","slug":"increment-decrement-operators-and-side-effects","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/increment-decrement-operators-and-side-effects\/","title":{"rendered":"6.4 &#8212; Increment\/decrement operators, and side effects"},"content":{"rendered":"<p class=\"cpp-section\">Incrementing and decrementing variables<\/p>\n<p>Incrementing (adding 1 to) and decrementing (subtracting 1 from) a variable are both so common that they have their own operators.<\/p>\n<p style=\"clear: both\">\n<p> <!-- break around image --><\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<th>Operator<\/th>\n<th>Symbol<\/th>\n<th>Form<\/th>\n<th>Operation<\/th>\n<\/tr>\n<tr>\n<td>Prefix increment (pre-increment)<\/td>\n<td>++<\/td>\n<td>++x<\/td>\n<td>Increment x, then return x<\/td>\n<\/tr>\n<tr>\n<td>Prefix decrement (pre-decrement)<\/td>\n<td>&ndash;&ndash;<\/td>\n<td>&ndash;&ndash;x<\/td>\n<td>Decrement x, then return x<\/td>\n<\/tr>\n<tr>\n<td>Postfix increment (post-increment)<\/td>\n<td>++<\/td>\n<td>x++<\/td>\n<td>Copy x, then increment x, then return the copy<\/td>\n<\/tr>\n<tr>\n<td>Postfix decrement (post-decrement)<\/td>\n<td>&ndash;&ndash;<\/td>\n<td>x&ndash;&ndash;<\/td>\n<td>Copy x, then decrement x, then return the copy<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>Note that there are two versions of each operator -- a prefix version (where the operator comes before the operand) and a postfix version (where the operator comes after the operand).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Prefix increment and decrement<\/p>\n<p>The prefix increment\/decrement operators are very straightforward.  First, the operand is incremented or decremented, and then expression evaluates to the value of the operand.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 5 };\r\n    int y { ++x }; \/\/ x is incremented to 6, x is evaluated to the value 6, and 6 is assigned to y\r\n\r\n    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\\n';\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\n6 6\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Postfix increment and decrement<\/p>\n<p>The postfix increment\/decrement operators are trickier.  First, a copy of the operand is made.  Then the operand (not the copy) is incremented or decremented.  Finally, the copy (not the original) is evaluated.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 5 };\r\n    int y { x++ }; \/\/ x is incremented to 6, copy of original x is evaluated to the value 5, and 5 is assigned to y\r\n\r\n    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\\n';\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\n6 5\r\n<\/pre>\n<p>Let&#8217;s examine how this line 6 works in more detail.  First, a temporary copy of <em>x<\/em> is made that starts with the same value as <em>x<\/em> (5).  Then the actual <em>x<\/em> is incremented from <em>5<\/em> to <em>6<\/em>.  Then the copy of <em>x<\/em> (which still has value <em>5<\/em>) is returned and assigned to <em>y<\/em>.  Then the temporary copy is discarded.<\/p>\n<p>Consequently, <em>y<\/em> ends up with the value of <em>5<\/em> (the pre-incremented value), and <em>x<\/em> ends up with the value <em>6<\/em> (the post-incremented value).<\/p>\n<p>Note that the postfix version takes a lot more steps, and thus may not be as performant as the prefix version.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">More examples<\/p>\n<p>Here is another example showing the difference between the prefix and postfix versions:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 5 };\r\n    int y { 5 };\r\n    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; ++x &lt;&lt; ' ' &lt;&lt; --y &lt;&lt; '\\n'; \/\/ prefix\r\n    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; x++ &lt;&lt; ' ' &lt;&lt; y-- &lt;&lt; '\\n'; \/\/ postfix\r\n    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This produces the output:<\/p>\n<pre>\r\n5 5\r\n6 4\r\n6 4\r\n6 4\r\n7 3\r\n<\/pre>\n<p>On the 8th line, we do a prefix increment and decrement.  On this line, <em>x<\/em> and <em>y<\/em> are incremented\/decremented <em>before<\/em> their values are sent to std::cout, so we see their updated values reflected by std::cout.<\/p>\n<p>On the 10th line, we do a postfix increment and decrement.  On this line, the copy of <em>x<\/em> and <em>y<\/em> (with the pre-incremented and pre-decremented values) are what is sent to std::cout, so we don&#8217;t see the increment and decrement reflected here.  Those changes don&#8217;t show up until the next line, when <em>x<\/em> and <em>y<\/em> are evaluated again.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">When to use prefix vs postfix<\/p>\n<p>In many cases, the prefix and postfix operators produce the same behavior:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int x { 0 };\r\n    ++x; \/\/ increments x to 1\r\n    x++; \/\/ increments x to 2\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In cases where code can be written to use either prefix or postfix, prefer the prefix versions, as they are generally more performant, and less likely to cause surprises.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Favor the prefix versions, as they are more performant and less likely to cause surprises.\n<\/p><\/div>\n<p>Use the postfix versions when doing so produces significantly more concise or understandable code than the equivalent code written using the prefix versions.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Side effects<\/p>\n<p>A function or expression is said to have a <strong>side effect<\/strong> if it has some observable effect beyond producing a return value.<\/p>\n<p>Common examples of side effects include changing the value of objects, doing input or output, or updating a graphical user interface (e.g. enabling or disabling a button).<\/p>\n<p>Most of the time, side effects are useful:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">x = 5; \/\/ the assignment operator has side effect of changing value of x\r\n++x; \/\/ operator++ has side effect of incrementing x\r\nstd::cout &lt;&lt; x; \/\/ operator&lt;&lt; has side effect of modifying the state of the console<\/code><\/pre>\n<p>The assignment operator in the above example has the side effect of changing the value of <em>x<\/em> permanently.  Even after the statement has finished executing, <em>x<\/em> will still have the value 5.  Similarly with operator++, the value of <em>x<\/em> is altered even after the statement has finished evaluating.  The outputting of <em>x<\/em> also has the side effect of modifying the state of the console, as you can now see the value of <em>x<\/em> printed to the console.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>The assignment operators, prefix operator, and postfix operator have side effects that permanently change the value of an object.<br \/>\nOther operators (such as the arithmetic operators) return a value, and do not modify their operands.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Side effects can cause order of evaluation issues<\/p>\n<p>In some cases, side effects can lead to order of evaluation problems.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y)\r\n{\r\n    return x + y;\r\n}\r\n\r\nint main()\r\n{\r\n    int x { 5 };\r\n    int value{ add(x, ++x) }; \/\/ undefined behavior: is this 5 + 6, or 6 + 6?\r\n    \/\/ It depends on what order your compiler evaluates the function arguments in\r\n\r\n    std::cout &lt;&lt; value &lt;&lt; '\\n'; \/\/ value could be 11 or 12, depending on how the above line evaluates!\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The C++ standard does not define the order in which function arguments are evaluated.  If the left argument is evaluated first, this becomes a call to add(5, 6), which equals 11.  If the right argument is evaluated first, this becomes a call to add(6, 6), which equals 12!  Note that this is only a problem because one of the arguments to function add() has a side effect.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>The C++ standard intentionally does not define these things so that compilers can do whatever is most natural (and thus most performant) for a given architecture.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The sequencing of side effects<\/p>\n<p>In many cases, C++ also does not specify when the side effects of operators must be applied.  This can lead to undefined behavior in cases where an object with a side effect applied is used more than once in the same statement.<\/p>\n<p>For example, the expression <code>x + ++x<\/code> is unspecified behavior.  When <code>x<\/code> is initialized to <code>1<\/code>, Visual Studio and GCC evaluate this as <code>2 + 2<\/code>, and Clang evaluates it as <code>1 + 2<\/code>!  This is due to differences in when the compilers apply the side effect of incrementing <code>x<\/code>.<\/p>\n<p>Even when the C++ standard does make it clear how things should be evaluated, historically this has been an area where there have been many compiler bugs.  These problems can generally <em>all<\/em> be avoided by ensuring that any variable that has a side-effect applied is used no more than once in a given statement.<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>C++ does not define the order of evaluation for function arguments or the operands of operators.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Don&#8217;t use a variable that has a side effect applied to it more than once in a given statement.  If you do, the result may be undefined.<\/p>\n<p>One exception is for simple assignment expressions such as <code>x = x + y<\/code> (which is essentially equivalent to <code>x += y<\/code>).\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/the-comma-operator\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">6.5<\/span>The comma operator\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/remainder-and-exponentiation\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">6.3<\/span>Remainder and Exponentiation\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Incrementing (adding 1 to) and decrementing (subtracting 1 from) a variable are both so common that they have their own operators. Note that there are two versions of each operator &#8212; a prefix version (where the operator comes before the operand) and a postfix version (where the operator comes after &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/57"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=57"}],"version-history":[{"count":52,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/57\/revisions"}],"predecessor-version":[{"id":18034,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/57\/revisions\/18034"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=57"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=57"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=57"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}