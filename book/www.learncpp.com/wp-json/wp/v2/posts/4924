{"id":4924,"date":"2016-11-06T22:42:33","date_gmt":"2016-11-07T06:42:33","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=4924"},"modified":"2025-02-18T19:14:52","modified_gmt":"2025-02-19T03:14:52","slug":"naming-collisions-and-an-introduction-to-namespaces","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/naming-collisions-and-an-introduction-to-namespaces\/","title":{"rendered":"2.9 &#8212; Naming collisions and an introduction to namespaces"},"content":{"rendered":"<p>Let&#8217;s say you are driving to a friend&#8217;s house for the first time, and the address given to you is 245 Front Street in Mill City.  Upon reaching Mill City, you take out your map, only to discover that Mill City actually has two different Front Streets across town from each other!  Which one would you go to?  Unless there were some additional clue to help you decide (e.g. you remember your friend&#8217;s house is near the river) you&#8217;d have to call your friend and ask for more information.  Because this would be confusing and inefficient (particularly for your mail carrier), in most countries, all street names and house addresses within a city are required to be unique.<\/p>\n<p>Similarly, C++ requires that all identifiers be non-ambiguous.  If two identical identifiers are introduced into the same program in a way that the compiler or linker can&#8217;t tell them apart, the compiler or linker will produce an error. This error is generally referred to as a <strong>naming collision<\/strong> (or <strong>naming conflict<\/strong>).<\/p>\n<p>If the colliding identifiers are introduced into the same file, the result will be a compiler error.  If the colliding identifiers are introduced into separate files belonging to the same program, the result will be a linker error.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">An example of a naming collision<\/p>\n<p>a.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid myFcn(int x)\r\n{\r\n    std::cout &lt;&lt; x;\r\n}<\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid myFcn(int x)\r\n{\r\n    std::cout &lt;&lt; 2 * x;\r\n}\r\n\r\nint main()\r\n{\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When the compiler compiles this program, it will compile <em>a.cpp<\/em> and <em>main.cpp<\/em> independently, and each file will compile with no problems.<\/p>\n<p>However, when the linker executes, it will link all the definitions in <em>a.cpp<\/em> and <em>main.cpp<\/em> together, and discover conflicting definitions for function <code>myFcn()<\/code>.  The linker will then abort with an error.  Note that this error occurs even though <code>myFcn()<\/code> is never called!<\/p>\n<p>Most naming collisions occur in two cases:<\/p>\n<ol start=\"1\">\n<li>Two (or more) identically named functions (or global variables) are introduced into separate files belonging to the same program.  This will result in a linker error, as shown above.\n<\/li>\n<li>Two (or more) identically named functions (or global variables) are introduced into the same file.  This will result in a compiler error.\n<\/li>\n<\/ol>\n<p>As programs get larger and use more identifiers, the odds of a naming collision being introduced increases significantly.  The good news is that C++ provides plenty of mechanisms for avoiding naming collisions.  Local scope, which keeps local variables defined inside functions from conflicting with each other, is one such mechanism.  But local scope doesn&#8217;t work for function names.  So how do we keep function names from conflicting with each other?<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Scope regions<\/p>\n<p>Back to our address analogy for a moment, having two Front Streets was only problematic because those streets existed within the same city.  On the other hand, if you had to deliver mail to two addresses, one at 245 Front Street in Mill City, and another address at 245 Front Street in Jonesville, there would be no confusion about where to go.  Put another way, cities provide groupings that allow us to disambiguate addresses that might otherwise conflict with each other.<\/p>\n<p>A <strong>scope region<\/strong> is an area of source code where all declared identifiers are considered distinct from names declared in other scopes (much like the cities in our analogy).  Two identifiers with the same name can be declared in separate scope regions without causing a naming conflict.  However, within a given scope region, all identifiers must be unique, otherwise a naming collision will result.<\/p>\n<p>The body of a function is one example of a scope region.  Two identically-named identifiers can be defined in separate functions without issue -- because each function provides a separate scope region, there is no collision.  However, if you try to define two identically-named identifiers within the same function, a naming collision will result, and the compiler will complain.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Namespaces<\/p>\n<p>A <strong>namespace<\/strong> provides another type of scope region (called <strong>namespace scope<\/strong>) that allows you to declare or define names inside of it for the purpose of disambiguation.  The names declared in a namespace are isolated from names declared in other scopes, allowing such names to exist without conflict.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>A name declared within a scope region (such as a namespace) is distinct from any identical name declared in another scope.\n<\/p><\/div>\n<p>For example, two functions with identical declarations can be defined inside different namespaces, and no naming collision or ambiguity will occur.<\/p>\n<p>Namespaces may only contain declarations and definitions (e.g. variables and functions).  Executable statements are not allowed unless they are part of a definition (e.g. within a function).  <\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>A namespace may only contain declarations and definitions.  Executable statements are only allowed as part of a definition (e.g. of a function).\n<\/p><\/div>\n<p>Namespaces are often used to group related identifiers in a large project to help ensure they don&#8217;t inadvertently collide with other identifiers.  For example, if you put all your math functions in a namespace named <code>math<\/code>, then your math functions won&#8217;t collide with identically named functions outside the <code>math<\/code> namespace.<\/p>\n<p>We&#8217;ll talk about how to create your own namespaces in a future lesson.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The global namespace<\/p>\n<p>In C++, any name that is not defined inside a class, function, or a namespace is considered to be part of an implicitly-defined namespace called the <strong>global namespace<\/strong> (sometimes also called <strong>the global scope<\/strong>).<\/p>\n<p>In the example at the top of the lesson, functions <code>main()<\/code> and both versions of <code>myFcn()<\/code> are defined inside the global namespace.  The naming collision encountered in the example happens because both versions of <code>myFcn()<\/code> end up inside the global namespace, which violates the rule that all names in the scope region must be unique.<\/p>\n<p>We discuss the global namespace in more detail in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-global-variables\/\">7.4 -- Introduction to global variables<\/a>.<\/p>\n<p>For now, there are two things you should know:<\/p>\n<ul>\n<li>Identifiers declared inside the global scope are in scope from the point of declaration to the end of the file.\n<\/li>\n<li>Although variables can be defined in the global namespace, this should generally be avoided (we discuss why in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/why-non-const-global-variables-are-evil\/\">7.8 -- Why (non-const) global variables are evil<\/a>).\n<\/li>\n<\/ul>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt; \/\/ imports the declaration of std::cout into the global scope\r\n\r\n\/\/ All of the following statements are part of the global namespace\r\n\r\nvoid foo();    \/\/ okay: function forward declaration\r\nint x;         \/\/ compiles but strongly discouraged: non-const global variable definition (without initializer)\r\nint y { 5 };   \/\/ compiles but strongly discouraged: non-const global variable definition (with initializer)\r\nx = 5;         \/\/ compile error: executable statements are not allowed in namespaces\r\n\r\nint main()     \/\/ okay: function definition\r\n{\r\n    return 0;\r\n}\r\n\r\nvoid goo();    \/\/ okay: A function forward declaration<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The std namespace<\/p>\n<p>When C++ was originally designed, all of the identifiers in the C++ standard library (including std::cin and std::cout) were available to be used without the <code>std::<\/code> prefix (they were part of the global namespace).  However, this meant that any identifier in the standard library could potentially conflict with any name you picked for your own identifiers (also defined in the global namespace).  Code that was once working might suddenly have a naming conflict when you include a different part of the standard library.   Or worse, code that compiled under one version of C++ might not compile under the next version of C++, as new identifiers introduced into the standard library could have a naming conflict with already written code.  So C++ moved all of the functionality in the standard library into a namespace named <code>std<\/code> (short for &#8220;standard&#8221;).<\/p>\n<p>It turns out that <code>std::cout<\/code>&#8216;s name isn&#8217;t really <code>std::cout<\/code>.  It&#8217;s actually just <code>cout<\/code>, and <code>std<\/code> is the name of the namespace that identifier <code>cout<\/code> is part of.  Because <code>cout<\/code> is defined in the <code>std<\/code> namespace, the name <code>cout<\/code> won&#8217;t conflict with any objects or functions named <code>cout<\/code> that we create outside of the <code>std<\/code> namespace (such as in the global namespace).<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>When you use an identifier that is defined inside a non-global namespace (e.g. the <code>std<\/code> namespace), you need to tell the compiler that the identifier lives inside the namespace.&#8221;\n<\/div>\n<p>There are a few different ways to do this.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Explicit namespace qualifier std::<\/p>\n<p>The most straightforward way to tell the compiler that we want to use <code>cout<\/code> from the <code>std<\/code> namespace is by explicitly using the <code>std::<\/code> prefix.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Hello world!\"; \/\/ when we say cout, we mean the cout defined in the std namespace\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The :: symbol is an operator called the <strong>scope resolution operator<\/strong>.  The identifier to the left of the <code>::<\/code> symbol identifies the namespace that the name to the right of the <code>::<\/code> symbol is contained within.  If no identifier to the left of the <code>::<\/code> symbol is provided, the global namespace is assumed.<\/p>\n<p>So when we say <code>std::cout<\/code> we&#8217;re saying &#8220;the <code>cout<\/code> that is declared in namespace <code>std<\/code>&#8220;.<\/p>\n<p>This is the safest way to use <code>cout<\/code>, because there&#8217;s no ambiguity about which <code>cout<\/code> we&#8217;re referencing (the one in the <code>std<\/code> namespace).<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Use explicit namespace prefixes to access identifiers defined in a namespace.\n<\/p><\/div>\n<p>When an identifier includes a namespace prefix, the identifier is called a <strong>qualified name<\/strong>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using namespace std (and why to avoid it)<\/p>\n<p>Another way to access identifiers inside a namespace is to use a using-directive statement.  Here&#8217;s our original &#8220;Hello world&#8221; program with a using-directive:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nusing namespace std; \/\/ this is a using-directive that allows us to access names in the std namespace with no namespace prefix\r\n\r\nint main()\r\n{\r\n    cout &lt;&lt; \"Hello world!\";\r\n    return 0;\r\n}<\/code><\/pre>\n<p>A <strong>using directive<\/strong> allows us to access the names in a namespace without using a namespace prefix.  So in the above example, when the compiler goes to determine what identifier <code>cout<\/code> is, it will match with <code>std::cout<\/code>, which, because of the using-directive, is accessible as just <code>cout<\/code>.<\/p>\n<p>Many texts, tutorials, and even some IDEs recommend or use a using-directive at the top of the program.  However, used in this way, this is a bad practice, and highly discouraged.<\/p>\n<p>Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt; \/\/ imports the declaration of std::cout into the global scope\r\n\r\nusing namespace std; \/\/ makes std::cout accessible as \"cout\"\r\n \r\nint cout() \/\/ defines our own \"cout\" function in the global namespace\r\n{\r\n    return 5;\r\n}\r\n \r\nint main()\r\n{\r\n    cout &lt;&lt; \"Hello, world!\"; \/\/ Compile error!  Which cout do we want here?  The one in the std namespace or the one we defined above?\r\n \r\n    return 0;\r\n}<\/code><\/pre>\n<p>The above program doesn&#8217;t compile, because the compiler now can&#8217;t tell whether we want the <code>cout<\/code> function that we defined, or <code>std::cout<\/code>.<\/p>\n<p>When using a using-directive in this manner, <em>any<\/em> identifier we define may conflict with <em>any<\/em> identically named identifier in the <code>std<\/code> namespace.  Even worse, while an identifier name may not conflict today, it may conflict with new identifiers added to the std namespace in future language revisions.  This was the whole point of moving all of the identifiers in the standard library into the <code>std<\/code> namespace in the first place!<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Avoid using-directives (such as <code>using namespace std;<\/code>) at the top of your program or in header files.  They violate the reason why namespaces were added in the first place.\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We talk more about using-declarations and using-directives (and how to use them responsibly) in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/using-declarations-and-using-directives\/\">7.13 -- Using declarations and using directives<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Curly braces and indented code<\/p>\n<p>In C++, curly braces are often used to delineate a scope region that is nested within another scope region (braces are also used for some non-scope-related purposes, such as list initialization).  For example, a function defined inside the global scope region uses curly braces to separate the scope region of the function from the global scope.<\/p>\n<p>In certain cases, identifiers defined outside the curly braces may still be part of the scope defined by the curly braces rather than the surrounding scope -- function parameters are a good example of this.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt; \/\/ imports the declaration of std::cout into the global scope\r\n\r\nvoid foo(int x) \/\/ foo is defined in the global scope, x is defined within scope of foo()\r\n{ \/\/ braces used to delineate nested scope region for function foo()\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n';\r\n} \/\/ x goes out of scope here\r\n\r\nint main()\r\n{ \/\/ braces used to delineate nested scope region for function main()\r\n    foo(5);\r\n\r\n    int x { 6 }; \/\/ x is defined within the scope of main()\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n';\r\n \r\n    return 0;\r\n} \/\/ x goes out of scope here\r\n\/\/ foo and main (and std::cout) go out of scope here (the end of the file)<\/code><\/pre>\n<p>The code that exists inside a nested scope region is conventionally indented one level, both for readability and to help indicate that it exists inside a separate scope region.<\/p>\n<p>The <code>#include<\/code> and function definitions for <code>foo()<\/code> and <code>main()<\/code> exist in the global scope region, so they are not indented.  The statements inside each function exist inside the nested scope region of the function, so they are indented one level.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-the-preprocessor\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">2.10<\/span>Introduction to the preprocessor\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/programs-with-multiple-code-files\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">2.8<\/span>Programs with multiple code files\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Let&#8217;s say you are driving to a friend&#8217;s house for the first time, and the address given to you is 245 Front Street in Mill City. Upon reaching Mill City, you take out your map, only to discover that Mill City actually has two different Front Streets across town from &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4924"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=4924"}],"version-history":[{"count":48,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4924\/revisions"}],"predecessor-version":[{"id":18205,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4924\/revisions\/18205"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=4924"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=4924"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=4924"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}