{"id":15423,"date":"2023-09-11T15:32:52","date_gmt":"2023-09-11T22:32:52","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15423"},"modified":"2024-08-15T09:25:19","modified_gmt":"2024-08-15T16:25:19","slug":"stdarray-length-and-indexing","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/stdarray-length-and-indexing\/","title":{"rendered":"17.2 &#8212; std::array length and indexing"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdvector-and-the-unsigned-length-and-subscript-problem\/\">16.3 -- std::vector and the unsigned length and subscript problem<\/a>, we discussed the unfortunate decision to make the standard library container classes use unsigned values for lengths and indices.  Because <code>std::array<\/code> is a standard library container class, it is subject to the same issues.<\/p>\n<p>In this lesson, we&#8217;ll recap ways to index and get the length of a <code>std::array<\/code>.  Because <code>std::vector<\/code> and <code>std::array<\/code> have similar interfaces, this will parallel the what we covered for <code>std::vector<\/code>.  But since only <code>std::array<\/code> has full support for constexpr, we&#8217;ll focus a little more on that.<\/p>\n<p>Before proceeding, now would be a good time to refresh your memory on &#8220;sign conversions are narrowing conversions, except when constexpr&#8221; (see <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdvector-and-the-unsigned-length-and-subscript-problem\/#constexprconversions\">16.3 -- std::vector and the unsigned length and subscript problem<\/a>).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The length of a <code>std::array<\/code> has type <code>std::size_t<\/code><\/p>\n<p><code>std::array<\/code> is implemented as a template struct whose declaration looks like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template&lt;typename T, std::size_t N&gt; \/\/ N is a non-type template parameter\r\nstruct array;<\/code><\/pre>\n<p>As you can see, the non-type template parameter representing the array length (<code>N<\/code>) has type <code>std::size_t<\/code>.  And as you&#8217;re probably aware by now, <code>std::size_t<\/code> is a large unsigned integral type.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover class templates (which includes struct templates) in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-templates\/\">13.13 -- Class templates<\/a> and non-type template parameters in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/non-type-template-parameters\/\">11.9 -- Non-type template parameters<\/a>.\n<\/p><\/div>\n<p>Thus, when we define a <code>std::array<\/code>, the length non-type template argument must either have type <code>std::size_t<\/code>, or be convertible to a value of type <code>std::size_t<\/code>.  Because this value must be constexpr, we don&#8217;t run into sign conversion issues when we use a signed integral value, as the compiler will happily convert a signed integral value to a <code>std::size_t<\/code> at compile-time without it being considered a narrowing conversion.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>Prior to C++23, C++ didn&#8217;t even have a literal suffix for <code>std::size_t<\/code>, as the implicit compile-time conversion from <code>int<\/code> to <code>std::size_t<\/code> typically suffices for cases where we need a constexpr <code>std::size_t<\/code>.<\/p>\n<p>The suffix was added primarily for type deduction purposes, as <code>constexpr auto x { 0 }<\/code> will give you an <code>int<\/code> rather than a <code>std::size_t<\/code>.   In such cases, being able to differentiate <code>0<\/code> (<code>int<\/code>) from <code>0UZ<\/code> (<code>std::size_t<\/code>) without having to use an explicit <code>static_cast<\/code> is useful.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><a name=\"size_type\"><\/a>The length and indices of <code>std::array<\/code> have type <code>size_type<\/code>, which is always <code>std::size_t<\/code> <a href=\"#size_type\"><i class=\"fa fa-link\" style=\"font-size: 0.8em;\"><\/i><\/a><\/p>\n<p>Just like a <code>std::vector<\/code>, <code>std::array<\/code> defines a nested typedef member named <code>size_type<\/code>, which is an alias for the type used for the length (and indices, if supported) of the container.  In the case of <code>std::array<\/code>, <code>size_type<\/code> is <em>always<\/em> an alias for <code>std::size_t<\/code>.<\/p>\n<p>Note that the non-type template parameter defining the length of the <code>std::array<\/code> is explicitly defined as <code>std::size_t<\/code> rather than <code>size_type<\/code>.  This is because <code>size_type<\/code> is a member of <code>std::array<\/code>, and isn&#8217;t defined at that point.  This is the only place that uses <code>std::size_t<\/code> explicitly -- everywhere else uses <code>size_type<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Getting the length of a <code>std::array<\/code><\/p>\n<p>There are three common ways to get the length of a <code>std::array<\/code> object.<\/p>\n<p>First, we can ask a <code>std::array<\/code> object for its length using the <code>size()<\/code> member function (which returns the length as unsigned <code>size_type<\/code>):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    constexpr std::array arr { 9.0, 7.2, 5.4, 3.6, 1.8 };\r\n    std::cout &lt;&lt; \"length: \" &lt;&lt; arr.size() &lt;&lt; '\\n'; \/\/ returns length as type `size_type` (alias for `std::size_t`)\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nlength: 5\r\n<\/pre>\n<p>Unlike <code>std::string<\/code> and <code>std::string_view<\/code>, which have both a <code>length()<\/code> and a <code>size()<\/code> member function (that do the same thing), <code>std::array<\/code> (and most other container types in C++) only have <code>size()<\/code>.<\/p>\n<p>Second, in C++17, we can use the <code>std::size()<\/code> non-member function (which for <code>std::array<\/code> just calls the <code>size()<\/code> member function, thus returning the length as unsigned <code>size_type<\/code>).<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    constexpr std::array arr{ 9, 7, 5, 3, 1 };\r\n    std::cout &lt;&lt; \"length: \" &lt;&lt; std::size(arr); \/\/ C++17, returns length as type `size_type` (alias for `std::size_t`)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Finally, in C++20, we can use the <code>std::ssize()<\/code> non-member function, which returns the length as a large <em>signed<\/em> integral type (usually<code>std::ptrdiff_t<\/code>):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    constexpr std::array arr { 9, 7, 5, 3, 1 };\r\n    std::cout &lt;&lt; \"length: \" &lt;&lt; std::ssize(arr); \/\/ C++20, returns length as a large signed integral type\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This is the only function of the three which returns the length as a signed type.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Getting the length of a <code>std::array<\/code> as a constexpr value<\/p>\n<p>Because the length of a <code>std::array<\/code> is constexpr, each of the above functions will return the length of a <code>std::array<\/code> as a constexpr value (even when called on a non-constexpr <code>std::array<\/code> object)!  This means we can use any of these functions in constant expressions, and the length returned can be implicitly converted to an <code>int<\/code> without it being a narrowing conversion:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::array arr { 9, 7, 5, 3, 1 }; \/\/ note: not constexpr for this example\r\n    constexpr int length{ std::size(arr) }; \/\/ ok: return value is constexpr std::size_t and can be converted to int, not a narrowing conversion\r\n\r\n    std::cout &lt;&lt; \"length: \" &lt;&lt; length &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightyellowbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For Visual Studio users<\/p>\n<p>Visual Studio incorrectly triggers warning C4365 for the above example.  The issue has been <a href=\"https:\/\/developercommunity.visualstudio.com\/t\/Bug:-C4365-triggers-incorrectly-for-cons\/10372737\">reported to Microsoft<\/a>.\n<\/div>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Due to a language defect, the above functions will return a non-constexpr value when called on a <code>std::array<\/code> function parameter passed by (const) reference:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nvoid printLength(const std::array&lt;int, 5&gt; &amp;arr)\r\n{\r\n    constexpr int length{ std::size(arr) }; \/\/ compile error!\r\n    std::cout &lt;&lt; \"length: \" &lt;&lt; length &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::array arr { 9, 7, 5, 3, 1 };\r\n    constexpr int length{ std::size(arr) }; \/\/ works just fine\r\n    std::cout &lt;&lt; \"length: \" &lt;&lt; length &lt;&lt; '\\n';\r\n\r\n    printLength(arr);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This defect has been addressed in C++23 by <a href=\"https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2022\/p2280r4.html\">P2280<\/a>.  At the time of writing, few compilers currently <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/compiler_support\/23\">support<\/a> this feature.<\/p>\n<p>A workaround is to make <code>foo()<\/code> a function template where the array length is a non-type template parameter.  This non-type template parameter can then be used inside the function.  We discuss this further in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/passing-and-returning-stdarray\/\">17.3 -- Passing and returning std::array<\/a>.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;auto Length&gt;\r\nvoid printLength(const std::array&lt;int, Length&gt; &amp;arr)\r\n{\r\n    std::cout &lt;&lt; \"length: \" &lt;&lt; Length &lt;&lt; '\\n';\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Subscripting <code>std::array<\/code> using <code>operator[]<\/code> or the <code>at()<\/code> member function<\/p>\n<p>In the prior lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdarray\/\">17.1 -- Introduction to std::array<\/a>, we covered that the most common way to index a <code>std::array<\/code> is to use the subscript operator (<code>operator[]<\/code>).  No bounds checking is done in this case, and passing in an invalid index will result in undefined behavior.<\/p>\n<p>Just like <code>std::vector<\/code>, <code>std::array<\/code> also has an <code>at()<\/code> member function that does subscripting with runtime bounds checking.  We recommend avoiding this function since we typically want to do bounds checking before indexing, or we want compile-time bounds checking.<\/p>\n<p>Both of these functions expect the index to be of type <code>size_type<\/code> (<code>std::size_t<\/code>).<\/p>\n<p>If either of these functions are called with a constexpr value, the compiler will do a constexpr conversion to <code>std::size_t<\/code>.  This isn&#8217;t considered to be a narrowing conversion, so you won&#8217;t run into sign problems here.<\/p>\n<p>However, if either of these functions are called with a non-constexpr signed integral value, the conversion to <code>std::size_t<\/code> is considered narrowing and your compiler may emit a warning.  We discuss this case further (using <code>std::vector<\/code>) in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdvector-and-the-unsigned-length-and-subscript-problem\/\">16.3 -- std::vector and the unsigned length and subscript problem<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><code>std::get()<\/code> does compile-time bounds checking for constexpr indices<\/p>\n<p>Since the length of a <code>std::array<\/code> is constexpr, if our index is also a constexpr value, then the compiler should be able to validate at compile-time that our constexpr index is within the bounds of the array (and stop compilation if the constexpr index is out of bounds).<\/p>\n<p>However, <code>operator[]<\/code> does no bounds checking by definition, and the <code>at()<\/code> member function only does runtime bounds checking.  And function parameters can&#8217;t be constexpr (even for constexpr or consteval functions), so how do we even pass a constexpr index?<\/p>\n<p>To get compile-time bounds checking when we have a constexpr index, we can use the <code>std::get()<\/code> function template, which takes the index as a non-type template argument:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    constexpr std::array prime{ 2, 3, 5, 7, 11 };\r\n\r\n    std::cout &lt;&lt; std::get&lt;3&gt;(prime); \/\/ print the value of element with index 3\r\n    std::cout &lt;&lt; std::get&lt;9&gt;(prime); \/\/ invalid index (compile error)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Inside the implementation of <code>std::get()<\/code>, there is a static_assert that checks to ensure that the non-type template argument is smaller than the array length.  If it isn&#8217;t, then the static_assert will halt the compilation process with compilation error.<\/p>\n<p>Since template arguments must be constexpr, <code>std::get()<\/code> can only be called with constexpr indices.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Initialize a <code>std::array<\/code> with the following values: &#8216;h&#8217;, &#8216;e&#8217;, &#8216;l&#8217;, &#8216;l&#8217;, &#8216;o&#8217;.  Print the length of the array, and then use <code>operator[]<\/code>, <code>at()<\/code> and <code>std::get()<\/code> to print the value of the element with index 1.<\/p>\n<p>The program should print:<\/p>\n<pre>\nThe length is 5\r\neee\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    constexpr std::array arr { 'h', 'e', 'l', 'l', 'o' };\r\n    std::cout &lt;&lt; \"The length is \" &lt;&lt; std::size(arr) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; arr[1] &lt;&lt; arr.at(1) &lt;&lt; std::get&lt;1&gt;(arr) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/passing-and-returning-stdarray\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.3<\/span>Passing and returning std::array\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdarray\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.1<\/span>Introduction to std::array\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we discussed the unfortunate decision to make the standard library container classes use unsigned values for lengths and indices. Because std::array is a standard library container class, it is subject to the same issues. In this lesson, we&#8217;ll recap ways to index and get the length of &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15423"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15423"}],"version-history":[{"count":10,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15423\/revisions"}],"predecessor-version":[{"id":17473,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15423\/revisions\/17473"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15423"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15423"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15423"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}