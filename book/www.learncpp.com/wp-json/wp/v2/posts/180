{"id":180,"date":"2008-01-30T15:46:11","date_gmt":"2008-01-30T23:46:11","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/122-virtual-functions\/"},"modified":"2024-12-11T20:07:26","modified_gmt":"2024-12-12T04:07:26","slug":"virtual-functions","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/virtual-functions\/","title":{"rendered":"25.2 &#8212; Virtual functions and polymorphism"},"content":{"rendered":"<p>In the previous lesson on <a href=\"http:\/\/www.learncpp.com\/cpp-tutorial\/121-pointers-and-references-to-the-base-class-of-derived-objects\/\">pointers and references to the base class of derived objects<\/a>, we took a look at a number of examples where using pointers or references to a base class had the potential to simplify code.  However, in every case, we ran up against the problem that the base pointer or reference was only able to call the base version of a function, not a derived version.<\/p>\n<p>Here&#8217;s a simple example of this behavior:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n    std::string_view getName() const { return \"Base\"; }\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\npublic:\r\n    std::string_view getName() const { return \"Derived\"; }\r\n};\r\n\r\nint main()\r\n{\r\n    Derived derived {};\r\n    Base&amp; rBase{ derived };\r\n    std::cout &lt;&lt; \"rBase is a \" &lt;&lt; rBase.getName() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This example prints the result:<\/p>\n<pre>\r\nrBase is a Base\r\n<\/pre>\n<p>Because rBase is a Base reference, it calls Base::getName(), even though it&#8217;s actually referencing the Base portion of a Derived object.<\/p>\n<p>In this lesson, we will show how to address this issue using virtual functions.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Virtual functions<\/p>\n<p>A <strong>virtual function<\/strong> is a special type of member function that, when called, resolves to the most-derived version of the function for the actual type of the object being referenced or pointed to.<\/p>\n<p>A derived function is considered a match if it has the same signature (name, parameter types, and whether it is const) and return type as the base version of the function.  Such functions are called <strong>overrides<\/strong>.<\/p>\n<p>To make a function virtual, simply place the &#8220;virtual&#8221; keyword before the function declaration.<\/p>\n<p>Here&#8217;s the above example with a virtual function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n    virtual std::string_view getName() const { return \"Base\"; } \/\/ note addition of virtual keyword\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\npublic:\r\n    virtual std::string_view getName() const { return \"Derived\"; }\r\n};\r\n\r\nint main()\r\n{\r\n    Derived derived {};\r\n    Base&amp; rBase{ derived };\r\n    std::cout &lt;&lt; \"rBase is a \" &lt;&lt; rBase.getName() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This example prints the result:<\/p>\n<pre>\r\nrBase is a Derived\r\n<\/pre>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>Some modern compilers may give an error about having virtual functions and an accessible non-virtual destructor.  If this is the case, add a virtual destructor to the base class.  In the above program, add this to the definition of <code>Base<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    virtual ~Base() = default;<\/code><\/pre>\n<p>We discuss virtual destructors in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/virtual-destructors-virtual-assignment-and-overriding-virtualization\/\">25.4 -- Virtual destructors, virtual assignment, and overriding virtualization<\/a>.\n<\/p><\/div>\n<p>Because rBase is a reference to the Base portion of a Derived object, when <em>rBase.getName()<\/em> is evaluated, it would normally resolve to Base::getName().  However, Base::getName() is virtual, which tells the program to go look and see if there are any more-derived versions of the function available for a Derived object.  In this case, it will resolve to Derived::getName()!<\/p>\n<p>Let&#8217;s take a look at a slightly more complex example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass A\r\n{\r\npublic:\r\n    virtual std::string_view getName() const { return \"A\"; }\r\n};\r\n\r\nclass B: public A\r\n{\r\npublic:\r\n    virtual std::string_view getName() const { return \"B\"; }\r\n};\r\n\r\nclass C: public B\r\n{\r\npublic:\r\n    virtual std::string_view getName() const { return \"C\"; }\r\n};\r\n\r\nclass D: public C\r\n{\r\npublic:\r\n    virtual std::string_view getName() const { return \"D\"; }\r\n};\r\n\r\nint main()\r\n{\r\n    C c {};\r\n    A&amp; rBase{ c };\r\n    std::cout &lt;&lt; \"rBase is a \" &lt;&lt; rBase.getName() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>What do you think this program will output?<\/p>\n<p>Let&#8217;s look at how this works.  First, we instantiate a C class object.  rBase is an A reference, which we set to reference the A portion of the C object.  Finally, we call rBase.getName().  rBase.getName() evaluates to A::getName().  However, A::getName() is virtual, so the compiler will call the most-derived match between A and C.  In this case, that is C::getName().  Note that it will not call D::getName(), because our original object was a C, not a D, so only functions between A and C are considered.<\/p>\n<p>As a result, our program outputs:<\/p>\n<pre>\r\nrBase is a C\r\n<\/pre>\n<p>Note that virtual function resolution only works when a virtual member function is called through a pointer or reference to a class type object.  This works because the compiler can differentiate the type of the pointer or reference from the type of the object being pointed to or referenced.  We see this in example above.<\/p>\n<p>Calling a virtual member function directly on an object (not through a pointer or reference) will always invoke the member function belonging to the same type of that object.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">C c{};\r\nstd::cout &lt;&lt; c.getName(); \/\/ will always call C::getName\r\n\r\nA a { c }; \/\/ copies the A portion of c into a (don't do this)\r\nstd::cout &lt;&lt; a.getName(); \/\/ will always call A::getName<\/code><\/pre>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Virtual function resolution only works when a member function is called through a pointer or reference to a class type object.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Polymorphism<\/p>\n<p>In programming, <strong>polymorphism<\/strong> refers to the ability of an entity to have multiple forms (the term &#8220;polymorphism&#8221; literally means &#8220;many forms&#8221;).  For example, consider the following two function declarations:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int add(int, int);\r\ndouble add(double, double);<\/code><\/pre>\n<p>The identifier <code>add<\/code> has two forms: <code>add(int, int)<\/code> and <code>add(double, double)<\/code>.<\/p>\n<p><strong>Compile-time polymorphism<\/strong> refers to forms of polymorphism that are resolved by the compiler.  These include function overload resolution, as well as template resolution.<\/p>\n<p><strong>Runtime polymorphism<\/strong> refers to forms of polymorphism that are resolved at runtime.  This includes virtual function resolution.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A more complex example<\/p>\n<p>Let&#8217;s take another look at the Animal example we were working with in the previous lesson.  Here&#8217;s the original class, along with some test code:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Animal\r\n{\r\nprotected:\r\n    std::string m_name {};\r\n\r\n    \/\/ We're making this constructor protected because\r\n    \/\/ we don't want people creating Animal objects directly,\r\n    \/\/ but we still want derived classes to be able to use it.\r\n    Animal(std::string_view name)\r\n        : m_name{ name }\r\n    {\r\n    }\r\n\r\npublic:\r\n    const std::string&amp; getName() const { return m_name; }\r\n    std::string_view speak() const { return \"???\"; }\r\n};\r\n\r\nclass Cat: public Animal\r\n{\r\npublic:\r\n    Cat(std::string_view name)\r\n        : Animal{ name }\r\n    {\r\n    }\r\n\r\n    std::string_view speak() const { return \"Meow\"; }\r\n};\r\n\r\nclass Dog: public Animal\r\n{\r\npublic:\r\n    Dog(std::string_view name)\r\n        : Animal{ name }\r\n    {\r\n    }\r\n\r\n    std::string_view speak() const { return \"Woof\"; }\r\n};\r\n\r\nvoid report(const Animal&amp; animal)\r\n{\r\n    std::cout &lt;&lt; animal.getName() &lt;&lt; \" says \" &lt;&lt; animal.speak() &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    Cat cat{ \"Fred\" };\r\n    Dog dog{ \"Garbo\" };\r\n\r\n    report(cat);\r\n    report(dog);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\nFred says ???\r\nGarbo says ???\r\n<\/pre>\n<p>Here&#8217;s the equivalent class with the speak() function made virtual:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Animal\r\n{\r\nprotected:\r\n    std::string m_name {};\r\n\r\n    \/\/ We're making this constructor protected because\r\n    \/\/ we don't want people creating Animal objects directly,\r\n    \/\/ but we still want derived classes to be able to use it.\r\n    Animal(std::string_view name)\r\n        : m_name{ name }\r\n    {\r\n    }\r\n\r\npublic:\r\n    const std::string&amp; getName() const { return m_name; }\r\n    virtual std::string_view speak() const { return \"???\"; }\r\n};\r\n\r\nclass Cat: public Animal\r\n{\r\npublic:\r\n    Cat(std::string_view name)\r\n        : Animal{ name }\r\n    {\r\n    }\r\n\r\n    virtual std::string_view speak() const { return \"Meow\"; }\r\n};\r\n\r\nclass Dog: public Animal\r\n{\r\npublic:\r\n    Dog(std::string_view name)\r\n        : Animal{ name }\r\n    {\r\n    }\r\n\r\n    virtual std::string_view speak() const { return \"Woof\"; }\r\n};\r\n\r\nvoid report(const Animal&amp; animal)\r\n{\r\n    std::cout &lt;&lt; animal.getName() &lt;&lt; \" says \" &lt;&lt; animal.speak() &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    Cat cat{ \"Fred\" };\r\n    Dog dog{ \"Garbo\" };\r\n\r\n    report(cat);\r\n    report(dog);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program produces the result:<\/p>\n<pre>\r\nFred says Meow\r\nGarbo says Woof\r\n<\/pre>\n<p>It works!<\/p>\n<p>When animal.speak() is evaluated, the program notes that Animal::speak() is a virtual function.  In the case where animal is referencing the Animal portion of a Cat object, the program looks at all the classes between Animal and Cat to see if it can find a more derived function.  In that case, it finds Cat::speak().  In the case where animal references the Animal portion of a Dog object, the program resolves the function call to Dog::speak().<\/p>\n<p>Note that we didn&#8217;t make Animal::getName() virtual.  This is because getName() is never overridden in any of the derived classes, therefore there is no need.<\/p>\n<p>Similarly, the following array example now works as expected:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">Cat fred{ \"Fred\" };\r\nCat misty{ \"Misty\" };\r\nCat zeke{ \"Zeke\" };\r\n \r\nDog garbo{ \"Garbo\" };\r\nDog pooky{ \"Pooky\" };\r\nDog truffle{ \"Truffle\" };\r\n\r\n\/\/ Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects\r\nAnimal* animals[]{ &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke };\r\n\r\nfor (const auto* animal : animals)\r\n    std::cout &lt;&lt; animal-&gt;getName() &lt;&lt; \" says \" &lt;&lt; animal-&gt;speak() &lt;&lt; '\\n';<\/code><\/pre>\n<p>Which produces the result:<\/p>\n<pre>\r\nFred says Meow\r\nGarbo says Woof\r\nMisty says Meow\r\nPooky says Woof\r\nTruffle says Woof\r\nZeke says Meow\r\n<\/pre>\n<p>Even though these two examples only use Cat and Dog, any other classes we derive from Animal would also work with our report() function and animal array without further modification!  This is perhaps the biggest benefit of virtual functions -- the ability to structure your code in such a way that newly derived classes will automatically work with the old code without modification!<\/p>\n<p>A word of warning: the signature of the derived class function must <em>exactly<\/em> match the signature of the base class virtual function in order for the derived class function to be used.  If the derived class function has different parameter types, the program will likely still compile fine, but the virtual function will not resolve as intended.  In the next lesson, we&#8217;ll discuss how to guard against this.<\/p>\n<p>Note that if a function is marked as virtual, all matching overrides in derived classes are also implicitly considered virtual, even if they are not explicitly marked as such.<\/p>\n<div class=\"cpp-note cpp-lightpurplebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Rule<\/p>\n<p>If a function is virtual, all matching overrides in derived classes are implicitly virtual.\n<\/p><\/div>\n<p>This does not work the other way around -- a virtual override in a derived class does not implicitly make the base class function virtual.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Return types of virtual functions<\/p>\n<p>Under normal circumstances, the return type of a virtual function and its override must match.  Consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Base\r\n{\r\npublic:\r\n    virtual int getValue() const { return 5; }\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\npublic:\r\n    virtual double getValue() const { return 6.78; }\r\n};<\/code><\/pre>\n<p>In this case, Derived::getValue() is not considered a matching override for Base::getValue() and compilation will fail.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Do not call virtual functions from constructors or destructors<\/p>\n<p>Here&#8217;s another gotcha that often catches unsuspecting new programmers.  You should not call virtual functions from constructors or destructors.  Why?<\/p>\n<p>Remember that when a Derived class is created, the Base portion is constructed first.  If you were to call a virtual function from the Base constructor, and Derived portion of the class hadn&#8217;t even been created yet, it would be unable to call the Derived version of the function because there&#8217;s no Derived object for the Derived function to work on.  In C++, it will call the Base version instead.<\/p>\n<p>A similar issue exists for destructors.  If you call a virtual function in a Base class destructor, it will always resolve to the Base class version of the function, because the Derived portion of the class will already have been destroyed.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Never call virtual functions from constructors or destructors.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The downside of virtual functions<\/p>\n<p>Since most of the time you&#8217;ll want your functions to be virtual, why not just make all functions virtual?  The answer is because it&#8217;s inefficient -- resolving a virtual function call takes longer than resolving a regular one.<\/p>\n<p>Furthermore, to make virtual functions work, the compiler has to allocate an extra pointer for each object of a class that has virtual functions.  This adds a lot of overhead to objects that otherwise have a small size.  We&#8217;ll talk about this more in future lessons in this chapter.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<ol start=\"1\">\n<li>What do the following programs print?  This exercise is meant to be done by inspection, not by compiling the examples with your compiler.\n<\/li>\n<\/ol>\n<p>1a) <\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass A\r\n{\r\npublic:\r\n    virtual std::string_view getName() const { return \"A\"; }\r\n};\r\n\r\nclass B: public A\r\n{\r\npublic:\r\n    virtual std::string_view getName() const { return \"B\"; }\r\n};\r\n\r\nclass C: public B\r\n{\r\npublic:\r\n\/\/ Note: no getName() function here\r\n};\r\n\r\nclass D: public C\r\n{\r\npublic:\r\n    virtual std::string_view getName() const { return \"D\"; }\r\n};\r\n\r\nint main()\r\n{\r\n    C c {};\r\n    A&amp; rBase{ c };\r\n    std::cout &lt;&lt; rBase.getName() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\nB.  rBase is an A reference pointing to a C object.  Normally rBase.getName() would call A::getName(), but A::getName() is virtual so it instead calls the most derived matching function between A and C.  That is B::getName(), which prints B.<\/div>\n<p>1b) <\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass A\r\n{\r\npublic:\r\n    virtual std::string_view getName() const { return \"A\"; }\r\n};\r\n\r\nclass B: public A\r\n{\r\npublic:\r\n    virtual std::string_view getName() const { return \"B\"; }\r\n};\r\n\r\nclass C: public B\r\n{\r\npublic:\r\n    virtual std::string_view getName() const { return \"C\"; }\r\n};\r\n\r\nclass D: public C\r\n{\r\npublic:\r\n    virtual std::string_view getName() const { return \"D\"; }\r\n};\r\n\r\nint main()\r\n{\r\n    C c;\r\n    B&amp; rBase{ c }; \/\/ note: rBase is a B this time\r\n    std::cout &lt;&lt; rBase.getName() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\nC.  This is pretty straightforward, as C::getName() is the most derived matching call between classes B and C.<\/div>\n<p>1c)  <\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass A\r\n{\r\npublic:\r\n    \/\/ note: no virtual keyword\r\n    std::string_view getName() const { return \"A\"; }\r\n};\r\n\r\nclass B: public A\r\n{\r\npublic:\r\n    virtual std::string_view getName() const { return \"B\"; }\r\n};\r\n\r\nclass C: public B\r\n{\r\npublic:\r\n    virtual std::string_view getName() const { return \"C\"; }\r\n};\r\n\r\nclass D: public C\r\n{\r\npublic:\r\n    virtual std::string_view getName() const { return \"D\"; }\r\n};\r\n\r\nint main()\r\n{\r\n    C c {};\r\n    A&amp; rBase{ c };\r\n    std::cout &lt;&lt; rBase.getName() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\nA.  Since A is not virtual, when rBase.getName() is called, A::getName() is called.<\/div>\n<p>1d) <\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass A\r\n{\r\npublic:\r\n    virtual std::string_view getName() const { return \"A\"; }\r\n};\r\n\r\nclass B: public A\r\n{\r\npublic:\r\n    \/\/ note: no virtual keyword in B, C, and D\r\n    std::string_view getName() const { return \"B\"; }\r\n};\r\n\r\nclass C: public B\r\n{\r\npublic:\r\n    std::string_view getName() const { return \"C\"; }\r\n};\r\n\r\nclass D: public C\r\n{\r\npublic:\r\n    std::string_view getName() const { return \"D\"; } \r\n};\r\n\r\nint main()\r\n{\r\n    C c {};\r\n    B&amp; rBase{ c }; \/\/ note: rBase is a B this time\r\n    std::cout &lt;&lt; rBase.getName() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\nC.  Even though B and C aren&#8217;t marked as virtual functions, A::getName() is virtual and B::getName() and C::getName() are overrides.  Therefore, B::getName() and C::getName() are considered implicitly virtual, and thus the call to rBase.getName() resolves to C::getName(), not B::getName().<\/div>\n<p>1e) <\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass A\r\n{\r\npublic:\r\n    virtual std::string_view getName() const { return \"A\"; }\r\n};\r\n\r\nclass B: public A\r\n{\r\npublic:\r\n    \/\/ Note: Functions in B, C, and D are non-const.\r\n    virtual std::string_view getName() { return \"B\"; }\r\n};\r\n\r\nclass C: public B\r\n{\r\npublic:\r\n    virtual std::string_view getName() { return \"C\"; }\r\n};\r\n\r\nclass D: public C\r\n{\r\npublic:\r\n    virtual std::string_view getName() { return \"D\"; }\r\n};\r\n\r\nint main()\r\n{\r\n    C c {};\r\n    A&amp; rBase{ c };\r\n    std::cout &lt;&lt; rBase.getName() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\nA.  This one is a little trickier.  rBase is an A reference to a C object, so rBase.getName() would normally call A::getName().  But A::getName() is virtual, so it calls the most derived version of the function between A and C.  And that is A::getName().  Because B::getName() and C::getName() are not const, they are not considered overrides!  Consequently, this program prints A.<\/div>\n<p>1f) <\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass A\r\n{\r\npublic:\r\n\tA() { std::cout &lt;&lt; getName(); } \/\/ note addition of constructor (getName() now called from here)\r\n\r\n\tvirtual std::string_view getName() const { return \"A\"; }\r\n};\r\n\r\nclass B : public A\r\n{\r\npublic:\r\n\tvirtual std::string_view getName() const { return \"B\"; }\r\n};\r\n\r\nclass C : public B\r\n{\r\npublic:\r\n\tvirtual std::string_view getName() const { return \"C\"; }\r\n};\r\n\r\nclass D : public C\r\n{\r\npublic:\r\n\tvirtual std::string_view getName() const { return \"D\"; }\r\n};\r\n\r\nint main()\r\n{\r\n\tC c {};\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_5'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_5\" style=\"display:none\">\nA.  Another tricky one.  When we create a C object, the A part is constructed first.  When the A constructor is called to do this, it calls virtual function getName().  Because the B and C parts of the class aren&#8217;t set up yet, this resolves to A::getName().<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/the-override-and-final-specifiers-and-covariant-return-types\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">25.3<\/span>The override and final specifiers, and covariant return types\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pointers-and-references-to-the-base-class-of-derived-objects\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">25.1<\/span>Pointers and references to the base class of derived objects\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the previous lesson on pointers and references to the base class of derived objects, we took a look at a number of examples where using pointers or references to a base class had the potential to simplify code. However, in every case, we ran up against the problem that &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/180"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=180"}],"version-history":[{"count":56,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/180\/revisions"}],"predecessor-version":[{"id":17977,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/180\/revisions\/17977"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=180"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=180"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=180"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}