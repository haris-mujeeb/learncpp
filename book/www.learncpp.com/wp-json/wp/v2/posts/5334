{"id":5334,"date":"2017-02-06T14:22:50","date_gmt":"2017-02-06T22:22:50","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=5334"},"modified":"2024-12-19T21:26:24","modified_gmt":"2024-12-20T05:26:24","slug":"function-try-blocks","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/function-try-blocks\/","title":{"rendered":"27.7 &#8212; Function try blocks"},"content":{"rendered":"<p>Try and catch blocks work well enough in most cases, but there is one particular case in which they are not sufficient.  Consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass A\r\n{\r\nprivate:\r\n\tint m_x;\r\npublic:\r\n\tA(int x) : m_x{x}\r\n\t{\r\n\t\tif (x &lt;= 0)\r\n\t\t\tthrow 1; \/\/ Exception thrown here\r\n\t}\r\n};\r\n\r\nclass B : public A\r\n{\r\npublic:\r\n\tB(int x) : A{x} \/\/ A initialized in member initializer list of B\r\n\t{\r\n\t\t\/\/ What happens if creation of A fails and we want to handle it here?\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\ttry\r\n\t{\r\n\t\tB b{0};\r\n\t}\r\n\tcatch (int)\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Oops\\n\";\r\n\t}\r\n}<\/code><\/pre>\n<p>In the above example, derived class B calls base class constructor A, which can throw an exception.  Because the creation of object b has been placed inside a try block (in function main()), if A throws an exception, main&#8217;s try block will catch it.  Consequently, this program prints:<\/p>\n<pre>\nOops\r\n<\/pre>\n<p>But what if we want to catch the exception inside of B?  The call to base constructor A happens via the member initializer list, before the B constructor&#8217;s body is called.  There&#8217;s no way to wrap a standard try block around it.<\/p>\n<p>In this situation, we have to use a slightly modified try block called a <strong>function try block<\/strong>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Function try blocks<\/p>\n<p>Function try blocks are designed to allow you to establish an exception handler around the body of an entire function, rather than around a block of code.<\/p>\n<p>The syntax for function try blocks is a little hard to describe, so we&#8217;ll show by example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass A\r\n{\r\nprivate:\r\n\tint m_x;\r\npublic:\r\n\tA(int x) : m_x{x}\r\n\t{\r\n\t\tif (x &lt;= 0)\r\n\t\t\tthrow 1; \/\/ Exception thrown here\r\n\t}\r\n};\r\n\r\nclass B : public A\r\n{\r\npublic:\r\n\tB(int x) try : A{x} \/\/ note addition of try keyword here\r\n\t{\r\n\t}\r\n\tcatch (...) \/\/ note this is at same level of indentation as the function itself\r\n\t{\r\n                \/\/ Exceptions from member initializer list or\r\n                \/\/ from constructor body are caught here\r\n\r\n                std::cerr &lt;&lt; \"Exception caught\\n\";\r\n\r\n                throw; \/\/ rethrow the existing exception\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\ttry\r\n\t{\r\n\t\tB b{0};\r\n\t}\r\n\tcatch (int)\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Oops\\n\";\r\n\t}\r\n}<\/code><\/pre>\n<p>When this program is run, it produces the output:<\/p>\n<pre>\nException caught\r\nOops\r\n<\/pre>\n<p>Let&#8217;s examine this program in more detail.<\/p>\n<p>First, note the addition of the <code>try<\/code> keyword before the member initializer list.  This indicates that everything after that point (until the end of the function) should be considered inside of the try block.<\/p>\n<p>Second, note that the associated catch block is at the same level of indentation as the entire function.  Any exception thrown between the try keyword and the end of the function body will be eligible to be caught here.<\/p>\n<p>When the above program runs, variable <code>b<\/code> begins construction, which calls B&#8217;s constructor (which utilizes a function try).   B&#8217;s constructor calls A&#8217;s constructor, which then raises an exception.  Because A&#8217;s constructor does not handle this exception, the exception propagates up the stack to B&#8217;s constructor, where it is caught by the function-level catch of B&#8217;s constructor.  The catch block prints &#8220;Exception caught&#8221;, and then rethrows the current exception up the stack, which is caught by the catch block in <code>main()<\/code>, which prints &#8220;Oops&#8221;.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Use function try blocks when you need a constructor to handle an exception thrown in the member initializer list.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Limitations on function catch blocks<\/p>\n<p>With a regular catch block (inside a function), we have three options: We can throw a new exception, rethrow the current exception, or resolve the exception (by either a return statement, or by letting control reach the end of the catch block).<\/p>\n<p>A function-level catch block for a constructor must either throw a new exception or rethrow the existing exception -- they are not allowed to resolve exceptions!  Return statements are also not allowed, and reaching the end of the catch block will implicitly rethrow.<\/p>\n<p>A function-level catch block for a destructor can throw, rethrow, or resolve the current exception via a return statement.  Reaching the end of the catch block will implicitly rethrow.<\/p>\n<p>A function-level catch block for other functions can throw, rethrow, or resolve the current exception via a return statement.  Reaching the end of the catch block will implicitly resolve the exception for non-value (void) returning functions and produce undefined behavior for value-returning functions!<\/p>\n<p>The following table summarizes the limitations and behavior of function-level catch blocks:<\/p>\n<div class=\"cpp-table-wrapper\">\n<table class=\"cpp-table\">\n<tr>\n<th> Function type <\/th>\n<th> Can resolve exceptions<br \/>via return statement <\/th>\n<th> Behavior at end of catch block <\/th>\n<\/tr>\n<tr>\n<td> Constructor <\/td>\n<td> No, must throw or rethrow <\/td>\n<td> Implicit rethrow <\/td>\n<\/tr>\n<tr>\n<td> Destructor <\/td>\n<td> Yes <\/td>\n<td> Implicit rethrow <\/td>\n<\/tr>\n<tr>\n<td> Non-value returning function <\/td>\n<td> Yes <\/td>\n<td> Resolve exception <\/td>\n<\/tr>\n<tr>\n<td> Value-returning function <\/td>\n<td> Yes <\/td>\n<td> Undefined behavior <\/td>\n<\/tr>\n<\/table>\n<\/div>\n<p>Because such behavior at the end of the catch block varies dramatically depending on the type of function (and includes undefined behavior in the case of value-returning functions), we recommend never letting control reach the end of the catch block, and always explicitly throwing, rethrowing, or returning.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Avoid letting control reach the end of a function-level catch block.  Instead, explicitly throw, rethrow, or return.\n<\/p><\/div>\n<p>In the program above, if we had not explicitly rethrow the exception in the function-level catch block of the constructor, control would have reached the end of the function-level catch, and because this was a constructor, an implicit rethrow would have happened instead.  The result would have been the same.<\/p>\n<p>Although function level try blocks can be used with non-member functions as well, they typically aren&#8217;t because there&#8217;s rarely a case where this would be needed.  They are almost exclusively used with constructors!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Function try blocks can catch both base and the current class exceptions<\/p>\n<p>In the above example, if either A or B&#8217;s constructor throws an exception, it will be caught by the try block around B&#8217;s constructor.<\/p>\n<p>We can see that in the following example, where we&#8217;re throwing an exception from class B instead of class A:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass A\r\n{\r\nprivate:\r\n\tint m_x;\r\npublic:\r\n\tA(int x) : m_x{x}\r\n\t{\r\n\t}\r\n};\r\n\r\nclass B : public A\r\n{\r\npublic:\r\n\tB(int x) try : A{x} \/\/ note addition of try keyword here\r\n\t{\r\n\t\tif (x &lt;= 0) \/\/ moved this from A to B\r\n\t\t\tthrow 1; \/\/ and this too\r\n\t}\r\n\tcatch (...)\r\n\t{\r\n                std::cerr &lt;&lt; \"Exception caught\\n\";\r\n\r\n                \/\/ If an exception isn't explicitly thrown here,\r\n                \/\/ the current exception will be implicitly rethrown\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\ttry\r\n\t{\r\n\t\tB b{0};\r\n\t}\r\n\tcatch (int)\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Oops\\n\";\r\n\t}\r\n}<\/code><\/pre>\n<p>We get the same output:<\/p>\n<pre>\nException caught\r\nOops\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Don&#8217;t use function try to clean up resources<\/p>\n<p>When construction of an object fails, the destructor of the class is not called.  Consequently, you may be tempted to use a function try block as a way to clean up a class that had partially allocated resources before failing.  However, referring to members of the failed object is considered undefined behavior since the object is &#8220;dead&#8221; before the catch block executes.  This means that you can&#8217;t use function try to clean up after a class.  If you want to clean up after a class, follow the standard rules for cleaning up classes that throw exceptions (see the &#8220;When constructors fail&#8221; subsection of lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/exceptions-classes-and-inheritance\/\">27.5 -- Exceptions, classes, and inheritance<\/a>).<\/p>\n<p>Function try is useful primarily for either logging failures before passing the exception up the stack, or for changing the type of exception thrown.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/exception-dangers-and-downsides\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">27.8<\/span>Exception dangers and downsides\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/rethrowing-exceptions\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">27.6<\/span>Rethrowing exceptions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Try and catch blocks work well enough in most cases, but there is one particular case in which they are not sufficient. Consider the following example: #include &lt;iostream&gt; class A { private: int m_x; public: A(int x) : m_x{x} { if (x &lt;= 0) throw 1; \/\/ Exception thrown here &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5334"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=5334"}],"version-history":[{"count":28,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5334\/revisions"}],"predecessor-version":[{"id":18003,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5334\/revisions\/18003"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=5334"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=5334"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=5334"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}