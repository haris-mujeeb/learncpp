{"id":5629,"date":"2017-03-16T16:04:15","date_gmt":"2017-03-17T00:04:15","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=5629"},"modified":"2024-06-02T16:11:45","modified_gmt":"2024-06-02T23:11:45","slug":"stdshared_ptr","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/stdshared_ptr\/","title":{"rendered":"22.6 &#8212; std::shared_ptr"},"content":{"rendered":"<p>Unlike std::unique_ptr, which is designed to singly own and manage a resource, std::shared_ptr is meant to solve the case where you need multiple smart pointers co-owning a resource.<\/p>\n<p>This means that it is fine to have multiple std::shared_ptr pointing to the same resource.  Internally, std::shared_ptr keeps track of how many std::shared_ptr are sharing the resource.  As long as at least one std::shared_ptr is pointing to the resource, the resource will not be deallocated, even if individual std::shared_ptr are destroyed.  As soon as the last std::shared_ptr managing the resource goes out of scope (or is reassigned to point at something else), the resource will be deallocated.<\/p>\n<p>Like std::unique_ptr, std::shared_ptr lives in the &lt;memory&gt; header.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;memory&gt; \/\/ for std::shared_ptr\r\n\r\nclass Resource\r\n{\r\npublic:\r\n\tResource() { std::cout &lt;&lt; \"Resource acquired\\n\"; }\r\n\t~Resource() { std::cout &lt;&lt; \"Resource destroyed\\n\"; }\r\n};\r\n\r\nint main()\r\n{\r\n\t\/\/ allocate a Resource object and have it owned by std::shared_ptr\r\n\tResource* res { new Resource };\r\n\tstd::shared_ptr&lt;Resource&gt; ptr1{ res };\r\n\t{\r\n\t\tstd::shared_ptr&lt;Resource&gt; ptr2 { ptr1 }; \/\/ make another std::shared_ptr pointing to the same thing\r\n\r\n\t\tstd::cout &lt;&lt; \"Killing one shared pointer\\n\";\r\n\t} \/\/ ptr2 goes out of scope here, but nothing happens\r\n\r\n\tstd::cout &lt;&lt; \"Killing another shared pointer\\n\";\r\n\r\n\treturn 0;\r\n} \/\/ ptr1 goes out of scope here, and the allocated Resource is destroyed<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\nResource acquired\r\nKilling one shared pointer\r\nKilling another shared pointer\r\nResource destroyed\r\n<\/pre>\n<p>In the above code, we create a dynamic Resource object, and set a std::shared_ptr named ptr1 to manage it.  Inside the nested block, we use the copy constructor to create a second std::shared_ptr (ptr2) that points to the same Resource.  When ptr2 goes out of scope, the Resource is not deallocated, because ptr1 is still pointing at the Resource.  When ptr1 goes out of scope, ptr1 notices there are no more std::shared_ptr managing the Resource, so it deallocates the Resource.<\/p>\n<p>Note that we created a second shared pointer from the first shared pointer.  This is important.  Consider the following similar program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;memory&gt; \/\/ for std::shared_ptr\r\n\r\nclass Resource\r\n{\r\npublic:\r\n\tResource() { std::cout &lt;&lt; \"Resource acquired\\n\"; }\r\n\t~Resource() { std::cout &lt;&lt; \"Resource destroyed\\n\"; }\r\n};\r\n\r\nint main()\r\n{\r\n\tResource* res { new Resource };\r\n\tstd::shared_ptr&lt;Resource&gt; ptr1 { res };\r\n\t{\r\n\t\tstd::shared_ptr&lt;Resource&gt; ptr2 { res }; \/\/ create ptr2 directly from res (instead of ptr1)\r\n\r\n\t\tstd::cout &lt;&lt; \"Killing one shared pointer\\n\";\r\n\t} \/\/ ptr2 goes out of scope here, and the allocated Resource is destroyed\r\n\r\n\tstd::cout &lt;&lt; \"Killing another shared pointer\\n\";\r\n\r\n\treturn 0;\r\n} \/\/ ptr1 goes out of scope here, and the allocated Resource is destroyed again<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\r\nResource acquired\r\nKilling one shared pointer\r\nResource destroyed\r\nKilling another shared pointer\r\nResource destroyed\r\n<\/pre>\n<p>and then crashes (at least on the author&#8217;s machine).<\/p>\n<p>The difference here is that we created two std::shared_ptr independently from each other.  As a consequence, even though they&#8217;re both pointing to the same Resource, they aren&#8217;t aware of each other.  When ptr2 goes out of scope, it thinks it&#8217;s the only owner of the Resource, and deallocates it.  When ptr1 later goes out of the scope, it thinks the same thing, and tries to delete the Resource again.  Then bad things happen.<\/p>\n<p>Fortunately, this is easily avoided: if you need more than one std::shared_ptr to a given resource, copy an existing std::shared_ptr.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Always make a copy of an existing std::shared_ptr if you need more than one std::shared_ptr pointing to the same resource.\n<\/p><\/div>\n<p>Just like with std::unique_ptr, std::shared_ptr can be a null pointer, so check to make sure it is valid before using it.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">std::make_shared<\/p>\n<p>Much like std::make_unique() can be used to create a std::unique_ptr in C++14, std::make_shared() can (and should) be used to make a std::shared_ptr.  std::make_shared() is available in C++11.<\/p>\n<p>Here&#8217;s our original example, using std::make_shared():<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;memory&gt; \/\/ for std::shared_ptr\r\n\r\nclass Resource\r\n{\r\npublic:\r\n\tResource() { std::cout &lt;&lt; \"Resource acquired\\n\"; }\r\n\t~Resource() { std::cout &lt;&lt; \"Resource destroyed\\n\"; }\r\n};\r\n\r\nint main()\r\n{\r\n\t\/\/ allocate a Resource object and have it owned by std::shared_ptr\r\n\tauto ptr1 { std::make_shared&lt;Resource&gt;() };\r\n\t{\r\n\t\tauto ptr2 { ptr1 }; \/\/ create ptr2 using copy of ptr1\r\n\r\n\t\tstd::cout &lt;&lt; \"Killing one shared pointer\\n\";\r\n\t} \/\/ ptr2 goes out of scope here, but nothing happens\r\n\r\n\tstd::cout &lt;&lt; \"Killing another shared pointer\\n\";\r\n\r\n\treturn 0;\r\n} \/\/ ptr1 goes out of scope here, and the allocated Resource is destroyed<\/code><\/pre>\n<p>The reasons for using std::make_shared() are the same as std::make_unique() -- std::make_shared() is simpler and safer (there&#8217;s no way to create two independent std::shared_ptr pointing to the same resource but unaware of each other using this method).  However, std::make_shared() is also more performant than not using it.  The reasons for this lie in the way that std::shared_ptr keeps track of how many pointers are pointing at a given resource.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Digging into std::shared_ptr<\/p>\n<p>Unlike std::unique_ptr, which uses a single pointer internally, std::shared_ptr uses two pointers internally.  One pointer points at the resource being managed.  The other points at a &#8220;control block&#8221;, which is a dynamically allocated object that tracks of a bunch of stuff, including how many std::shared_ptr are pointing at the resource.  When a std::shared_ptr is created via a std::shared_ptr constructor, the memory for the managed object (which is usually passed in) and control block (which the constructor creates) are allocated separately.  However, when using std::make_shared(), this can be optimized into a single memory allocation, which leads to better performance.<\/p>\n<p>This also explains why independently creating two std::shared_ptr pointed to the same resource gets us into trouble.  Each std::shared_ptr will have one pointer pointing at the resource.  However, each std::shared_ptr will independently allocate its own control block, which will indicate that it is the only pointer owning that resource.  Thus, when that std::shared_ptr goes out of scope, it will deallocate the resource, not realizing there are other std::shared_ptr also trying to manage that resource.<\/p>\n<p>However, when a std::shared_ptr is cloned using copy assignment, the data in the control block can be appropriately updated to indicate that there are now additional std::shared_ptr co-managing the resource.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Shared pointers can be created from unique pointers<\/p>\n<p>A std::unique_ptr can be converted into a std::shared_ptr via a special std::shared_ptr constructor that accepts a std::unique_ptr r-value.  The contents of the std::unique_ptr will be moved to the std::shared_ptr.<\/p>\n<p>However, std::shared_ptr can not be safely converted to a std::unique_ptr.  This means that if you&#8217;re creating a function that is going to return a smart pointer, you&#8217;re better off returning a std::unique_ptr and assigning it to a std::shared_ptr if and when that&#8217;s appropriate.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The perils of std::shared_ptr<\/p>\n<p>std::shared_ptr has some of the same challenges as std::unique_ptr -- if the std::shared_ptr is not properly disposed of (either because it was dynamically allocated and never deleted, or it was part of an object that was dynamically allocated and never deleted) then the resource it is managing won&#8217;t be deallocated either.  With std::unique_ptr, you only have to worry about one smart pointer being properly disposed of.  With std::shared_ptr, you have to worry about them all.  If any of the std::shared_ptr managing a resource are not properly destroyed, the resource will not be deallocated properly.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">std::shared_ptr and arrays<\/p>\n<p>In C++17 and earlier, std::shared_ptr does not have proper support for managing arrays, and should not be used to manage a C-style array.  As of C++20, std::shared_ptr does have support for arrays.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Conclusion<\/p>\n<p>std::shared_ptr is designed for the case where you need multiple smart pointers co-managing the same resource.  The resource will be deallocated when the last std::shared_ptr managing the resource is destroyed.   <\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/circular-dependency-issues-with-stdshared_ptr-and-stdweak_ptr\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">22.7<\/span>Circular dependency issues with std::shared_ptr, and std::weak_ptr\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdunique_ptr\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">22.5<\/span>std::unique_ptr\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Unlike std::unique_ptr, which is designed to singly own and manage a resource, std::shared_ptr is meant to solve the case where you need multiple smart pointers co-owning a resource. This means that it is fine to have multiple std::shared_ptr pointing to the same resource. Internally, std::shared_ptr keeps track of how many &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5629"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=5629"}],"version-history":[{"count":25,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5629\/revisions"}],"predecessor-version":[{"id":5757,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5629\/revisions\/5757"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=5629"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=5629"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=5629"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}