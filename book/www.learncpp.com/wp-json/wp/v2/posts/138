{"id":138,"date":"2007-09-26T11:36:15","date_gmt":"2007-09-26T19:36:15","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/92-overloading-the-arithmetic-operators\/"},"modified":"2024-10-21T13:47:48","modified_gmt":"2024-10-21T20:47:48","slug":"overloading-the-arithmetic-operators-using-friend-functions","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-the-arithmetic-operators-using-friend-functions\/","title":{"rendered":"21.2 &#8212; Overloading the arithmetic operators using friend functions"},"content":{"rendered":"<p>Some of the most commonly used operators in C++ are the arithmetic operators -- that is, the plus operator (+), minus operator (-), multiplication operator (*), and division operator (\/).  Note that all of the arithmetic operators are binary operators -- meaning they take two operands -- one on each side of the operator.  All four of these operators are overloaded in the exact same way.<\/p>\n<p>It turns out that there are three different ways to overload operators: the member function way, the friend function way, and the normal function way.  In this lesson, we&#8217;ll cover the friend function way (because it&#8217;s more intuitive for most binary operators).  Next lesson, we&#8217;ll discuss the normal function way.  Finally, in a later lesson in this chapter, we&#8217;ll cover the member function way.  And, of course, we&#8217;ll also summarize when to use each in more detail.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Overloading operators using friend functions<\/p>\n<p>Consider the following class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Cents\r\n{\r\nprivate:\r\n\tint m_cents {};\r\n\r\npublic:\r\n\tCents(int cents) : m_cents{ cents } { }\r\n\tint getCents() const { return m_cents; }\r\n};<\/code><\/pre>\n<p>The following example shows how to overload operator plus (+) in order to add two &#8220;Cents&#8221; objects together:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Cents\r\n{\r\nprivate:\r\n\tint m_cents {};\r\n\r\npublic:\r\n\tCents(int cents) : m_cents{ cents } { }\r\n\r\n\t\/\/ add Cents + Cents using a friend function\r\n\tfriend Cents operator+(const Cents&amp; c1, const Cents&amp; c2);\r\n\r\n\tint getCents() const { return m_cents; }\r\n};\r\n\r\n\/\/ note: this function is not a member function!\r\nCents operator+(const Cents&amp; c1, const Cents&amp; c2)\r\n{\r\n\t\/\/ use the Cents constructor and operator+(int, int)\r\n\t\/\/ we can access m_cents directly because this is a friend function\r\n\treturn c1.m_cents + c2.m_cents;\r\n}\r\n\r\nint main()\r\n{\r\n\tCents cents1{ 6 };\r\n\tCents cents2{ 8 };\r\n\tCents centsSum{ cents1 + cents2 };\r\n\tstd::cout &lt;&lt; \"I have \" &lt;&lt; centsSum.getCents() &lt;&lt; \" cents.\\n\";\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This produces the result:<\/p>\n<pre>\r\nI have 14 cents.\r\n<\/pre>\n<p>Overloading the plus operator (+) is as simple as declaring a function named operator+, giving it two parameters of the type of the operands we want to add, picking an appropriate return type, and then writing the function.<\/p>\n<p>In the case of our Cents object, implementing our operator+() function is very simple.  First, the parameter types: in this version of operator+, we are going to add two Cents objects together, so our function will take two objects of type Cents.  Second, the return type: our operator+ is going to return a result of type Cents, so that&#8217;s our return type.<\/p>\n<p>Finally, implementation: to add two Cents objects together, we really need to add the m_cents member from each Cents object.  Because our overloaded operator+() function is a friend of the class, we can access the m_cents member of our parameters directly.  Also, because m_cents is an integer, and C++ knows how to add integers together using the built-in version of the plus operator that works with integer operands, we can simply use the + operator to do the adding.<\/p>\n<p>Overloading the subtraction operator (-) is simple as well:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Cents\r\n{\r\nprivate:\r\n\tint m_cents {};\r\n\r\npublic:\r\n\texplicit Cents(int cents) : m_cents{ cents } { }\r\n\r\n\t\/\/ add Cents + Cents using a friend function\r\n\tfriend Cents operator+(const Cents&amp; c1, const Cents&amp; c2);\r\n\r\n\t\/\/ subtract Cents - Cents using a friend function\r\n\tfriend Cents operator-(const Cents&amp; c1, const Cents&amp; c2);\r\n\r\n\tint getCents() const { return m_cents; }\r\n};\r\n\r\n\/\/ note: this function is not a member function!\r\nCents operator+(const Cents&amp; c1, const Cents&amp; c2)\r\n{\r\n\t\/\/ use the Cents constructor and operator+(int, int)\r\n\t\/\/ we can access m_cents directly because this is a friend function\r\n\treturn Cents { c1.m_cents + c2.m_cents };\r\n}\r\n\r\n\/\/ note: this function is not a member function!\r\nCents operator-(const Cents&amp; c1, const Cents&amp; c2)\r\n{\r\n\t\/\/ use the Cents constructor and operator-(int, int)\r\n\t\/\/ we can access m_cents directly because this is a friend function\r\n\treturn Cents { c1.m_cents - c2.m_cents };\r\n}\r\n\r\nint main()\r\n{\r\n\tCents cents1{ 6 };\r\n\tCents cents2{ 2 };\r\n\tCents centsSum{ cents1 - cents2 };\r\n\tstd::cout &lt;&lt; \"I have \" &lt;&lt; centsSum.getCents() &lt;&lt; \" cents.\\n\";\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Overloading the multiplication operator (*) and the division operator (\/) is as easy as defining functions for <code>operator*<\/code> and <code>operator\/<\/code> respectively.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Friend functions can be defined inside the class<\/p>\n<p>Even though friend functions are not members of the class, they can still be defined inside the class if desired:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Cents\r\n{\r\nprivate:\r\n\tint m_cents {};\r\n\r\npublic:\r\n\texplicit Cents(int cents) : m_cents{ cents } { }\r\n\r\n\t\/\/ add Cents + Cents using a friend function\r\n        \/\/ This function is not considered a member of the class, even though the definition is inside the class\r\n\tfriend Cents operator+(const Cents&amp; c1, const Cents&amp; c2)\r\n\t{\r\n\t\t\/\/ use the Cents constructor and operator+(int, int)\r\n\t\t\/\/ we can access m_cents directly because this is a friend function\r\n\t\treturn Cents { c1.m_cents + c2.m_cents };\r\n\t}\r\n\r\n\tint getCents() const { return m_cents; }\r\n};\r\n\r\nint main()\r\n{\r\n\tCents cents1{ 6 };\r\n\tCents cents2{ 8 };\r\n\tCents centsSum{ cents1 + cents2 };\r\n\tstd::cout &lt;&lt; \"I have \" &lt;&lt; centsSum.getCents() &lt;&lt; \" cents.\\n\";\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This is fine for overloaded operators with trivial implementations.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Overloading operators for operands of different types<\/p>\n<p>Often it is the case that you want your overloaded operators to work with operands that are different types.  For example, if we have Cents(4), we may want to add the integer 6 to this to produce the result Cents(10).<\/p>\n<p>When C++ evaluates the expression <code>x + y<\/code>, x becomes the first parameter, and y becomes the second parameter.  When x and y have the same type, it does not matter if you add x + y or y + x -- either way, the same version of operator+ gets called.  However, when the operands have different types, x + y does not call the same function as y + x.<\/p>\n<p>For example, <code>Cents(4) + 6<\/code> would call operator+(Cents, int), and <code>6 + Cents(4)<\/code> would call operator+(int, Cents).  Consequently, whenever we overload binary operators for operands of different types, we actually need to write two functions -- one for each case.  Here is an example of that:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Cents\r\n{\r\nprivate:\r\n\tint m_cents {};\r\n\r\npublic:\r\n\texplicit Cents(int cents) : m_cents{ cents } { }\r\n\r\n\t\/\/ add Cents + int using a friend function\r\n\tfriend Cents operator+(const Cents&amp; c1, int value);\r\n\r\n\t\/\/ add int + Cents using a friend function\r\n\tfriend Cents operator+(int value, const Cents&amp; c1);\r\n\r\n\r\n\tint getCents() const { return m_cents; }\r\n};\r\n\r\n\/\/ note: this function is not a member function!\r\nCents operator+(const Cents&amp; c1, int value)\r\n{\r\n\t\/\/ use the Cents constructor and operator+(int, int)\r\n\t\/\/ we can access m_cents directly because this is a friend function\r\n\treturn Cents { c1.m_cents + value };\r\n}\r\n\r\n\/\/ note: this function is not a member function!\r\nCents operator+(int value, const Cents&amp; c1)\r\n{\r\n\t\/\/ use the Cents constructor and operator+(int, int)\r\n\t\/\/ we can access m_cents directly because this is a friend function\r\n\treturn Cents { c1.m_cents + value };\r\n}\r\n\r\nint main()\r\n{\r\n\tCents c1{ Cents{ 4 } + 6 };\r\n\tCents c2{ 6 + Cents{ 4 } };\r\n\r\n\tstd::cout &lt;&lt; \"I have \" &lt;&lt; c1.getCents() &lt;&lt; \" cents.\\n\";\r\n\tstd::cout &lt;&lt; \"I have \" &lt;&lt; c2.getCents() &lt;&lt; \" cents.\\n\";\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Note that both overloaded functions have the same implementation -- that&#8217;s because they do the same thing, they just take their parameters in a different order.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Another example<\/p>\n<p>Let&#8217;s take a look at another example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass MinMax\r\n{\r\nprivate:\r\n\tint m_min {}; \/\/ The min value seen so far\r\n\tint m_max {}; \/\/ The max value seen so far\r\n\r\npublic:\r\n\tMinMax(int min, int max)\r\n\t\t: m_min { min }, m_max { max }\r\n\t{ }\r\n\r\n\tint getMin() const { return m_min; }\r\n\tint getMax() const { return m_max; }\r\n\r\n\tfriend MinMax operator+(const MinMax&amp; m1, const MinMax&amp; m2);\r\n\tfriend MinMax operator+(const MinMax&amp; m, int value);\r\n\tfriend MinMax operator+(int value, const MinMax&amp; m);\r\n};\r\n\r\nMinMax operator+(const MinMax&amp; m1, const MinMax&amp; m2)\r\n{\r\n\t\/\/ Get the minimum value seen in m1 and m2\r\n\tint min{ m1.m_min &lt; m2.m_min ? m1.m_min : m2.m_min };\r\n\r\n\t\/\/ Get the maximum value seen in m1 and m2\r\n\tint max{ m1.m_max &gt; m2.m_max ? m1.m_max : m2.m_max };\r\n\r\n\treturn MinMax { min, max };\r\n}\r\n\r\nMinMax operator+(const MinMax&amp; m, int value)\r\n{\r\n\t\/\/ Get the minimum value seen in m and value\r\n\tint min{ m.m_min &lt; value ? m.m_min : value };\r\n\r\n\t\/\/ Get the maximum value seen in m and value\r\n\tint max{ m.m_max &gt; value ? m.m_max : value };\r\n\r\n\treturn MinMax { min, max };\r\n}\r\n\r\nMinMax operator+(int value, const MinMax&amp; m)\r\n{\r\n\t\/\/ calls operator+(MinMax, int)\r\n\treturn m + value;\r\n}\r\n\r\nint main()\r\n{\r\n\tMinMax m1{ 10, 15 };\r\n\tMinMax m2{ 8, 11 };\r\n\tMinMax m3{ 3, 12 };\r\n\r\n\tMinMax mFinal{ m1 + m2 + 5 + 8 + m3 + 16 };\r\n\r\n\tstd::cout &lt;&lt; \"Result: (\" &lt;&lt; mFinal.getMin() &lt;&lt; \", \" &lt;&lt;\r\n\t\tmFinal.getMax() &lt;&lt; \")\\n\";\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>The MinMax class keeps track of the minimum and maximum values that it has seen so far.  We have overloaded the + operator 3 times, so that we can add two MinMax objects together, or add integers to MinMax objects.<\/p>\n<p>This example produces the result:<\/p>\n<pre>\r\nResult: (3, 16)\r\n<\/pre>\n<p>which you will note is the minimum and maximum values that we added to mFinal.<\/p>\n<p>Let&#8217;s talk a little bit more about how &#8220;MinMax mFinal { m1 + m2 + 5 + 8 + m3 + 16 }&#8221; evaluates.  Remember that operator+ evaluates from left to right, so m1 + m2 evaluates first.  This becomes a call to operator+(m1, m2), which produces the return value MinMax(8, 15).  Then MinMax(8, 15) + 5 evaluates next.  This becomes a call to operator+(MinMax(8, 15), 5), which produces return value MinMax(5, 15).  Then MinMax(5, 15) + 8 evaluates in the same way to produce MinMax(5, 15).  Then MinMax(5, 15) + m3 evaluates to produce MinMax(3, 15).  And finally, MinMax(3, 15) + 16 evaluates to MinMax(3, 16).  This final result is then used to initialize mFinal.<\/p>\n<p>In other words, this expression evaluates as &#8220;MinMax mFinal = (((((m1 + m2) + 5) + 8) + m3) + 16)&#8221;, with each successive operation returning a MinMax object that becomes the left-hand operand for the following operator.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Implementing operators using other operators<\/p>\n<p>In the above example, note that we defined operator+(int, MinMax) by calling operator+(MinMax, int) (which produces the same result).  This allows us to reduce the implementation of operator+(int, MinMax) to a single line, making our code easier to maintain by minimizing redundancy and making the function simpler to understand.<\/p>\n<p>It is often possible to define overloaded operators by calling other overloaded operators.  You should do so if and when doing so produces simpler code.  In cases where the implementation is trivial (e.g. a single line) it may or may not be worth doing this.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #1<\/p>\n<p>\na) Write a class named Fraction that has an integer numerator and denominator member.  Write a print() function that prints out the fraction.<\/p>\n<p>The following code should compile:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    Fraction f1{ 1, 4 };\r\n    f1.print();\r\n\r\n    Fraction f2{ 1, 2 };\r\n    f2.print();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This should print:<\/p>\n<pre>\r\n1\/4\r\n1\/2\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Fraction\r\n{\r\nprivate:\r\n\tint m_numerator { 0 };\r\n\tint m_denominator { 1 };\r\n\r\npublic:\r\n\texplicit Fraction(int numerator, int denominator=1)\r\n\t\t: m_numerator{numerator}, m_denominator{denominator}\r\n\t{\r\n\t}\r\n\r\n\tvoid print() const\r\n\t{\r\n\t\tstd::cout &lt;&lt; m_numerator &lt;&lt; '\/' &lt;&lt; m_denominator &lt;&lt; '\\n';\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tFraction f1 {1, 4};\r\n\tf1.print();\r\n\t\r\n\tFraction f2 {1, 2};\r\n\tf2.print();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>b) Add overloaded multiplication operators to handle multiplication between a Fraction and integer, and between two Fractions.  Use the friend function method.<\/p>\n<p>Hint: To multiply two fractions, first multiply the two numerators together, and then multiply the two denominators together.  To multiply a fraction and an integer, multiply the numerator of the fraction by the integer and leave the denominator alone.<\/p>\n<p>The following code should compile:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    Fraction f1{2, 5};\r\n    f1.print();\r\n\r\n    Fraction f2{3, 8};\r\n    f2.print();\r\n\r\n    Fraction f3{ f1 * f2 };\r\n    f3.print();\r\n\r\n    Fraction f4{ f1 * 2 };\r\n    f4.print();\r\n\r\n    Fraction f5{ 2 * f2 };\r\n    f5.print();\r\n\r\n    Fraction f6{ Fraction{1, 2} * Fraction{2, 3} * Fraction{3, 4} };\r\n    f6.print();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This should print:<\/p>\n<pre>\r\n2\/5\r\n3\/8\r\n6\/40\r\n4\/5\r\n6\/8\r\n6\/24\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Fraction\r\n{\r\nprivate:\r\n\tint m_numerator { 0 };\r\n\tint m_denominator { 1 };\r\n\r\npublic:\r\n\texplicit Fraction(int numerator, int denominator=1)\r\n\t\t: m_numerator{numerator}, m_denominator{denominator}\r\n\t{\r\n\t}\r\n\r\n\t\/\/ We don't want to pass by value, because copying is slow.\r\n\t\/\/ We can't and shouldn't pass by non-const reference, because then\r\n\t\/\/ our functions wouldn't work with r-values.\r\n\tfriend Fraction operator*(const Fraction&amp; f1, const Fraction&amp; f2);\r\n\tfriend Fraction operator*(const Fraction&amp; f1, int value);\r\n\tfriend Fraction operator*(int value, const Fraction&amp; f1);\r\n\r\n\tvoid print() const\r\n\t{\r\n\t\tstd::cout &lt;&lt; m_numerator &lt;&lt; '\/' &lt;&lt; m_denominator &lt;&lt; '\\n';\r\n\t}\r\n};\r\n\r\nFraction operator*(const Fraction&amp; f1, const Fraction&amp; f2)\r\n{\r\n\treturn Fraction { f1.m_numerator * f2.m_numerator, f1.m_denominator * f2.m_denominator };\r\n}\r\n\r\nFraction operator*(const Fraction&amp; f1, int value)\r\n{\r\n\treturn Fraction { f1.m_numerator * value, f1.m_denominator };\r\n}\r\n\r\nFraction operator*(int value, const Fraction&amp; f1)\r\n{\r\n\treturn Fraction { f1 * value };\r\n}\r\n\r\nint main()\r\n{\r\n\tFraction f1{2, 5};\r\n\tf1.print();\r\n\r\n\tFraction f2{3, 8};\r\n\tf2.print();\r\n\r\n\tFraction f3{ f1 * f2 };\r\n\tf3.print();\r\n\r\n\tFraction f4{ f1 * 2 };\r\n\tf4.print();\r\n\r\n\tFraction f5{ 2 * f2 };\r\n\tf5.print();\r\n\r\n\tFraction f6{ Fraction{1, 2} * Fraction{2, 3} * Fraction{3, 4} };\r\n\tf6.print();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>c) Why does the program continue to work correctly if we make the constructor non-explicit and remove the operators for integer multiplication from the previous solution?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Remove explicit from constructor\r\n\tFraction(int numerator, int denominator=1)\r\n\t\t: m_numerator{numerator}, m_denominator{denominator}\r\n\t{\r\n\t}\r\n\r\n\/\/ We can remove these operators, and the program continues to work\r\nFraction operator*(const Fraction&amp; f1, int value);\r\nFraction operator*(int value, const Fraction&amp; f1);<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<p>We still have<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">Fraction operator*(const Fraction&amp; f1, const Fraction&amp; f2)<\/code><\/pre>\n<p>When we multiply a fraction with an integer, for example <\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">Fraction f5{ 2 * f2 };<\/code><\/pre>\n<p>The non-explicit <code>Fraction(int, int)<\/code> constructor will be used to construct a new <code>Fraction<\/code> from 2. This new <code>Fraction<\/code> is then multiplied by <code>f2<\/code> using the <code>Fraction * Fraction<\/code> operator.<\/p>\n<p>Because this requires converting <code>2<\/code> to a <code>Fraction<\/code>, this is slightly slower than the implementation with overloaded operators for integer multiplication.\n<\/div>\n<p>d) If we make the reference parameters of the <code>operator*(Fraction, Fraction)<\/code> non-const, the following line from the <code>main<\/code> function no longer works. Why?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ The non-const multiplication operator looks like this\r\nFraction operator*(Fraction&amp; f1, Fraction&amp; f2)\r\n\r\n\/\/ This doesn't work anymore\r\nFraction f6{ Fraction{1, 2} * Fraction{2, 3} * Fraction{3, 4} };<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<p>We&#8217;re multiplying temporary <code>Fraction<\/code> objects, but non-const references cannot bind to temporaries.\n<\/div>\n<p>e) Extra credit: the fraction 2\/4 is the same as 1\/2, but 2\/4 is not reduced to the lowest terms.  We can reduce any given fraction to lowest terms by finding the greatest common divisor (GCD) between the numerator and denominator, and then dividing both the numerator and denominator by the GCD.<\/p>\n<p><code>std::gcd()<\/code> was added to the standard library in C++17 (in the &lt;numeric&gt; header).<\/p>\n<p>If you&#8217;re on an older compiler, you can use this function to find the GCD:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cmath&gt; \/\/ for std::abs\r\n\r\nint gcd(int a, int b) {\r\n    return (b == 0) ? std::abs(a) : gcd(b, a % b);\r\n}<\/code><\/pre>\n<p>Write a member function named reduce() that reduces your fraction.  Make sure all fractions are properly reduced.<\/p>\n<p>The following should compile:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    Fraction f1{2, 5};\r\n    f1.print();\r\n\r\n    Fraction f2{3, 8};\r\n    f2.print();\r\n\r\n    Fraction f3{ f1 * f2 };\r\n    f3.print();\r\n\r\n    Fraction f4{ f1 * 2 };\r\n    f4.print();\r\n\r\n    Fraction f5{ 2 * f2 };\r\n    f5.print();\r\n\r\n    Fraction f6{ Fraction{1, 2} * Fraction{2, 3} * Fraction{3, 4} };\r\n    f6.print();\r\n\r\n    Fraction f7{0, 6};\r\n    f7.print();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>And produce the result:<\/p>\n<pre>\r\n2\/5\r\n3\/8\r\n3\/20\r\n4\/5\r\n3\/4\r\n1\/4\r\n0\/1\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;numeric&gt; \/\/ for std::gcd\r\n\r\n\/\/ This version of the Fraction class auto-reduces fractions\r\nclass Fraction\r\n{\r\nprivate:\r\n\tint m_numerator{ 0 };\r\n\tint m_denominator{ 1 };\r\n\r\npublic:\r\n\texplicit Fraction(int numerator, int denominator = 1)\r\n\t\t: m_numerator{ numerator }, m_denominator{ denominator }\r\n\t{\r\n\t\t\/\/ We put reduce() in the constructor to ensure any fractions we make get reduced!\r\n\t\t\/\/ Since all of the overloaded operators create new Fractions, we can guarantee this will get called here\r\n\t\treduce();\r\n\t}\r\n\r\n\tvoid reduce()\r\n\t{\r\n\t\tint gcd{ std::gcd(m_numerator, m_denominator) };\r\n\t\tif (gcd) \/\/ Make sure we don't try to divide by 0\r\n\t\t{\r\n\t\t\tm_numerator \/= gcd;\r\n\t\t\tm_denominator \/= gcd;\r\n\t\t}\r\n\t}\r\n\r\n\tfriend Fraction operator*(const Fraction&amp; f1, const Fraction&amp; f2);\r\n\tfriend Fraction operator*(const Fraction&amp; f1, int value);\r\n\tfriend Fraction operator*(int value, const Fraction&amp; f1);\r\n\r\n\tvoid print() const\r\n\t{\r\n\t\tstd::cout &lt;&lt; m_numerator &lt;&lt; '\/' &lt;&lt; m_denominator &lt;&lt; '\\n';\r\n\t}\r\n};\r\n\r\nFraction operator*(const Fraction&amp; f1, const Fraction&amp; f2)\r\n{\r\n\treturn Fraction { f1.m_numerator * f2.m_numerator, f1.m_denominator * f2.m_denominator };\r\n}\r\n\r\nFraction operator*(const Fraction&amp; f1, int value)\r\n{\r\n\treturn Fraction { f1.m_numerator * value, f1.m_denominator };\r\n}\r\n\r\nFraction operator*(int value, const Fraction&amp; f1)\r\n{\r\n\treturn Fraction { f1 * value };\r\n}\r\n\r\nint main()\r\n{\r\n\tFraction f1{ 2, 5 };\r\n\tf1.print();\r\n\r\n\tFraction f2{ 3, 8 };\r\n\tf2.print();\r\n\r\n\tFraction f3{ f1 * f2 };\r\n\tf3.print();\r\n\r\n\tFraction f4{ f1 * 2 };\r\n\tf4.print();\r\n\r\n\tFraction f5{ 2 * f2 };\r\n\tf5.print();\r\n\r\n\tFraction f6{ Fraction{1, 2} * Fraction{2, 3} * Fraction{3, 4} };\r\n\tf6.print();\r\n\r\n\tFraction f7{ 0, 6 };\r\n\tf7.print();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-operators-using-normal-functions\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.3<\/span>Overloading operators using normal functions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-operator-overloading\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.1<\/span>Introduction to operator overloading\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Some of the most commonly used operators in C++ are the arithmetic operators &#8212; that is, the plus operator (+), minus operator (-), multiplication operator (*), and division operator (\/). Note that all of the arithmetic operators are binary operators &#8212; meaning they take two operands &#8212; one on each &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/138"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=138"}],"version-history":[{"count":57,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/138\/revisions"}],"predecessor-version":[{"id":17783,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/138\/revisions\/17783"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=138"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=138"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=138"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}