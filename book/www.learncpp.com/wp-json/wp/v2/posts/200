{"id":200,"date":"2008-04-18T16:54:25","date_gmt":"2008-04-19T00:54:25","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=200"},"modified":"2025-01-27T09:36:05","modified_gmt":"2025-01-27T17:36:05","slug":"function-templates","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/function-templates\/","title":{"rendered":"11.6 &#8212; Function templates"},"content":{"rendered":"<p>Let&#8217;s say you wanted to write a function to calculate the maximum of two numbers.  You might do so like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int max(int x, int y)\r\n{\r\n    return (x &lt; y) ? y : x;\r\n    \/\/ Note: we use &lt; instead of &gt; because std::max uses &lt;\r\n}<\/code><\/pre>\n<p>While the caller can pass different values into the function, the type of the parameters is fixed, so the caller can only pass in <code>int<\/code> values.  That means this function really only works well for integers (and types that can be promoted to <code>int<\/code>).<\/p>\n<p>So what happens later when you want to find the max of two <code>double<\/code> values?  Because C++ requires us to specify the type of all function parameters, the solution is to create a new overloaded version of <code>max<\/code> with parameters of type <code>double<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">double max(double x, double y)\r\n{\r\n    return (x &lt; y) ? y: x;\r\n}<\/code><\/pre>\n<p>Note that the code for the implementation of the double version of <code>max<\/code> is exactly the same as for the int version of <code>max<\/code>!  In fact, this implementation works for many different types: including <code>int<\/code>, <code>double<\/code>, <code>long<\/code>, <code>long double<\/code>, and even new types that you&#8217;ve created yourself (which we&#8217;ll cover how to do in future lessons).<\/p>\n<p>Having to create overloaded functions with the same implementation for each set of parameter types we want to support is a maintenance headache, a recipe for errors, and a clear violation of the DRY (don&#8217;t repeat yourself) principle.  There&#8217;s a less-obvious challenge here as well: a programmer who wishes to use the <code>max<\/code> function may wish to call it with an argument type that the author of the <code>max<\/code> did not anticipate (and thus did not write an overloaded function for).<\/p>\n<p>What we are really missing is some way to write a single version of <code>max<\/code> that can work with arguments of any type (even types that may not have been anticipated when the code for <code>max<\/code> was written).  Normal functions are simply not up to the task here.  Fortunately, C++ supports another feature that was designed specifically to solve this kind of problem.<\/p>\n<p>Welcome to the world of C++ templates.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Introduction to C++ templates<\/p>\n<p>In C++, the template system was designed to simplify the process of creating functions (or classes) that are able to work with different data types.<\/p>\n<p>Instead of manually creating a bunch of mostly-identical functions or classes (one for each set of different types), we instead create a single <em>template<\/em>.  Just like a normal definition, a <strong>template<\/strong> definition describes what a function or class looks like.  Unlike a normal definition (where all types must be specified), in a template we can use one or more placeholder types.  A placeholder type represents some type that is not known at the time the template is defined, but that will be provided later (when the template is used).<\/p>\n<p>Once a template is defined, the compiler can use the template to generate as many overloaded functions (or classes) as needed, each using different actual types!<\/p>\n<p>The end result is the same -- we end up with a bunch of mostly-identical functions or classes (one for each set of different types).  But we only have to create and maintain a single template, and the compiler does all the hard work to create the rest for us.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>The compiler can use a single template to generate a family of related functions or classes, each using a different set of actual types.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>Because the concept behind templates can be hard to describe in words, let&#8217;s try an analogy.<\/p>\n<p>If you were to look up the word &#8220;template&#8221; in the dictionary, you&#8217;d find a definition that was similar to the following: &#8220;a template is a model that serves as a pattern for creating similar objects&#8221;.  One type of template that is very easy to understand is that of a stencil.  A stencil is a thin piece of material (such as a piece of cardboard or plastic) with a shape cut out of it (e.g. a happy face).  By placing the stencil on top of another object, then spraying paint through the hole, you can very quickly replicate the cut-out shape.  The stencil itself only needs to be created once, and then it can be reused as many times as desired, to create the cut out shape in as many different colors as you like.  Even better, the color of a shape made with the stencil doesn&#8217;t have to be determined until the stencil is actually used.<\/p>\n<p>A template is essentially a stencil for creating functions or classes.  We create the template (our stencil) once, and then we can use it as many times as needed, to stencil out a function or class for a specific set of actual types.  Those actual types don&#8217;t need to be determined until the template is actually used.\n<\/p><\/div>\n<p>Because the actual types aren&#8217;t determined until the template is used in a program (not when the template is written), the author of the template doesn&#8217;t have to try to anticipate all of the actual types that might be used.  This means template code can be used with types that didn&#8217;t even exist when the template was written!  We&#8217;ll see how this comes in handy later, when we start exploring the C++ standard library, which is absolutely full of template code!<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Templates can work with types that didn&#8217;t even exist when the template was written.  This helps make template code both flexible and future proof!\n<\/p><\/div>\n<p>In the rest of this lesson, we&#8217;ll introduce and explore how to create function templates, and describe how they work in more detail.  We&#8217;ll save discussion of class templates until after we&#8217;ve covered what classes are.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Function templates<\/p>\n<p>A <strong>function template<\/strong> is a function-like definition that is used to generate one or more overloaded functions, each with a different set of actual types.  This is what will allow us to create functions that can work with many different types.  The initial function template that is used to generate other functions is called the <strong>primary template<\/strong>, and the functions generated from the primary template are called <strong>instantiated functions<\/strong>.<\/p>\n<p>When we create a primary function template, we use <strong>placeholder types<\/strong> (technically called <strong>type template parameters<\/strong>, informally called <strong>template types<\/strong>) for any parameter types, return types, or types used in the function body that we want to be specified later, by the user of the template.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>C++ supports 3 different kinds of template parameters:<\/p>\n<ul>\n<li>Type template parameters (where the template parameter represents a type).\n<\/li>\n<li>Non-type template parameters (where the template parameter represents a constexpr value).\n<\/li>\n<li>Template template parameters (where the template parameter represents a template).\n<\/li>\n<\/ul>\n<p>Type template parameters are by far the most common, so we&#8217;ll focus on those first.  We&#8217;ll also discuss non-type template parameters, which are seeing increased usage in modern C++.\n<\/p><\/div>\n<p>Function templates are something that is best taught by example, so let&#8217;s convert our normal <code>max(int, int)<\/code> function from the example above into a function template.  It&#8217;s surprisingly easy, and we&#8217;ll explain what&#8217;s happening along the way.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Creating a <code>max()<\/code> function template<\/p>\n<p>Here&#8217;s the <code>int<\/code> version of <code>max()<\/code> again:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int max(int x, int y)\r\n{\r\n    return (x &lt; y) ? y : x;\r\n}<\/code><\/pre>\n<p>Note that we use type <code>int<\/code> three times in this function: once for parameter <code>x<\/code>, once for parameter <code>y<\/code>, and once for the return type of the function.<\/p>\n<p>To create a function template for <code>max()<\/code>, we&#8217;re going to do two things.  First, we&#8217;re going to replace any actual types that we want to be specified later with type template parameters.  In this case, because we have only one type that needs replacing (<code>int<\/code>), we only need one type template parameter (which we&#8217;ll call <code>T<\/code>):<\/p>\n<p>Here&#8217;s our new function that uses a single template type, where all occurrences of actual type <code>int<\/code> have been replaced with type template parameter <code>T<\/code> :<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">T max(T x, T y) \/\/ won't compile because we haven't defined T\r\n{\r\n    return (x &lt; y) ? y : x;\r\n}<\/code><\/pre>\n<p>This is a good start -- however, it won&#8217;t compile because the compiler doesn&#8217;t know what <code>T<\/code> is!  And this is still a normal function, not a function template.<\/p>\n<p>Second, we&#8217;re going to tell the compiler that this is a template, and that <code>T<\/code> is a type template parameter that is a placeholder for any type.  Both of these are done using a <strong>template parameter declaration<\/strong>, which defines any template parameters that will be subsequently used.  The scope of a template parameter declaration is strictly limited to the function template (or class template) that follows.  Therefore, each function template or class template needs its own template parameter declaration.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;typename T&gt; \/\/ this is the template parameter declaration defining T as a type template parameter\r\nT max(T x, T y) \/\/ this is the function template definition for max&lt;T&gt;\r\n{\r\n    return (x &lt; y) ? y : x;\r\n}<\/code><\/pre>\n<p>In our template parameter declaration, we start with the keyword <code>template<\/code>, which tells the compiler that we&#8217;re creating a template.  Next, we specify all of the template parameters that our template will use inside angled brackets (<code>&lt;&gt;<\/code>).  For each type template parameter, we use the keyword <code>typename<\/code> (preferred) or <code>class<\/code>, followed by the name of the type template parameter (e.g. <code>T<\/code>).<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We discuss how to create function templates with multiple template types in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-templates-with-multiple-template-types\/\">11.8 -- Function templates with multiple template types<\/a>.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>There is no difference between the <code>typename<\/code> and <code>class<\/code> keywords in this context.  You will often see people use the <code>class<\/code> keyword since it was introduced into the language earlier.  However, we prefer the newer <code>typename<\/code> keyword, because it makes it clearer that the type template parameter can be replaced by any type (such as a fundamental type), not just class types.\n<\/div>\n<p>Believe it or not, we&#8217;re done!  We have created a template version of our <code>max()<\/code> function that can accept arguments of different types.<\/p>\n<p>In the next lesson, we&#8217;ll look at how we use our <code>max<\/code> function template to generate one or more <code>max()<\/code> functions with parameters of different types and actually call those functions.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Naming template parameters<\/p>\n<p>Much like we often use a single letter for variable names used in trivial situations (e.g. <code>x<\/code>), it&#8217;s conventional to use a single capital letter (starting with <code>T<\/code>) when the template parameter is used in a trivial or obvious way.  For example, in our <code>max<\/code> function template:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;typename T&gt;\r\nT max(T x, T y)\r\n{\r\n    return (x &lt; y) ? y : x;\r\n}<\/code><\/pre>\n<p>We don&#8217;t need to give <code>T<\/code> a complex name, because it&#8217;s obviously just a placeholder type for the values being compared, and <code>T<\/code> can be any type that can be compared (such as <code>int<\/code>, <code>double<\/code>, or <code>char<\/code>, but not <code>nullptr<\/code>).<\/p>\n<p>Our function templates will generally use this naming convention.<\/p>\n<p>If a type template parameter has a non-obvious usage or specific requirements that must be met, there are two common conventions for such names:<\/p>\n<ul>\n<li>Starting with a capital letter (e.g. <code>Allocator<\/code>).  The standard library uses this naming convention.\n<\/li>\n<li>Prefixed with a <code>T<\/code>, then starting with a capital letter (e.g. <code>TAllocator<\/code>).  This makes it easier to see that the type is a type template parameter.\n<\/li>\n<\/ul>\n<p>Which you choose is a matter of personal preference.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>As an example, the standard library has an overload of <code>std::max()<\/code> that is declared like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template&lt; class T, class Compare &gt;\r\nconst T&amp; max( const T&amp; a, const T&amp; b, Compare comp ); \/\/ ignore the &amp; for now, we'll cover these in a future lesson<\/code><\/pre>\n<p>Because <code>a<\/code> and <code>b<\/code> are of type <code>T<\/code>, we know that we don&#8217;t care what type <code>a<\/code> and <code>b<\/code> are -- they can be any type.  Because <code>comp<\/code> has type <code>Compare<\/code>, we know that <code>comp<\/code> must be a type that meets the requirements for a <code>Compare<\/code> (whatever that is).<\/p>\n<p>When a function template is instantiated, the compiler replaces the template parameters with the template arguments and then compiles the resulting instantiated function.  Whether the function compiles depends on how the object(s) of each type are used within the function.  Therefore, the requirements for a given template parameter are essentially implicitly defined.<\/p>\n<p>Because it can be hard to infer requirements from how objects of the type are used, this is one of those areas where it is useful to consult technical documentation, which should explicitly state the requirements.  For example, if we want to know what the requirements for a <code>Compare<\/code> are, we can look up the documentation for <code>std::max<\/code> (e.g. see <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/algorithm\/max\">https:\/\/en.cppreference.com\/w\/cpp\/algorithm\/max<\/a>) and it should be listed there.\n<\/div>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Use a single capital letter starting with <code>T<\/code> (e.g. <code>T<\/code>, <code>U<\/code>, <code>V<\/code>, etc&#8230;) to name type template parameters that are used in trivial or obvious ways and represent &#8220;any reasonable type&#8221;.<\/p>\n<p>If the type template parameter has a non-obvious usage or specific requirements that must be met, then a more descriptive name is warranted (e.g. <code>Allocator<\/code> or <code>TAllocator<\/code>).\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Describe why construction blueprints are a type of template.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>The construction blueprint itself is just a piece of paper that describes how to construct a building.  Using the blueprint, construction crews can quickly erect many buildings with an identical structure.  However, the specific material types used for each building can vary (e.g. what type of material is used for the siding of the building), and don&#8217;t need to be determined until the buildings are actually built.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-template-instantiation\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">11.7<\/span>Function template instantiation\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/default-arguments\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">11.5<\/span>Default arguments\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Let&#8217;s say you wanted to write a function to calculate the maximum of two numbers. You might do so like this: int max(int x, int y) { return (x &lt; y) ? y : x; \/\/ Note: we use &lt; instead of &gt; because std::max uses &lt; } While the &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[12,13,14,15,16],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/200"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=200"}],"version-history":[{"count":38,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/200\/revisions"}],"predecessor-version":[{"id":5097,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/200\/revisions\/5097"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=200"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=200"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=200"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}