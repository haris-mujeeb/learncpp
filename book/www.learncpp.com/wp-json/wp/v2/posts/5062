{"id":5062,"date":"2016-11-22T16:48:26","date_gmt":"2016-11-23T00:48:26","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=5062"},"modified":"2024-12-29T17:43:16","modified_gmt":"2024-12-30T01:43:16","slug":"dynamic-casting","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/dynamic-casting\/","title":{"rendered":"25.10 &#8212; Dynamic casting"},"content":{"rendered":"<p>Way back in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/explicit-type-conversion-casting-and-static-cast\/\">10.6 -- Explicit type conversion (casting) and static_cast<\/a>, we examined the concept of casting, and the use of static_cast to convert variables from one type to another.<\/p>\n<p>In this lesson, we&#8217;ll continue by examining another type of cast: dynamic_cast.<\/p>\n<p><strong>The need for dynamic_cast<\/strong><\/p>\n<p>When dealing with polymorphism, you&#8217;ll often encounter cases where you have a pointer to a base class, but you want to access some information that exists only in a derived class.<\/p>\n<p>Consider the following (slightly contrived) program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Base\r\n{\r\nprotected:\r\n\tint m_value{};\r\n\r\npublic:\r\n\tBase(int value)\r\n\t\t: m_value{value}\r\n\t{\r\n\t}\r\n\t\r\n\tvirtual ~Base() = default;\r\n};\r\n\r\nclass Derived : public Base\r\n{\r\nprotected:\r\n\tstd::string m_name{};\r\n\r\npublic:\r\n\tDerived(int value, std::string_view name)\r\n\t\t: Base{value}, m_name{name}\r\n\t{\r\n\t}\r\n\r\n\tconst std::string&amp; getName() const { return m_name; }\r\n};\r\n\r\nBase* getObject(bool returnDerived)\r\n{\r\n\tif (returnDerived)\r\n\t\treturn new Derived{1, \"Apple\"};\r\n\telse\r\n\t\treturn new Base{2};\r\n}\r\n\r\nint main()\r\n{\r\n\tBase* b{ getObject(true) };\r\n\r\n\t\/\/ how do we print the Derived object's name here, having only a Base pointer?\r\n\r\n\tdelete b;\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In this program, function getObject() always returns a Base pointer, but that pointer may be pointing to either a Base or a Derived object.  In the case where the Base pointer is actually pointing to a Derived object, how would we call Derived::getName()?<\/p>\n<p>One way would be to add a virtual function to Base called getName() (so we could call it with a Base pointer\/reference, and have it dynamically resolve to Derived::getName()).  But what would this function return if you called it with a Base pointer\/reference that was actually pointing to a Base object?  There isn&#8217;t really any value that makes sense.  Furthermore, we would be polluting our Base class with things that really should only be the concern of the Derived class.<\/p>\n<p>We know that C++ will implicitly let you convert a Derived pointer into a Base pointer (in fact, getObject() does just that).  This process is sometimes called <strong>upcasting<\/strong>.  However, what if there was a way to convert a Base pointer back into a Derived pointer?  Then we could call Derived::getName() directly using that pointer, and not have to worry about virtual function resolution at all.<\/p>\n<p><strong>dynamic_cast<\/strong><\/p>\n<p>C++ provides a casting operator named <strong>dynamic_cast<\/strong> that can be used for just this purpose.  Although dynamic casts have a few different capabilities, by far the most common use for dynamic casting is for converting base-class pointers into derived-class pointers.  This process is called <strong>downcasting<\/strong>.<\/p>\n<p>Using dynamic_cast works just like static_cast.  Here&#8217;s our example main() from above, using a dynamic_cast to convert our Base pointer back into a Derived pointer:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n\tBase* b{ getObject(true) };\r\n\r\n\tDerived* d{ dynamic_cast&lt;Derived*&gt;(b) }; \/\/ use dynamic cast to convert Base pointer into Derived pointer\r\n\r\n\tstd::cout &lt;&lt; \"The name of the Derived is: \" &lt;&lt; d-&gt;getName() &lt;&lt; '\\n';\r\n\r\n\tdelete b;\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\nThe name of the Derived is: Apple\r\n<\/pre>\n<p><strong>dynamic_cast failure<\/strong><\/p>\n<p>The above example works because b is actually pointing to a Derived object, so converting b into a Derived pointer is successful.<\/p>\n<p>However, we&#8217;ve made quite a dangerous assumption: that b is pointing to a Derived object.  What if b wasn&#8217;t pointing to a Derived object?  This is easily tested by changing the argument to getObject() from true to false.  In that case, getObject() will return a Base pointer to a Base object.  When we try to dynamic_cast that to a Derived, it will fail, because the conversion can&#8217;t be made.<\/p>\n<p>If a dynamic_cast fails, the result of the conversion will be a null pointer.<\/p>\n<p>Because we haven&#8217;t checked for a null pointer result, we access d->getName(), which will try to dereference a null pointer, leading to undefined behavior (probably a crash).<\/p>\n<p>In order to make this program safe, we need to ensure the result of the dynamic_cast actually succeeded:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n\tBase* b{ getObject(true) };\r\n\r\n\tDerived* d{ dynamic_cast&lt;Derived*&gt;(b) }; \/\/ use dynamic cast to convert Base pointer into Derived pointer\r\n\r\n\tif (d) \/\/ make sure d is non-null\r\n\t\tstd::cout &lt;&lt; \"The name of the Derived is: \" &lt;&lt; d-&gt;getName() &lt;&lt; '\\n';\r\n\r\n\tdelete b;\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightpurplebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Rule<\/p>\n<p>Always ensure your dynamic casts actually succeeded by checking for a null pointer result.\n<\/p><\/div>\n<p>Note that because dynamic_cast does some consistency checking at runtime (to ensure the conversion can be made), use of dynamic_cast does incur a performance penalty.<\/p>\n<p>Also note that there are several cases where downcasting using dynamic_cast will not work:<\/p>\n<ol start=\"1\">\n<li>With protected or private inheritance.\n<\/li>\n<li>For classes that do not declare or inherit any virtual functions (and thus don&#8217;t have a virtual table).\n<\/li>\n<li>In certain cases involving virtual base classes (see <a href=\"https:\/\/msdn.microsoft.com\/en-us\/library\/cby9kycs.aspx\">this page<\/a> for an example of some of these cases, and how to resolve them).\n<\/li>\n<\/ol>\n<p><strong>Downcasting with static_cast<\/strong><\/p>\n<p>It turns out that downcasting can also be done with static_cast. The main difference is that static_cast does no runtime type checking to ensure that what you&#8217;re doing makes sense.  This makes using static_cast faster, but more dangerous.  If you cast a Base* to a Derived*, it will &#8220;succeed&#8221; even if the Base pointer isn&#8217;t pointing to a Derived object.  This will result in undefined behavior when you try to access the resulting Derived pointer (that is actually pointing to a Base object).<\/p>\n<p>If you&#8217;re absolutely sure that the pointer you&#8217;re downcasting will succeed, then using static_cast is acceptable.  One way to ensure that you know what type of object you&#8217;re pointing to is to use a virtual function.  Here&#8217;s one (not great) way to do that:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\n\/\/ Class identifier\r\nenum class ClassID\r\n{\r\n\tbase,\r\n\tderived\r\n\t\/\/ Others can be added here later\r\n};\r\n\r\nclass Base\r\n{\r\nprotected:\r\n\tint m_value{};\r\n\r\npublic:\r\n\tBase(int value)\r\n\t\t: m_value{value}\r\n\t{\r\n\t}\r\n\r\n\tvirtual ~Base() = default;\r\n\tvirtual ClassID getClassID() const { return ClassID::base; }\r\n};\r\n\r\nclass Derived : public Base\r\n{\r\nprotected:\r\n\tstd::string m_name{};\r\n\r\npublic:\r\n\tDerived(int value, std::string_view name)\r\n\t\t: Base{value}, m_name{name}\r\n\t{\r\n\t}\r\n\r\n\tconst std::string&amp; getName() const { return m_name; }\r\n\tClassID getClassID() const override { return ClassID::derived; }\r\n\r\n};\r\n\r\nBase* getObject(bool bReturnDerived)\r\n{\r\n\tif (bReturnDerived)\r\n\t\treturn new Derived{1, \"Apple\"};\r\n\telse\r\n\t\treturn new Base{2};\r\n}\r\n\r\nint main()\r\n{\r\n\tBase* b{ getObject(true) };\r\n\r\n\tif (b-&gt;getClassID() == ClassID::derived)\r\n\t{\r\n\t\t\/\/ We already proved b is pointing to a Derived object, so this should always succeed\r\n\t\tDerived* d{ static_cast&lt;Derived*&gt;(b) };\r\n\t\tstd::cout &lt;&lt; \"The name of the Derived is: \" &lt;&lt; d-&gt;getName() &lt;&lt; '\\n';\r\n\t}\r\n\r\n\tdelete b;\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>But if you&#8217;re going to go through all of the trouble to implement this (and pay the cost of calling a virtual function and processing the result), you might as well just use dynamic_cast.<\/p>\n<p>Also consider what would happen if our object were actually some class that is derived from Derived (let&#8217;s call it <code>D2<\/code>).  The above check <code>b-&gt;getClassID() == ClassID::derived<\/code> will fail because <code>getClassId()<\/code> would return <code>ClassID::D2<\/code>, which is not equal to <code>ClassID::derived<\/code>.  Dynamic casting <code>D2<\/code> to <code>Derived<\/code> would succeed though, since a <code>D2<\/code> is a <code>Derived<\/code>!<\/p>\n<p><strong>dynamic_cast and references<\/strong><\/p>\n<p>Although all of the above examples show dynamic casting of pointers (which is more common), dynamic_cast can also be used with references.  This works analogously to how dynamic_cast works with pointers.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Base\r\n{\r\nprotected:\r\n\tint m_value;\r\n\r\npublic:\r\n\tBase(int value)\r\n\t\t: m_value{value}\r\n\t{\r\n\t}\r\n\r\n\tvirtual ~Base() = default; \r\n};\r\n\r\nclass Derived : public Base\r\n{\r\nprotected:\r\n\tstd::string m_name;\r\n\r\npublic:\r\n\tDerived(int value, std::string_view name)\r\n\t\t: Base{value}, m_name{name}\r\n\t{\r\n\t}\r\n\r\n\tconst std::string&amp; getName() const { return m_name; }\r\n};\r\n\r\nint main()\r\n{\r\n\tDerived apple{1, \"Apple\"}; \/\/ create an apple\r\n\tBase&amp; b{ apple }; \/\/ set base reference to object\r\n\tDerived&amp; d{ dynamic_cast&lt;Derived&amp;&gt;(b) }; \/\/ dynamic cast using a reference instead of a pointer\r\n\r\n\tstd::cout &lt;&lt; \"The name of the Derived is: \" &lt;&lt; d.getName() &lt;&lt; '\\n'; \/\/ we can access Derived::getName through d\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Because C++ does not have a &#8220;null reference&#8221;, dynamic_cast can&#8217;t return a null reference upon failure.  Instead, if the dynamic_cast of a reference fails, an exception of type std::bad_cast is thrown.  We talk about exceptions later in this tutorial.<\/p>\n<p><strong>dynamic_cast vs static_cast<\/strong><\/p>\n<p>New programmers are sometimes confused about when to use static_cast vs dynamic_cast.  The answer is quite simple: use static_cast unless you&#8217;re downcasting, in which case dynamic_cast is usually a better choice.  However, you should also consider avoiding casting altogether and just use virtual functions.<\/p>\n<p><strong>Downcasting vs virtual functions<\/strong><\/p>\n<p>There are some developers who believe dynamic_cast is evil and indicative of a bad class design.  Instead, these programmers say you should use virtual functions.<\/p>\n<p>In general, using a virtual function <em>should<\/em> be preferred over downcasting.  However, there are times when downcasting is the better choice:<\/p>\n<ul>\n<li>When you can not modify the base class to add a virtual function (e.g. because the base class is part of the standard library)<\/li>\n<li>When you need access to something that is derived-class specific (e.g. an access function that only exists in the derived class)<\/li>\n<li>When adding a virtual function to your base class doesn&#8217;t make sense (e.g. there is no appropriate value for the base class to return).  Using a pure virtual function may be an option here if you don&#8217;t need to instantiate the base class.<\/li>\n<\/ul>\n<p><strong>A warning about dynamic_cast and RTTI<\/strong><\/p>\n<p>Run-time type information (RTTI) is a feature of C++ that exposes information about an object&#8217;s data type at runtime.  This capability is leveraged by dynamic_cast.  Because RTTI has a pretty significant space performance cost, some compilers allow you to turn RTTI off as an optimization.  Needless to say, if you do this, dynamic_cast won&#8217;t function correctly.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/printing-inherited-classes-using-operator\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">25.11<\/span>Printing inherited classes using operator&lt;&lt;\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/object-slicing\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">25.9<\/span>Object slicing\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Way back in lesson , we examined the concept of casting, and the use of static_cast to convert variables from one type to another. In this lesson, we&#8217;ll continue by examining another type of cast: dynamic_cast. The need for dynamic_cast When dealing with polymorphism, you&#8217;ll often encounter cases where you &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5062"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=5062"}],"version-history":[{"count":33,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5062\/revisions"}],"predecessor-version":[{"id":18039,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5062\/revisions\/18039"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=5062"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=5062"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=5062"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}