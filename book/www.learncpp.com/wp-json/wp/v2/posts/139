{"id":139,"date":"2007-10-01T16:41:53","date_gmt":"2007-10-02T00:41:53","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/93-overloading-the-io-operators\/"},"modified":"2025-01-29T14:55:59","modified_gmt":"2025-01-29T22:55:59","slug":"overloading-the-io-operators","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-the-io-operators\/","title":{"rendered":"21.4 &#8212; Overloading the I\/O operators"},"content":{"rendered":"<p>For classes that have multiple member variables, printing each of the individual variables on the screen can get tiresome fast.  For example, consider the following class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Point\r\n{\r\nprivate:\r\n    double m_x{};\r\n    double m_y{};\r\n    double m_z{};\r\n\r\npublic:\r\n    Point(double x=0.0, double y=0.0, double z=0.0)\r\n      : m_x{x}, m_y{y}, m_z{z}\r\n    {\r\n    }\r\n\r\n    double getX() const { return m_x; }\r\n    double getY() const { return m_y; }\r\n    double getZ() const { return m_z; }\r\n};<\/code><\/pre>\n<p>If you wanted to print an instance of this class to the screen, you&#8217;d have to do something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">Point point { 5.0, 6.0, 7.0 };\r\n\r\nstd::cout &lt;&lt; \"Point(\" &lt;&lt; point.getX() &lt;&lt; \", \" &lt;&lt;\r\n    point.getY() &lt;&lt; \", \" &lt;&lt;\r\n    point.getZ() &lt;&lt; ')';<\/code><\/pre>\n<p>Of course, it makes more sense to do this as a reusable function.  And in previous examples, you&#8217;ve seen us create <code>print()<\/code> functions that work like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Point\r\n{\r\nprivate:\r\n    double m_x{};\r\n    double m_y{};\r\n    double m_z{};\r\n\r\npublic:\r\n    Point(double x=0.0, double y=0.0, double z=0.0)\r\n      : m_x{x}, m_y{y}, m_z{z}\r\n    {\r\n    }\r\n\r\n    double getX() const { return m_x; }\r\n    double getY() const { return m_y; }\r\n    double getZ() const { return m_z; }\r\n\r\n    void print() const\r\n    {\r\n        std::cout &lt;&lt; \"Point(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \", \" &lt;&lt; m_z &lt;&lt; ')';\r\n    }\r\n};<\/code><\/pre>\n<p>While this is much better, it still has some downsides.  Because <code>print()<\/code> returns <code>void<\/code>, it can&#8217;t be called in the middle of an output statement.  Instead, you have to do this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    const Point point { 5.0, 6.0, 7.0 };\r\n\r\n    std::cout &lt;&lt; \"My point is: \";\r\n    point.print();\r\n    std::cout &lt;&lt; \" in Cartesian space.\\n\";\r\n}<\/code><\/pre>\n<p>It would be much easier if you could simply type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">Point point{5.0, 6.0, 7.0};\r\ncout &lt;&lt; \"My point is: \" &lt;&lt; point &lt;&lt; \" in Cartesian space.\\n\";<\/code><\/pre>\n<p>and get the same result.  There would be no breaking up output across multiple statements, and no having to remember what you named the print function.<\/p>\n<p>Fortunately, by overloading <code>operator&lt;&lt;<\/code>, you can!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Overloading <code>operator&lt;&lt;<\/code><\/p>\n<p>Overloading <code>operator&lt;&lt;<\/code> is similar to overloading operator+ (they are both binary operators), except that the parameter types are different.<\/p>\n<p>Consider the expression <code>std::cout &lt;&lt; point<\/code>.  If the operator is <code>&lt;&lt;<\/code>, what are the operands?  The left operand is the <code>std::cout<\/code> object, and the right operand is your <code>Point<\/code> class object.  <code>std::cout<\/code> is actually an object of type <code>std::ostream<\/code>.  Therefore, our overloaded function will look like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ std::ostream is the type for object std::cout\r\nfriend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Point&amp; point);<\/code><\/pre>\n<p>Implementation of <code>operator&lt;&lt;<\/code> for our <code>Point<\/code> class is fairly straightforward -- because C++ already knows how to output doubles using <code>operator&lt;&lt;<\/code>, and our members are all doubles, we can simply use <code>operator&lt;&lt;<\/code> to output the data members of our <code>Point<\/code>.  Here is the above <code>Point<\/code> class with the overloaded <code>operator&lt;&lt;<\/code>.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Point\r\n{\r\nprivate:\r\n    double m_x{};\r\n    double m_y{};\r\n    double m_z{};\r\n\r\npublic:\r\n    Point(double x=0.0, double y=0.0, double z=0.0)\r\n      : m_x{x}, m_y{y}, m_z{z}\r\n    {\r\n    }\r\n\r\n    friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Point&amp; point);\r\n};\r\n\r\nstd::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Point&amp; point)\r\n{\r\n    \/\/ Since operator&lt;&lt; is a friend of the Point class, we can access Point's members directly.\r\n    out &lt;&lt; \"Point(\" &lt;&lt; point.m_x &lt;&lt; \", \" &lt;&lt; point.m_y &lt;&lt; \", \" &lt;&lt; point.m_z &lt;&lt; ')'; \/\/ actual output done here\r\n\r\n    return out; \/\/ return std::ostream so we can chain calls to operator&lt;&lt;\r\n}\r\n\r\nint main()\r\n{\r\n    const Point point1 { 2.0, 3.0, 4.0 };\r\n\r\n    std::cout &lt;&lt; point1 &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This is pretty straightforward -- note how similar our output line is to the line in the <code>print()<\/code> function we wrote previously.  The most notable difference is that <code>std::cout<\/code> has become parameter <code>out<\/code> (which will be a reference to <code>std::cout<\/code> when the function is called).<\/p>\n<p>The trickiest part here is the return type.  With the arithmetic operators, we calculated and returned a single answer by value (because we were creating and returning a new result).  However, if you try to return <code>std::ostream<\/code> by value, you&#8217;ll get a compiler error.  This happens because <code>std::ostream<\/code> specifically disallows being copied.<\/p>\n<p>In this case, we return the left hand parameter as a reference.  This not only prevents a copy of <code>std::ostream<\/code> from being made, it also allows us to &#8220;chain&#8221; output commands together, such as <code>std::cout &lt;&lt; point &lt;&lt; '\\n'<\/code>.<\/p>\n<p>Consider what would happen if our <code>operator&lt;&lt;<\/code> returned <code>void<\/code> instead.  When the compiler evaluates <code>std::cout &lt;&lt; point &lt;&lt; '\\n'<\/code>, due to the precedence\/associativity rules, it evaluates this expression as <code>(std::cout &lt;&lt; point) &lt;&lt; '\\n';<\/code>.  <code>std::cout &lt;&lt; point<\/code> would call our void-returning overloaded <code>operator&lt;&lt;<\/code> function, which returns <code>void<\/code>.  Then the partially evaluated expression becomes: <code>void &lt;&lt; '\\n';<\/code>, which makes no sense!<\/p>\n<p>By returning the <code>out<\/code> parameter as the return type instead, <code>(std::cout &lt;&lt; point)<\/code> returns <code>std::cout<\/code>.  Then our partially evaluated expression becomes: <code>std::cout &lt;&lt; '\\n';<\/code>, which then gets evaluated itself!<\/p>\n<p>Any time we want our overloaded binary operators to be chainable in such a manner, the left operand should be returned (by reference).  Returning the left-hand parameter by reference is okay in this case -- since the left-hand parameter was passed in by the calling function, it must still exist when the called function returns.  Therefore, we don&#8217;t have to worry about referencing something that will go out of scope and get destroyed when the operator returns.<\/p>\n<p>Just to prove it works, consider the following example, which uses the Point class with the overloaded <code>operator&lt;&lt;<\/code> we wrote above:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Point\r\n{\r\nprivate:\r\n    double m_x{};\r\n    double m_y{};\r\n    double m_z{};\r\n\r\npublic:\r\n    Point(double x=0.0, double y=0.0, double z=0.0)\r\n      : m_x{x}, m_y{y}, m_z{z}\r\n    {\r\n    }\r\n\r\n    friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Point&amp; point);\r\n};\r\n\r\nstd::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Point&amp; point)\r\n{\r\n    \/\/ Since operator&lt;&lt; is a friend of the Point class, we can access Point's members directly.\r\n    out &lt;&lt; \"Point(\" &lt;&lt; point.m_x &lt;&lt; \", \" &lt;&lt; point.m_y &lt;&lt; \", \" &lt;&lt; point.m_z &lt;&lt; ')';\r\n\r\n    return out;\r\n}\r\n\r\nint main()\r\n{\r\n    Point point1 { 2.0, 3.5, 4.0 };\r\n    Point point2 { 6.0, 7.5, 8.0 };\r\n\r\n    std::cout &lt;&lt; point1 &lt;&lt; ' ' &lt;&lt; point2 &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This produces the following result:<\/p>\n<pre>\nPoint(2, 3.5, 4) Point(6, 7.5, 8)\r\n<\/pre>\n<p>In the above example, <code>operator&lt;&lt;<\/code> is a friend because it needs direct access to the member of <code>Point<\/code>.  However, if the members could be accessed via getters, then <code>operator&lt;&lt;<\/code> could be implemented as a non-friend.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Overloading <code>operator&gt;&gt;<\/code><\/p>\n<p>It is also possible to overload the input operator.  This is done in a manner analogous to overloading the output operator.  The key thing you need to know is that <code>std::cin<\/code> is an object of type <code>std::istream<\/code>.  Here&#8217;s our <code>Point<\/code> class with an overloaded <code>operator&gt;&gt;<\/code> added:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Point\r\n{\r\nprivate:\r\n    double m_x{};\r\n    double m_y{};\r\n    double m_z{};\r\n\r\npublic:\r\n    Point(double x=0.0, double y=0.0, double z=0.0)\r\n      : m_x{x}, m_y{y}, m_z{z}\r\n    {\r\n    }\r\n\r\n    friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Point&amp; point);\r\n    friend std::istream&amp; operator&gt;&gt; (std::istream&amp; out, Point&amp; point);\r\n};\r\n\r\nstd::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Point&amp; point)\r\n{\r\n    \/\/ Since operator&lt;&lt; is a friend of the Point class, we can access Point's members directly.\r\n    out &lt;&lt; \"Point(\" &lt;&lt; point.m_x &lt;&lt; \", \" &lt;&lt; point.m_y &lt;&lt; \", \" &lt;&lt; point.m_z &lt;&lt; ')';\r\n\r\n    return out;\r\n}\r\n\r\n\/\/ note that point must be non-const so we can modify the object\r\nstd::istream&amp; operator&gt;&gt; (std::istream&amp; in, Point&amp; point)\r\n{\r\n    \/\/ This version subject to partial extraction issues (see below)\r\n    in &gt;&gt; point.m_x &gt;&gt; point.m_y &gt;&gt; point.m_z;\r\n\r\n    return in;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter a point: \";\r\n\r\n    Point point{ 1.0, 2.0, 3.0 }; \/\/ non-zero test data\r\n    std::cin &gt;&gt; point;\r\n\r\n    std::cout &lt;&lt; \"You entered: \" &lt;&lt; point &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Assuming the user enters <code>4.0 5.6 7.26<\/code> as input, the program produces the following result:<\/p>\n<pre>\nYou entered: Point(4, 5.6, 7.26)\r\n<\/pre>\n<p>Now let&#8217;s see what happens when the user enters <code>4.0b 5.6 7.26<\/code> as input (notice the <code>b<\/code> after the <code>4.0<\/code>):<\/p>\n<pre>\nYou entered: Point(4, 0, 3)\r\n<\/pre>\n<p>Our point is now a weird hybrid consisting of one value from the user&#8217;s input (<code>4.0<\/code>), one value that has been zero-initialized (<code>0.0<\/code>), and one value that was untouched by the input function (<code>3.0<\/code>).  That&#8217;s&#8230;  not great!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Guarding against partial extraction<\/p>\n<p>When we&#8217;re extracting a single value, there are only two possible outcomes: the extraction fails, or it is successful.  However, when we&#8217;re extracting more than one value as part of an input operation, things get a bit more complicated.<\/p>\n<p>The above implementation of <code>operator&gt;&gt;<\/code> can result in a partial extraction.  And this is exactly what we&#8217;re seeing with input <code>4.0b 5.6 7.26<\/code>.  The extraction to <code>x_y<\/code> successfully extracts <code>4.0<\/code> from the user&#8217;s input, leaving <code>b 5.6 7.26<\/code> in the input stream.  The extraction to <code>m_y<\/code> fails to extract <code>b<\/code>, so <code>m_y<\/code> is copy-assigned the value <code>0.0<\/code> and the input stream is set to failure mode.  Since we haven&#8217;t cleared failure mode, the extraction to <code>m_z<\/code> aborts immediately, and the value that <code>m_z<\/code> had before the extraction attempt remains (<code>3.0<\/code>).<\/p>\n<p>There is no case where this is a desirable outcome.  And in some cases, it might even be actively dangerous.  Imagine we were writing an <code>operator&gt;&gt;<\/code> for a <code>Fraction<\/code> object instead.  After successfully extracting the numerator, a failed extraction to the denominator would set the denominator to <code>0.0<\/code>, which might later cause a divide by zero and cause the application to crash.<\/p>\n<p>So how might we avoid this?  One way is to make our operations transactional.  A <strong>transactional operation<\/strong> must either completely succeed or completely fail -- no partial successes or failures are allowed.  This is sometimes known as &#8220;all or nothing&#8221;.  If a failure occurs at any point during the transaction, prior changes made by the operation must be undone.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Transactions occur all the time in real life.  Consider the case where I want to transfer money from one bank account to another.  This requires two steps: First the money must first be deducted from one account, and then it must be credited to the other account.  In the execution of this operation, there are three possibilities:<\/p>\n<ul>\n<li>The deduction step fails (e.g. not enough funds).  The transaction fails, and neither account balance reflects the transfer.\n<\/li>\n<li>The crediting step fails (e.g. due to a technical problem).  In this case, the deduction (which has already succeeded) must be undone.  The transaction fails, and neither account balance reflects the transfer.\n<\/li>\n<li>Both steps succeed.  The transaction is successful, and both account balances reflect the transfer.\n<\/li>\n<\/ul>\n<p>The end result is that there are only two possible outcomes: the transfer fully fails and the account balances are unchanged, or the transfer succeeds and the account balances are both changed.\n<\/p><\/div>\n<p>Let&#8217;s reimplement our overloaded <code>Point<\/code> <code>operator&gt;&gt;<\/code> as a transactional operation:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ note that point must be non-const so we can modify the object\r\n\/\/ note that this implementation is a non-friend\r\nstd::istream&amp; operator&gt;&gt; (std::istream&amp; in, Point&amp; point)\r\n{\r\n    double x{};\r\n    double y{};\r\n    double z{};\r\n    \r\n    if (in &gt;&gt; x &gt;&gt; y &gt;&gt; z)      \/\/ if all extractions succeeded\r\n        point = Point{x, y, z}; \/\/ overwrite our existing point\r\n        \r\n    return in;\r\n}<\/code><\/pre>\n<p>In this implementation, we&#8217;re not overwriting the data members directly with the user&#8217;s input.  Instead, we&#8217;re extracting the user&#8217;s input to temporary variables (<code>x<\/code>, <code>y<\/code>, and <code>z<\/code>).  Once all extraction attempts have completed, we check whether all extractions were successful.  If so, then we update all the members of <code>Point<\/code> together.  Otherwise, we do not update any of them.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p><code>if (in &gt;&gt; x &gt;&gt; y &gt;&gt; z)<\/code> is equivalent to <code>in &gt;&gt; x &gt;&gt; y &gt;&gt; z;  if (in)<\/code>.  Remember, each extraction returns <code>in<\/code> so that multiple extractions can be chained together.  The single-statement version uses the <code>in<\/code> returned from the last extraction as the condition of the if-statement, whereas the multi-statement version uses <code>in<\/code> explicitly.\n<\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>Transactional operations can be implemented using a number of different strategies.  For example:<\/p>\n<ul>\n<li>Alter on success: Store the result of each sub-operation.  If all sub-operations succeed, replace the relevant data with the stored results.  This is the strategy we use in the <code>Point<\/code> example above.\n<\/li>\n<li>Restore on failure: Copy any data that can be altered.  If any sub-operation fails, the changes made by prior sub-operations can be reverted using the data from copy.\n<\/li>\n<li>Rollback on failure: If any sub-operation fails, each prior sub-operation is reversed (using an opposite sub-operation).  This strategy is often used in databases, where the data is too large to back up, and the result of sub-operations can&#8217;t be stored.\n<\/li>\n<\/ul>\n<\/div>\n<p>While the above <code>operator&gt;&gt;<\/code> prevents partial extractions, it is inconsistent with how <code>operator&gt;&gt;<\/code> works for fundamental types.  When extraction to an object with a fundamental type fails, the object isn&#8217;t left unaltered -- it is copy assigned the value <code>0<\/code> (this ensures the object has some consistent value in case it wasn&#8217;t initialized before the extraction attempt).  Therefore, for consistency, you may wish to have a failed extraction reset the object to its default state (at least in cases where such a thing exists).<\/p>\n<p>Here&#8217;s an alternate version of <code>operator&gt;&gt;<\/code> that resets <code>Point<\/code> to its default state if any extraction fails:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ note that point must be non-const so we can modify the object\r\n\/\/ note that this implementation is a non-friend\r\nstd::istream&amp; operator&gt;&gt; (std::istream&amp; in, Point&amp; point)\r\n{\r\n    double x{};\r\n    double y{};\r\n    double z{};\r\n    \r\n    in &gt;&gt; x &gt;&gt; y &gt;&gt; z;\r\n    point = in ? Point{x, y, z} : Point{};\r\n        \r\n    return in;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>Such an operation is technically no longer transactional (because failure doesn&#8217;t &#8220;do nothing&#8221;).  There doesn&#8217;t appear to be a general term for operations that guarantee no partial results.  Perhaps &#8220;indivisible operation&#8221;.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Handling semantically invalid input<\/p>\n<p>Extraction can fail in different ways.<\/p>\n<p>In cases where <code>operator&gt;&gt;<\/code> simply fails to extract anything to a variable, <code>std::cin<\/code> will automatically be placed in failure mode (which we discuss in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdcin-and-handling-invalid-input\/\">9.5 -- std::cin and handling invalid input<\/a>).  The caller of this function can then check <code>std::cin<\/code> to see if it failed and handle that case as appropriate.<\/p>\n<p>But what about cases where the user inputs a value that is extractable but semantically invalid (e.g. a <code>Fraction<\/code> with a denominator of <code>0<\/code>)?  Because <code>std::cin<\/code> did extract something, it won&#8217;t go into failure mode automatically.  And then the caller probably won&#8217;t realize something went wrong.<\/p>\n<p>To address this, we can have our overloaded <code>operator&gt;&gt;<\/code> determine whether any of the values that were extracted are semantically invalid, and if so, manually put the input stream in failure mode.  This can be done by calling <code>std::cin.setstate(std::ios_base::failbit);<\/code>.<\/p>\n<p>Here&#8217;s an example of a transactional overloaded <code>operator&gt;&gt;<\/code> for <code>Point<\/code> that will cause the input stream to enter failure mode if the user inputs an extractable negative value:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::istream&amp; operator&gt;&gt; (std::istream&amp; in, Point&amp; point)\r\n{\r\n    double x{};\r\n    double y{};\r\n    double z{};\r\n    \r\n    in &gt;&gt; x &gt;&gt; y &gt;&gt; z;\r\n    if (x &lt; 0.0 || y &lt; 0.0 || z &lt; 0.0)       \/\/ if any extractable input is negative\r\n        in.setstate(std::ios_base::failbit); \/\/ set failure mode manually\r\n    point = in ? Point{x, y, z} : Point{};\r\n       \r\n    return in;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Conclusion<\/p>\n<p>Overloading <code>operator&lt;&lt;<\/code> and <code>operator&gt;&gt;<\/code> make it easy to output your class to screen and accept user input from the console.  <\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Take the Fraction class below and add an overloaded <code>operator&lt;&lt;<\/code> and <code>operator&gt;&gt;<\/code> to it.  Your <code>operator&gt;&gt;<\/code> should avoid partial extractions and fail if user inputs a denominator of <code>0<\/code>.  It should not reset the Fraction to default on failure.<\/p>\n<p>The following program should compile:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n\tFraction f1{};\r\n\tstd::cout &lt;&lt; \"Enter fraction 1: \";\r\n\tstd::cin &gt;&gt; f1;\r\n\r\n\tFraction f2{};\r\n\tstd::cout &lt;&lt; \"Enter fraction 2: \";\r\n\tstd::cin &gt;&gt; f2;\r\n\r\n\tstd::cout &lt;&lt; f1 &lt;&lt; \" * \" &lt;&lt; f2 &lt;&lt; \" is \" &lt;&lt; f1 * f2 &lt;&lt; '\\n'; \/\/ note: The result of f1 * f2 is an r-value\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>And produce the result:<\/p>\n<pre>\nEnter fraction 1: 2\/3\r\nEnter fraction 2: 3\/8\r\n2\/3 * 3\/8 is 1\/4\r\n<\/pre>\n<p>Here&#8217;s the Fraction class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;numeric&gt; \/\/ for std::gcd\r\n \r\nclass Fraction\r\n{\r\nprivate:\r\n\tint m_numerator{};\r\n\tint m_denominator{};\r\n \r\npublic:\r\n\tFraction(int numerator=0, int denominator=1):\r\n\t\tm_numerator{numerator}, m_denominator{denominator}\r\n\t{\r\n\t\t\/\/ We put reduce() in the constructor to ensure any new fractions we make get reduced!\r\n\t\t\/\/ Any fractions that are overwritten will need to be re-reduced\r\n\t\treduce();\r\n\t}\r\n\r\n\tvoid reduce()\r\n\t{\r\n\t\tint gcd{ std::gcd(m_numerator, m_denominator) };\r\n\t\tif (gcd)\r\n\t\t{\r\n\t\t\tm_numerator \/= gcd;\r\n\t\t\tm_denominator \/= gcd;\r\n\t\t}\r\n\t}\r\n \r\n\tfriend Fraction operator*(const Fraction&amp; f1, const Fraction&amp; f2);\r\n\tfriend Fraction operator*(const Fraction&amp; f1, int value);\r\n\tfriend Fraction operator*(int value, const Fraction&amp; f1);\r\n \r\n\tvoid print() const\r\n\t{\r\n\t\tstd::cout &lt;&lt; m_numerator &lt;&lt; '\/' &lt;&lt; m_denominator &lt;&lt; '\\n';\r\n\t}\r\n};\r\n \r\nFraction operator*(const Fraction&amp; f1, const Fraction&amp; f2)\r\n{\r\n\treturn Fraction { f1.m_numerator * f2.m_numerator, f1.m_denominator * f2.m_denominator };\r\n}\r\n \r\nFraction operator*(const Fraction&amp; f1, int value)\r\n{\r\n\treturn Fraction { f1.m_numerator * value, f1.m_denominator };\r\n}\r\n \r\nFraction operator*(int value, const Fraction&amp; f1)\r\n{\r\n\treturn Fraction { f1.m_numerator * value, f1.m_denominator };\r\n}<\/code><\/pre>\n<p>If you\u2019re on a pre-C++17 compiler, you can replace std::gcd with this function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cmath&gt;\r\n \r\nint gcd(int a, int b) {\r\n    return (b == 0) ? std::abs(a) : gcd(b, a % b);\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;limits&gt;\r\n#include &lt;numeric&gt; \/\/ for std::gcd\r\n\r\nclass Fraction\r\n{\r\nprivate:\r\n    int m_numerator{ 0 };\r\n    int m_denominator{ 1 };\r\n\r\npublic:\r\n    Fraction(int numerator=0, int denominator = 1) :\r\n        m_numerator{ numerator }, m_denominator{ denominator }\r\n    {\r\n        \/\/ We put reduce() in the constructor to ensure any new fractions we make get reduced!\r\n        \/\/ Any fractions that are overwritten will need to be re-reduced\r\n        reduce();\r\n    }\r\n\r\n    void reduce()\r\n    {\r\n        int gcd{ std::gcd(m_numerator, m_denominator) };\r\n        if (gcd)\r\n        {\r\n            m_numerator \/= gcd;\r\n            m_denominator \/= gcd;\r\n        }\r\n    }\r\n\r\n    friend Fraction operator*(const Fraction&amp; f1, const Fraction&amp; f2);\r\n    friend Fraction operator*(const Fraction&amp; f1, int value);\r\n    friend Fraction operator*(int value, const Fraction&amp; f1);\r\n\r\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1);\r\n\r\n    void print() const\r\n    {\r\n        std::cout &lt;&lt; m_numerator &lt;&lt; '\/' &lt;&lt; m_denominator &lt;&lt; '\\n';\r\n    }\r\n};\r\n\r\nFraction operator*(const Fraction&amp; f1, const Fraction&amp; f2)\r\n{\r\n    return Fraction { f1.m_numerator * f2.m_numerator, f1.m_denominator * f2.m_denominator };\r\n}\r\n\r\nFraction operator*(const Fraction&amp; f1, int value)\r\n{\r\n    return Fraction { f1.m_numerator * value, f1.m_denominator };\r\n}\r\n\r\nFraction operator*(int value, const Fraction&amp; f1)\r\n{\r\n    return Fraction { f1.m_numerator * value, f1.m_denominator };\r\n}\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)\r\n{\r\n    out &lt;&lt; f1.m_numerator &lt;&lt; '\/' &lt;&lt; f1.m_denominator;\r\n    return out;\r\n}\r\n\r\nstd::istream&amp; operator&gt;&gt;(std::istream&amp; in, Fraction&amp; f1)\r\n{\r\n    int numerator {};\r\n    char ignore {};\r\n    int denominator {};\r\n    \r\n    in &gt;&gt; numerator &gt;&gt; ignore &gt;&gt; denominator;\r\n    if (denominator == 0)                       \/\/ if our denominator is semantically invalid\r\n        in.setstate(std::ios_base::failbit);    \/\/ set failure mode manually\r\n    if (in)                                     \/\/ if we're not in failure mode\r\n        f1 = Fraction {numerator, denominator}; \/\/ update our object to the extracted values\r\n\r\n    return in;\r\n}\r\n\r\nint main()\r\n{\r\n    Fraction f1{};\r\n    std::cout &lt;&lt; \"Enter fraction 1: \";\r\n    std::cin &gt;&gt; f1;\r\n\r\n    Fraction f2{};\r\n    std::cout &lt;&lt; \"Enter fraction 2: \";\r\n    std::cin &gt;&gt; f2;\r\n\r\n    std::cout &lt;&lt; f1 &lt;&lt; \" * \" &lt;&lt; f2 &lt;&lt; \" is \" &lt;&lt; f1 * f2 &lt;&lt; '\\n'; \/\/ note: The result of f1 * f2 is an r-value\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-operators-using-member-functions\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.5<\/span>Overloading operators using member functions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-operators-using-normal-functions\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.3<\/span>Overloading operators using normal functions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>For classes that have multiple member variables, printing each of the individual variables on the screen can get tiresome fast. For example, consider the following class: class Point { private: double m_x{}; double m_y{}; double m_z{}; public: Point(double x=0.0, double y=0.0, double z=0.0) : m_x{x}, m_y{y}, m_z{z} { } double &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/139"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=139"}],"version-history":[{"count":43,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/139\/revisions"}],"predecessor-version":[{"id":18139,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/139\/revisions\/18139"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=139"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=139"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=139"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}