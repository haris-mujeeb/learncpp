{"id":207,"date":"2008-06-19T19:07:22","date_gmt":"2008-06-20T03:07:22","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=207"},"modified":"2023-09-11T11:00:48","modified_gmt":"2023-09-11T18:00:48","slug":"template-non-type-parameters","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/template-non-type-parameters\/","title":{"rendered":"26.2 &#8212; Template non-type parameters"},"content":{"rendered":"<p>In previous lessons, you&#8217;ve learned how to use template type parameters to create functions and classes that are type independent.   A template type parameter is a placeholder type that is substituted for a type passed in as an argument.<\/p>\n<p>However, template type parameters are not the only type of template parameters available.  Template classes and functions can make use of another kind of template parameter known as a non-type parameter.<\/p>\n<p><strong>Non-type parameters<\/strong><\/p>\n<p>A template non-type parameter is a template parameter where the type of the parameter is predefined and is substituted for a constexpr value passed in as an argument.<\/p>\n<p>A non-type parameter can be any of the following types:<\/p>\n<ul>\n<li>An integral type<\/li>\n<li>An enumeration type<\/li>\n<li>A pointer or reference to a class object<\/li>\n<li>A pointer or reference to a function<\/li>\n<li>A pointer or reference to a class member function<\/li>\n<li>std::nullptr_t<\/li>\n<li>A floating point type (since C++20)<\/li>\n<\/ul>\n<p>In the following example, we create a non-dynamic (static) array class that uses both a type parameter and a non-type parameter.  The type parameter controls the data type of the static array, and the integral non-type parameter controls how large the static array is.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T, int size&gt; \/\/ size is an integral non-type parameter\r\nclass StaticArray\r\n{\r\nprivate:\r\n    \/\/ The non-type parameter controls the size of the array\r\n    T m_array[size] {};\r\n\r\npublic:\r\n    T* getArray();\r\n\t\r\n    T&amp; operator[](int index)\r\n    {\r\n        return m_array[index];\r\n    }\r\n};\r\n\r\n\/\/ Showing how a function for a class with a non-type parameter is defined outside of the class\r\ntemplate &lt;typename T, int size&gt;\r\nT* StaticArray&lt;T, size&gt;::getArray()\r\n{\r\n    return m_array;\r\n}\r\n\r\nint main()\r\n{\r\n    \/\/ declare an integer array with room for 12 integers\r\n    StaticArray&lt;int, 12&gt; intArray;\r\n\r\n    \/\/ Fill it up in order, then print it backwards\r\n    for (int count { 0 }; count &lt; 12; ++count)\r\n        intArray[count] = count;\r\n\r\n    for (int count { 11 }; count &gt;= 0; --count)\r\n        std::cout &lt;&lt; intArray[count] &lt;&lt; ' ';\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    \/\/ declare a double buffer with room for 4 doubles\r\n    StaticArray&lt;double, 4&gt; doubleArray;\r\n\r\n    for (int count { 0 }; count &lt; 4; ++count)\r\n        doubleArray[count] = 4.4 + 0.1 * count;\r\n\r\n    for (int count { 0 }; count &lt; 4; ++count)\r\n        std::cout &lt;&lt; doubleArray[count] &lt;&lt; ' ';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This code produces the following:<\/p>\n<pre>\r\n11 10 9 8 7 6 5 4 3 2 1 0\r\n4.4 4.5 4.6 4.7\r\n<\/pre>\n<p>One noteworthy thing about the above example is that we do not have to dynamically allocate the m_array member variable!  This is because for any given instance of the StaticArray class, size must be constexpr.  For example, if you instantiate a StaticArray&lt;int, 12&gt;, the compiler replaces size with 12.  Thus m_array is of type int[12], which can be allocated statically.<\/p>\n<p>This functionality is used by the standard library class std::array.  When you allocate a std::array&lt;int, 5&gt;, the int is a type parameter, and the 5 is a non-type parameter!<\/p>\n<p>Note that if you try to instantiate a template non-type parameter with a non-constexpr value, it will not work:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;int size&gt;\r\nclass Foo\r\n{\r\n};\r\n\r\nint main()\r\n{\r\n    int x{ 4 }; \/\/ x is non-constexpr\r\n    Foo&lt;x&gt; f; \/\/ error: the template non-type argument must be constexpr\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In such a case, your compiler will issue an error.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-template-specialization\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">26.3<\/span>Function template specialization\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/template-classes\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">26.1<\/span>Template classes\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In previous lessons, you&#8217;ve learned how to use template type parameters to create functions and classes that are type independent. A template type parameter is a placeholder type that is substituted for a type passed in as an argument. However, template type parameters are not the only type of template &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[12,19,14,20,15,16],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/207"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=207"}],"version-history":[{"count":22,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/207\/revisions"}],"predecessor-version":[{"id":15247,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/207\/revisions\/15247"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=207"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=207"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=207"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}