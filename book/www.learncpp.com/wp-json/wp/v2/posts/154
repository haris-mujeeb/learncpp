{"id":154,"date":"2007-11-13T10:03:33","date_gmt":"2007-11-13T18:03:33","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/101-constructor-initialization-lists\/"},"modified":"2025-02-05T18:26:23","modified_gmt":"2025-02-06T02:26:23","slug":"constructor-member-initializer-lists","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/constructor-member-initializer-lists\/","title":{"rendered":"14.10 &#8212; Constructor member initializer lists"},"content":{"rendered":"<p>This lesson continues our introduction of constructors from lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-constructors\/\">14.9 -- Introduction to constructors<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Member initialization via a member initialization list<\/p>\n<p>To have a constructor initialize members, we do so using a <strong>member initializer list<\/strong> (often called a &#8220;member initialization list&#8221;).  Do not confuse this with the similarly named &#8220;initializer list&#8221; that is used to initialize aggregates with a list of values.<\/p>\n<p>Member initialization lists are something that is best learned by example.  In the following example, our <code>Foo(int, int)<\/code> constructor has been updated to use a member initializer list to initialize <code>m_x<\/code>, and <code>m_y<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Foo\r\n{\r\nprivate:\r\n    int m_x {};\r\n    int m_y {};\r\n\r\npublic:\r\n    Foo(int x, int y)\r\n        : m_x { x }, m_y { y } \/\/ here's our member initialization list\r\n    {\r\n        std::cout &lt;&lt; \"Foo(\" &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; \") constructed\\n\";\r\n    }\r\n\r\n    void print() const\r\n    {\r\n        std::cout &lt;&lt; \"Foo(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \")\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Foo foo{ 6, 7 };\r\n    foo.print();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The member initializer list is defined after the constructor parameters.  It begins with a colon (:), and then lists each member to initialize along with the initialization value for that variable, separated by a comma.  You must use a direct form of initialization here (preferably using braces, but parentheses works as well) -- using copy initialization (with an equals) does not work here.  Also note that the member initializer list does not end in a semicolon.<\/p>\n<p>This program produces the following output:<\/p>\n<pre>\nFoo(6, 7) constructed\r\nFoo(6, 7)\r\n<\/pre>\n<p>When <code>foo<\/code> is instantiated, the members in the initialization list are initialized with the specified initialization values.  In this case, the member initializer list initializes <code>m_x<\/code> to the value of <code>x<\/code> (which is <code>6<\/code>), and <code>m_y<\/code> to the value of <code>y<\/code> (which is <code>7<\/code>).  Then the body of the constructor runs.<\/p>\n<p>When the <code>print()<\/code> member function is called, you can see that <code>m_x<\/code> still has value <code>6<\/code> and <code>m_y<\/code> still has value <code>7<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Member initializer list formatting<\/p>\n<p>C++ provides a lot of freedom to format your member initializer lists as you prefer, as it doesn&#8217;t care where you put your colon, commas, or whitespace.<\/p>\n<p>The following styles are all valid (and you&#8217;re likely to see all three in practice):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    Foo(int x, int y) : m_x { x }, m_y { y }\r\n    {\r\n    }<\/code><\/pre>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    Foo(int x, int y) :\r\n        m_x { x },\r\n        m_y { y }\r\n    {\r\n    }<\/code><\/pre>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    Foo(int x, int y)\r\n        : m_x { x }\r\n        , m_y { y }\r\n    {\r\n    }<\/code><\/pre>\n<p>Our recommendation is to use the third style above:<\/p>\n<ul>\n<li>Put the colon on the line after the constructor name, as this cleanly separates the member initializer list from the function prototype.\n<\/li>\n<li>Indent your member initializer list, to make it easier to see the function names.\n<\/li>\n<\/ul>\n<p>If the member initialization list is short\/trivial, all initializers can go on one line:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    Foo(int x, int y)\r\n        : m_x { x }, m_y { y }\r\n    {\r\n    }<\/code><\/pre>\n<p>Otherwise (or if you prefer), each member and initializer pair can be placed on a separate line (starting with a comma to maintain alignment):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    Foo(int x, int y)\r\n        : m_x { x }\r\n        , m_y { y }\r\n    {\r\n    }<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Member initialization order<\/p>\n<p>Because the C++ standard says so, the members in a member initializer list are always initialized in the order in which they are defined inside the class (not in the order they are defined in the member initializer list).<\/p>\n<p>In the above example, because <code>m_x<\/code> is defined before <code>m_y<\/code> in the class definition, <code>m_x<\/code> will be initialized first (even if it is not listed first in the member initializer list).<\/p>\n<p>Because we intuitively expect variables to be initialized left to right, this can cause subtle errors to occur.  Consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt; \/\/ for std::max\r\n#include &lt;iostream&gt;\r\n\r\nclass Foo\r\n{\r\nprivate:\r\n    int m_x{};\r\n    int m_y{};\r\n\r\npublic:\r\n    Foo(int x, int y)\r\n        : m_y { std::max(x, y) }, m_x { m_y } \/\/ issue on this line\r\n    {\r\n    }\r\n\r\n    void print() const\r\n    {\r\n        std::cout &lt;&lt; \"Foo(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \")\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Foo foo { 6, 7 };\r\n    foo.print();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, our intent is to calculate the larger of the initialization values passed in (via <code>std::max(x, y)<\/code> and then use this value to initialize both <code>m_x<\/code> and <code>m_y<\/code>.  However, on the author&#8217;s machine, the following result is printed:<\/p>\n<pre>\nFoo(-858993460, 7)\r\n<\/pre>\n<p>What happened?  Even though <code>m_y<\/code> is listed first in the member initialization list, because <code>m_x<\/code> is defined first in the class, <code>m_x<\/code> gets initialized first.  And <code>m_x<\/code> gets initialized to the value of <code>m_y<\/code>, which hasn&#8217;t been initialized yet.  Finally, <code>m_y<\/code> gets initialized to the greater of the initialization values.<\/p>\n<p>To help prevent such errors, members in the member initializer list should be listed in the order in which they are defined in the class.  Some compilers will issue a warning if members are initialized out of order.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Member variables in a member initializer list should be listed in order that they are defined in the class.\n<\/p><\/div>\n<p>It&#8217;s also a good idea to avoid initializing members using the value of other members (if possible).  That way, even if you do make a mistake in the initialization order, it shouldn&#8217;t matter because there are no dependencies between initialization values.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Member initializer list vs default member initializers<\/p>\n<p>Members can be initialized in a few different ways:<\/p>\n<ul>\n<li>If a member is listed in the member initializer list, that initialization value is used\n<\/li>\n<li>Otherwise, if the member has a default member initializer, that initialization value is used\n<\/li>\n<li>Otherwise, the member is default-initialized.\n<\/li>\n<\/ul>\n<p>This means that if a member has both a default member initializer and is listed in the member initializer list for the constructor, the member initializer list value takes precedence.<\/p>\n<p>Here&#8217;s an example showing all three initialization methods:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Foo\r\n{\r\nprivate:\r\n    int m_x {};    \/\/ default member initializer (will be ignored)\r\n    int m_y { 2 }; \/\/ default member initializer (will be used)\r\n    int m_z;      \/\/ no initializer\r\n\r\npublic:\r\n    Foo(int x)\r\n        : m_x { x } \/\/ member initializer list\r\n    {\r\n        std::cout &lt;&lt; \"Foo constructed\\n\";\r\n    }\r\n\r\n    void print() const\r\n    {\r\n        std::cout &lt;&lt; \"Foo(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \", \" &lt;&lt; m_z &lt;&lt; \")\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Foo foo { 6 };\r\n    foo.print();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>On the author&#8217;s machine, this output:<\/p>\n<pre>\nFoo constructed\r\nFoo(6, 2, -858993460)\r\n<\/pre>\n<p>Here&#8217;s what&#8217;s happening.  When <code>foo<\/code> is constructed, only <code>m_x<\/code> appears in the member initializer list, so <code>m_x<\/code> is first initialized to <code>6<\/code>.  <code>m_y<\/code> is not in the member initialization list, but it does have a default member initializer, so it is initialized to <code>2<\/code>.  <code>m_z<\/code> is neither in the member initialization list, nor does it have a default member initializer, so it is default-initialized (which for fundamental types, means it is left uninitialized).  Thus, when we print the value of <code>m_z<\/code>, we get undefined behavior.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constructor function bodies<\/p>\n<p>The bodies of constructors functions are most often left empty.  This is because we primarily use constructor for initialization, which is done via the member initializer list.  If that is all we need to do, then we don&#8217;t need any statements in the body of the constructor.<\/p>\n<p>However, because the statements in the body of the constructor execute after the member initializer list has executed, we can add statements to do any other setup tasks required.  In the above examples, we print something to the console to show that the constructor executed, but we could do other things like open a file or database, allocate memory, etc&#8230;<\/p>\n<p>New programmers sometimes use the body of the constructor to assign values to members:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Foo\r\n{\r\nprivate:\r\n    int m_x { 0 };\r\n    int m_y { 1 };\r\n\r\npublic:\r\n    Foo(int x, int y)\r\n    {\r\n        m_x = x; \/\/ incorrect: this is an assignment, not an initialization\r\n        m_y = y; \/\/ incorrect: this is an assignment, not an initialization\r\n    }\r\n\r\n    void print() const\r\n    {\r\n        std::cout &lt;&lt; \"Foo(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \")\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Foo foo { 6, 7 };\r\n    foo.print();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Although in this simple case this will produce the expected result, in case where members are required to be initialized (such as for data members that are const or references) assignment will not work.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Once the member initializer list has finished executing, the object is considered initialized.  Once the function body has finished executing, the object is considered constructed.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Prefer using the member initializer list to initialize your members over assigning values in the body of the constructor.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Detecting and handling invalid arguments to constructors<\/p>\n<p>Consider the following Fraction class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Fraction\r\n{\r\nprivate:\r\n    int m_numerator {};\r\n    int m_denominator {};\r\n\r\npublic:\r\n    Fraction(int numerator, int denominator):\r\n        m_numerator { numerator }, m_denominator { denominator }\r\n    {\r\n    }\r\n};<\/code><\/pre>\n<p>Because a Fraction is a numerator divided by a denominator, the denominator of a fraction cannot be zero (otherwise we get a divide by zero, which is mathematically undefined).  In other words, this class has an invariant that <code>m_denominator<\/code> cannot be <code>0<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We discussed class invariants in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-classes\/\">14.2 -- Introduction to classes<\/a>.\n<\/p><\/div>\n<p>So what do we do when the user tries to create a Fraction with a zero denominator (e.g. <code>Fraction f { 1, 0 };<\/code>)?<\/p>\n<p>Inside a member initializer list, our tools for detecting and handling errors are quite limited.  We can use the conditional operator to detect an error, but then what?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Fraction\r\n{\r\nprivate:\r\n    int m_numerator {};\r\n    int m_denominator {};\r\n\r\npublic:\r\n    Fraction(int numerator, int denominator):\r\n        m_numerator { numerator }, m_denominator { denominator != 0.0 ? denominator : ??? } \/\/ what do we do here?\r\n    {\r\n    }\r\n};<\/code><\/pre>\n<p>We could change the denominator to a valid value, but then the user is going to get a <code>Fraction<\/code> that doesn&#8217;t contain the values they asked for, and we don&#8217;t have any way to notify them that we did something unexpected.  Thus, we typically won&#8217;t try to do any kind of validation in the member initializer list -- we&#8217;ll just initialize the members with the values passed in, and then try to deal with the situation.<\/p>\n<p>Inside the body of the constructor, we can use statements, so we have more options for detecting and handling errors.  This is a good place to <code>assert<\/code> or <code>static_assert<\/code> that the arguments passed in are semantically valid, but that doesn&#8217;t actually handle runtime errors in a production build.<\/p>\n<p>When a constructor cannot construct a semantically valid object, we say it has failed.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">When constructors fail (a prelude)<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/detecting-and-handling-errors\/\">9.4 -- Detecting and handling errors<\/a>, we introduced the topic of error handling, and discussed some options for handling cases where a function cannot proceed due to an error occurring.  Since constructors are functions, they are susceptible to the same issues.<\/p>\n<p>In that lesson, we suggested 4 strategies for dealing with such errors:<\/p>\n<ul>\n<li>Resolve the error within the function.\n<\/li>\n<li>Pass the error back to the caller to deal with.\n<\/li>\n<li>Halt the program.\n<\/li>\n<li>Throw an exception.\n<\/li>\n<\/ul>\n<p>In most cases, we don&#8217;t have enough information to resolve such issues entirely within the constructor.  So fixing the issue is generally not an option.<\/p>\n<p>With non-member and non-special member functions, we can pass an error back to the caller to deal with.  But constructors have no return value, so we don&#8217;t have a good way to do that.  In some cases, we can add an <code>isValid()<\/code> member function (or an overloaded conversion to <code>bool<\/code>) that returns whether the object is currently in a valid state or not.  For example, an <code>isValid()<\/code> function for <code>Fraction<\/code> would return <code>true<\/code> when <code>m_denominator != 0.0<\/code>.  But this means the caller has to remember to actually call the function any time a new Fraction is created.  And having semantically invalid objects that are accessible is likely to lead to bugs.  So while this is better than nothing, it&#8217;s not that great of an option.<\/p>\n<p>In certain types of programs, we can just halt the entire program and let the user rerun the program with the proper inputs&#8230; but in most cases, that&#8217;s just not acceptable.  So probably not.<\/p>\n<p>And that leaves throwing an exception.  Exceptions abort the construction process entirely, which means the user never gets access to a semantically invalid object.  So in most cases, throwing an exception is the best thing to do in these situations.  <\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Throwing an exception is usually the best thing to do when a constructor fails (and cannot recover).  We discuss this further in lessons <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/exceptions-classes-and-inheritance\/\">27.5 -- Exceptions, classes, and inheritance<\/a> and <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-try-blocks\/\">27.7 -- Function try blocks<\/a>.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>For now, we&#8217;ll generally assume that construction of our class object succeeds in creating a semantically valid object.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>If exceptions aren&#8217;t possible or desired (either because you&#8217;ve decided not to use them or because you haven&#8217;t learned about them yet), there is one other reasonable option.  Instead of letting the user create the class directly, provide a function that either returns an instance of the class or something that indicates failure.<\/p>\n<p>In the following example, our <code>createFraction()<\/code> function returns a <code>std::optional&lt;Fraction&gt;<\/code> that optionally contains a valid <code>Fraction<\/code>.  If it does, then we can use that Fraction.  If not, then the caller can detect that and deal with it.  We cover <code>std::optional<\/code> in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdoptional\/\">12.15 -- std::optional<\/a> and friend functions in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/friend-non-member-functions\/\">15.8 -- Friend non-member functions<\/a>.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;optional&gt;\r\n\r\nclass Fraction\r\n{\r\nprivate:\r\n    int m_numerator { 0 };\r\n    int m_denominator { 1 };\r\n\r\n    \/\/ private constructor can't be called by public\r\n    Fraction(int numerator, int denominator):\r\n        m_numerator { numerator }, m_denominator { denominator }\r\n    {\r\n    }\r\n\r\npublic:\r\n    \/\/ Allow this function to access private members\r\n    friend std::optional&lt;Fraction&gt; createFraction(int numerator, int denominator);\r\n};\r\n\r\nstd::optional&lt;Fraction&gt; createFraction(int numerator, int denominator)\r\n{\r\n    if (denominator == 0)\r\n        return {};\r\n    \r\n    return Fraction{numerator, denominator};\r\n}\r\n\r\nint main()\r\n{\r\n    auto f1 { createFraction(0, 1) };\r\n    if (f1)\r\n    {\r\n        std::cout &lt;&lt; \"Fraction created\\n\";\r\n    }\r\n\r\n    auto f2 { createFraction(0, 0) };\r\n    if (!f2)\r\n    {\r\n        std::cout &lt;&lt; \"Bad fraction\\n\";\r\n    }   \r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Write a class named Ball.  Ball should have two private member variables, one to hold a color, and one to hold a radius.  Also write a function to print out the color and radius of the ball.<\/p>\n<p>The following sample program should compile:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n\tBall blue { \"blue\", 10.0 };\r\n\tprint(blue);\r\n\r\n\tBall red { \"red\", 12.0 };\r\n\tprint(red);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>and produce the result:<\/p>\n<pre>\nBall(blue, 10)\r\nBall(red, 12)\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Ball\r\n{\r\nprivate:\r\n\tstd::string m_color { \"none\" };\r\n\tdouble m_radius { 0.0 };\r\n\r\npublic:\r\n\tBall(std::string_view color, double radius)\r\n\t\t: m_color { color }\r\n\t\t, m_radius { radius }\r\n\t{\r\n\t}\r\n\r\n\tconst std::string&amp; getColor() const { return m_color; }\r\n\tdouble getRadius() const { return m_radius; }\r\n};\r\n\r\nvoid print(const Ball&amp; ball)\r\n{\r\n    std::cout &lt;&lt; \"Ball(\" &lt;&lt; ball.getColor() &lt;&lt; \", \" &lt;&lt; ball.getRadius() &lt;&lt; \")\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n\tBall blue { \"blue\", 10.0 };\r\n\tprint(blue);\r\n\r\n\tBall red { \"red\", 12.0 };\r\n\tprint(red);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>Why did we make <code>print()<\/code> a non-member function instead of a member function?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p>The rationale for this is given in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/the-benefits-of-data-hiding-encapsulation\/#prefer-non-member-functions\">14.8 -- The benefits of data hiding (encapsulation)<\/a>.\n<\/p><\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #3<\/p>\n<p>Why did we make <code>m_color<\/code> a <code>std::string<\/code> instead of a <code>std::string_view<\/code>?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<p>In this particular example, it doesn&#8217;t matter (because our color arguments are C-style string literals, which doesn&#8217;t go out of scope). <\/p>\n<p>But conceptually, we want our <code>Ball<\/code> class to be an owner of the color passed in.  If <code>m_color<\/code> were a <code>std::string_view<\/code>, passing in a temporary object for the color argument (e.g. a <code>std::string<\/code> returned from a function) would leave <code>m_color<\/code> dangling when the temporary color argument was destroyed.<\/p>\n<p>We discuss this case in more detail (and show an example) in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/struct-miscellany\/\">13.11 -- Struct miscellany<\/a>.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/default-constructors-and-default-arguments\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.11<\/span>Default constructors and default arguments\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-constructors\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.9<\/span>Introduction to constructors\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>This lesson continues our introduction of constructors from lesson . Member initialization via a member initialization list To have a constructor initialize members, we do so using a (often called a &#8220;member initialization list&#8221;). Do not confuse this with the similarly named &#8220;initializer list&#8221; that is used to initialize aggregates &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/154"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=154"}],"version-history":[{"count":61,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/154\/revisions"}],"predecessor-version":[{"id":18173,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/154\/revisions\/18173"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=154"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=154"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=154"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}