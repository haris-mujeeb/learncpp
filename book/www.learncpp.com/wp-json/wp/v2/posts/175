{"id":175,"date":"2008-01-24T15:39:21","date_gmt":"2008-01-24T23:39:21","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/117-multiple-inheritance\/"},"modified":"2024-07-11T22:09:55","modified_gmt":"2024-07-12T05:09:55","slug":"multiple-inheritance","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/multiple-inheritance\/","title":{"rendered":"24.9 &#8212; Multiple inheritance"},"content":{"rendered":"<p>So far, all of the examples of inheritance we&#8217;ve presented have been single inheritance -- that is, each inherited class has one and only one parent.  However, C++ provides the ability to do multiple inheritance.  <strong>Multiple inheritance<\/strong> enables a derived class to inherit members from more than one parent.<\/p>\n<p>Let&#8217;s say we wanted to write a program to keep track of a bunch of teachers.  A teacher is a person.  However, a teacher is also an employee (they are their own employer if working for themselves).  Multiple inheritance can be used to create a Teacher class that inherits properties from both Person and Employee.  To use multiple inheritance, simply specify each base class (just like in single inheritance), separated by a comma.<\/p>\n<p><img src=\"http:\/\/www.learncpp.com\/images\/CppTutorial\/Section11\/PersonTeacher.gif\"><\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Person\r\n{\r\nprivate:\r\n    std::string m_name{};\r\n    int m_age{};\r\n\r\npublic:\r\n    Person(std::string_view name, int age)\r\n        : m_name{ name }, m_age{ age }\r\n    {\r\n    }\r\n\r\n    const std::string&amp; getName() const { return m_name; }\r\n    int getAge() const { return m_age; }\r\n};\r\n\r\nclass Employee\r\n{\r\nprivate:\r\n    std::string m_employer{};\r\n    double m_wage{};\r\n\r\npublic:\r\n    Employee(std::string_view employer, double wage)\r\n        : m_employer{ employer }, m_wage{ wage }\r\n    {\r\n    }\r\n\r\n    const std::string&amp; getEmployer() const { return m_employer; }\r\n    double getWage() const { return m_wage; }\r\n};\r\n\r\n\/\/ Teacher publicly inherits Person and Employee\r\nclass Teacher : public Person, public Employee\r\n{\r\nprivate:\r\n    int m_teachesGrade{};\r\n\r\npublic:\r\n    Teacher(std::string_view name, int age, std::string_view employer, double wage, int teachesGrade)\r\n        : Person{ name, age }, Employee{ employer, wage }, m_teachesGrade{ teachesGrade }\r\n    {\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Teacher t{ \"Mary\", 45, \"Boo\", 14.3, 8 };\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Mixins<\/p>\n<p>A <strong>mixin<\/strong> (also spelled &#8220;mix-in&#8221;) is a small class that can be inherited from in order to add properties to a class.  The name mixin indicates that the class is intended to be mixed into other classes, not instantiated on its own.<\/p>\n<p>In the following example, the <code>Box<\/code>, <code>Label<\/code>, and <code>Tooltip<\/code> classes are mixins that we inherit from in order to create a new <code>Button<\/code> class.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ h\/t to reader Waldo for this example\r\n#include &lt;string&gt;\r\n\r\nstruct Point2D\r\n{\r\n\tint x{};\r\n\tint y{};\r\n};\r\n\r\nclass Box \/\/ mixin Box class\r\n{\r\npublic:\r\n\tvoid setTopLeft(Point2D point) { m_topLeft = point; }\r\n\tvoid setBottomRight(Point2D point) { m_bottomRight = point; }\r\nprivate:\r\n\tPoint2D m_topLeft{};\r\n\tPoint2D m_bottomRight{};\r\n};\r\n\r\nclass Label \/\/ mixin Label class\r\n{\r\npublic:\r\n\tvoid setText(const std::string_view str) { m_text = str; }\r\n\tvoid setFontSize(int fontSize) { m_fontSize = fontSize; }\r\nprivate:\r\n\tstd::string m_text{};\r\n\tint m_fontSize{};\r\n};\r\n\r\nclass Tooltip \/\/ mixin Tooltip class\r\n{\r\npublic:\r\n\tvoid setText(const std::string_view str) { m_text = str; }\r\nprivate:\r\n\tstd::string m_text{};\r\n};\r\n\r\nclass Button : public Box, public Label, public Tooltip {}; \/\/ Button using three mixins\r\n\r\nint main()\r\n{\r\n\tButton button{};\r\n\tbutton.Box::setTopLeft({ 1, 1 });\r\n\tbutton.Box::setBottomRight({ 10, 10 });\r\n\tbutton.Label::setText(\"Submit\");\r\n\tbutton.Label::setFontSize(6);\r\n\tbutton.Tooltip::setText(\"Submit the form to the server\");\r\n}<\/code><\/pre>\n<p>You may be wondering why we use explicit <code>Box::<\/code>, <code>Label::<\/code>, and <code>Tooltip::<\/code> scope resolution prefixes when this isn&#8217;t necessary in most cases.<\/p>\n<ol start=\"1\">\n<li><code>Label::setText()<\/code> and <code>Tooltip::setText()<\/code> have the same prototype.  If we called <code>button.setText()<\/code>, the compiler would produce an ambiguous function call compilation error.  In such cases, we must use the prefix to disambiguate which version we want.\n<\/li>\n<li>In non-ambiguous cases, using the mixin name provides documentation as to which mixin the function call applies to, which helps make our code easier to understand.\n<\/li>\n<li>Non-ambiguous cases may become ambiguous in the future if we add additional mixins.  Using explicit prefixes helps prevent this from occurring.\n<\/li>\n<\/ol>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Because mixins are designed to add functionality to the derived class, not to provide an interface, mixins typically do not use virtual functions (covered in the next chapter).  Instead, if a mixin class needs to be customized to work in a particular way, templates are typically used.  For this reason, mixin classes are often templatized.<\/p>\n<p>Perhaps surprisingly, a derived class can inherit from a mixin base class using the derived class as a template type parameter.  Such inheritance is called <strong>Curiously Recurring Template Pattern<\/strong> (CRTP for short), which looks like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ The Curiously Recurring Template Pattern (CRTP)\r\n\r\ntemplate &lt;class T&gt;\r\nclass Mixin\r\n{\r\n    \/\/ Mixin&lt;T&gt; can use template type parameter T to access members of Derived\r\n    \/\/ via (static_cast&lt;T*&gt;(this))\r\n};\r\n\r\nclass Derived : public Mixin&lt;Derived&gt;\r\n{\r\n};<\/code><\/pre>\n<p>You can find a simple example using CRTP <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/language\/crtp\">here<\/a>.\n<\/div>\n<p><strong>Problems with multiple inheritance<\/strong><\/p>\n<p>While multiple inheritance seems like a simple extension of single inheritance, multiple inheritance introduces a lot of issues that can markedly increase the complexity of programs and make them a maintenance nightmare.  Let&#8217;s take a look at some of these situations.<\/p>\n<p>First, ambiguity can result when multiple base classes contain a function with the same name.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass USBDevice\r\n{\r\nprivate:\r\n    long m_id {};\r\n\r\npublic:\r\n    USBDevice(long id)\r\n        : m_id { id }\r\n    {\r\n    }\r\n\r\n    long getID() const { return m_id; }\r\n};\r\n\r\nclass NetworkDevice\r\n{\r\nprivate:\r\n    long m_id {};\r\n\r\npublic:\r\n    NetworkDevice(long id)\r\n        : m_id { id }\r\n    {\r\n    }\r\n\r\n    long getID() const { return m_id; }\r\n};\r\n\r\nclass WirelessAdapter: public USBDevice, public NetworkDevice\r\n{\r\npublic:\r\n    WirelessAdapter(long usbId, long networkId)\r\n        : USBDevice { usbId }, NetworkDevice { networkId }\r\n    {\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    WirelessAdapter c54G { 5442, 181742 };\r\n    std::cout &lt;&lt; c54G.getID(); \/\/ Which getID() do we call?\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When <code>c54G.getID() <\/code> is compiled, the compiler looks to see if WirelessAdapter contains a function named getID().  It doesn&#8217;t.  The compiler then looks to see if any of the parent classes have a function named getID().  See the problem here?  The problem is that c54G actually contains TWO getID() functions: one inherited from USBDevice, and one inherited from NetworkDevice.  Consequently, this function call is ambiguous, and you will receive a compiler error if you try to compile it.<\/p>\n<p>However, there is a way to work around this problem: you can explicitly specify which version you meant to call:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    WirelessAdapter c54G { 5442, 181742 };\r\n    std::cout &lt;&lt; c54G.USBDevice::getID();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>While this workaround is pretty simple, you can see how things can get complex when your class inherits from four or six base classes, which inherit from other classes themselves.  The potential for naming conflicts increases exponentially as you inherit more classes, and each of these naming conflicts needs to be resolved explicitly.<\/p>\n<p>Second, and more serious is the <a href=\"http:\/\/en.wikipedia.org\/wiki\/Diamond_problem\">diamond problem<\/a>, which your author likes to call the &#8220;diamond of doom&#8221;.  This occurs when a class multiply inherits from two classes which each inherit from a single base class.  This leads to a diamond shaped inheritance pattern.<\/p>\n<p>For example, consider the following set of classes:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class PoweredDevice\r\n{\r\n};\r\n\r\nclass Scanner: public PoweredDevice\r\n{\r\n};\r\n\r\nclass Printer: public PoweredDevice\r\n{\r\n};\r\n\r\nclass Copier: public Scanner, public Printer\r\n{\r\n};<\/code><\/pre>\n<p><img src=\"http:\/\/www.learncpp.com\/images\/CppTutorial\/Section11\/PoweredDevice.gif\"><\/p>\n<p>Scanners and printers are both powered devices, so they derived from PoweredDevice.  However, a copy machine incorporates the functionality of both Scanners and Printers.<\/p>\n<p>There are many issues that arise in this context, including whether Copier should have one or two copies of PoweredDevice, and how to resolve certain types of ambiguous references.  While most of these issues can be addressed through explicit scoping, the maintenance overhead added to your classes in order to deal with the added complexity can cause development time to skyrocket.  We&#8217;ll talk more about ways to resolve the diamond problem in the next chapter (lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/virtual-base-classes\/\">25.8 -- Virtual base classes<\/a>).<\/p>\n<p><strong>Is multiple inheritance more trouble than it&#8217;s worth?<\/strong><\/p>\n<p>As it turns out, most of the problems that can be solved using multiple inheritance can be solved using single inheritance as well.  Many object-oriented languages (eg. Smalltalk, PHP) do not even support multiple inheritance.  Many relatively modern languages such as Java and C# restrict classes to single inheritance of normal classes, but allow multiple inheritance of interface classes (which we will talk about later).  The driving idea behind disallowing multiple inheritance in these languages is that it simply makes the language too complex, and ultimately causes more problems than it fixes.<\/p>\n<p>Many authors and experienced programmers believe multiple inheritance in C++ should be avoided at all costs due to the many potential problems it brings.  Your author does not agree with this approach, because there are times and situations when multiple inheritance is the best way to proceed.  However, multiple inheritance should be used extremely judiciously.<\/p>\n<p>As an interesting aside, you have already been using classes written using multiple inheritance without knowing it: the iostream library objects std::cin and std::cout are both implemented using multiple inheritance!<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Avoid multiple inheritance unless alternatives lead to more complexity.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-24-summary-and-quiz\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">24.x<\/span>Chapter 24 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/hiding-inherited-functionality\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">24.8<\/span>Hiding inherited functionality\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>So far, all of the examples of inheritance we&#8217;ve presented have been single inheritance &#8212; that is, each inherited class has one and only one parent. However, C++ provides the ability to do multiple inheritance. Multiple inheritance enables a derived class to inherit members from more than one parent. Let&#8217;s &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/175"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=175"}],"version-history":[{"count":25,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/175\/revisions"}],"predecessor-version":[{"id":17307,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/175\/revisions\/17307"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=175"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=175"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=175"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}