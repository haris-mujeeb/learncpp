{"id":215,"date":"2008-10-25T12:07:37","date_gmt":"2008-10-25T20:07:37","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=215"},"modified":"2024-09-12T12:20:17","modified_gmt":"2024-09-12T19:20:17","slug":"uncaught-exceptions-catch-all-handlers","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/uncaught-exceptions-catch-all-handlers\/","title":{"rendered":"27.4 &#8212; Uncaught exceptions and catch-all handlers"},"content":{"rendered":"<p>By now, you should have a reasonable idea of how exceptions work.  In this lesson, we&#8217;ll cover a few more interesting exception cases.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Uncaught exceptions<\/p>\n<p>When a function throws an exception that it does not handle itself, it is making the assumption that a function somewhere down the call stack will handle the exception.  In the following example, mySqrt() assumes someone will handle the exception that it throws -- but what happens if nobody actually does?<\/p>\n<p>Here&#8217;s our square root program again, minus the try block in main():<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;cmath&gt; \/\/ for sqrt() function\r\n\r\n\/\/ A modular square root function\r\ndouble mySqrt(double x)\r\n{\r\n    \/\/ If the user entered a negative number, this is an error condition\r\n    if (x &lt; 0.0)\r\n        throw \"Can not take sqrt of negative number\"; \/\/ throw exception of type const char*\r\n\r\n    return std::sqrt(x);\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter a number: \";\r\n    double x;\r\n    std::cin &gt;&gt; x;\r\n\r\n    \/\/ Look ma, no exception handler!\r\n    std::cout &lt;&lt; \"The sqrt of \" &lt;&lt; x &lt;&lt; \" is \" &lt;&lt; mySqrt(x) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Now, let&#8217;s say the user enters -4, and mySqrt(-4) raises an exception.  Function mySqrt() doesn&#8217;t handle the exception, so the program looks to see if some function down the call stack will handle the exception.  main() does not have a handler for this exception either, so no handler can be found.<\/p>\n<p>When no exception handler for a function can be found, std::terminate() is called, and the application is terminated.  In such cases, the call stack may or may not be unwound!  If the stack is not unwound, local variables will not be destroyed, and any cleanup expected upon destruction of said variables will not happen!<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>The call stack may or may not be unwound if an exception is unhandled.<\/p>\n<p>If the stack is not unwound, local variables will not be destroyed, which may cause problems if those variables have non-trivial destructors.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>Although it might seem strange to not unwind the stack in such a case, there is a good reason for not doing so.  An unhandled exception is generally something you want to avoid at all costs.  If the stack were unwound, then all of the debug information about the state of the stack that led up to the throwing of the unhandled exception would be lost!  By not unwinding, we preserve that information, making it easier to determine how an unhandled exception was thrown, and fix it.\n<\/p><\/div>\n<p>When an exception is unhandled, the operating system will generally notify you that an unhandled exception error has occurred.  How it does this depends on the operating system, but possibilities include printing an error message, popping up an error dialog, or simply crashing.  Some OSes are less graceful than others.  Generally this is something you want to avoid!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Catch-all handlers<\/p>\n<p>And now we find ourselves in a conundrum:<\/p>\n<ul>\n<li>Functions can potentially throw exceptions of any data type (including program-defined data types), meaning there is an infinite number of possible exception types to catch.\n<\/li>\n<li>If an exception is not caught, your program will terminate immediately (and the stack may not be unwound, so your program may not even clean up after itself properly).\n<\/li>\n<li>Adding explicit catch handlers for every possible type is tedious, especially for the ones that are expected to be reached only in exceptional cases!\n<\/li>\n<\/ul>\n<p>Fortunately, C++ also provides us with a mechanism to catch all types of exceptions.  This is known as a <strong>catch-all handler<\/strong>.  A catch-all handler works just like a normal catch block, except that instead of using a specific type to catch, it uses the ellipses operator (&#8230;) as the type to catch.  For this reason, the catch-all handler is also sometimes called an &#8220;ellipsis catch handler&#8221;<\/p>\n<p>If you recall from lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/ellipsis-and-why-to-avoid-them\/\">20.5 -- Ellipsis (and why to avoid them)<\/a>, ellipses were previously used to pass arguments of any type to a function.  In this context, they represent exceptions of any data type.  Here&#8217;s an simple example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\ttry\r\n\t{\r\n\t\tthrow 5; \/\/ throw an int exception\r\n\t}\r\n\tcatch (double x)\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"We caught an exception of type double: \" &lt;&lt; x &lt;&lt; '\\n';\r\n\t}\r\n\tcatch (...) \/\/ catch-all handler\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"We caught an exception of an undetermined type\\n\";\r\n\t}\r\n}<\/code><\/pre>\n<p>Because there is no specific exception handler for type int, the catch-all handler catches this exception.  This example produces the following result:<\/p>\n<pre>\nWe caught an exception of an undetermined type\r\n<\/pre>\n<p>The catch-all handler must be placed last in the catch block chain.  This is to ensure that exceptions can be caught by exception handlers tailored to specific data types if those handlers exist.<\/p>\n<p>Often, the catch-all handler block is left empty:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">catch(...) {} \/\/ ignore any unanticipated exceptions<\/code><\/pre>\n<p>This will catch any unanticipated exceptions, ensuring that stack unwinding occurs up to this point and preventing the program from terminating, but does no specific error handling.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using the catch-all handler to wrap main()<\/p>\n<p>One use for the catch-all handler is to wrap the contents of main():<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct GameSession\r\n{\r\n    \/\/ Game session data here\r\n};\r\n\r\nvoid runGame(GameSession&amp;)\r\n{\r\n    throw 1;\r\n}\r\n\r\nvoid saveGame(GameSession&amp;)\r\n{\r\n    \/\/ Save user's game here\r\n}\r\n\r\nint main()\r\n{\r\n    GameSession session{};\r\n\r\n    try\r\n    {\r\n        runGame(session);\r\n    }\r\n    catch(...)\r\n    {\r\n        std::cerr &lt;&lt; \"Abnormal termination\\n\";\r\n    }\r\n\r\n    saveGame(session); \/\/ save the user's game (even if catch-all handler was hit)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this case, if runGame() or any of the functions it calls throws an exception that is not handled, it will be caught by this catch-all handler.  The stack will be unwound in an orderly manner (ensuring destruction of local variables).  This will also prevent the program from terminating immediately, giving us a chance to print an error of our choosing and save the user&#8217;s state before exiting.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>If your program uses exceptions, consider using a catch-all handler in main, to help ensure orderly behavior if an unhandled exception occurs.<\/p>\n<p>If an exception is caught by the catch-all handler, you should assume the program is now in some indeterminate state, perform cleanup immediately, and then terminate.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Debugging unhandled exceptions<\/p>\n<p>Unhandled exceptions are an indication that something unexpected has happened, and we probably want to diagnose why an unhandled exception was thrown in the first place.  Many debuggers will (or can be configured to) break on unhandled exceptions, allowing us to view the stack at the point where the unhandled exception was thrown.  However, if we have a catch-all handler, then all exceptions are handled, and (because the stack is unwound) we lose useful diagnostic information.<\/p>\n<p>Therefore, in debug builds, it can be useful to disable the catch-all handler.  We can do this via conditional compilation directives.<\/p>\n<p>Here&#8217;s one way to do that:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct GameSession\r\n{\r\n    \/\/ Game session data here\r\n};\r\n\r\nvoid runGame(GameSession&amp;)\r\n{\r\n    throw 1;\r\n}\r\n\r\nvoid saveGame(GameSession&amp;)\r\n{\r\n    \/\/ Save user's game here\r\n}\r\n\r\nclass DummyException \/\/ a dummy class that can't be instantiated\r\n{\r\n    DummyException() = delete;\r\n}; \r\n\r\nint main()\r\n{\r\n    GameSession session {}; \r\n\r\n    try\r\n    {\r\n        runGame(session);\r\n    }\r\n#ifndef NDEBUG \/\/ if we're in release node\r\n    catch(...) \/\/ compile in the catch-all handler\r\n    {\r\n        std::cerr &lt;&lt; \"Abnormal termination\\n\";\r\n    }\r\n#else \/\/ in debug mode, compile in a catch that will never be hit (for syntactic reasons)\r\n    catch(DummyException)\r\n    {\r\n    }\r\n#endif\r\n\r\n    saveGame(session); \/\/ save the user's game (even if catch-all handler was hit)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Syntactically, a try block requires at least one associated catch block.  So if the catch-all handler is conditionally compiled out, we either need to conditionally compile out the try block, or we need to conditionally compile in another catch block.  It&#8217;s cleaner to do the latter.<\/p>\n<p>For this purpose, we create class <code>DummyException<\/code> which can&#8217;t be instantiated because it has a deleted default constructor and no other constructors.  When <code>NDEBUG<\/code> is defined, we compile-in a catch handler to catch an exception of type <code>DummyException<\/code>.  Since we can&#8217;t create a <code>DummyException<\/code>, this catch handler will never catch anything.   Therefore any exceptions that reach this point will not be handled.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/exceptions-classes-and-inheritance\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">27.5<\/span>Exceptions, classes, and inheritance\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/exceptions-functions-and-stack-unwinding\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">27.3<\/span>Exceptions, functions, and stack unwinding\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>By now, you should have a reasonable idea of how exceptions work. In this lesson, we&#8217;ll cover a few more interesting exception cases. Uncaught exceptions When a function throws an exception that it does not handle itself, it is making the assumption that a function somewhere down the call stack &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[12,30,31,25,14,16],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/215"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=215"}],"version-history":[{"count":22,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/215\/revisions"}],"predecessor-version":[{"id":17596,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/215\/revisions\/17596"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=215"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=215"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=215"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}