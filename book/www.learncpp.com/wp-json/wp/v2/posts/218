{"id":218,"date":"2008-12-07T14:43:10","date_gmt":"2008-12-07T22:43:10","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=218"},"modified":"2025-02-02T21:35:38","modified_gmt":"2025-02-03T05:35:38","slug":"generating-random-numbers-using-mersenne-twister","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/generating-random-numbers-using-mersenne-twister\/","title":{"rendered":"8.14 &#8212; Generating random numbers using Mersenne Twister"},"content":{"rendered":"<p>In the previous lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-random-number-generation\/\">8.13 -- Introduction to random number generation<\/a>, we introduced the concept of random number generation, and discussed how PRNG algorithms are typically used to simulate randomness in programs.<\/p>\n<p>In this lesson, we&#8217;ll take a look at how to generate random numbers in your programs.  To access any of the randomization capabilities in C++, we include the <code>&lt;random&gt;<\/code> header of the standard library.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Generating random numbers in C++ using Mersenne Twister<\/p>\n<p>The Mersenne Twister PRNG, besides having a great name, is probably the most popular PRNG across all programming languages.  Although it is a bit old by today&#8217;s standards, it generally produces quality results and has decent performance.  The random library has support for two Mersenne Twister types:<\/p>\n<ul>\n<li><code>mt19937<\/code> is a Mersenne Twister that generates 32-bit unsigned integers\n<\/li>\n<li><code>mt19937_64<\/code> is a Mersenne Twister that generates 64-bit unsigned integers\n<\/li>\n<\/ul>\n<p>Using Mersenne Twister is straightforward: <\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;random&gt; \/\/ for std::mt19937\r\n\r\nint main()\r\n{\r\n\tstd::mt19937 mt{}; \/\/ Instantiate a 32-bit Mersenne Twister\r\n\r\n\t\/\/ Print a bunch of random numbers\r\n\tfor (int count{ 1 }; count &lt;= 40; ++count)\r\n\t{\r\n\t\tstd::cout &lt;&lt; mt() &lt;&lt; '\\t'; \/\/ generate a random number\r\n\r\n\t\t\/\/ If we've printed 5 numbers, start a new row\r\n\t\tif (count % 5 == 0)\r\n\t\t\tstd::cout &lt;&lt; '\\n';\r\n\t}\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This produces the result:<\/p>\n<pre>\n3499211612      581869302       3890346734      3586334585      545404204\r\n4161255391      3922919429      949333985       2715962298      1323567403\r\n418932835       2350294565      1196140740      809094426       2348838239\r\n4264392720      4112460519      4279768804      4144164697      4156218106\r\n676943009       3117454609      4168664243      4213834039      4111000746\r\n471852626       2084672536      3427838553      3437178460      1275731771\r\n609397212       20544909        1811450929      483031418       3933054126\r\n2747762695      3402504553      3772830893      4120988587      2163214728\r\n<\/pre>\n<p>First, we include the &lt;random&gt; header, since that&#8217;s where all the random number capabilities live.  Next, we instantiate a 32-bit Mersenne Twister engine via the statement <code>std::mt19937 mt<\/code>.  Then, each time we want to generate a random 32-bit unsigned integer, we call <code>mt()<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>Since <code>mt<\/code> is a variable, you may be wondering what <code>mt()<\/code> means.<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdstring\/\">5.7 -- Introduction to std::string<\/a>, we showed an example where we called the function <code>name.length()<\/code>, which invoked the <code>length()<\/code> function on <code>std::string<\/code> variable <code>name<\/code>.<\/p>\n<p><code>mt()<\/code> is a concise syntax for calling the function <code>mt.operator()<\/code>, which for these PRNG types has been defined to return the next random result in the sequence.  The advantage of using <code>operator()<\/code> instead of a named function is that we don&#8217;t need to remember the function&#8217;s name, and the concise syntax is less typing.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Rolling a dice using Mersenne Twister<\/p>\n<p>A 32-bit PRNG will generate random numbers between 0 and 4,294,967,295, but we do not always want numbers in that range.  If our program was simulating a board game or a dice game, we&#8217;d probably want to simulate the roll of a 6-sided dice by generating random numbers between 1 and 6.  If our program was a dungeon adventure, and the player had a sword that did between 7 and 11 damage to monsters, then we&#8217;d want to generate random numbers between 7 and 11 whenever the player hit a monster.<\/p>\n<p>Unfortunately, PRNGs can&#8217;t do this.  They can only generate numbers that use the full range.  What we need is some way to convert a number that is output from our PRNG into a value in the smaller range we want (with an even probability of each value occurring).  While we could write a function to do this ourselves, doing so in a way that produces non-biased results is non-trivial.<\/p>\n<p>Fortunately, the random library can help us here, in the form of random number distributions.  A <strong>random number distribution<\/strong> converts the output of a PRNG into some other distribution of numbers.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>For the stats geeks: a random number distribution is just a probability distribution designed to take PRNG values as input.\n<\/p><\/div>\n<p>The random library has many random numbers distributions, most of which you will never use unless you&#8217;re doing some kind of statistical analysis.  But there&#8217;s one random number distribution that&#8217;s extremely useful: a <strong>uniform distribution<\/strong> is a random number distribution that produces outputs between two numbers X and Y (inclusive) with equal probability.<\/p>\n<p>Here&#8217;s a similar program to the one above, using a uniform distribution to simulate the roll of a 6-sided dice:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;random&gt; \/\/ for std::mt19937 and std::uniform_int_distribution\r\n\r\nint main()\r\n{\r\n\tstd::mt19937 mt{};\r\n\r\n\t\/\/ Create a reusable random number generator that generates uniform numbers between 1 and 6\r\n\tstd::uniform_int_distribution die6{ 1, 6 }; \/\/ for C++14, use std::uniform_int_distribution&lt;&gt; die6{ 1, 6 };\r\n\r\n\t\/\/ Print a bunch of random numbers\r\n\tfor (int count{ 1 }; count &lt;= 40; ++count)\r\n\t{\r\n\t\tstd::cout &lt;&lt; die6(mt) &lt;&lt; '\\t'; \/\/ generate a roll of the die here\r\n\r\n\t\t\/\/ If we've printed 10 numbers, start a new row\r\n\t\tif (count % 10 == 0)\r\n\t\t\tstd::cout &lt;&lt; '\\n';\r\n\t}\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This produces the result:<\/p>\n<pre>\n3       1       3       6       5       2       6       6       1       2\r\n2       6       1       1       6       1       4       5       2       5\r\n6       2       6       2       1       3       5       4       5       6\r\n1       4       2       3       1       2       2       6       2       1\r\n<\/pre>\n<p>There are only two noteworthy differences in this example compared to the previous one.  First, we&#8217;ve created a uniform distribution variable (named <code>die6<\/code>) to generate numbers between 1 and 6.  Second, instead of calling <code>mt()<\/code> to generate 32-bit unsigned integer random numbers, we&#8217;re now calling <code>die6(mt)<\/code> to generate a value between 1 and 6.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The above program isn&#8217;t as random as it seems<\/p>\n<p>Although the results of our dice rolling example above are pretty random, there&#8217;s a major flaw with the program.  Run the program 3 times and see if you can figure out what it is.  Go ahead, we&#8217;ll wait.<\/p>\n<p><em>Jeopardy music<\/em><\/p>\n<p>If you run the program multiple times, you will note that it prints the same numbers every time!  While each number in the sequence is random with regards to the previous one, the entire sequence is not random at all!  Each run of our program produces the exact same result.<\/p>\n<p>Imagine that you&#8217;re writing a game of hi-lo, where the user has 10 tries to guess a number that has been picked randomly, and the computer tells the user whether their guess is too high or too low.  If the computer picks the same random number every time, the game won&#8217;t be interesting past the first time it is played.  So let\u2019s take a deeper look at why this is happening, and how we can fix it.<\/p>\n<p>In the prior lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-random-number-generation\/\">8.13 -- Introduction to random number generation<\/a>), we covered that each number in a PRNG sequence is in a deterministic way.  And that the state of the PRNG is initialized from the seed value.  Thus, given any starting seed number, PRNGs will always generate the same sequence of numbers from that seed as a result.<\/p>\n<p>Because we are value initializing our Mersenne Twister, it is being initialized with the same seed every time the program is run.  And because the seed is the same, the random numbers being generated are also the same.<\/p>\n<p>In order to make our entire sequence randomized differently each time the program is run, we need to pick a seed that\u2019s not a fixed number.  The first answer that probably comes to mind is that we need a random number for our seed!  That\u2019s a good thought, but if we need a random number to generate random numbers, then we\u2019re in a catch-22.  It turns out, we really don\u2019t need our seed to be a random number -- we just need to pick something that changes each time the program is run.  Then we can use our PRNG to generate a unique sequence of pseudo-random numbers from that seed.<\/p>\n<p>There are two methods that are commonly used to do this:<\/p>\n<ul>\n<li>Use the system clock\n<\/li>\n<li>Use the system&#8217;s random device\n<\/li>\n<\/ul>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Seeding with the system clock<\/p>\n<p>What&#8217;s one thing that&#8217;s different every time you run your program?  Unless you manage to run your program twice at exactly the same moment in time, the answer is that the current time is different.  Therefore, if we use the current time as our seed value, then our program will produce a different set of random numbers each time it is run.  C and C++ have a long history of PRNGs being seeded using the current time (using the <code>std::time()<\/code> function), so you will probably see this in a lot of existing code.<\/p>\n<p>Fortunately, C++ has a chrono library containing various clocks that we can use to generate a seed value.  To minimize the chance of two time values being identical if the program is run quickly in succession, we want to use some time measure that changes as quickly as possible.  For this, we&#8217;ll ask the clock how much time has passed since the earliest time it can measure.  This time is measured in &#8220;ticks&#8221;, which is a very small unit of time (usually nanoseconds, but could be milliseconds).<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;random&gt; \/\/ for std::mt19937\r\n#include &lt;chrono&gt; \/\/ for std::chrono\r\n\r\nint main()\r\n{\r\n\t\/\/ Seed our Mersenne Twister using steady_clock\r\n\tstd::mt19937 mt{ static_cast&lt;std::mt19937::result_type&gt;(\r\n\t\tstd::chrono::steady_clock::now().time_since_epoch().count()\r\n\t\t) };\r\n\r\n\t\/\/ Create a reusable random number generator that generates uniform numbers between 1 and 6\r\n\tstd::uniform_int_distribution die6{ 1, 6 }; \/\/ for C++14, use std::uniform_int_distribution&lt;&gt; die6{ 1, 6 };\r\n\r\n\t\/\/ Print a bunch of random numbers\r\n\tfor (int count{ 1 }; count &lt;= 40; ++count)\r\n\t{\r\n\t\tstd::cout &lt;&lt; die6(mt) &lt;&lt; '\\t'; \/\/ generate a roll of the die here\r\n\r\n\t\t\/\/ If we've printed 10 numbers, start a new row\r\n\t\tif (count % 10 == 0)\r\n\t\t\tstd::cout &lt;&lt; '\\n';\r\n\t}\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>The above program has only two changes from the prior.  First, we&#8217;re including &lt;chrono&gt;, which gives us access to the clock.  Second, we&#8217;re using the current time from the clock as a seed value for our Mersenne Twister.<\/p>\n<p>The results generated by this program should now be different each time it is run, which you can verify experimentally by running it several times.<\/p>\n<p>The downside of this approach is that if the program is run several times in quick succession, the seeds generated for each run won&#8217;t be that different, which can impact the quality of the random results from a statistical standpoint.  For normal programs, this doesn&#8217;t matter, but for programs that require high quality, independent results, this method of seeding may be insufficient.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p><code>std::chrono::high_resolution_clock<\/code> is a popular choice instead of <code>std::chrono::steady_clock<\/code>.  <code>std::chrono::high_resolution_clock<\/code> is the clock that uses the most granular unit of time, but it may use the system clock for the current time, which can be changed or rolled back by users.  <code>std::chrono::steady_clock<\/code> may have a less granular tick time, but is the only clock with a guarantee that users cannot adjust it.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Seeding with the random device<\/p>\n<p>The random library contains a type called <code>std::random_device<\/code> that is an implementation-defined PRNG.  Normally we avoid implementation-defined capabilities because they have no guarantees about quality or portability, but this is one of the exception cases.  Typically <code>std::random_device<\/code> will ask the OS for a pseudo-random number (how it does this depends on the OS).<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;random&gt; \/\/ for std::mt19937 and std::random_device\r\n\r\nint main()\r\n{\r\n\tstd::mt19937 mt{ std::random_device{}() };\r\n\r\n\t\/\/ Create a reusable random number generator that generates uniform numbers between 1 and 6\r\n\tstd::uniform_int_distribution die6{ 1, 6 }; \/\/ for C++14, use std::uniform_int_distribution&lt;&gt; die6{ 1, 6 };\r\n\r\n\t\/\/ Print a bunch of random numbers\r\n\tfor (int count{ 1 }; count &lt;= 40; ++count)\r\n\t{\r\n\t\tstd::cout &lt;&lt; die6(mt) &lt;&lt; '\\t'; \/\/ generate a roll of the die here\r\n\r\n\t\t\/\/ If we've printed 10 numbers, start a new row\r\n\t\tif (count % 10 == 0)\r\n\t\t\tstd::cout &lt;&lt; '\\n';\r\n\t}\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In the above program, we&#8217;re seeding our Mersenne Twister with one random number generated from a temporary instance of <code>std::random_device<\/code>.  If you run this program multiple times, it should also produce different results each time.<\/p>\n<p>One potential problem with <code>std::random_device<\/code>: it isn&#8217;t required to be non-deterministic, meaning it <em>could<\/em>, on some systems, produce the same sequence every time the program is run, which is exactly what we&#8217;re trying to avoid.  There was a <a href=\"https:\/\/gcc.gnu.org\/bugzilla\/show_bug.cgi?id=85494\">bug in MinGW<\/a> (fixed in GCC 9.2) that would do exactly this, making <code>std::random_device<\/code> useless.<\/p>\n<p>However, the latest versions of the most popular compilers (GCC\/MinGW, Clang, Visual Studio) support proper implementations of <code>std::random_device<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Use <code>std::random_device<\/code> to seed your PRNGs (unless it&#8217;s not implemented properly for your target compiler\/architecture).\n<\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Q: What does <code>std::random_device{}()<\/code> mean?<\/p>\n<p><code>std::random_device{}<\/code> creates a value-initialized temporary object of type <code>std::random_device<\/code>.  The <code>()<\/code> then calls <code>operator()<\/code> on that temporary object, which returns a randomized value (which we use as an initializer for our Mersenne Twister)<\/p>\n<p>It&#8217;s the equivalent of the calling the following function, which uses a syntax you should be more familiar with:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">unsigned int getRandomDeviceValue()\r\n{\r\n   std::random_device rd{}; \/\/ create a value initialized std::random_device object\r\n   return rd(); \/\/ return the result of operator() to the caller\r\n}<\/code><\/pre>\n<p>Using <code>std::random_device{}()<\/code> allows us to get the same result without creating a named function or named variable, so it&#8217;s much more concise.\n<\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Q: If std::random_device is random itself, why don&#8217;t we just use that instead of Mersenne Twister?<\/p>\n<p>Because std::random_device is implementation defined, we can&#8217;t assume much about it.  It may be expensive to access or it may cause our program to pause while waiting for more random numbers to become available.  The pool of numbers that it draws from may also be depleted quickly, which would impact the random results for other applications requesting random numbers via the same method.  For this reason, std::random_device is better used to seed other PRNGs rather than as a PRNG itself.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Only seed a PRNG once<\/p>\n<p>Many PRNGs can be reseeded after the initial seeding.  This essentially re-initializes the state of the random number generator, causing it to generate results starting from the new seed state.  Reseeding should generally be avoided unless you have a specific reason to do so, as it can cause the results to be less random, or not random at all.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Only seed a given pseudo-random number generator once, and do not reseed it.\n<\/p><\/div>\n<p>Here&#8217;s an example of a common mistake that new programmers make:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;random&gt;\r\n\r\nint getCard()\r\n{\r\n    std::mt19937 mt{ std::random_device{}() }; \/\/ this gets created and seeded every time the function is called\r\n    std::uniform_int_distribution card{ 1, 52 };\r\n    return card(mt);\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; getCard() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the <code>getCard()<\/code> function, the random number generator is being created and seeded every time the function is called.  This is inefficient at best, and will likely cause poor random results.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Mersenne Twister and underseeding issues<\/p>\n<p>The internal state of a Mersenne Twister requires 19937 bits (2493 bytes), which is 624 32-bit values or 312 64-bit values.  As a result, <code>std::mt19937<\/code> allocates 624 integers, whereas <code>std::mt19937_64<\/code> allocates 312 integers.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>The integers allocated by <code>std::mt19937<\/code> are defined to be of type <code>std::uint_fast32_t<\/code>, which could be 32-bit or 64-bit integers depending on the architecture.  If <code>std::uint_fast32_t<\/code> resolves to a 64-bit integer, <code>std::mt19937<\/code> will use 624 64-bit integers, making it double the size it needs to be.\n<\/div>\n<p>In the examples above, where we seed our <code>std::mt19937<\/code> from the clock or std::random_device, our seed is only a single integer.  This means we&#8217;re essentially initializing 624 integers using a single integer, which is significantly underseeding the Mersenne Twister PRNG.  The Random library does the best it can to fill in the remaining 623 values with &#8220;random&#8221; data&#8230; but it can&#8217;t work magic.  Underseeded PRNG can generate results that are suboptimal for applications that need the highest quality results.  For example, seeding <code>std::mt19937<\/code> with a single 32-bit value will never generate the number <code>42<\/code> as its first output.<\/p>\n<p>So how do we fix this?  As of C++20, there&#8217;s no easy way.  But we do have some suggestions.<\/p>\n<p>First, let&#8217;s talk about <code>std::seed_seq<\/code> (which stands for &#8220;seed sequence&#8221;).  In the prior lesson, we mentioned that ideally we want our seed data to be as many bits as the state of our PRNG, or our PRNG will be underseeded.  But in many cases (especially when our PRNG has a large state), we won&#8217;t have that many bits of randomized seed data.<\/p>\n<p><code>std::seed_seq<\/code> is a type that was designed to help with this.  We can pass it as many randomized values as we have, and then it will generate as many additional unbiased seed values as needed to initialize a PRNG&#8217;s state.  If you initialize <code>std::seed_seq<\/code> with a single value (e.g. from <code>std::random_device<\/code>) and then initialize a Mersenne Twister with the <code>std::seed_seq<\/code> object, <code>std::seed_seq<\/code> will generate 623 values of additional seed data.  This won&#8217;t add randomness, but it will give us a better mix of 0 and 1 bits.  However, the more random data we can provide <code>std::seed_seq<\/code>, the better job it will do for us.  So the easiest idea is to simply use <code>std::random_device<\/code> to give <code>std::seed_seq<\/code> more data to work with.  If we initialize <code>std::seed_seq<\/code> with 8 values from <code>std::random_device<\/code> instead of 1, then the remaining values generated by <code>std::seed_seq<\/code> should be much better:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;random&gt;\r\n\r\nint main()\r\n{\r\n\tstd::random_device rd{};\r\n\tstd::seed_seq ss{ rd(), rd(), rd(), rd(), rd(), rd(), rd(), rd() }; \/\/ get 8 integers of random numbers from std::random_device for our seed\r\n\tstd::mt19937 mt{ ss }; \/\/ initialize our Mersenne Twister with the std::seed_seq\r\n\r\n\t\/\/ Create a reusable random number generator that generates uniform numbers between 1 and 6\r\n\tstd::uniform_int_distribution die6{ 1, 6 }; \/\/ for C++14, use std::uniform_int_distribution&lt;&gt; die6{ 1, 6 };\r\n\r\n\t\/\/ Print a bunch of random numbers\r\n\tfor (int count{ 1 }; count &lt;= 40; ++count)\r\n\t{\r\n\t\tstd::cout &lt;&lt; die6(mt) &lt;&lt; '\\t'; \/\/ generate a roll of the die here\r\n\r\n\t\t\/\/ If we've printed 10 numbers, start a new row\r\n\t\tif (count % 10 == 0)\r\n\t\t\tstd::cout &lt;&lt; '\\n';\r\n\t}\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This is pretty straightforward so there isn&#8217;t much reason not to do this at a minimum.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Q: Why not give std::seed_seq 624 values from <code>std::random_device<\/code>?<\/p>\n<p>You can, but this is likely to be slow, and risks depleting the pool of random numbers that <code>std::random_device<\/code> uses.\n<\/div>\n<p>You can also use other &#8220;random&#8221; inputs to <code>std::seed_seq<\/code>.  We&#8217;ve already shown you how to get a value from the clock, so you can throw that in easily.  Other things that are sometimes used include the current thread id, the address of particular functions, the user&#8217;s id, the process id, etc&#8230;  Doing that is beyond the scope of this article, but <a href=\"https:\/\/www.pcg-random.org\/posts\/ease-of-use-without-loss-of-power.html\">this article<\/a> has some context and a link to <a href=\"https:\/\/gist.github.com\/imneme\/540829265469e673d045\">randutils.hpp<\/a> that implements this.<\/p>\n<p>An alternate path is to use a different PRNG with a smaller state.  Many good PRNGs use 64 or 128 bits of state, which can easily be initialized using <code>std::seed_seq<\/code> filled with 8 calls to <code>std::random_device<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Warming up a PRNG<\/p>\n<p>When a PRNG is given a poor quality seed (or underseeded), the initial results of the PRNG may not be high quality.  For this reason, some PRNGs benefit from being &#8220;warmed up&#8221;, which is a technique where the first N results generated from the PRNG are discarded.  This allows the internal state of the PRNG to be mixed up such that the subsequent results should be of higher quality.  Typically a few hundred to a few thousand initial results are discarded.  The longer the period of the PRNG, the more initial results should be discarded.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>Visual Studio&#8217;s implementation of <code>rand()<\/code> had (or still has?) a bug where the first generated result would not be sufficiently randomized.  You may see older programs that use <code>rand()<\/code> discard a single result as a way to avoid this issue.\n<\/div>\n<p>The <code>seed_seq<\/code> initialization used by <code>std::mt19937<\/code> performs a warm up, so we don&#8217;t need to explicitly warm up <code>std::mt19937<\/code> objects.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><a name=\"RandomH\"><\/a>Random numbers across multiple functions or files (Random.h) <a href=\"#RandomH\"><i class=\"fa fa-link\" style=\"font-size: 0.8em;\"><\/i><\/a><\/p>\n<p>This content was moved to <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/global-random-numbers-random-h\/\">8.15 -- Global random numbers (Random.h)<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Debugging programs that use random numbers<\/p>\n<p>Programs that use random numbers can be difficult to debug because the program may exhibit different behaviors each time it is run.  When this is the case, the erroneous behavior you may happen, or it may not.  This can waste a lot of time.  When debugging, it&#8217;s helpful to ensure your program executes the same (incorrect) way each time.  That way, you can run the program as many times as needed to isolate where the error is.<\/p>\n<p>For this reason, when debugging, it&#8217;s a useful technique to seed your PRNG with a specific fixed value (e.g. <code>5<\/code>) that causes the erroneous behavior to occur.  If a given seed doesn&#8217;t cause your program to exhibit the error, keep incrementing the seed value until you find one that does.  This will ensure your program generates the same results each time, making debugging easier.  Once you&#8217;ve found the error, you can use your normal seeding method to start generating randomized results again.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Random FAQ<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Q: Help!  My random number generator is generating the same sequence of random numbers.<\/p>\n<p>If your random number generator is generating the same sequence of random numbers every time your program is run, you probably didn&#8217;t seed it properly (or at all).  Make sure you&#8217;re seeding it with a value that changes each time the program is run.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Q: Help!  My random number generator keeps generating the same number over and over.<\/p>\n<p>If your random number generator is generating the same number every time you ask it for a random number, then you are probably either reseeding the random number generator before generating a random number, or you&#8217;re creating a new random generator for each random number.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/global-random-numbers-random-h\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">8.15<\/span>Global random numbers (Random.h)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-random-number-generation\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">8.13<\/span>Introduction to random number generation\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the previous lesson , we introduced the concept of random number generation, and discussed how PRNG algorithms are typically used to simulate randomness in programs. In this lesson, we&#8217;ll take a look at how to generate random numbers in your programs. To access any of the randomization capabilities in &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[12,34,14,35,36,37,38,16],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/218"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=218"}],"version-history":[{"count":137,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/218\/revisions"}],"predecessor-version":[{"id":18157,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/218\/revisions\/18157"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=218"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=218"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=218"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}