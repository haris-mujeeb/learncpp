{"id":2331,"date":"2015-08-15T16:46:51","date_gmt":"2015-08-16T00:46:51","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=2331"},"modified":"2023-10-25T14:50:53","modified_gmt":"2023-10-25T21:50:53","slug":"c-style-string-symbolic-constants","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/c-style-string-symbolic-constants\/","title":{"rendered":"17.11 &#8212; C-style string symbolic constants"},"content":{"rendered":"<p>In the previous lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/c-style-strings\/\">17.10 -- C-style strings<\/a>), we discussed how to create and initialize C-style string objects:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    char name[]{ \"Alex\" }; \/\/ C-style string\r\n    std::cout &lt;&lt; name &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>C++ supports two different ways to create C-style string symbolic constants:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    const char name[] { \"Alex\" };        \/\/ case 1: const C-style string initialized with C-style string literal\r\n    const char* const color{ \"Orange\" }; \/\/ case 2: const pointer to C-style string literal\r\n\r\n    std::cout &lt;&lt; name &lt;&lt; ' ' &lt;&lt; color &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nAlex Orange\r\n<\/pre>\n<p>While the above two methods produce the same results, C++ deals with the memory allocation for these slightly differently.<\/p>\n<p>In case 1, &#8220;Alex&#8221; is put into (probably read-only) memory somewhere.  Then the program allocates memory for a C-style array of length 5 (four explicit characters plus the null terminator), and initializes that memory with the string &#8220;Alex&#8221;.  So we end up with 2 copies of &#8220;Alex&#8221; -- one in global memory somewhere, and the other owned by <code>name<\/code>.  Since <code>name<\/code> is const (and will never be modified), making a copy is inefficient.<\/p>\n<p>In case 2, how the compiler handles this is implementation defined.  What <em>usually<\/em> happens is that the compiler places the string &#8220;Orange&#8221; into read-only memory somewhere, and then initializes the pointer with the address of the string.<\/p>\n<p>For optimization purposes, multiple string literals may be consolidated into a single value.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">const char* name1{ \"Alex\" };\r\nconst char* name2{ \"Alex\" };<\/code><\/pre>\n<p>These are two different string literals with the same value. Because these literals are constants, the compiler may opt to save memory by combining these into a single shared string literal, with both <code>name1<\/code> and <code>name2<\/code> pointed at the same address.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Type deduction with const C-style strings<\/p>\n<p>Type deduction using a C-style string literal is fairly straightforward:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    auto s1{ \"Alex\" };  \/\/ type deduced as const char*\r\n    auto* s2{ \"Alex\" }; \/\/ type deduced as const char*\r\n    auto&amp; s3{ \"Alex\" }; \/\/ type deduced as const char(&amp;)[5]<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Outputting pointers and C-style strings<\/p>\n<p>You may have noticed something interesting about the way <code>std::cout<\/code> handles pointers of different types.<\/p>\n<p>Consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int narr[]{ 9, 7, 5, 3, 1 };\r\n    char carr[]{ \"Hello!\" };\r\n    const char* ptr{ \"Alex\" };\r\n\r\n    std::cout &lt;&lt; narr &lt;&lt; '\\n'; \/\/ narr will decay to type int*\r\n    std::cout &lt;&lt; carr &lt;&lt; '\\n'; \/\/ carr will decay to type char*\r\n    std::cout &lt;&lt; ptr &lt;&lt; '\\n'; \/\/ name is already type char*\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>On the author&#8217;s machine, this printed:<\/p>\n<pre>\n003AF738\r\nHello!\r\nAlex\r\n<\/pre>\n<p>Why did the int array print an address, but the character arrays print as strings?<\/p>\n<p>The answer is that the output streams (e.g. <code>std::cout<\/code>) make some assumptions about your intent.  If you pass it a non-char pointer, it will simply print the contents of that pointer (the address that the pointer is holding).  However, if you pass it an object of type <code>char*<\/code> or <code>const char*<\/code>, it will assume you&#8217;re intending to print a string.  Consequently, instead of printing the pointer&#8217;s value (an address), it will print the string being pointed to instead!<\/p>\n<p>While this is desired most of the time, it can lead to unexpected results.  Consider the following case:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    char c{ 'Q' };\r\n    std::cout &lt;&lt; &amp;c;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this case, the programmer is intending to print the address of variable <code>c<\/code>.  However, <code>&amp;c<\/code> has type <code>char*<\/code>, so <code>std::cout<\/code> tries to print this as a string!  And because <code>c<\/code> is not null-terminated, we get undefined behavior.<\/p>\n<p>On the author&#8217;s machine, this printed:<\/p>\n<pre>\nQ\u2560\u2560\u2560\u2560\u255c\u25614;\u00bf\u25a0A\r\n<\/pre>\n<p>Why did it do this?  Well, first it assumed <code>&amp;c<\/code> (which has type <code>char*<\/code>) was a C-style string.  So it printed the &#8216;Q&#8217;, and then kept going.  Next in memory was a bunch of garbage.  Eventually, it ran into some memory holding a <code>0<\/code> value, which it interpreted as a null terminator, so it stopped.  What you see may be different depending on what&#8217;s in memory after variable <code>c<\/code>.<\/p>\n<p>This case is somewhat unlikely to occur in real-life (as you&#8217;re not likely to actually want to print memory addresses), but it is illustrative of how things work under the hood, and how programs can inadvertently go off the rails.<\/p>\n<p>If you actually want to print the address of a char pointer, static_cast it to type <code>const void*<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    const char* ptr{ \"Alex\" };\r\n\r\n    std::cout &lt;&lt; ptr &lt;&lt; '\\n';                           \/\/ print ptr as C-style string\r\n    std::cout &lt;&lt; static_cast&lt;const void*&gt;(ptr) &lt;&lt; '\\n'; \/\/ print address held by ptr\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover <code>void*<\/code> in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/void-pointers\/\">19.5 -- Void pointers<\/a>.  You don&#8217;t need to know how it works to use it here.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Favor std::string_view for C-style string symbolic constants<\/p>\n<p>There is little reason to use C-style string symbolic constants in modern C++.  Instead, favor <code>constexpr std::string_view<\/code> objects, which tend to be just as fast (if not faster) and behave more consistently.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Avoid C-style string symbolic constants in favor of <code>constexpr std::string_view<\/code>.\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/multidimensional-c-style-arrays\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.12<\/span>Multidimensional C-style Arrays\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/c-style-strings\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.10<\/span>C-style strings\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the previous lesson (), we discussed how to create and initialize C-style string objects: #include &lt;iostream&gt; int main() { char name[]{ &#8220;Alex&#8221; }; \/\/ C-style string std::cout &lt;&lt; name &lt;&lt; &#8216;\\n&#8217;; return 0; } C++ supports two different ways to create C-style string symbolic constants: #include &lt;iostream&gt; int main() &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/2331"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=2331"}],"version-history":[{"count":41,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/2331\/revisions"}],"predecessor-version":[{"id":16000,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/2331\/revisions\/16000"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=2331"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=2331"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=2331"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}