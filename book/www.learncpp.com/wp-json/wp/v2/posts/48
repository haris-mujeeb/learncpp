{"id":48,"date":"2007-06-09T19:07:05","date_gmt":"2007-06-10T03:07:05","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=48"},"modified":"2025-03-19T09:53:22","modified_gmt":"2025-03-19T16:53:22","slug":"chars","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/chars\/","title":{"rendered":"4.11 &#8212; Chars"},"content":{"rendered":"<p>To this point, the fundamental data types we&#8217;ve looked at have been used to hold numbers (integers and floating points) or true\/false values (Booleans).  But what if we want to store letters or punctuation?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Would you like a burrito? (y\/n)\";\r\n\r\n    \/\/ We want the user to enter a 'y' or 'n' character\r\n    \/\/ How do we do this?\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The <strong>char<\/strong> data type was designed to hold a single <code>character<\/code>.  A <strong>character<\/strong> can be a single letter, number, symbol, or whitespace.<\/p>\n<p>The char data type is an integral type, meaning the underlying value is stored as an integer.  Similar to how a Boolean value <code>0<\/code> is interpreted as <code>false<\/code> and non-zero is interpreted as <code>true<\/code>, the integer stored by a <code>char<\/code> variable are intepreted as an <code>ASCII character<\/code>.<\/p>\n<p><strong>ASCII<\/strong> stands for American Standard Code for Information Interchange, and it defines a particular way to represent English characters (plus a few other symbols) as numbers between 0 and 127 (called an <strong>ASCII code<\/strong> or <strong>code point<\/strong>).  For example, ASCII code 97 is interpreted as the character &#8216;a&#8217;.<\/p>\n<p>Character literals are always placed between single quotes (e.g. &#8216;g&#8217;, &#8216;1&#8217;, &#8216; &#8216;).<\/p>\n<p style=\"clear: both\">Here\u2019s a full table of ASCII characters:<\/p>\n<p> <!-- break around image --><\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<th>Code<\/th>\n<th>Symbol<\/th>\n<th>Code<\/th>\n<th>Symbol<\/th>\n<th>Code<\/th>\n<th>Symbol<\/th>\n<th>Code<\/th>\n<th>Symbol<\/th>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">0<\/td>\n<td>NUL (null)<\/td>\n<td style=\"background-color:#CCCCCC;\">32<\/td>\n<td>(space)<\/td>\n<td style=\"background-color:#CCCCCC;\">64<\/td>\n<td>@<\/td>\n<td style=\"background-color:#CCCCCC;\">96<\/td>\n<td>&#96;<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\"\">1<\/td>\n<td>SOH (start of header)<\/td>\n<td style=\"background-color:#CCCCCC;\">33<\/td>\n<td>!<\/td>\n<td style=\"background-color:#CCCCCC;\">65<\/td>\n<td>A<\/td>\n<td style=\"background-color:#CCCCCC;\">97<\/td>\n<td>a<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">2<\/td>\n<td>STX (start of text)<\/td>\n<td style=\"background-color:#CCCCCC;\">34<\/td>\n<td>\u201d<\/td>\n<td style=\"background-color:#CCCCCC;\">66<\/td>\n<td>B<\/td>\n<td style=\"background-color:#CCCCCC;\">98<\/td>\n<td>b<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">3<\/td>\n<td>ETX (end of text)<\/td>\n<td style=\"background-color:#CCCCCC;\">35<\/td>\n<td>#<\/td>\n<td style=\"background-color:#CCCCCC;\">67<\/td>\n<td>C<\/td>\n<td style=\"background-color:#CCCCCC;\">99<\/td>\n<td>c<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">4<\/td>\n<td>EOT (end of transmission)<\/td>\n<td style=\"background-color:#CCCCCC;\">36<\/td>\n<td>$<\/td>\n<td style=\"background-color:#CCCCCC;\">68<\/td>\n<td>D<\/td>\n<td style=\"background-color:#CCCCCC;\">100<\/td>\n<td>d<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">5<\/td>\n<td>ENQ (enquiry)<\/td>\n<td style=\"background-color:#CCCCCC;\">37<\/td>\n<td>%<\/td>\n<td style=\"background-color:#CCCCCC;\">69<\/td>\n<td>E<\/td>\n<td style=\"background-color:#CCCCCC;\">101<\/td>\n<td>e<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">6<\/td>\n<td>ACK (acknowledge)<\/td>\n<td style=\"background-color:#CCCCCC;\">38<\/td>\n<td>&#038;<\/td>\n<td style=\"background-color:#CCCCCC;\">70<\/td>\n<td>F<\/td>\n<td style=\"background-color:#CCCCCC;\">102<\/td>\n<td>f<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">7<\/td>\n<td>BEL (bell)<\/td>\n<td style=\"background-color:#CCCCCC;\">39<\/td>\n<td>\u2019<\/td>\n<td style=\"background-color:#CCCCCC;\">71<\/td>\n<td>G<\/td>\n<td style=\"background-color:#CCCCCC;\">103<\/td>\n<td>g<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">8<\/td>\n<td>BS (backspace)<\/td>\n<td style=\"background-color:#CCCCCC;\">40<\/td>\n<td>(<\/td>\n<td style=\"background-color:#CCCCCC;\">72<\/td>\n<td>H<\/td>\n<td style=\"background-color:#CCCCCC;\">104<\/td>\n<td>h<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">9<\/td>\n<td>HT (horizontal tab)<\/td>\n<td style=\"background-color:#CCCCCC;\">41<\/td>\n<td>)<\/td>\n<td style=\"background-color:#CCCCCC;\">73<\/td>\n<td>I<\/td>\n<td style=\"background-color:#CCCCCC;\">105<\/td>\n<td>i<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">10<\/td>\n<td>LF (line feed\/new line)<\/td>\n<td style=\"background-color:#CCCCCC;\">42<\/td>\n<td>*<\/td>\n<td style=\"background-color:#CCCCCC;\">74<\/td>\n<td>J<\/td>\n<td style=\"background-color:#CCCCCC;\">106<\/td>\n<td>j<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">11<\/td>\n<td>VT (vertical tab)<\/td>\n<td style=\"background-color:#CCCCCC;\">43<\/td>\n<td>+<\/td>\n<td style=\"background-color:#CCCCCC;\">75<\/td>\n<td>K<\/td>\n<td style=\"background-color:#CCCCCC;\">107<\/td>\n<td>k<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">12<\/td>\n<td>FF (form feed \/ new page)<\/td>\n<td style=\"background-color:#CCCCCC;\">44<\/td>\n<td>,<\/td>\n<td style=\"background-color:#CCCCCC;\">76<\/td>\n<td>L<\/td>\n<td style=\"background-color:#CCCCCC;\">108<\/td>\n<td>l<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">13<\/td>\n<td>CR (carriage return)<\/td>\n<td style=\"background-color:#CCCCCC;\">45<\/td>\n<td>-<\/td>\n<td style=\"background-color:#CCCCCC;\">77<\/td>\n<td>M<\/td>\n<td style=\"background-color:#CCCCCC;\">109<\/td>\n<td>m<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">14<\/td>\n<td>SO (shift out)<\/td>\n<td style=\"background-color:#CCCCCC;\">46<\/td>\n<td>.<\/td>\n<td style=\"background-color:#CCCCCC;\">78<\/td>\n<td>N<\/td>\n<td style=\"background-color:#CCCCCC;\">110<\/td>\n<td>n<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">15<\/td>\n<td>SI (shift in)<\/td>\n<td style=\"background-color:#CCCCCC;\">47<\/td>\n<td>\/<\/td>\n<td style=\"background-color:#CCCCCC;\">79<\/td>\n<td>O<\/td>\n<td style=\"background-color:#CCCCCC;\">111<\/td>\n<td>o<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">16<\/td>\n<td>DLE (data link escape)<\/td>\n<td style=\"background-color:#CCCCCC;\">48<\/td>\n<td>0<\/td>\n<td style=\"background-color:#CCCCCC;\">80<\/td>\n<td>P<\/td>\n<td style=\"background-color:#CCCCCC;\">112<\/td>\n<td>p<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">17<\/td>\n<td>DC1 (data control 1)<\/td>\n<td style=\"background-color:#CCCCCC;\">49<\/td>\n<td>1<\/td>\n<td style=\"background-color:#CCCCCC;\">81<\/td>\n<td>Q<\/td>\n<td style=\"background-color:#CCCCCC;\">113<\/td>\n<td>q<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">18<\/td>\n<td>DC2 (data control 2)<\/td>\n<td style=\"background-color:#CCCCCC;\">50<\/td>\n<td>2<\/td>\n<td style=\"background-color:#CCCCCC;\">82<\/td>\n<td>R<\/td>\n<td style=\"background-color:#CCCCCC;\">114<\/td>\n<td>r<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">19<\/td>\n<td>DC3 (data control 3)<\/td>\n<td style=\"background-color:#CCCCCC;\">51<\/td>\n<td>3<\/td>\n<td style=\"background-color:#CCCCCC;\">83<\/td>\n<td>S<\/td>\n<td style=\"background-color:#CCCCCC;\">115<\/td>\n<td>s<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">20<\/td>\n<td>DC4 (data control 4)<\/td>\n<td style=\"background-color:#CCCCCC;\">52<\/td>\n<td>4<\/td>\n<td style=\"background-color:#CCCCCC;\">84<\/td>\n<td>T<\/td>\n<td style=\"background-color:#CCCCCC;\">116<\/td>\n<td>t<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">21<\/td>\n<td>NAK (negative acknowledge)<\/td>\n<td style=\"background-color:#CCCCCC;\">53<\/td>\n<td>5<\/td>\n<td style=\"background-color:#CCCCCC;\">85<\/td>\n<td>U<\/td>\n<td style=\"background-color:#CCCCCC;\">117<\/td>\n<td>u<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">22<\/td>\n<td>SYN (synchronous idle)<\/td>\n<td style=\"background-color:#CCCCCC;\">54<\/td>\n<td>6<\/td>\n<td style=\"background-color:#CCCCCC;\">86<\/td>\n<td>V<\/td>\n<td style=\"background-color:#CCCCCC;\">118<\/td>\n<td>v<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">23<\/td>\n<td>ETB (end of transmission block)<\/td>\n<td style=\"background-color:#CCCCCC;\">55<\/td>\n<td>7<\/td>\n<td style=\"background-color:#CCCCCC;\">87<\/td>\n<td>W<\/td>\n<td style=\"background-color:#CCCCCC;\">119<\/td>\n<td>w<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">24<\/td>\n<td>CAN (cancel)<\/td>\n<td style=\"background-color:#CCCCCC;\">56<\/td>\n<td>8<\/td>\n<td style=\"background-color:#CCCCCC;\">88<\/td>\n<td>X<\/td>\n<td style=\"background-color:#CCCCCC;\">120<\/td>\n<td>x<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">25<\/td>\n<td>EM (end of medium)<\/td>\n<td style=\"background-color:#CCCCCC;\">57<\/td>\n<td>9<\/td>\n<td style=\"background-color:#CCCCCC;\">89<\/td>\n<td>Y<\/td>\n<td style=\"background-color:#CCCCCC;\">121<\/td>\n<td>y<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">26<\/td>\n<td>SUB (substitute)<\/td>\n<td style=\"background-color:#CCCCCC;\">58<\/td>\n<td>:<\/td>\n<td style=\"background-color:#CCCCCC;\">90<\/td>\n<td>Z<\/td>\n<td style=\"background-color:#CCCCCC;\">122<\/td>\n<td>z<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">27<\/td>\n<td>ESC (escape)<\/td>\n<td style=\"background-color:#CCCCCC;\">59<\/td>\n<td>;<\/td>\n<td style=\"background-color:#CCCCCC;\">91<\/td>\n<td>[<\/td>\n<td style=\"background-color:#CCCCCC;\">123<\/td>\n<td>{<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">28<\/td>\n<td>FS (file separator)<\/td>\n<td style=\"background-color:#CCCCCC;\">60<\/td>\n<td>&lt;<\/td>\n<td style=\"background-color:#CCCCCC;\">92<\/td>\n<td>\\ <\/td>\n<td style=\"background-color:#CCCCCC;\">124<\/td>\n<td>|<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">29<\/td>\n<td>GS (group separator)<\/td>\n<td style=\"background-color:#CCCCCC;\">61<\/td>\n<td>=<\/td>\n<td style=\"background-color:#CCCCCC;\">93<\/td>\n<td>]<\/td>\n<td style=\"background-color:#CCCCCC;\">125<\/td>\n<td>}<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">30<\/td>\n<td>RS (record separator)<\/td>\n<td style=\"background-color:#CCCCCC;\">62<\/td>\n<td>&gt;<\/td>\n<td style=\"background-color:#CCCCCC;\">94<\/td>\n<td>^<\/td>\n<td style=\"background-color:#CCCCCC;\">126<\/td>\n<td>~<\/td>\n<\/tr>\n<tr>\n<td style=\"background-color:#CCCCCC;\">31<\/td>\n<td>US (unit separator)<\/td>\n<td style=\"background-color:#CCCCCC;\">63<\/td>\n<td>?<\/td>\n<td style=\"background-color:#CCCCCC;\">95<\/td>\n<td>_<\/td>\n<td style=\"background-color:#CCCCCC;\">127<\/td>\n<td>DEL (delete)<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>Codes 0-31 and 127 are called the unprintable chars.  These codes were designed to control peripheral devices such as printers (e.g. by instructing the printer how to move the print head).  Most of these are obsolete now.  If you try to print these chars, the results are dependent upon your OS (you may get some emoji-like characters).<\/p>\n<p>Codes 32-126 are called the printable characters, and they represent the letters, number characters, and punctuation that most computers use to display basic English text.<\/p>\n<p>If you try to print a character whose value is outside the range of ASCII, the results are also dependent upon your OS.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Initializing chars<\/p>\n<p>You can initialize char variables using character literals:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">char ch2{ 'a' }; \/\/ initialize with code point for 'a' (stored as integer 97) (preferred)<\/code><\/pre>\n<p>You can initialize chars with integers as well, but this should be avoided if possible<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">char ch1{ 97 }; \/\/ initialize with integer 97 ('a') (not preferred)<\/code><\/pre>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Be careful not to mix up character numbers with integer numbers.  The following two initializations are not the same:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">char ch{5}; \/\/ initialize with integer 5 (stored as integer 5)\r\nchar ch{'5'}; \/\/ initialize with code point for '5' (stored as integer 53)<\/code><\/pre>\n<p>Character numbers are intended to be used when we want to represent numbers as text, rather than as numbers to apply mathematical operations to.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Printing chars<\/p>\n<p>When using std::cout to print a char, std::cout outputs the char variable as an ASCII character:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    char ch1{ 'a' }; \/\/ (preferred)\r\n    std::cout &lt;&lt; ch1; \/\/ cout prints character 'a'\r\n\r\n    char ch2{ 98 }; \/\/ code point for 'b' (not preferred)\r\n    std::cout &lt;&lt; ch2; \/\/ cout prints a character ('b')\r\n\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This produces the result:<\/p>\n<pre>\r\nab\r\n<\/pre>\n<p>We can also output char literals directly:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::cout &lt;&lt; 'c';<\/code><\/pre>\n<p>This produces the result:<\/p>\n<pre>\r\nc\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Inputting chars<\/p>\n<p>The following program asks the user to input a character, then prints out the character:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Input a keyboard character: \";\r\n\r\n    char ch{};\r\n    std::cin &gt;&gt; ch;\r\n    std::cout &lt;&lt; \"You entered: \" &lt;&lt; ch &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Here&#8217;s the output from one run:<\/p>\n<pre>\r\nInput a keyboard character: q\r\nYou entered: q\r\n<\/pre>\n<p>Note that std::cin will let you enter multiple characters.  However, variable <em>ch<\/em> can only hold 1 character.  Consequently, only the first input character is extracted into variable <em>ch<\/em>.  The rest of the user input is left in the input buffer that std::cin uses, and can be extracted with subsequent calls to std::cin.<\/p>\n<p>You can see this behavior in the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Input a keyboard character: \"; \/\/ assume the user enters \"abcd\" (without quotes)\r\n\r\n    char ch{};\r\n    std::cin &gt;&gt; ch; \/\/ ch = 'a', \"bcd\" is left queued.\r\n    std::cout &lt;&lt; \"You entered: \" &lt;&lt; ch &lt;&lt; '\\n';\r\n\r\n    \/\/ Note: The following cin doesn't ask the user for input, it grabs queued input!\r\n    std::cin &gt;&gt; ch; \/\/ ch = 'b', \"cd\" is left queued.\r\n    std::cout &lt;&lt; \"You entered: \" &lt;&lt; ch &lt;&lt; '\\n';\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<pre>\nInput a keyboard character: abcd\r\nYou entered: a\r\nYou entered: b\r\n<\/pre>\n<p>If you want to read in more than one char at a time (e.g. to read in a name, word, or sentence), you&#8217;ll want to use a string instead of a char.  A string is a collection of sequential characters (and thus, a string can hold multiple symbols).  We discuss this in upcoming lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdstring\/\">5.7 -- Introduction to std::string<\/a>).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Extracting whitespace characters<\/p>\n<p>Because extracting input ignores leading whitespace, this can lead to unexpected results when trying to extract whitespace characters to a char variable:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Input a keyboard character: \"; \/\/ assume the user enters \"a b\" (without quotes)\r\n\r\n    char ch{};\r\n    std::cin &gt;&gt; ch; \/\/ extracts a, leaves \" b\\n\" in stream\r\n    std::cout &lt;&lt; \"You entered: \" &lt;&lt; ch &lt;&lt; '\\n';\r\n\r\n    std::cin &gt;&gt; ch; \/\/ skips leading whitespace (the space), extracts b, leaves \"\\n\" in stream\r\n    std::cout &lt;&lt; \"You entered: \" &lt;&lt; ch &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<pre>\nInput a keyboard character: a b\r\nYou entered: a\r\nYou entered: b\r\n<\/pre>\n<p>In the above example, we may have expected to extract the space, but because leading whitespace is skipped, we extracted the <code>b<\/code> character instead.<\/p>\n<p>One simple way to address this is to use the <code>std::cin.get()<\/code> function to perform the extraction instead, as this function does not ignore leading whitespace:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Input a keyboard character: \"; \/\/ assume the user enters \"a b\" (without quotes)\r\n\r\n    char ch{};\r\n    std::cin.get(ch); \/\/ extracts a, leaves \" b\\n\" in stream\r\n    std::cout &lt;&lt; \"You entered: \" &lt;&lt; ch &lt;&lt; '\\n';\r\n\r\n    std::cin.get(ch); \/\/ extracts space, leaves \"b\\n\" in stream\r\n    std::cout &lt;&lt; \"You entered: \" &lt;&lt; ch &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<pre>\nInput a keyboard character: a b\r\nYou entered: a\r\nYou entered:  \r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Char size, range, and default sign<\/p>\n<p>Char is defined by C++ to always be 1 byte in size.  By default, a char may be signed or unsigned (though it&#8217;s usually signed).  If you&#8217;re using chars to hold ASCII characters, you don&#8217;t need to specify a sign (since both signed and unsigned chars can hold values between 0 and 127).<\/p>\n<p>If you&#8217;re using a char to hold small integers (something you should not do unless you&#8217;re explicitly optimizing for space), you should always specify whether it is signed or unsigned. A signed char can hold a number between -128 and 127.  An unsigned char can hold a number between 0 and 255.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Escape sequences<\/p>\n<p>There are some sequences of characters in C++ that have special meaning.  These characters are called <strong>escape sequences<\/strong>.  An escape sequence starts with a &#8216;\\&#8217; (backslash) character, and then a following letter or number.<\/p>\n<p>You&#8217;ve already seen the most common escape sequence: <code>'\\n'<\/code>, which can be used to print a newline:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 5 };\r\n    std::cout &lt;&lt; \"The value of x is: \" &lt;&lt; x &lt;&lt; '\\n'; \/\/ standalone \\n goes in single quotes\r\n    std::cout &lt;&lt; \"First line\\nSecond line\\n\";        \/\/ \\n can be embedded in double quotes\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This outputs:<\/p>\n<pre>\r\nThe value of x is: 5\r\nFirst line\r\nSecond line\r\n<\/pre>\n<p>Another commonly used escape sequence is <code>'\\t'<\/code>, which embeds a horizontal tab:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"First part\\tSecond part\";\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Which outputs:<\/p>\n<pre>\r\nFirst part\tSecond part\r\n<\/pre>\n<p>Three other notable escape sequences are:<br \/>\n\\&#8217; prints a single quote<br \/>\n\\&#8221; prints a double quote<br \/>\n\\\\ prints a backslash<\/p>\n<p>Here&#8217;s a table of all of the escape sequences:<\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<th>Name<\/th>\n<th>Symbol<\/th>\n<th>Meaning<\/th>\n<\/tr>\n<tr>\n<td>Alert<\/td>\n<td>\\a<\/td>\n<td>Makes an alert, such as a beep<\/td>\n<\/tr>\n<tr>\n<td>Backspace<\/td>\n<td>\\b<\/td>\n<td>Moves the cursor back one space<\/td>\n<\/tr>\n<tr>\n<td>Formfeed<\/td>\n<td>\\f<\/td>\n<td>Moves the cursor to next logical page<\/td>\n<\/tr>\n<tr>\n<td>Newline<\/td>\n<td>\\n<\/td>\n<td>Moves cursor to next line<\/td>\n<\/tr>\n<tr>\n<td>Carriage return<\/td>\n<td>\\r<\/td>\n<td>Moves cursor to beginning of line<\/td>\n<\/tr>\n<tr>\n<td>Horizontal tab<\/td>\n<td>\\t<\/td>\n<td>Prints a horizontal tab<\/td>\n<\/tr>\n<tr>\n<td>Vertical tab<\/td>\n<td>\\v<\/td>\n<td>Prints a vertical tab<\/td>\n<\/tr>\n<tr>\n<td>Single quote<\/td>\n<td>\\&#8217;<\/td>\n<td>Prints a single quote<\/td>\n<\/tr>\n<tr>\n<td>Double quote<\/td>\n<td>\\&#8221;<\/td>\n<td>Prints a double quote<\/td>\n<\/tr>\n<tr>\n<td>Backslash<\/td>\n<td>\\\\ <\/td>\n<td>Prints a backslash.<\/td>\n<\/tr>\n<tr>\n<td>Question mark<\/td>\n<td>\\?<\/td>\n<td>Prints a question mark.<br \/>No longer relevant. You can use question marks unescaped.<\/td>\n<\/tr>\n<tr>\n<td>Octal number<\/td>\n<td>\\(number)<\/td>\n<td>Translates into char represented by octal <\/p>\n<tr>\n<td>Hex number<\/td>\n<td>\\x(number)<\/td>\n<td>Translates into char represented by hex number<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>Here are some examples:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"\\\"This is quoted text\\\"\\n\";\r\n    std::cout &lt;&lt; \"This string contains a single backslash \\\\\\n\";\r\n    std::cout &lt;&lt; \"6F in hex is char '\\x6F'\\n\";\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Prints:<\/p>\n<pre>\r\n\"This is quoted text\"\r\nThis string contains a single backslash \\\r\n6F in hex is char 'o'\r\n<\/pre>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Escape sequences start with a backslash (\\), not a forward slash (\/).  If you use a forward slash by accident, it may still compile, but will not yield the desired result.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Newline (\\n) vs. std::endl<\/p>\n<p>We cover this topic in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-iostream-cout-cin-and-endl\/\">1.5 -- Introduction to iostream: cout, cin, and endl<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">What&#8217;s the difference between putting symbols in single and double quotes?<\/p>\n<p>Text between single quotes is treated as a <code>char<\/code> literal, which represents a single character.  For example, <code>'a'<\/code> represents the character <code>a<\/code>, <code>'+'<\/code> represents the character for the plus symbol, <code>'5'<\/code> represents the character <code>5<\/code> (not the number 5), and  <code>'\\n'<\/code> represents the newline character.<\/p>\n<p>Text between double quotes (e.g. &#8220;Hello, world!&#8221;) is treated as a C-style string literal, which can contain multiple characters.  We discuss strings in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/literals\/\">5.2 -- Literals<\/a>.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Single characters should usually be single-quoted, not double-quoted (e.g. <code>'t'<\/code> or <code>'\\n'<\/code>, not <code>\"t\"<\/code> or <code>\"\\n\"<\/code>).  One possible exception occurs when doing output, where it can be preferential to double quote everything for consistency (see lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-iostream-cout-cin-and-endl\/\">1.5 -- Introduction to iostream: cout, cin, and endl<\/a>).\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Avoid multicharacter literals<\/p>\n<p>For backwards compatibility reasons, many C++ compilers support <strong>multicharacter literals<\/strong>, which are char literals that contain multiple characters (e.g. <code>'56'<\/code>).  If supported, these have an implementation-defined value (meaning it varies depending on the compiler).  Because they are not part of the C++ standard, and their value is not strictly defined, multicharacter literals should be avoided.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Avoid multicharacter literals (e.g. <code>'56'<\/code>).\n<\/div>\n<p>Multicharacter literal support often causes problems for new programmers when the forget whether escape sequences use forward slashes or backslashes:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y)\r\n{\r\n\treturn x + y;\r\n}\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; add(1, 2) &lt;&lt; '\/n'; \/\/ we used a forward slash instead of a backslash here\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>The programmer expects this program to print the value <code>3<\/code> and a newline.  But instead, on the author&#8217;s machine, it outputs the following:<\/p>\n<pre>\n312142\r\n<\/pre>\n<p>The issue here is that the programmer accidentally used <code>'\/n'<\/code> (a multicharacter literal consisting of a forward slash and an <code>'n'<\/code> character) instead of <code>'\\n'<\/code> (the escape sequence for a newline).  The program first prints <code>3<\/code> (the result of <code>add(1, 2)<\/code>) correctly.  But then it prints the value of multicharacter literal <code>'\/n'<\/code>, which on the author&#8217;s machine had the implementation-defined value <code>12142<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Make sure that your newlines are using escape sequence <code>'\\n'<\/code> , not multicharacter literal <code>'\/n'<\/code>.\n<\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Note that if we&#8217;d double-quoted the output <code>\"\/n\"<\/code>, the program would have printed <code>3\/n<\/code>, which is still wrong, but much less confusing.\n<\/div>\n<p>Here&#8217;s another example.  Let&#8217;s start with the following:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 5 };\r\n    std::cout &lt;&lt; \"The value of x is \" &lt;&lt; x &lt;&lt; '\\n'; \r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program outputs exactly as you expect:<\/p>\n<pre>\nThe value of x is 5\r\n<\/pre>\n<p>But this output isn&#8217;t nearly exciting enough, so we decide to add an exclamation point before the newline:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 5 };\r\n    std::cout &lt;&lt; \"The value of x is \" &lt;&lt; x &lt;&lt; '!\\n'; \/\/ added exclamation point\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>While we expect this to output the following:<\/p>\n<pre>\nThe value of x is 5!\r\n<\/pre>\n<p>Because <code>'!\\n'<\/code> is a multicharacter literal, on the author&#8217;s machine, this actually printed:<\/p>\n<pre>\nThe value of x is 58458\r\n<\/pre>\n<p>This is not only incorrect, it can be hard to debug because you are likely to assume that <code>x<\/code> has the wrong value.<\/p>\n<p>Using double quotes when outputting character literals (instead of single quotes) either makes these kind of issues easier to discover or avoids them entirely.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">What about the other char types, <code>wchar_t<\/code>, <code>char8_t<\/code>, <code>char16_t<\/code>, and <code>char32_t<\/code>?<\/p>\n<p>Much like ASCII maps the integers 0-127 to American English characters, other character encoding standards exist to map integers (of varying sizes) to characters in other languages.  The most well-known mapping outside of ASCII is the Unicode standard, which maps over 144,000 integers to characters in many different languages.  Because Unicode contains so many code points, a single Unicode code point needs 32-bits to represent a character (called UTF-32).  However, Unicode characters can also be encoded using multiple 16-bit or 8-bit characters (called UTF-16 and UTF-8 respectively).<\/p>\n<p><code>char16_t<\/code> and <code>char32_t<\/code> were added to C++11 to provide explicit support for 16-bit and 32-bit Unicode characters.    These char types have the same size as <code>std::uint_least16_t<\/code> and <code>std::uint_least32_t<\/code> respectively (but are distinct types).  <code>char8_t<\/code> was added in C++20 to provide support for 8-bit Unicode (UTF-8).  It is a distinct type that uses the same representation as <code>unsigned char<\/code>.<\/p>\n<p>You won&#8217;t need to use <code>char8_t<\/code>, <code>char16_t<\/code>, or <code>char32_t<\/code> unless you&#8217;re planning on making your program Unicode compatible.  <code>wchar_t<\/code> should be avoided in almost all cases (except when interfacing with the Windows API), as its size is implementation-defined.<\/p>\n<p>Unicode and localization are generally outside the scope of these tutorials, so we won&#8217;t cover it further.  In the meantime, you should only use ASCII characters when working with characters (and strings).  Using characters from other character sets may cause your characters to display incorrectly.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-type-conversion-and-static_cast\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">4.12<\/span>Introduction to type conversion and static_cast\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-if-statements\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">4.10<\/span>Introduction to if statements\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>To this point, the fundamental data types we&#8217;ve looked at have been used to hold numbers (integers and floating points) or true\/false values (Booleans). But what if we want to store letters or punctuation? #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &#8220;Would you like a burrito? (y\/n)&#8221;; \/\/ We want &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/48"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=48"}],"version-history":[{"count":64,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/48\/revisions"}],"predecessor-version":[{"id":18261,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/48\/revisions\/18261"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=48"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=48"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=48"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}