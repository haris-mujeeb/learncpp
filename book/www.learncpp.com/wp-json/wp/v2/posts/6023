{"id":6023,"date":"2017-06-27T16:28:46","date_gmt":"2017-06-28T00:28:46","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=6023"},"modified":"2024-06-09T20:05:38","modified_gmt":"2024-06-10T03:05:38","slug":"calling-inherited-functions-and-overriding-behavior","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/calling-inherited-functions-and-overriding-behavior\/","title":{"rendered":"24.7 &#8212; Calling inherited functions and overriding behavior"},"content":{"rendered":"<p>By default, derived classes inherit all of the behaviors defined in a base class.  In this lesson, we&#8217;ll examine in more detail how member functions are selected, as well as how we can leverage this to change behaviors in a derived class.<\/p>\n<p>When a member function is called on a derived class object, the compiler first looks to see if any function with that name exists in the derived class.  If so, all overloaded functions with that name are considered, and the function overload resolution process is used to determine whether there is a best match.  If not, the compiler walks up the inheritance chain, checking each parent class in turn in the same way.<\/p>\n<p>Put another way, the compiler will select the best matching function from the most-derived class with at least one function with that name.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Calling a base class function<\/p>\n<p>First, let&#8217;s explore what happens when the derived class has no matching function, but the base class does:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n    Base() { }\r\n\r\n    void identify() const { std::cout &lt;&lt; \"Base::identify()\\n\"; }\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\npublic:\r\n    Derived() { }\r\n};\r\n\r\nint main()\r\n{\r\n    Base base {};\r\n    base.identify();\r\n\r\n    Derived derived {};\r\n    derived.identify();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nBase::identify()\r\nBase::identify()\r\n<\/pre>\n<p>When <code>base.identify()<\/code> is called, the compiler looks to see if a function named <code>identify()<\/code> has been defined in class <code>Base<\/code>.  It has, so the compiler looks to see if it is a match.  It is, so it is called<\/p>\n<p>When <code>derived.identify()<\/code> is called, the compiler looks to see if a function named <code>identify()<\/code> has been defined in the <code>Derived<\/code> class.  It hasn&#8217;t.  So it moves to the parent class (in this case, <code>Base<\/code>), and tries again there.  <code>Base<\/code> has defined an <code>identify()<\/code> function, so it uses that one.  In other words, <code>Base::identify()<\/code> was used because <code>Derived::identify()<\/code> doesn&#8217;t exist.<\/p>\n<p>This means that if the behavior provided by a base class is sufficient, we can simply use the base class behavior.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Redefining behaviors<\/p>\n<p>However, if we had defined <code>Derived::identify()<\/code> in the <code>Derived<\/code> class, it would have been used instead.<\/p>\n<p>This means that we can make functions work differently with our derived classes by redefining them in the derived class!<\/p>\n<p>For example, let&#8217;s say we want <code>derived.identify()<\/code> to print <code>Derived::identify()<\/code>.  We can simply add function <code>identify()<\/code> in the <code>Derived<\/code> class so it returns the correct response when we call function <code>identify()<\/code> with a <code>Derived<\/code> object.<\/p>\n<p>To modify the way a function defined in a base class works in the derived class, simply redefine the function in the derived class.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n    Base() { }\r\n\r\n    void identify() const { std::cout &lt;&lt; \"Base::identify()\\n\"; }\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\npublic:\r\n    Derived() { }\r\n\r\n    void identify() const { std::cout &lt;&lt; \"Derived::identify()\\n\"; }\r\n};\r\n\r\nint main()\r\n{\r\n    Base base {};\r\n    base.identify();\r\n\r\n    Derived derived {};\r\n    derived.identify();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nBase::identify()\r\nDerived::identify()\r\n<\/pre>\n<p>Note that when you redefine a function in the derived class, the derived function does not inherit the access specifier of the function with the same name in the base class.  It uses whatever access specifier it is defined under in the derived class.  Therefore, a function that is defined as private in the base class can be redefined as public in the derived class, or vice-versa!<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\nprivate:\r\n\tvoid print() const \r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Base\";\r\n\t}\r\n};\r\n \r\nclass Derived : public Base\r\n{\r\npublic:\r\n\tvoid print() const \r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Derived \";\r\n\t}\r\n};\r\n \r\n \r\nint main()\r\n{\r\n\tDerived derived {};\r\n\tderived.print(); \/\/ calls derived::print(), which is public\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Adding to existing functionality<\/p>\n<p>Sometimes we don&#8217;t want to completely replace a base class function, but instead want to add additional functionality to it when called with a derived object.  In the above example, note that <code>Derived::identify()<\/code> completely hides <code>Base::identify()<\/code>!  This may not be what we want.  It is possible to have our derived function call the base version of the function of the same name (in order to reuse code) and then add additional functionality to it.<\/p>\n<p>To have a derived function call a base function of the same name, simply do a normal function call, but prefix the function with the scope qualifier of the base class.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n    Base() { }\r\n\r\n    void identify() const { std::cout &lt;&lt; \"Base::identify()\\n\"; }\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\npublic:\r\n    Derived() { }\r\n\r\n    void identify() const\r\n    {\r\n        std::cout &lt;&lt; \"Derived::identify()\\n\";\r\n        Base::identify(); \/\/ note call to Base::identify() here\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Base base {};\r\n    base.identify();\r\n\r\n    Derived derived {};\r\n    derived.identify();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nBase::identify()\r\nDerived::identify()\r\nBase::identify()\r\n<\/pre>\n<p>When <code>derived.identify()<\/code> is executed, it resolves to <code>Derived::identify()<\/code>.  After printing <code>Derived::identify()<\/code>, it then calls <code>Base::identify()<\/code>, which prints <code>Base::identify()<\/code>.<\/p>\n<p>This should be pretty straightforward.  Why do we need to use the scope resolution operator (::)?  If we had defined <code>Derived::identify()<\/code> like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n    Base() { }\r\n\r\n    void identify() const { std::cout &lt;&lt; \"Base::identify()\\n\"; }\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\npublic:\r\n    Derived() { }\r\n\r\n    void identify() const\r\n    {\r\n        std::cout &lt;&lt; \"Derived::identify()\\n\";\r\n        identify(); \/\/ no scope resolution results in self-call and infinite recursion\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Base base {};\r\n    base.identify();\r\n\r\n    Derived derived {};\r\n    derived.identify();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Calling function <code>identify()<\/code> without a scope resolution qualifier would default to the <code>identify()<\/code> in the current class, which would be <code>Derived::identify()<\/code>.  This would cause <code>Derived::identify()<\/code> to call itself, which would lead to an infinite recursion!<\/p>\n<p>There&#8217;s one bit of trickiness that we can run into when trying to call friend functions in base classes, such as <code>operator&lt;&lt;<\/code>.  Because friend functions of the base class aren&#8217;t actually part of the base class, using the scope resolution qualifier won&#8217;t work.  Instead, we need a way to make our <code>Derived<\/code> class temporarily look like the <code>Base<\/code> class so that the right version of the function can be called.<\/p>\n<p>Fortunately, that&#8217;s easy to do, using <code>static_cast<\/code>.  Here&#8217;s an example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n    Base() { }\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Base&amp;)\r\n\t{\r\n\t\tout &lt;&lt; \"In Base\\n\";\r\n\t\treturn out;\r\n\t}\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\npublic:\r\n    Derived() { }\r\n\r\n \tfriend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Derived&amp; d)\r\n\t{\r\n\t\tout &lt;&lt; \"In Derived\\n\";\r\n\t\t\/\/ static_cast Derived to a Base object, so we call the right version of operator&lt;&lt;\r\n\t\tout &lt;&lt; static_cast&lt;const Base&amp;&gt;(d); \r\n\t\treturn out;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Derived derived {};\r\n\r\n    std::cout &lt;&lt; derived &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because a <code>Derived<\/code> is-a Base, we can <code>static_cast<\/code> our <code>Derived<\/code> object into a <code>Base<\/code> reference, so that the appropriate version of <code>operator&lt;&lt;<\/code> that uses a <code>Base<\/code> is called.<\/p>\n<p>This prints:<\/p>\n<pre>\nIn Derived\r\nIn Base\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Overload resolution in derived classes<\/p>\n<p>As noted at the top of the lesson, the compiler will select the best matching function from the most-derived class with at least one function with that name.<\/p>\n<p>First, let&#8217;s take a look at a simple case where we have overloaded member functions:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n    void print(int)    { std::cout &lt;&lt; \"Base::print(int)\\n\"; }\r\n    void print(double) { std::cout &lt;&lt; \"Base::print(double)\\n\"; }\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\npublic:\r\n};\r\n\r\n\r\nint main()\r\n{\r\n    Derived d{};\r\n    d.print(5); \/\/ calls Base::print(int)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>For the call <code>d.print(5)<\/code>, the compiler doesn&#8217;t find a function named <code>print()<\/code> in <code>Derived<\/code>, so it checks <code>Base<\/code> where it finds two functions with that name.  It uses the function overload resolution process to determine that <code>Base::print(int)<\/code> is a better match than <code>Base::print(double)<\/code>.  Therefore, <code>Base::print(int)<\/code> gets called, just like we&#8217;d expect.<\/p>\n<p>Now let&#8217;s look at a case that doesn&#8217;t behave like we might expect:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n    void print(int)    { std::cout &lt;&lt; \"Base::print(int)\\n\"; }\r\n    void print(double) { std::cout &lt;&lt; \"Base::print(double)\\n\"; }\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\npublic:\r\n    void print(double) { std::cout &lt;&lt; \"Derived::print(double)\"; } \/\/ this function added\r\n};\r\n\r\n\r\nint main()\r\n{\r\n    Derived d{};\r\n    d.print(5); \/\/ calls Derived::print(double), not Base::print(int)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>For the call <code>d.print(5)<\/code>, the compiler finds one function named <code>print()<\/code> in <code>Derived<\/code>, therefore it will only consider functions in <code>Derived<\/code> when trying to determine what function to resolve to.  This function is also the best matching function in <code>Derived<\/code> for this function call.  Therefore, this calls <code>Derived::print(double)<\/code>.<\/p>\n<p>Since <code>Base::print(int)<\/code> has a parameter that is a better match for int argument <code>5<\/code> than <code>Derived::print(double)<\/code>, you may have been expecting this function call to resolve to <code>Base::print(int)<\/code>.  But because <code>d<\/code> is a <code>Derived<\/code>, there is at least one <code>print()<\/code> function in <code>Derived<\/code>, and <code>Derived<\/code> is more derived than <code>Base<\/code>, the functions in <code>Base<\/code> are not even considered.<\/p>\n<p>So what if we actually want <code>d.print(5)<\/code> to resolve to <code>Base::print(int)<\/code>?  One not-great way is to define a <code>Derived::print(int)<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n    void print(int)    { std::cout &lt;&lt; \"Base::print(int)\\n\"; }\r\n    void print(double) { std::cout &lt;&lt; \"Base::print(double)\\n\"; }\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\npublic:\r\n    void print(int n) { Base::print(n); } \/\/ works but not great, as we have to define \r\n    void print(double) { std::cout &lt;&lt; \"Derived::print(double)\"; }\r\n};\r\n\r\nint main()\r\n{\r\n    Derived d{};\r\n    d.print(5); \/\/ calls Derived::print(int), which calls Base::print(int)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>While this works, it&#8217;s not great, as we have to add a function to <code>Derived<\/code> for every overload we want to fall through to <code>Base<\/code>.  That could be a lot of extra functions that essentially just route calls to <code>Base<\/code>.<\/p>\n<p>A better option is to use a using-declaration in <code>Derived<\/code> to make all <code>Base<\/code> functions with a certain name visible from within <code>Derived<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n    void print(int)    { std::cout &lt;&lt; \"Base::print(int)\\n\"; }\r\n    void print(double) { std::cout &lt;&lt; \"Base::print(double)\\n\"; }\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\npublic:\r\n    using Base::print; \/\/ make all Base::print() functions eligible for overload resolution\r\n    void print(double) { std::cout &lt;&lt; \"Derived::print(double)\"; }\r\n};\r\n\r\n\r\nint main()\r\n{\r\n    Derived d{};\r\n    d.print(5); \/\/ calls Base::print(int), which is the best matching function visible in Derived\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>By putting the using-declaration <code>using Base::print;<\/code> inside <code>Derived<\/code>, we are telling the compiler that all <code>Base<\/code> functions named <code>print<\/code> should be visible in <code>Derived<\/code>, which will cause them to be eligible for overload resolution.  As a result, <code>Base::print(int)<\/code> is selected over <code>Derived::print(double)<\/code>.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/hiding-inherited-functionality\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">24.8<\/span>Hiding inherited functionality\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/adding-new-functionality-to-a-derived-class\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">24.6<\/span>Adding new functionality to a derived class\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>By default, derived classes inherit all of the behaviors defined in a base class. In this lesson, we&#8217;ll examine in more detail how member functions are selected, as well as how we can leverage this to change behaviors in a derived class. When a member function is called on a &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/6023"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=6023"}],"version-history":[{"count":21,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/6023\/revisions"}],"predecessor-version":[{"id":6032,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/6023\/revisions\/6032"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=6023"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=6023"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=6023"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}