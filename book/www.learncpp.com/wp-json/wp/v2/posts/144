{"id":144,"date":"2007-10-11T10:22:38","date_gmt":"2007-10-11T18:22:38","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/96-overloading-operators-using-member-functions\/"},"modified":"2023-10-30T13:06:36","modified_gmt":"2023-10-30T20:06:36","slug":"overloading-operators-using-member-functions","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-operators-using-member-functions\/","title":{"rendered":"21.5 &#8212; Overloading operators using member functions"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-the-arithmetic-operators-using-friend-functions\/\">21.2 -- Overloading the arithmetic operators using friend functions<\/a>, you learned how to overload the arithmetic operators using friend functions.  You also learned you can overload operators as normal functions.  Many operators can be overloaded in a different way: as a member function.<\/p>\n<p>Overloading operators using a member function is very similar to overloading operators using a friend function.  When overloading an operator using a member function:<\/p>\n<ul>\n<li>The overloaded operator must be added as a member function of the left operand.<\/li>\n<li>The left operand becomes the implicit *this object<\/li>\n<li>All other operands become function parameters.<\/li>\n<\/ul>\n<p>As a reminder, here&#8217;s how we overloaded operator+ using a friend function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Cents\r\n{\r\nprivate:\r\n    int m_cents {};\r\n\r\npublic:\r\n    Cents(int cents)\r\n        : m_cents { cents } { }\r\n\r\n    \/\/ Overload Cents + int\r\n    friend Cents operator+(const Cents&amp; cents, int value);\r\n\r\n    int getCents() const { return m_cents; }\r\n};\r\n\r\n\/\/ note: this function is not a member function!\r\nCents operator+(const Cents&amp; cents, int value)\r\n{\r\n    return Cents(cents.m_cents + value);\r\n}\r\n\r\nint main()\r\n{\r\n\tconst Cents cents1 { 6 };\r\n\tconst Cents cents2 { cents1 + 2 };\r\n\tstd::cout &lt;&lt; \"I have \" &lt;&lt; cents2.getCents() &lt;&lt; \" cents.\\n\";\r\n \r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Converting a friend overloaded operator to a member overloaded operator is easy:<\/p>\n<ol>\n<li>The overloaded operator is defined as a member instead of a friend (Cents::operator+ instead of friend operator+)<\/li>\n<li>The left parameter is removed, because that parameter now becomes the implicit *this object.<\/li>\n<li>Inside the function body, all references to the left parameter can be removed (e.g. cents.m_cents becomes m_cents, which implicitly references the *this object).<\/li>\n<\/ol>\n<p>Now, the same operator overloaded using the member function method:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Cents\r\n{\r\nprivate:\r\n    int m_cents {};\r\n\r\npublic:\r\n    Cents(int cents)\r\n        : m_cents { cents } { }\r\n\r\n    \/\/ Overload Cents + int\r\n    Cents operator+(int value) const;\r\n\r\n    int getCents() const { return m_cents; }\r\n};\r\n\r\n\/\/ note: this function is a member function!\r\n\/\/ the cents parameter in the friend version is now the implicit *this parameter\r\nCents Cents::operator+ (int value) const\r\n{\r\n    return Cents { m_cents + value };\r\n}\r\n\r\nint main()\r\n{\r\n\tconst Cents cents1 { 6 };\r\n\tconst Cents cents2 { cents1 + 2 };\r\n\tstd::cout &lt;&lt; \"I have \" &lt;&lt; cents2.getCents() &lt;&lt; \" cents.\\n\";\r\n \r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Note that the usage of the operator does not change (in both cases, <code>cents1 + 2<\/code>), we&#8217;ve simply defined the function differently.  Our two-parameter friend function becomes a one-parameter member function, with the leftmost parameter in the friend version (cents) becoming the implicit *this parameter in the member function version.<\/p>\n<p>Let&#8217;s take a closer look at how the expression <code>cents1 + 2<\/code> evaluates.<\/p>\n<p>In the friend function version, the expression <code>cents1 + 2<\/code> becomes function call operator+(cents1, 2).  Note that there are two function parameters.  This is straightforward.<\/p>\n<p>In the member function version, the expression <code>cents1 + 2<\/code> becomes function call <code>cents1.operator+(2)<\/code>.  Note that there is now only one explicit function parameter, and cents1 has become an object prefix.  However, in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/the-hidden-this-pointer-and-member-function-chaining\/\">15.1 -- The hidden &#8220;this&#8221; pointer and member function chaining<\/a>, we mentioned that the compiler implicitly converts an object prefix into a hidden leftmost parameter named *this.  So in actuality, <code>cents1.operator+(2)<\/code> becomes <code>operator+(&amp;\u200bcents1, 2)<\/code>, which is almost identical to the friend version.<\/p>\n<p>Both cases produce the same result, just in slightly different ways.<\/p>\n<p>So if we can overload an operator as a friend or a member, which should we use?  In order to answer that question, there&#8217;s a few more things you&#8217;ll need to know.<\/p>\n<p><strong>Not everything can be overloaded as a friend function<\/strong><\/p>\n<p>The assignment (=), subscript ([]), function call (()), and member selection (->) operators must be overloaded as member functions, because the language requires them to be.<\/p>\n<p><strong>Not everything can be overloaded as a member function<\/strong><\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-the-io-operators\/\">21.4 -- Overloading the I\/O operators<\/a>, we overloaded operator&lt;&lt; for our Point class using the friend function method.  Here&#8217;s a reminder of how we did that:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n \r\nclass Point\r\n{\r\nprivate:\r\n    double m_x {};\r\n    double m_y {};\r\n    double m_z {};\r\n \r\npublic:\r\n    Point(double x=0.0, double y=0.0, double z=0.0)\r\n        : m_x { x }, m_y { y }, m_z { z }\r\n    {\r\n    }\r\n \r\n    friend std::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Point&amp; point);\r\n};\r\n \r\nstd::ostream&amp; operator&lt;&lt; (std::ostream&amp; out, const Point&amp; point)\r\n{\r\n    \/\/ Since operator&lt;&lt; is a friend of the Point class, we can access Point's members directly.\r\n    out &lt;&lt; \"Point(\" &lt;&lt; point.m_x &lt;&lt; \", \" &lt;&lt; point.m_y &lt;&lt; \", \" &lt;&lt; point.m_z &lt;&lt; \")\";\r\n \r\n    return out;\r\n}\r\n \r\nint main()\r\n{\r\n    Point point1 { 2.0, 3.0, 4.0 };\r\n \r\n    std::cout &lt;&lt; point1;\r\n \r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, we are not able to overload operator&lt;&lt; as a member function.  Why not?  Because the overloaded operator must be added as a member of the left operand.  In this case, the left operand is an object of type std::ostream.  std::ostream is fixed as part of the standard library.  We can&#8217;t modify the class declaration to add the overload as a member function of std::ostream.<\/p>\n<p>This necessitates that operator&lt;&lt; be overloaded as a normal function (preferred) or a friend.<\/p>\n<p>Similarly, although we can overload operator+(Cents, int) as a member function (as we did above), we can&#8217;t overload operator+(int, Cents) as a member function, because int isn&#8217;t a class we can add members to.<\/p>\n<p>Typically, we won&#8217;t be able to use a member overload if the left operand is either not a class (e.g. int), or it is a class that we can&#8217;t modify (e.g. std::ostream).<\/p>\n<p><strong>When to use a normal, friend, or member function overload<\/strong><\/p>\n<p>In most cases, the language leaves it up to you to determine whether you want to use the normal\/friend or member function version of the overload.  However, one of the two is usually a better choice than the other.<\/p>\n<p>When dealing with binary operators that don&#8217;t modify the left operand (e.g. operator+), the normal or friend function version is typically preferred, because it works for all parameter types (even when the left operand isn&#8217;t a class object, or is a class that is not modifiable).  The normal or friend function version has the added benefit of &#8220;symmetry&#8221;, as all operands become explicit parameters (instead of the left operand becoming *this and the right operand becoming an explicit parameter).<\/p>\n<p>When dealing with binary operators that do modify the left operand (e.g. operator+=), the member function version is typically preferred.  In these cases, the leftmost operand will always be a class type, and having the object being modified become the one pointed to by *this is natural.  Because the rightmost operand becomes an explicit parameter, there&#8217;s no confusion over who is getting modified and who is getting evaluated.<\/p>\n<p>Unary operators are usually overloaded as member functions as well, since the member version has no parameters.<\/p>\n<p>The following rules of thumb can help you determine which form is best for a given situation:<\/p>\n<ul>\n<li>If you&#8217;re overloading assignment (=), subscript ([]), function call (()), or member selection (->), do so as a member function.<\/li>\n<li>If you&#8217;re overloading a unary operator, do so as a member function.<\/li>\n<li>If you&#8217;re overloading a binary operator that does not modify its left operand (e.g. operator+), do so as a normal function (preferred) or friend function.<\/li>\n<li>If you&#8217;re overloading a binary operator that modifies its left operand, but you can&#8217;t add members to the class definition of the left operand (e.g. operator&lt;&lt;, which has a left operand of type ostream), do so as a normal function (preferred) or friend function.<\/li>\n<li>If you&#8217;re overloading a binary operator that modifies its left operand (e.g. operator+=), and you can modify the definition of the left operand, do so as a member function.<\/li>\n<\/ul>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-unary-operators\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.6<\/span>Overloading unary operators +, -, and !\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-the-io-operators\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.4<\/span>Overloading the I\/O operators\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , you learned how to overload the arithmetic operators using friend functions. You also learned you can overload operators as normal functions. Many operators can be overloaded in a different way: as a member function. Overloading operators using a member function is very similar to overloading operators using &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/144"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=144"}],"version-history":[{"count":27,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/144\/revisions"}],"predecessor-version":[{"id":16025,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/144\/revisions\/16025"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=144"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=144"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=144"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}