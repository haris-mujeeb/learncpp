{"id":4814,"date":"2016-10-29T15:32:33","date_gmt":"2016-10-29T23:32:33","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=4814"},"modified":"2024-01-31T23:20:47","modified_gmt":"2024-02-01T07:20:47","slug":"chapter-24-summary-and-quiz","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-24-summary-and-quiz\/","title":{"rendered":"24.x &#8212; Chapter 24 summary and quiz"},"content":{"rendered":"<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Summary<\/p>\n<p>Inheritance allows us to model an is-a relationship between two objects.  The object being inherited from is called the parent class, base class, or superclass.  The object doing the inheriting is called the child class, derived class, or subclass.<\/p>\n<p>When a derived class inherits from a base class, the derived class acquires all of the members of the base class.<\/p>\n<p style=\"clear: both\">\n<p> <!-- break around image --><\/p>\n<p>When a derived class is constructed, the base portion of the class is constructed first, and then the derived portion is constructed.  In more detail:<\/p>\n<ol>\n<li>Memory for the derived class is set aside (enough for both the base and derived portions).<\/li>\n<li>The appropriate derived class constructor is called.<\/li>\n<li>The base class object is constructed first using the appropriate base class constructor. If no base class constructor is specified, the default constructor will be used.<\/li>\n<li>The initialization list of the derived class initializes members of the derived class.<\/li>\n<li>The body of the derived class constructor executes.<\/li>\n<li>Control is returned to the caller.<\/li>\n<\/ol>\n<p>Destruction happens in the opposite order, from most-derived to most-base class.<\/p>\n<p>C++ has 3 access specifiers: public, private, and protected.  The protected access specifier allows the class the member belongs to, friends, and derived classes to access protected members, but not the public.<\/p>\n<p>Classes can inherit from another class publicly, privately, or protectedly.  Classes almost always inherit publicly.<\/p>\n<p>Here&#8217;s a table of all of the access specifier and inheritance types combinations:<\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<th>Access specifier in base class<\/th>\n<th>Access specifier when inherited publicly<\/th>\n<th>Access specifier when inherited privately<\/th>\n<th>Access specifier when inherited protectedly<\/th>\n<\/tr>\n<tr>\n<td>Public<\/td>\n<td>Public<\/td>\n<td>Private<\/td>\n<td>Protected<\/td>\n<\/tr>\n<tr>\n<td>Private<\/td>\n<td>Inaccessible<\/td>\n<td>Inaccessible<\/td>\n<td>Inaccessible<\/td>\n<\/tr>\n<tr>\n<td>Protected<\/td>\n<td>Protected<\/td>\n<td>Private<\/td>\n<td>Protected<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>Derived classes can add new functions, change the way functions that exist in the base class work in the derived class, change an inherited member&#8217;s access level, or hide functionality.<\/p>\n<p>Multiple inheritance enables a derived class to inherit members from more than one parent.  You should generally avoid multiple inheritance unless alternatives lead to more complexity.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #1<\/p>\n<p>\nFor each of the following programs, determine what they output, or if they would not compile, indicate why.  This exercise is meant to be done by inspection, so do not compile these (otherwise the answers are trivial).<\/p>\n<p>a) <\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n\tBase()\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Base()\\n\";\r\n\t}\r\n\t~Base()\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"~Base()\\n\";\r\n\t}\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\npublic:\r\n\tDerived()\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Derived()\\n\";\r\n\t}\r\n\t~Derived()\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"~Derived()\\n\";\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tDerived d;\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>Construction happens in order from most-Parent to most-Child.  Destruction happens in the opposite order.<\/p>\n<pre>\r\nBase()\r\nDerived()\r\n~Derived()\r\n~Base()\r\n<\/pre>\n<\/div>\n<p>b) <\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n\tBase()\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Base()\\n\";\r\n\t}\r\n\t~Base()\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"~Base()\\n\";\r\n\t}\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\npublic:\r\n\tDerived()\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Derived()\\n\";\r\n\t}\r\n\t~Derived()\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"~Derived()\\n\";\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tDerived d;\r\n\tBase b;\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Hint: Local variables are destroyed in the opposite order of definition.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p>First we construct d, which prints:<\/p>\n<pre>\r\nBase()\r\nDerived()\r\n<\/pre>\n<p>Then we construct b, which prints:<\/p>\n<pre>\r\nBase()\r\n<\/pre>\n<p>Then we destruct b, which prints:<\/p>\n<pre>\r\n~Base()\r\n<\/pre>\n<p>Then we destruct d, which prints:<\/p>\n<pre>\r\n~Derived()\r\n~Base()\r\n<\/pre>\n<\/div>\n<p>c)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\nprivate:\r\n\tint m_x {};\r\npublic:\r\n\tBase(int x): m_x{ x }\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Base()\\n\";\r\n\t}\r\n\t~Base()\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"~Base()\\n\";\r\n\t}\r\n\r\n\tvoid print() const { std::cout &lt;&lt; \"Base: \" &lt;&lt; m_x &lt;&lt; '\\n';  }\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\npublic:\r\n\tDerived(int y):  Base{ y }\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Derived()\\n\";\r\n\t}\r\n\t~Derived()\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"~Derived()\\n\";\r\n\t}\r\n\r\n\tvoid print() const { std::cout &lt;&lt; \"Derived: \" &lt;&lt; m_x &lt;&lt; '\\n'; }\r\n};\r\n\r\nint main()\r\n{\r\n\tDerived d{ 5 };\r\n\td.print();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<p>Doesn&#8217;t compile, Derived::print() can&#8217;t access private member m_x\n<\/p><\/div>\n<p>d)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\nprotected:\r\n\tint m_x {};\r\npublic:\r\n\tBase(int x): m_x{ x }\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Base()\\n\";\r\n\t}\r\n\t~Base()\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"~Base()\\n\";\r\n\t}\r\n\r\n\tvoid print() const { std::cout &lt;&lt; \"Base: \" &lt;&lt; m_x &lt;&lt; '\\n';  }\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\npublic:\r\n\tDerived(int y):  Base{ y }\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Derived()\\n\";\r\n\t}\r\n\t~Derived()\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"~Derived()\\n\";\r\n\t}\r\n\r\n\tvoid print() const { std::cout &lt;&lt; \"Derived: \" &lt;&lt; m_x &lt;&lt; '\\n'; }\r\n};\r\n\r\nint main()\r\n{\r\n\tDerived d{ 5 };\r\n\td.print();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<pre>\r\nBase()\r\nDerived()\r\nDerived: 5\r\n~Derived()\r\n~Base()\r\n<\/pre>\n<\/div>\n<p>e) <\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\nprotected:\r\n\tint m_x {};\r\npublic:\r\n\tBase(int x): m_x{ x }\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Base()\\n\";\r\n\t}\r\n\t~Base()\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"~Base()\\n\";\r\n\t}\r\n\r\n\tvoid print() const { std::cout &lt;&lt; \"Base: \" &lt;&lt; m_x &lt;&lt; '\\n';  }\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\npublic:\r\n\tDerived(int y):  Base{ y }\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Derived()\\n\";\r\n\t}\r\n\t~Derived()\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"~Derived()\\n\";\r\n\t}\r\n\r\n\tvoid print() const { std::cout &lt;&lt; \"Derived: \" &lt;&lt; m_x &lt;&lt; '\\n'; }\r\n};\r\n\r\nclass D2 : public Derived\r\n{\r\npublic:\r\n\tD2(int z): Derived{ z }\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"D2()\\n\";\r\n\t}\r\n\t~D2()\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"~D2()\\n\";\r\n\t}\r\n\r\n        \/\/ note: no print() function here\r\n};\r\n\r\nint main()\r\n{\r\n\tD2 d{ 5 };\r\n\td.print();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\n<p>Base()<br \/>\nDerived()<br \/>\nD2()<br \/>\nDerived: 5<br \/>\n~D2()<br \/>\n~Derived()<br \/>\n~Base()\n<\/p><\/div>\n<\/p>\n<\/div>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #2<\/p>\n<p>\na) Write an Apple class and a Banana class that are derived from a common Fruit class.  Fruit should have two members: a name and a color.<\/p>\n<p>The following program should run:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n\tApple a{ \"red\" };\r\n\tBanana b{};\r\n\r\n\tstd::cout &lt;&lt; \"My \" &lt;&lt; a.getName() &lt;&lt; \" is \" &lt;&lt; a.getColor() &lt;&lt; \".\\n\";\r\n\tstd::cout &lt;&lt; \"My \" &lt;&lt; b.getName() &lt;&lt; \" is \" &lt;&lt; b.getColor() &lt;&lt; \".\\n\";\r\n\t\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>And produce the result:<\/p>\n<pre>\r\nMy apple is red.\r\nMy banana is yellow.\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_5'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_5\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Fruit\r\n{\r\nprivate:\r\n\tstd::string m_name;\r\n\tstd::string m_color;\r\n\r\npublic:\r\n\tFruit(std::string_view name, std::string_view color)\r\n\t\t: m_name{ name }, m_color{ color }\r\n\t{\r\n\t}\r\n\r\n\tconst std::string&amp; getName() const { return m_name; }\r\n\tconst std::string&amp; getColor() const { return m_color; }\r\n};\r\n\r\nclass Apple: public Fruit\r\n{\r\npublic:\r\n\tApple(std::string_view color=\"red\")\r\n\t\t: Fruit{ \"apple\", color }\r\n\t{\r\n\t}\r\n};\r\n\r\nclass Banana : public Fruit\r\n{\r\npublic:\r\n\tBanana()\r\n\t\t: Fruit{ \"banana\", \"yellow\" }\r\n\t{\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tApple a{ \"red\" };\r\n\tBanana b;\r\n\r\n\tstd::cout &lt;&lt; \"My \" &lt;&lt; a.getName() &lt;&lt; \" is \" &lt;&lt; a.getColor() &lt;&lt; \".\\n\";\r\n\tstd::cout &lt;&lt; \"My \" &lt;&lt; b.getName() &lt;&lt; \" is \" &lt;&lt; b.getColor() &lt;&lt; \".\\n\";\r\n\t\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>b) Add a new class to the previous program called GrannySmith that inherits from Apple.<\/p>\n<p>The following program should run:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n\tApple a{ \"red\" };\r\n\tBanana b;\r\n\tGrannySmith c;\r\n\r\n\tstd::cout &lt;&lt; \"My \" &lt;&lt; a.getName() &lt;&lt; \" is \" &lt;&lt; a.getColor() &lt;&lt; \".\\n\";\r\n\tstd::cout &lt;&lt; \"My \" &lt;&lt; b.getName() &lt;&lt; \" is \" &lt;&lt; b.getColor() &lt;&lt; \".\\n\";\r\n\tstd::cout &lt;&lt; \"My \" &lt;&lt; c.getName() &lt;&lt; \" is \" &lt;&lt; c.getColor() &lt;&lt; \".\\n\";\r\n\t\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>And produce the result:<\/p>\n<pre>\r\nMy apple is red.\r\nMy banana is yellow.\r\nMy granny smith apple is green.\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_6'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_6\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Fruit\r\n{\r\nprivate:\r\n\tstd::string m_name;\r\n\tstd::string m_color;\r\n\r\npublic:\r\n\tFruit(std::string_view name, std::string_view color)\r\n\t\t: m_name{ name }, m_color{ color }\r\n\t{\r\n\t}\r\n\r\n\tconst std::string&amp; getName() const { return m_name; }\r\n\tconst std::string&amp; getColor() const { return m_color; }\r\n};\r\n\r\nclass Apple: public Fruit\r\n{\r\n\/\/ The previous constructor we used for Apple had a fixed name (\"apple\").\r\n\/\/ We need a new constructor for GrannySmith to use to set the name of the fruit\r\nprotected: \/\/ protected so only derived classes can access\r\n\tApple(std::string_view name, std::string_view color)\r\n\t\t: Fruit{ name, color }\r\n\t{\r\n\t}\r\n\r\npublic:\r\n\tApple(std::string_view color=\"red\")\r\n\t\t: Fruit{ \"apple\", color }\r\n\t{\r\n\t}\r\n};\r\n\r\nclass Banana : public Fruit\r\n{\r\npublic:\r\n\tBanana()\r\n\t\t: Fruit{ \"banana\", \"yellow\" }\r\n\t{\r\n\t}\r\n};\r\n\r\nclass GrannySmith : public Apple\r\n{\r\npublic:\r\n\tGrannySmith()\r\n\t\t: Apple{ \"granny smith apple\", \"green\" }\r\n\t{\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tApple a{ \"red\" };\r\n\tBanana b;\r\n\tGrannySmith c;\r\n\r\n\tstd::cout &lt;&lt; \"My \" &lt;&lt; a.getName() &lt;&lt; \" is \" &lt;&lt; a.getColor() &lt;&lt; \".\\n\";\r\n\tstd::cout &lt;&lt; \"My \" &lt;&lt; b.getName() &lt;&lt; \" is \" &lt;&lt; b.getColor() &lt;&lt; \".\\n\";\r\n\tstd::cout &lt;&lt; \"My \" &lt;&lt; c.getName() &lt;&lt; \" is \" &lt;&lt; c.getColor() &lt;&lt; \".\\n\";\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<\/div>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #3<\/p>\n<p>\nChallenge time!  The following quiz question is more difficult and lengthy.  We&#8217;re going to write a simple game where you fight monsters.  The goal of the game is to collect as much gold as you can before you die or get to level 20.<\/p>\n<p>Our program is going to consist of 3 classes: a Creature class, a Player class, and a Monster class.  Player and Monster both inherit from Creature.<\/p>\n<p>a) First create the Creature class.  Creatures have 5 attributes: A name (std::string), a symbol (a char), an amount of health (int), the amount of damage they do per attack (int), and the amount of gold they are carrying (int).  Implement these as class members.  Write a full set of getters (a get function for each member).  Add three other functions: void reduceHealth(int) reduces the Creature&#8217;s health by an integer amount.  bool isDead() returns true when the Creature&#8217;s health is 0 or less.  void addGold(int) adds gold to the Creature.<\/p>\n<p>The following program should run:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nint main()\r\n{\r\n\tCreature o{ \"orc\", 'o', 4, 2, 10 };\r\n\to.addGold(5);\r\n\to.reduceHealth(1);\r\n\tstd::cout &lt;&lt; \"The \" &lt;&lt; o.getName() &lt;&lt; \" has \" &lt;&lt; o.getHealth() &lt;&lt; \" health and is carrying \" &lt;&lt; o.getGold() &lt;&lt; \" gold.\\n\";\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>And produce the result:<\/p>\n<pre>\r\nThe orc has 3 health and is carrying 15 gold.\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_7'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_7\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt; \/\/ Requires C++17\r\n\r\nclass Creature\r\n{\r\nprotected:\r\n\tstd::string m_name;\r\n\tchar m_symbol {};\r\n\tint m_health {};\r\n\tint m_damage {};\r\n\tint m_gold {};\r\n\r\npublic:\r\n\tCreature(std::string_view name, char symbol, int health, int damage, int gold)\r\n\t\t: m_name{ name }\r\n\t\t, m_symbol{ symbol }\r\n\t\t, m_health{ health }\r\n\t\t, m_damage{ damage }\r\n\t\t, m_gold{ gold }\r\n\t{\r\n\t}\r\n\r\n\tconst std::string&amp; getName() const { return m_name; }\r\n\tchar getSymbol() const { return m_symbol; }\r\n\tint getHealth() const { return m_health; }\r\n\tint getDamage() const { return m_damage; }\r\n\tint getGold() const { return m_gold; }\r\n\r\n\tvoid reduceHealth(int health) { m_health -= health; }\r\n\tbool isDead() const { return m_health &lt;= 0; }\r\n\tvoid addGold(int gold) { m_gold += gold; }\r\n};\r\n\r\nint main()\r\n{\r\n\tCreature o{ \"orc\", 'o', 4, 2, 10 };\r\n\to.addGold(5);\r\n\to.reduceHealth(1);\r\n\tstd::cout &lt;&lt; \"The \" &lt;&lt; o.getName() &lt;&lt; \" has \" &lt;&lt; o.getHealth() &lt;&lt; \" health and is carrying \" &lt;&lt; o.getGold() &lt;&lt; \" gold.\\n\";\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>b) Now we&#8217;re going to create the Player class.  The Player class inherits from Creature.  Player has one additional member, the player&#8217;s level, which starts at 1.  The player has a custom name (entered by the user), uses symbol &#8216;@&#8217;, has 10 health, does 1 damage to start, and has no gold.  Write a function called levelUp() that increases the player&#8217;s level and damage by 1.  Also write a getter for the level member.  Finally, write a function called hasWon() that returns true if the player has reached level 20.<\/p>\n<p>Write a new main() function that asks the user for their name and produces the output as follows:<\/p>\n<pre>\r\nEnter your name: Alex\r\nWelcome, Alex.\r\nYou have 10 health and are carrying 0 gold.\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_8'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_8\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt; \/\/ std::string_view requires C++17\r\n\r\nclass Creature\r\n{\r\nprotected:\r\n\tstd::string m_name;\r\n\tchar m_symbol {};\r\n\tint m_health {};\r\n\tint m_damage {};\r\n\tint m_gold {};\r\n\r\npublic:\r\n\tCreature(std::string_view name, char symbol, int health, int damage, int gold)\r\n\t\t: m_name{ name }\r\n\t\t, m_symbol{ symbol }\r\n\t\t, m_health{ health }\r\n\t\t, m_damage{ damage }\r\n\t\t, m_gold{ gold }\r\n\t{\r\n\t}\r\n\r\n\tconst std::string&amp; getName() const { return m_name; }\r\n\tchar getSymbol() const { return m_symbol; }\r\n\tint getHealth() const { return m_health; }\r\n\tint getDamage() const { return m_damage; }\r\n\tint getGold() const { return m_gold; }\r\n\r\n\tvoid reduceHealth(int health) { m_health -= health; }\r\n\tbool isDead() const { return m_health &lt;= 0; }\r\n\tvoid addGold(int gold) { m_gold += gold; }\r\n};\r\n\r\nclass Player : public Creature\r\n{\r\n\tint m_level{ 1 };\r\n\r\npublic:\r\n\tPlayer(std::string_view name)\r\n\t\t: Creature{ name, '@', 10, 1, 0 }\r\n\t{\r\n\t}\r\n\r\n\tvoid levelUp()\r\n\t{\r\n\t\t++m_level;\r\n\t\t++m_damage;\r\n\t}\r\n\r\n\tint getLevel() const { return m_level; }\r\n\tbool hasWon() const { return m_level &gt;= 20; }\r\n};\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; \"Enter your name: \";\r\n\tstd::string playerName;\r\n\tstd::cin &gt;&gt; playerName;\r\n\r\n\tPlayer p{ playerName };\r\n\tstd::cout &lt;&lt; \"Welcome, \" &lt;&lt; p.getName() &lt;&lt; \".\\n\";\r\n\r\n\tstd::cout &lt;&lt; \"You have \" &lt;&lt; p.getHealth() &lt;&lt; \" health and are carrying \" &lt;&lt; p.getGold() &lt;&lt; \" gold.\\n\";\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>c) Next up is the Monster class.  Monster also inherits from Creature.  Monsters have no non-inherited member variables.<\/p>\n<p>First, write an empty Monster class inheriting from Creature, and then add an enum inside the Monster class named Type that contains enumerators for the 3 monsters that we&#8217;ll have in this game: <code>dragon<\/code>, <code>orc<\/code>, and <code>slime<\/code> (you&#8217;ll also want a <code>max_types<\/code> enumerator, as that will come in handy in a bit).<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_9'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_9\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Monster : public Creature\r\n{\r\npublic:\r\n\tenum Type\r\n\t{\r\n\t\tdragon,\r\n\t\torc,\r\n\t\tslime,\r\n\t\tmax_types\r\n\t};\r\n};<\/code><\/pre>\n<\/div>\n<p>d) Each Monster type will have a different name, symbol, starting health, gold, and damage. Here is a table of stats for each monster Type:<\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<th>Type<\/th>\n<th>Name<\/th>\n<th>Symbol<\/th>\n<th>Health<\/th>\n<th>Damage<\/th>\n<th>Gold<\/th>\n<\/tr>\n<tr>\n<td>dragon<\/td>\n<td>dragon<\/td>\n<td>D<\/td>\n<td>20<\/td>\n<td>4<\/td>\n<td>100<\/td>\n<\/tr>\n<tr>\n<td>orc<\/td>\n<td>orc<\/td>\n<td>o<\/td>\n<td>4<\/td>\n<td>2<\/td>\n<td>25<\/td>\n<\/tr>\n<tr>\n<td>slime<\/td>\n<td>slime<\/td>\n<td>s<\/td>\n<td>1<\/td>\n<td>1<\/td>\n<td>10<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>Next step is to write a Monster constructor, so we can create monsters.  The Monster constructor should take a Type enum as a parameter, and then create a Monster with the appropriate stats for that kind of monster.<\/p>\n<p>There are a number of different ways to implement this (some better, some worse).  However in this case, because all of our monster attributes are predefined (not random or customized per creature), we can use a lookup table.  Our lookup table will be a C-style array of Creature, where indexing the array with a Type will return the appropriate Creature for that Type.<\/p>\n<p>Since this Creature table is specific to Monster, we can define it inside the Monster class as <code>static inline Creature monsterData[] { }<\/code>, initialized with our Creature elements.<\/p>\n<p>Our Monster constructor is then easy: we can call the Creature copy constructor and pass it the appropriate Creature from our monsterData table.<\/p>\n<p>The following program should compile:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nint main()\r\n{\r\n\tMonster m{ Monster::Type::orc };\r\n\tstd::cout &lt;&lt; \"A \" &lt;&lt; m.getName() &lt;&lt; \" (\" &lt;&lt; m.getSymbol() &lt;&lt; \") was created.\\n\";\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>and print:<\/p>\n<pre>\r\nA orc (o) was created.\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_10'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_10\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n \r\nclass Creature\r\n{\r\nprotected:\r\n    std::string m_name;\r\n    char m_symbol {};\r\n    int m_health {};\r\n    int m_damage {};\r\n    int m_gold {};\r\n \r\npublic:\r\n     Creature(std::string_view name, char symbol, int health, int damage, int gold)\r\n        : m_name{ name }\r\n        , m_symbol{ symbol }\r\n        , m_health{ health }\r\n        , m_damage{ damage }\r\n        , m_gold{ gold }\r\n    { }\r\n \r\n    char getSymbol() const { return m_symbol; }\r\n    const std::string&amp; getName() const { return m_name; }\r\n    bool isDead() const { return m_health &lt;= 0; }\r\n    int getGold() const { return m_gold; }\r\n    void addGold(int gold) { m_gold += gold; }\r\n    void reduceHealth(int health) { m_health -= health; }\r\n    int getHealth() const { return m_health; }\r\n    int getDamage() const { return m_damage; }\r\n};\r\n \r\nclass Player : public Creature\r\n{\r\n    int m_level{ 1 };\r\n \r\npublic:\r\n    Player(const std::string&amp; name)\r\n        : Creature{ name, '@', 10, 1, 0 }\r\n    {\r\n    }\r\n \r\n    void levelUp()\r\n    {\r\n        ++m_level;\r\n        ++m_damage;\r\n    }\r\n \r\n    int getLevel() const { return m_level; }\r\n    bool hasWon() const { return m_level &gt;= 20; }\r\n};\r\n \r\nclass Monster : public Creature\r\n{\r\npublic:\r\n    enum Type\r\n    {\r\n        dragon,\r\n        orc,\r\n        slime,\r\n        max_types\r\n    };\r\n \r\nprivate:\r\n    inline static Creature monsterData[] {\r\n        Creature { \"dragon\", 'D', 20, 4, 100 },\r\n        Creature { \"orc\", 'o', 4, 2, 25 },\r\n        Creature { \"slime\", 's', 1, 1, 10 }\r\n        };\r\n\r\n    static_assert(std::size(monsterData) == max_types);\r\n\r\npublic:\r\n    Monster(Type type)\r\n        : Creature{ monsterData[type] }\r\n    {\r\n    }\r\n};\r\n \r\nint main()\r\n{\r\n    Monster m{ Monster::Type::orc };\r\n    std::cout &lt;&lt; \"A \" &lt;&lt; m.getName() &lt;&lt; \" (\" &lt;&lt; m.getSymbol() &lt;&lt; \") was created.\\n\";\r\n \r\n  return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>e) Finally, add a <code>static<\/code> function to Monster named <code>getRandomMonster()<\/code>.  This function should pick a random number from <code>0<\/code> to <code>max_types-1<\/code> and return a monster (by value) with that <code>Type<\/code> (you&#8217;ll need to <code>static_cast<\/code> the <code>int<\/code> to a <code>Type<\/code> to pass it to the <code>Monster<\/code> constructor).<\/p>\n<p>Lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/global-random-numbers-random-h\/#RandomH\">8.15 -- Global random numbers (Random.h)<\/a> contains code you can use to pick a random number.<\/p>\n<p>The following main function should run:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nint main()\r\n{\r\n\tfor (int i{ 0 }; i &lt; 10; ++i)\r\n\t{\r\n\t\tMonster m{ Monster::getRandomMonster() };\r\n\t\tstd::cout &lt;&lt; \"A \" &lt;&lt; m.getName() &lt;&lt; \" (\" &lt;&lt; m.getSymbol() &lt;&lt; \") was created.\\n\";\r\n\t}\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>The results of this program should be randomized.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_11'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_11\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"Random.h\" \/\/ https:\/\/www.learncpp.com\/cpp-tutorial\/global-random-numbers-random-h\/\r\n#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n \r\nclass Creature\r\n{\r\nprotected:\r\n    std::string m_name;\r\n    char m_symbol {};\r\n    int m_health {};\r\n    int m_damage {};\r\n    int m_gold {};\r\n \r\npublic:\r\n     Creature(std::string_view name, char symbol, int health, int damage, int gold)\r\n        : m_name{ name }\r\n        , m_symbol{ symbol }\r\n        , m_health{ health }\r\n        , m_damage{ damage }\r\n        , m_gold{ gold }\r\n    { }\r\n \r\n    char getSymbol() const { return m_symbol; }\r\n    const std::string&amp; getName() const { return m_name; }\r\n    bool isDead() const { return m_health &lt;= 0; }\r\n    int getGold() const { return m_gold; }\r\n    void addGold(int gold) { m_gold += gold; }\r\n    void reduceHealth(int health) { m_health -= health; }\r\n    int getHealth() const { return m_health; }\r\n    int getDamage() const { return m_damage; }\r\n};\r\n \r\nclass Player : public Creature\r\n{\r\n    int m_level{ 1 };\r\n \r\npublic:\r\n    Player(const std::string&amp; name)\r\n        : Creature{ name, '@', 10, 1, 0 }\r\n    {\r\n    }\r\n \r\n    void levelUp()\r\n    {\r\n        ++m_level;\r\n        ++m_damage;\r\n    }\r\n \r\n    int getLevel() const { return m_level; }\r\n    bool hasWon() const { return m_level &gt;= 20; }\r\n};\r\n \r\nclass Monster : public Creature\r\n{\r\npublic:\r\n    enum Type\r\n    {\r\n        dragon,\r\n        orc,\r\n        slime,\r\n        max_types\r\n    };\r\n \r\nprivate:\r\n    inline static Creature monsterData[] {\r\n        Creature { \"dragon\", 'D', 20, 4, 100 },\r\n        Creature { \"orc\", 'o', 4, 2, 25 },\r\n        Creature { \"slime\", 's', 1, 1, 10 }\r\n        };\r\n\r\n    static_assert(std::size(monsterData) == max_types);\r\n\r\npublic:\r\n    Monster(Type type)\r\n        : Creature{ monsterData[type] }\r\n    {\r\n    }\r\n \r\n    static Monster getRandomMonster()\r\n    {\r\n        int num{ Random::get(0, max_types - 1) };\r\n        return Monster{ static_cast&lt;Type&gt;(num) };\r\n    }\r\n};\r\n \r\nint main()\r\n{\r\n    for (int i{ 0 }; i &lt; 10; ++i)\r\n    {\r\n        Monster m{ Monster::getRandomMonster() };\r\n        std::cout &lt;&lt; \"A \" &lt;&lt; m.getName() &lt;&lt; \" (\" &lt;&lt; m.getSymbol() &lt;&lt; \") was created.\\n\";\r\n    }\r\n \r\n  return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>f) We&#8217;re finally set to write our game logic!<\/p>\n<p>Here are the rules for the game:<\/p>\n<p>The player encounters one randomly generated monster at a time.<br \/>\nFor each monster, the player has two choices: (R)un or (F)ight.<br \/>\nIf the player decides to Run, they have a 50% chance of escaping.<br \/>\nIf the player escapes, they move to the next encounter with no ill effects.<br \/>\nIf the player does not escape, the monster gets a free attack, and the player chooses their next action.<br \/>\nIf the player chooses to fight, the player attacks first. The monster&#8217;s health is reduced by the player&#8217;s damage.<br \/>\nIf the monster dies, the player takes any gold the monster is carrying. The player also levels up, increasing their level and damage by 1.<br \/>\nIf the monster does not die, the monster attacks the player back. The player&#8217;s health is reduced by the monster&#8217;s damage.<br \/>\nThe game ends when the player has died (loss) or reached level 20 (win)<br \/>\nIf the player dies, the game should tell the player what level they were and how much gold they had.<br \/>\nIf the player wins, the game should tell the player they won, and how much gold they had<\/p>\n<p>Here&#8217;s a sample game session:<\/p>\n<p>Enter your name: Alex<br \/>\nWelcome, Alex<br \/>\nYou have encountered a slime (s).<br \/>\n(R)un or (F)ight: f<br \/>\nYou hit the slime for 1 damage.<br \/>\nYou killed the slime.<br \/>\nYou are now level 2.<br \/>\nYou found 10 gold.<br \/>\nYou have encountered a dragon (D).<br \/>\n(R)un or (F)ight: r<br \/>\nYou failed to flee.<br \/>\nThe dragon hit you for 4 damage.<br \/>\n(R)un or (F)ight: r<br \/>\nYou successfully fled.<br \/>\nYou have encountered a orc (o).<br \/>\n(R)un or (F)ight: f<br \/>\nYou hit the orc for 2 damage.<br \/>\nThe orc hit you for 2 damage.<br \/>\n(R)un or (F)ight: f<br \/>\nYou hit the orc for 2 damage.<br \/>\nYou killed the orc.<br \/>\nYou are now level 3.<br \/>\nYou found 25 gold.<br \/>\nYou have encountered a dragon (D).<br \/>\n(R)un or (F)ight: r<br \/>\nYou failed to flee.<br \/>\nThe dragon hit you for 4 damage.<br \/>\nYou died at level 3 and with 35 gold.<br \/>\nToo bad you can&#8217;t take it with you!<\/p>\n<p>Hint: Create 4 functions:<\/p>\n<ul>\n<li>The main() function should handle game setup (creating the Player) and the main game loop.\n<\/li>\n<li>fightMonster() handles the fight between the Player and a single Monster, including asking the player what they want to do, handling the run or fight cases.\n<\/li>\n<li>attackMonster() handles the player attacking the monster, including leveling up.\n<\/li>\n<li>attackPlayer() handles the monster attacking the player.\n<\/li>\n<\/ul>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_12'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_12\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"Random.h\" \/\/ https:\/\/www.learncpp.com\/cpp-tutorial\/global-random-numbers-random-h\/\r\n#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n \r\nclass Creature\r\n{\r\nprotected:\r\n    std::string m_name;\r\n    char m_symbol {};\r\n    int m_health {};\r\n    int m_damage {};\r\n    int m_gold {};\r\n \r\npublic:\r\n     Creature(std::string_view name, char symbol, int health, int damage, int gold)\r\n        : m_name{ name }\r\n        , m_symbol{ symbol }\r\n        , m_health{ health }\r\n        , m_damage{ damage }\r\n        , m_gold{ gold }\r\n    { }\r\n \r\n    char getSymbol() const { return m_symbol; }\r\n    const std::string&amp; getName() const { return m_name; }\r\n    bool isDead() const { return m_health &lt;= 0; }\r\n    int getGold() const { return m_gold; }\r\n    void addGold(int gold) { m_gold += gold; }\r\n    void reduceHealth(int health) { m_health -= health; }\r\n    int getHealth() const { return m_health; }\r\n    int getDamage() const { return m_damage; }\r\n};\r\n \r\nclass Player : public Creature\r\n{\r\n    int m_level{ 1 };\r\n \r\npublic:\r\n    Player(const std::string&amp; name)\r\n        : Creature{ name, '@', 10, 1, 0 }\r\n    {\r\n    }\r\n \r\n    void levelUp()\r\n    {\r\n        ++m_level;\r\n        ++m_damage;\r\n    }\r\n \r\n    int getLevel() const { return m_level; }\r\n    bool hasWon() const { return m_level &gt;= 20; }\r\n};\r\n \r\nclass Monster : public Creature\r\n{\r\npublic:\r\n    enum Type\r\n    {\r\n        dragon,\r\n        orc,\r\n        slime,\r\n        max_types\r\n    };\r\n \r\nprivate:\r\n    inline static Creature monsterData[] {\r\n        Creature { \"dragon\", 'D', 20, 4, 100 },\r\n        Creature { \"orc\", 'o', 4, 2, 25 },\r\n        Creature { \"slime\", 's', 1, 1, 10 }\r\n        };\r\n\r\n    static_assert(std::size(monsterData) == max_types);\r\n\r\npublic:\r\n    Monster(Type type)\r\n        : Creature{ monsterData[type] }\r\n    {\r\n    }\r\n \r\n    static Monster getRandomMonster()\r\n    {\r\n        int num{ Random::get(0, max_types - 1) };\r\n        return Monster{ static_cast&lt;Type&gt;(num) };\r\n    }\r\n};\r\n \r\n\/\/ This function handles the player attacking the monster\r\nvoid attackMonster(Player&amp; player, Monster&amp; monster)\r\n{\r\n    \/\/ If the player is dead, we can't attack the monster\r\n    if (player.isDead())\r\n        return;\r\n\r\n    std::cout &lt;&lt; \"You hit the \" &lt;&lt; monster.getName() &lt;&lt; \" for \" &lt;&lt; player.getDamage() &lt;&lt; \" damage.\\n\";\r\n\r\n    \/\/ Reduce the monster's health by the player's damage\r\n    monster.reduceHealth(player.getDamage());\r\n\r\n    \/\/ If the monster is now dead, level the player up\r\n    if (monster.isDead())\r\n    {\r\n        std::cout &lt;&lt; \"You killed the \" &lt;&lt; monster.getName() &lt;&lt; \".\\n\";\r\n        player.levelUp();\r\n        std::cout &lt;&lt; \"You are now level \" &lt;&lt; player.getLevel() &lt;&lt; \".\\n\";\r\n        std::cout &lt;&lt; \"You found \" &lt;&lt; monster.getGold() &lt;&lt; \" gold.\\n\";\r\n        player.addGold(monster.getGold());\r\n    }\r\n}\r\n\r\n\/\/ This function handles the monster attacking the player\r\nvoid attackPlayer(const Monster&amp; monster, Player&amp; player)\r\n{\r\n    \/\/ If the monster is dead, it can't attack the player\r\n    if (monster.isDead())\r\n        return;\r\n\r\n    \/\/ Reduce the player's health by the monster's damage\r\n    player.reduceHealth(monster.getDamage());\r\n    std::cout &lt;&lt; \"The \" &lt;&lt; monster.getName() &lt;&lt; \" hit you for \" &lt;&lt; monster.getDamage() &lt;&lt; \" damage.\\n\";\r\n}\r\n\r\n\/\/ This function handles the entire fight between a player and a randomly generated monster\r\nvoid fightMonster(Player&amp; player)\r\n{\r\n    \/\/ First randomly generate a monster\r\n    Monster monster{ Monster::getRandomMonster() };\r\n    std::cout &lt;&lt; \"You have encountered a \" &lt;&lt; monster.getName() &lt;&lt; \" (\" &lt;&lt; monster.getSymbol() &lt;&lt; \").\\n\";\r\n\r\n    \/\/ While the monster isn't dead and the player isn't dead, the fight continues\r\n    while (!monster.isDead() &amp;&amp; !player.isDead())\r\n    {\r\n        std::cout &lt;&lt; \"(R)un or (F)ight: \";\r\n        char input{};\r\n        std::cin &gt;&gt; input;\r\n        if (input == 'R' || input == 'r')\r\n        {\r\n            \/\/ 50% chance of fleeing successfully\r\n            if (Random::get(1, 2) == 1)\r\n            {\r\n                std::cout &lt;&lt; \"You successfully fled.\\n\";\r\n                return; \/\/ success ends the encounter\r\n            }\r\n            else\r\n            {\r\n                \/\/ Failure to flee gives the monster a free attack on the player\r\n                std::cout &lt;&lt; \"You failed to flee.\\n\";\r\n                attackPlayer(monster, player);\r\n                continue;\r\n            }\r\n        }\r\n\r\n        if (input == 'F' || input == 'f')\r\n        {\r\n            \/\/ Player attacks first, monster attacks second\r\n            attackMonster(player, monster);\r\n            attackPlayer(monster, player);\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter your name: \";\r\n    std::string playerName;\r\n    std::cin &gt;&gt; playerName;\r\n\r\n    Player player{ playerName };\r\n    std::cout &lt;&lt; \"Welcome, \" &lt;&lt; player.getName() &lt;&lt; '\\n';\r\n\r\n    \/\/ If the player isn't dead and hasn't won yet, the game continues\r\n    while (!player.isDead() &amp;&amp; !player.hasWon())\r\n        fightMonster(player);\r\n\r\n    \/\/ At this point, the player is either dead or has won\r\n    if (player.isDead())\r\n    {\r\n        std::cout &lt;&lt; \"You died at level \" &lt;&lt; player.getLevel() &lt;&lt; \" and with \" &lt;&lt; player.getGold() &lt;&lt; \" gold.\\n\";\r\n        std::cout &lt;&lt; \"Too bad you can't take it with you!\\n\";\r\n    }\r\n    else\r\n    {\r\n        std::cout &lt;&lt; \"You won the game with \" &lt;&lt; player.getGold() &lt;&lt; \" gold!\\n\";\r\n    }\r\n\r\n  return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>g) Extra credit:<br \/>\nReader <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/11-x-chapter-11-comprehensive-quiz\/comment-page-5\/#comment-471079\">Tom<\/a> didn&#8217;t sharpen his sword enough to defeat the mighty dragon.  Help him by implementing the following potions in different sizes:<\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<th>Type<\/th>\n<th>Effect (Small)<\/th>\n<th>Effect (Medium)<\/th>\n<th>Effect (Large)<\/th>\n<\/tr>\n<tr>\n<td>Health<\/td>\n<td>+2 Health<\/td>\n<td>+2 Health<\/td>\n<td>+5 Health<\/td>\n<\/tr>\n<tr>\n<td>Strength<\/td>\n<td>+1 Damage<\/td>\n<td>+1 Damage<\/td>\n<td>+1 Damage<\/td>\n<\/tr>\n<tr>\n<td>Poison<\/td>\n<td>-1 Health<\/td>\n<td>-1 Health<\/td>\n<td>-1 Health<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>Feel free to get creative and add more potions or change their effects!<\/p>\n<p>The player has a 30% chance of finding a potion after every won fight and has the choice between drinking or not drinking it. If the player doesn&#8217;t drink the potion, it disappears. The player doesn&#8217;t know what type of potion was found until the player drinks it, at which point the type and size of the potion is revealed and the effect is applied.<\/p>\n<p>In the following example, the player found a poison potion and died from drinking it (Poison was much more damaging in this example)<\/p>\n<pre>\r\nYou have encountered a slime (s).\r\n(R)un or (F)ight: f\r\nYou hit the slime for 1 damage.\r\nYou killed the slime.\r\nYou are now level 2.\r\nYou found 10 gold.\r\nYou found a mythical potion! Do you want to drink it? [y\/n]: y\r\nYou drank a Medium potion of Poison\r\nYou died at level 2 and with 10 gold.\r\nToo bad you can't take it with you!\r\n<\/pre>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_0'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_0\" style=\"display:none; margin-bottom: 1em\">Hint: Add a Potion class that has a type and size member variable, along with a member function that returns its name and a static member function the creates a random Potion, similar to the getRandomMonster() function.<br \/>\nIn the Player class, add a drinkPotion() member function the applies the potion&#8217;s effect.<\/div>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_13'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_13\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"Random.h\" \/\/ https:\/\/www.learncpp.com\/cpp-tutorial\/global-random-numbers-random-h\/\r\n#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;sstream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Potion\r\n{\r\npublic:\r\n    \/\/ All possible types of potions\r\n    enum Type\r\n    {\r\n        health,\r\n        strength,\r\n        poison,\r\n\r\n        \/\/ For random potion generation\r\n        max_type\r\n    };\r\n\r\n    enum Size\r\n    {\r\n        small,\r\n        medium,\r\n        large,\r\n\r\n        max_size\r\n    };\r\n\r\n\r\nprivate:\r\n    Type m_type{};\r\n    Size m_size{};\r\n\r\npublic:\r\n    Potion(Type type, Size size)\r\n        : m_type{ type },\r\n        m_size{ size }\r\n    {\r\n    }\r\n\r\n    Type getType() const { return m_type; }\r\n    Size getSize() const { return m_size; }\r\n\r\n    \/\/ The names of potions are compile-time literals, we can\r\n    \/\/ return a std::string_view.\r\n    static std::string_view getPotionTypeName(Type type)\r\n    {\r\n        static constexpr std::string_view names[] {\r\n          \"Health\",\r\n          \"Strength\",\r\n          \"Poison\"\r\n        };\r\n\r\n        return names[type];\r\n    }\r\n\r\n    static std::string_view getPotionSizeName(Size size)\r\n    {\r\n        static constexpr std::string_view names[] {\r\n          \"Small\",\r\n          \"Medium\",\r\n          \"Large\"\r\n        };\r\n\r\n        return names[size];\r\n    }\r\n\r\n    std::string getName() const\r\n    {\r\n        \/\/ We use a std::stringstream, but this could also be solved using\r\n        \/\/ std::string.\r\n        \/\/ We first used std::stringstream in lesson 7.13.\r\n        std::stringstream result{};\r\n\r\n        result &lt;&lt; getPotionSizeName(getSize()) &lt;&lt; \" potion of \" &lt;&lt; getPotionTypeName(getType());\r\n\r\n        \/\/ We can extract the string from an std::stringstream by using the str()\r\n        \/\/ member function.\r\n        return result.str();\r\n    }\r\n\r\n    static Potion getRandomPotion()\r\n    {\r\n        return Potion{\r\n          static_cast&lt;Type&gt;(Random::get(0, max_type - 1)),\r\n          static_cast&lt;Size&gt;(Random::get(0, max_size - 1))\r\n        };\r\n    }\r\n};\r\n\r\nclass Creature\r\n{\r\nprotected:\r\n    std::string m_name;\r\n    char m_symbol {};\r\n    int m_health {};\r\n    int m_damage {};\r\n    int m_gold {};\r\n \r\npublic:\r\n     Creature(std::string_view name, char symbol, int health, int damage, int gold)\r\n        : m_name{ name }\r\n        , m_symbol{ symbol }\r\n        , m_health{ health }\r\n        , m_damage{ damage }\r\n        , m_gold{ gold }\r\n    { }\r\n \r\n    char getSymbol() const { return m_symbol; }\r\n    const std::string&amp; getName() const { return m_name; }\r\n    bool isDead() const { return m_health &lt;= 0; }\r\n    int getGold() const { return m_gold; }\r\n    void addGold(int gold) { m_gold += gold; }\r\n    void reduceHealth(int health) { m_health -= health; }\r\n    int getHealth() const { return m_health; }\r\n    int getDamage() const { return m_damage; }\r\n};\r\n \r\nclass Player : public Creature\r\n{\r\n    int m_level{ 1 };\r\n \r\npublic:\r\n    Player(const std::string&amp; name)\r\n        : Creature{ name, '@', 10, 1, 0 }\r\n    {\r\n    }\r\n \r\n    void levelUp()\r\n    {\r\n        ++m_level;\r\n        ++m_damage;\r\n    }\r\n\r\n    \/\/ Applies a potion's effect to the player\r\n    void drinkPotion(const Potion&amp; potion)\r\n    {\r\n        switch (potion.getType())\r\n        {\r\n        case Potion::health:\r\n            \/\/ Only a health potion's size affects its power. All other\r\n            \/\/ potions are independent of size.\r\n            m_health += ((potion.getSize() == Potion::large) ? 5 : 2);\r\n            break;\r\n        case Potion::strength:\r\n            ++m_damage;\r\n            break;\r\n        case Potion::poison:\r\n            reduceHealth(1);\r\n            break;\r\n            \/\/ Handle max_type to silence the compiler warning. Don't use default:\r\n            \/\/ because we want the compiler to warn us if we add a new potion but\r\n            \/\/ forget to implement its effect.\r\n        case Potion::max_type:\r\n            break;\r\n        }\r\n    }\r\n\r\n    int getLevel() const { return m_level; }\r\n    bool hasWon() const { return m_level &gt;= 20; }\r\n};\r\n \r\nclass Monster : public Creature\r\n{\r\npublic:\r\n    enum Type\r\n    {\r\n        dragon,\r\n        orc,\r\n        slime,\r\n        max_types\r\n    };\r\n \r\nprivate:\r\n    inline static Creature monsterData[] {\r\n        Creature { \"dragon\", 'D', 20, 4, 100 },\r\n        Creature { \"orc\", 'o', 4, 2, 25 },\r\n        Creature { \"slime\", 's', 1, 1, 10 }\r\n        };\r\n\r\n    static_assert(std::size(monsterData) == max_types);\r\n\r\npublic:\r\n    Monster(Type type)\r\n        : Creature{ monsterData[type] }\r\n    {\r\n    }\r\n \r\n    static Monster getRandomMonster()\r\n    {\r\n        int num{ Random::get(0, max_types - 1) };\r\n        return Monster{ static_cast&lt;Type&gt;(num) };\r\n    }\r\n};\r\n\r\n\/\/ We moved this out of attackMonster() to keep the function shorter.\r\nvoid onMonsterKilled(Player&amp; player, const Monster&amp; monster)\r\n{\r\n    std::cout &lt;&lt; \"You killed the \" &lt;&lt; monster.getName() &lt;&lt; \".\\n\";\r\n    player.levelUp();\r\n    std::cout &lt;&lt; \"You are now level \" &lt;&lt; player.getLevel() &lt;&lt; \".\\n\";\r\n    std::cout &lt;&lt; \"You found \" &lt;&lt; monster.getGold() &lt;&lt; \" gold.\\n\";\r\n    player.addGold(monster.getGold());\r\n\r\n    \/\/ 30% chance of finding a potion\r\n    constexpr int potionChance{ 30 };\r\n    if (Random::get(1, 100) &lt;= potionChance)\r\n    {\r\n        \/\/ Generate a random potion\r\n        auto potion{ Potion::getRandomPotion() };\r\n\r\n        std::cout &lt;&lt; \"You found a mythical potion! Do you want to drink it? [y\/n]: \";\r\n        char choice{};\r\n        std::cin &gt;&gt; choice;\r\n\r\n        if (choice == 'Y' || choice == 'y')\r\n        {\r\n            \/\/ Apply the effect\r\n            player.drinkPotion(potion);\r\n            \/\/ Reveal the potion type and size\r\n            std::cout &lt;&lt; \"You drank a \" &lt;&lt; potion.getName() &lt;&lt; \".\\n\";\r\n        }\r\n    }\r\n}\r\n\r\n\/\/ This function handles the player attacking the monster\r\nvoid attackMonster(Player&amp; player, Monster&amp; monster)\r\n{\r\n    \/\/ If the player is dead, we can't attack the monster\r\n    if (player.isDead())\r\n        return;\r\n\r\n    std::cout &lt;&lt; \"You hit the \" &lt;&lt; monster.getName() &lt;&lt; \" for \" &lt;&lt; player.getDamage() &lt;&lt; \" damage.\\n\";\r\n\r\n    \/\/ Reduce the monster's health by the player's damage\r\n    monster.reduceHealth(player.getDamage());\r\n\r\n    \/\/ If the monster is now dead, level the player up\r\n    if (monster.isDead())\r\n    {\r\n        \/\/ Reward the player\r\n        onMonsterKilled(player, monster);\r\n    }\r\n}\r\n\r\n\/\/ This function handles the monster attacking the player\r\nvoid attackPlayer(const Monster&amp; monster, Player&amp; player)\r\n{\r\n    \/\/ If the monster is dead, it can't attack the player\r\n    if (monster.isDead())\r\n        return;\r\n\r\n    \/\/ Reduce the player's health by the monster's damage\r\n    player.reduceHealth(monster.getDamage());\r\n    std::cout &lt;&lt; \"The \" &lt;&lt; monster.getName() &lt;&lt; \" hit you for \" &lt;&lt; monster.getDamage() &lt;&lt; \" damage.\\n\";\r\n}\r\n\r\n\/\/ This function handles the entire fight between a player and a randomly generated monster\r\nvoid fightMonster(Player&amp; player)\r\n{\r\n    \/\/ First randomly generate a monster\r\n    Monster monster{ Monster::getRandomMonster() };\r\n    std::cout &lt;&lt; \"You have encountered a \" &lt;&lt; monster.getName() &lt;&lt; \" (\" &lt;&lt; monster.getSymbol() &lt;&lt; \").\\n\";\r\n\r\n    \/\/ While the monster isn't dead and the player isn't dead, the fight continues\r\n    while (!monster.isDead() &amp;&amp; !player.isDead())\r\n    {\r\n        std::cout &lt;&lt; \"(R)un or (F)ight: \";\r\n        char input{};\r\n        std::cin &gt;&gt; input;\r\n        if (input == 'R' || input == 'r')\r\n        {\r\n            \/\/ 50% chance of fleeing successfully\r\n            if (Random::get(1, 2) == 1)\r\n            {\r\n                std::cout &lt;&lt; \"You successfully fled.\\n\";\r\n                return; \/\/ success ends the encounter\r\n            }\r\n            else\r\n            {\r\n                \/\/ Failure to flee gives the monster a free attack on the player\r\n                std::cout &lt;&lt; \"You failed to flee.\\n\";\r\n                attackPlayer(monster, player);\r\n                continue;\r\n            }\r\n        }\r\n\r\n        if (input == 'F' || input == 'f')\r\n        {\r\n            \/\/ Player attacks first, monster attacks second\r\n            attackMonster(player, monster);\r\n            attackPlayer(monster, player);\r\n        }\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter your name: \";\r\n    std::string playerName;\r\n    std::cin &gt;&gt; playerName;\r\n\r\n    Player player{ playerName };\r\n    std::cout &lt;&lt; \"Welcome, \" &lt;&lt; player.getName() &lt;&lt; '\\n';\r\n\r\n    \/\/ If the player isn't dead and hasn't won yet, the game continues\r\n    while (!player.isDead() &amp;&amp; !player.hasWon())\r\n        fightMonster(player);\r\n\r\n    \/\/ At this point, the player is either dead or has won\r\n    if (player.isDead())\r\n    {\r\n        std::cout &lt;&lt; \"You died at level \" &lt;&lt; player.getLevel() &lt;&lt; \" and with \" &lt;&lt; player.getGold() &lt;&lt; \" gold.\\n\";\r\n        std::cout &lt;&lt; \"Too bad you can't take it with you!\\n\";\r\n    }\r\n    else\r\n    {\r\n        std::cout &lt;&lt; \"You won the game with \" &lt;&lt; player.getGold() &lt;&lt; \" gold!\\n\";\r\n    }\r\n\r\n  return 0;\r\n}<\/code><\/pre>\n<\/div>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pointers-and-references-to-the-base-class-of-derived-objects\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">25.1<\/span>Pointers and references to the base class of derived objects\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/multiple-inheritance\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">24.9<\/span>Multiple inheritance\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Inheritance allows us to model an is-a relationship between two objects. The object being inherited from is called the parent class, base class, or superclass. The object doing the inheriting is called the child class, derived class, or subclass. When a derived class inherits from a base class, the derived &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4814"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=4814"}],"version-history":[{"count":71,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4814\/revisions"}],"predecessor-version":[{"id":16617,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4814\/revisions\/16617"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=4814"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=4814"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=4814"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}