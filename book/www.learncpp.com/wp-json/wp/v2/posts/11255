{"id":11255,"date":"2021-06-17T17:50:26","date_gmt":"2021-06-18T01:50:26","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=11255"},"modified":"2024-08-21T10:03:39","modified_gmt":"2024-08-21T17:03:39","slug":"function-template-instantiation","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/function-template-instantiation\/","title":{"rendered":"11.7 &#8212; Function template instantiation"},"content":{"rendered":"<p>In the previous lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-templates\/\">11.6 -- Function templates<\/a>), we introduced function templates, and converted a normal <code>max()<\/code> function into a <code>max&lt;T&gt;<\/code> function template:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;typename T&gt;\r\nT max(T x, T y)\r\n{\r\n    return (x &lt; y) ? y : x;\r\n}<\/code><\/pre>\n<p>In this lesson, we&#8217;ll focus on how function templates are used.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using a function template<\/p>\n<p>Function templates are not actually functions -- their code isn&#8217;t compiled or executed directly.  Instead, function templates have one job: to generate functions (that are compiled and executed).<\/p>\n<p>To use our <code>max&lt;T&gt;<\/code> function template, we can make a function call with the following syntax:<\/p>\n<pre>\r\nmax&lt;actual_type&gt;(arg1, arg2); \/\/ actual_type is some actual type, like int or double\r\n<\/pre>\n<p>This looks a lot like a normal function call -- the primary difference is the addition of the type in angled brackets (called a <strong>template argument<\/strong>), which specifies the actual type that will be used in place of template type <code>T<\/code>.<\/p>\n<p>Let&#8217;s take a look at this in a simple example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nT max(T x, T y)\r\n{\r\n    return (x &lt; y) ? y : x;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; max&lt;int&gt;(1, 2) &lt;&lt; '\\n'; \/\/ instantiates and calls function max&lt;int&gt;(int, int)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When the compiler encounters the function call <code>max&lt;int&gt;(1, 2)<\/code>, it will determine that a function definition for <code>max&lt;int&gt;(int, int)<\/code> does not already exist.  Consequently, the compiler will implicitly use our <code>max&lt;T&gt;<\/code> function template to create one.<\/p>\n<p>The process of creating functions (with specific types) from function templates (with template types) is called <strong>function template instantiation<\/strong> (or <strong>instantiation<\/strong> for short).  When a function is instantiated due to a function call, it&#8217;s called <strong>implicit instantiation<\/strong>.  A function that is instantiated from a template is technically called a <strong>specialization<\/strong>, but in common language is often called a <strong>function instance<\/strong>.  The template from which a specialization is produced is called a <strong>primary template<\/strong>.  Function instances are normal functions in all regards.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Nomenclature<\/p>\n<p>The term &#8220;specialization&#8221; is more often used to refer to explicit specialization, which allows us to explicitly define a specialization (rather than have it implicitly instantiated from the primary template).  We cover explicit specialization in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-template-specialization\/\">26.3 -- Function template specialization<\/a>.\n<\/p><\/div>\n<p>The process for instantiating a function is simple: the compiler essentially clones the primary template and replaces the template type (<code>T<\/code>) with the actual type we&#8217;ve specified (<code>int<\/code>).<\/p>\n<p>So when we call <code>max&lt;int&gt;(1, 2)<\/code>, the function specialization that gets instantiated looks something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template&lt;&gt; \/\/ ignore this for now\r\nint max&lt;int&gt;(int x, int y) \/\/ the generated function max&lt;int&gt;(int, int)\r\n{\r\n    return (x &lt; y) ? y : x;\r\n}<\/code><\/pre>\n<p>Here&#8217;s the same example as above, showing what the compiler actually compiles after all instantiations are done:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ a declaration for our function template (we don't need the definition any more)\r\ntemplate &lt;typename T&gt; \r\nT max(T x, T y);\r\n\r\ntemplate&lt;&gt;\r\nint max&lt;int&gt;(int x, int y) \/\/ the generated function max&lt;int&gt;(int, int)\r\n{\r\n    return (x &lt; y) ? y : x;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; max&lt;int&gt;(1, 2) &lt;&lt; '\\n'; \/\/ instantiates and calls function max&lt;int&gt;(int, int)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>You can compile this yourself and see that it works.  A function template is only instantiated the first time a function call is made in each translation unit.  Further calls to the function are routed to the already instantiated function.<\/p>\n<p>Conversely, if no function call is made to a function template, the function template won&#8217;t be instantiated in that translation unit.<\/p>\n<p>Let&#8217;s do another example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nT max(T x, T y) \/\/ function template for max(T, T)\r\n{\r\n    return (x &lt; y) ? y : x;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; max&lt;int&gt;(1, 2) &lt;&lt; '\\n';    \/\/ instantiates and calls function max&lt;int&gt;(int, int)\r\n    std::cout &lt;&lt; max&lt;int&gt;(4, 3) &lt;&lt; '\\n';    \/\/ calls already instantiated function max&lt;int&gt;(int, int)\r\n    std::cout &lt;&lt; max&lt;double&gt;(1, 2) &lt;&lt; '\\n'; \/\/ instantiates and calls function max&lt;double&gt;(double, double)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This works similarly to the previous example, but our function template will be used to generate two functions this time: one time replacing <code>T<\/code> with <code>int<\/code>, and the other time replacing <code>T<\/code> with <code>double<\/code>.  After all instantiations, the program will look something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ a declaration for our function template (we don't need the definition any more)\r\ntemplate &lt;typename T&gt;\r\nT max(T x, T y); \r\n\r\ntemplate&lt;&gt;\r\nint max&lt;int&gt;(int x, int y) \/\/ the generated function max&lt;int&gt;(int, int)\r\n{\r\n    return (x &lt; y) ? y : x;\r\n}\r\n\r\ntemplate&lt;&gt;\r\ndouble max&lt;double&gt;(double x, double y) \/\/ the generated function max&lt;double&gt;(double, double)\r\n{\r\n    return (x &lt; y) ? y : x;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; max&lt;int&gt;(1, 2) &lt;&lt; '\\n';    \/\/ instantiates and calls function max&lt;int&gt;(int, int)\r\n    std::cout &lt;&lt; max&lt;int&gt;(4, 3) &lt;&lt; '\\n';    \/\/ calls already instantiated function max&lt;int&gt;(int, int)\r\n    std::cout &lt;&lt; max&lt;double&gt;(1, 2) &lt;&lt; '\\n'; \/\/ instantiates and calls function max&lt;double&gt;(double, double)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>One additional thing to note here: when we instantiate <code>max&lt;double&gt;<\/code>, the instantiated function has parameters of type <code>double<\/code>.  Because we&#8217;ve provided <code>int<\/code> arguments, those arguments will be implicitly converted to <code>double<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Template argument deduction<\/p>\n<p>In most cases, the actual types we want to use for instantiation will match the type of our function parameters.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::cout &lt;&lt; max&lt;int&gt;(1, 2) &lt;&lt; '\\n'; \/\/ specifying we want to call max&lt;int&gt;<\/code><\/pre>\n<p>In this function call, we&#8217;ve specified that we want to replace <code>T<\/code> with <code>int<\/code>, but we&#8217;re also calling the function with <code>int<\/code> arguments.<\/p>\n<p>In cases where the type of the arguments match the actual type we want, we do not need to specify the actual type -- instead, we can use <strong>template argument deduction<\/strong> to have the compiler deduce the actual type that should be used from the argument types in the function call.<\/p>\n<p>For example, instead of making a function call like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::cout &lt;&lt; max&lt;int&gt;(1, 2) &lt;&lt; '\\n'; \/\/ specifying we want to call max&lt;int&gt;<\/code><\/pre>\n<p>We can do one of these instead:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::cout &lt;&lt; max&lt;&gt;(1, 2) &lt;&lt; '\\n';\r\nstd::cout &lt;&lt; max(1, 2) &lt;&lt; '\\n';<\/code><\/pre>\n<p>In either case, the compiler will see that we haven&#8217;t provided an actual type, so it will attempt to deduce an actual type from the function arguments that will allow it to generate a <code>max()<\/code> function where all template parameters match the type of the provided arguments.  In this example, the compiler will deduce that using function template <code>max&lt;T&gt;<\/code> with actual type <code>int<\/code> allows it to instantiate function <code>max&lt;int&gt;(int, int)<\/code>, so that the type of both function parameters (<code>int<\/code>) matches the type of the provided arguments (<code>int<\/code>).<\/p>\n<p>The difference between the two cases has to do with how the compiler resolves the function call from a set of overloaded functions.  In the top case (with the empty angled brackets), the compiler will only consider <code>max&lt;int&gt;<\/code> template function overloads when determining which overloaded function to call.  In the bottom case (with no angled brackets), the compiler will consider both <code>max&lt;int&gt;<\/code> template function overloads and <code>max<\/code> non-template function overloads.  When the bottom case results in both a template function and a non-template function that are equally viable, the non-template function will be preferred.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>The normal function call syntax will prefer a non-template function over an equally viable function instantiated from a template.\n<\/p><\/div>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nT max(T x, T y)\r\n{\r\n    std::cout &lt;&lt; \"called max&lt;int&gt;(int, int)\\n\";\r\n    return (x &lt; y) ? y : x;\r\n}\r\n\r\nint max(int x, int y)\r\n{\r\n    std::cout &lt;&lt; \"called max(int, int)\\n\";\r\n    return (x &lt; y) ? y : x;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; max&lt;int&gt;(1, 2) &lt;&lt; '\\n'; \/\/ calls max&lt;int&gt;(int, int)\r\n    std::cout &lt;&lt; max&lt;&gt;(1, 2) &lt;&lt; '\\n';    \/\/ deduces max&lt;int&gt;(int, int) (non-template functions not considered)\r\n    std::cout &lt;&lt; max(1, 2) &lt;&lt; '\\n';      \/\/ calls max(int, int)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Note how the syntax in the bottom case looks identical to a normal function call!  In most cases, this normal function call syntax will be the one we use to call functions instantiated from a function template.<\/p>\n<p>There are a few reasons for this:<\/p>\n<ul>\n<li>The syntax is more concise.\n<\/li>\n<li>It&#8217;s rare that we&#8217;ll have both a matching non-template function and a function template.\n<\/li>\n<li>If we do have a matching non-template function and a matching function template, we will usually prefer the non-template function to be called.\n<\/li>\n<\/ul>\n<p>That last point may be non-obvious.  A function template has an implementation that works for multiple types -- but as a result, it must be generic.  A non-template function only handles a specific combination of types.  It can have an implementation that is more optimized or more specialized for those specific types than the function template version.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ This function template can handle many types, so its implementation is generic\r\ntemplate &lt;typename T&gt;\r\nvoid print(T x)\r\n{\r\n    std::cout &lt;&lt; x; \/\/ print T however it normally prints\r\n}\r\n\r\n\/\/ This function only needs to consider how to print a bool, so it can specialize how it handles\r\n\/\/ printing of a bool\r\nvoid print(bool x)\r\n{\r\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; x; \/\/ print bool as true or false, not 1 or 0\r\n}\r\n\r\nint main()\r\n{\r\n    print&lt;bool&gt;(true); \/\/ calls print&lt;bool&gt;(bool) -- prints 1\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    print&lt;&gt;(true);     \/\/ deduces print&lt;bool&gt;(bool) (non-template functions not considered) -- prints 1\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    print(true);       \/\/ calls print(bool) -- prints true\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Favor the normal function call syntax when making calls to a function instantiated from a function template (unless you need the function template version to be preferred over a matching non-template function).\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Function templates with non-template parameters<\/p>\n<p>It&#8217;s possible to create function templates that have both template parameters and non-template parameters.  The type template parameters can be matched to any type, and the non-template parameters work like the parameters of normal functions.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ T is a type template parameter\r\n\/\/ double is a non-template parameter\r\n\/\/ We don't need to provide names for these parameters since they aren't used\r\ntemplate &lt;typename T&gt;\r\nint someFcn(T, double)\r\n{\r\n    return 5;\r\n}\r\n\r\nint main()\r\n{\r\n    someFcn(1, 3.4); \/\/ matches someFcn(int, double)\r\n    someFcn(1, 3.4f); \/\/ matches someFcn(int, double) -- the float is promoted to a double\r\n    someFcn(1.2, 3.4); \/\/ matches someFcn(double, double)\r\n    someFcn(1.2f, 3.4); \/\/ matches someFcn(float, double)\r\n    someFcn(1.2f, 3.4f); \/\/ matches someFcn(float, double) -- the float is promoted to a double\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This function template has a templated first parameter, but the second parameter is fixed with type <code>double<\/code>.  Note that the return type can also be any type.  In this case, our function will always return an <code>int<\/code> value.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Instantiated functions may not always compile<\/p>\n<p>Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nT addOne(T x)\r\n{\r\n    return x + 1;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; addOne(1) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; addOne(2.3) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The compiler will effectively compile and execute this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nT addOne(T x);\r\n\r\ntemplate&lt;&gt;\r\nint addOne&lt;int&gt;(int x)\r\n{\r\n    return x + 1;\r\n}\r\n\r\ntemplate&lt;&gt;\r\ndouble addOne&lt;double&gt;(double x)\r\n{\r\n    return x + 1;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; addOne(1) &lt;&lt; '\\n';   \/\/ calls addOne&lt;int&gt;(int)\r\n    std::cout &lt;&lt; addOne(2.3) &lt;&lt; '\\n'; \/\/ calls addOne&lt;double&gt;(double)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>which will produce the result:<\/p>\n<pre>\r\n2\r\n3.3\r\n<\/pre>\n<p>But what if we try something like this?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nT addOne(T x)\r\n{\r\n    return x + 1;\r\n}\r\n\r\nint main()\r\n{\r\n    std::string hello { \"Hello, world!\" };\r\n    std::cout &lt;&lt; addOne(hello) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When the compiler tries to resolve <code>addOne(hello)<\/code> it won&#8217;t find a non-template function match for <code>addOne(std::string)<\/code>, but it will find our function template for <code>addOne(T)<\/code>, and determine that it can generate an <code>addOne(std::string)<\/code> function from it.  Thus, the compiler will generate and compile this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nT addOne(T x);\r\n\r\ntemplate&lt;&gt;\r\nstd::string addOne&lt;std::string&gt;(std::string x)\r\n{\r\n    return x + 1;\r\n}\r\n\r\nint main()\r\n{\r\n    std::string hello{ \"Hello, world!\" };\r\n    std::cout &lt;&lt; addOne(hello) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, this will generate a compile error, because <code>x + 1<\/code> doesn&#8217;t make sense when <code>x<\/code> is a <code>std::string<\/code>.  The obvious solution here is simply not to call <code>addOne()<\/code> with an argument of type <code>std::string<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Instantiated functions may not always make sense semantically<\/p>\n<p>The compiler will successfully compile an instantiated function template as long as it makes sense syntactically.  However, the compiler does not have any way to check that such a function actually makes sense semantically.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nT addOne(T x)\r\n{\r\n    return x + 1;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; addOne(\"Hello, world!\") &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this example, we&#8217;re calling <code>addOne()<\/code> on a C-style string literal.  What does that actually mean semantically?  Who knows!<\/p>\n<p>Perhaps surprisingly, because C++ syntactically allows addition of an integer value to a string literal (we cover this in future lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pointer-arithmetic-and-subscripting\/\">17.9 -- Pointer arithmetic and subscripting<\/a>), the above example compiles, and produces the following result:<\/p>\n<pre>\nello, world!\r\n<\/pre>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>The compiler will instantiate and compile function templates that do not make sense semantically as long as they are syntactically valid.  It is your responsibility to make sure you are calling such function templates with arguments that make sense.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>We can tell the compiler that instantiation of function templates with certain arguments should be disallowed.  This is done by using function template specialization, which allow us to overload a function template for a specific set of template arguments, along with <code>= delete<\/code>, which tells the compiler that any use of the function should emit a compilation error.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nT addOne(T x)\r\n{\r\n    return x + 1;\r\n}\r\n\r\n\/\/ Use function template specialization to tell the compiler that addOne(const char*) should emit a compilation error\r\n\/\/ const char* will match a string literal\r\ntemplate &lt;&gt;\r\nconst char* addOne(const char* x) = delete;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; addOne(\"Hello, world!\") &lt;&lt; '\\n'; \/\/ compile error\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>We cover function template specialization in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-template-specialization\/\">26.3 -- Function template specialization<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Function templates and default arguments for non-template parameters<\/p>\n<p>Just like normal functions, function templates can have default arguments for non-template parameters.  Each function instantiated from the template will use the same default argument.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nvoid print(T val, int times=1)\r\n{\r\n    while (times--)\r\n    {\r\n        std::cout &lt;&lt; val;        \r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    print(5);      \/\/ print 5 1 time\r\n    print('a', 3); \/\/ print 'a' 3 times\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n5aaa\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Beware function templates with modifiable static local variables<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/static-local-variables\/\">7.11 -- Static local variables<\/a>, we discussed static local variables, which are local variables with static duration (they persist for the lifetime of the program).<\/p>\n<p>When a static local variable is used in a function template, each function instantiated from that template will have a separate version of the static local variable.  This is rarely a problem if the static local variable is const.  But if the static local variable is one that is modified, the results may not be as expected.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ Here's a function template with a static local variable that is modified\r\ntemplate &lt;typename T&gt;\r\nvoid printIDAndValue(T value)\r\n{\r\n    static int id{ 0 };\r\n    std::cout &lt;&lt; ++id &lt;&lt; \") \" &lt;&lt; value &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    printIDAndValue(12);\r\n    printIDAndValue(13);\r\n\r\n    printIDAndValue(14.5);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This produces the result:<\/p>\n<pre>\n1) 12\r\n2) 13\r\n1) 14.5\r\n<\/pre>\n<p>You may have been expecting the last line to print <code>3) 14.5<\/code>.  However, this is what the compiler actually compiles and executes:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nvoid printIDAndValue(T value);\r\n\r\ntemplate &lt;&gt;\r\nvoid printIDAndValue&lt;int&gt;(int value)\r\n{\r\n    static int id{ 0 };\r\n    std::cout &lt;&lt; ++id &lt;&lt; \") \" &lt;&lt; value &lt;&lt; '\\n';\r\n}\r\n\r\ntemplate &lt;&gt;\r\nvoid printIDAndValue&lt;double&gt;(double value)\r\n{\r\n    static int id{ 0 };\r\n    std::cout &lt;&lt; ++id &lt;&lt; \") \" &lt;&lt; value &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    printIDAndValue(12);   \/\/ calls printIDAndValue&lt;int&gt;()\r\n    printIDAndValue(13);   \/\/ calls printIDAndValue&lt;int&gt;()\r\n\r\n    printIDAndValue(14.5); \/\/ calls printIDAndValue&lt;double&gt;()\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Note that <code>printIDAndValue&lt;int&gt;<\/code> and <code>printIDAndValue&lt;double&gt;<\/code> each have their own independent static local variable named <code>id<\/code>, not one that is shared between them.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Generic programming<\/p>\n<p>Because template types can be replaced with any actual type, template types are sometimes called <strong>generic types<\/strong>.  And because templates can be written agnostically of specific types, programming with templates is sometimes called <strong>generic programming<\/strong>.  Whereas C++ typically has a strong focus on types and type checking, in contrast, generic programming lets us focus on the logic of algorithms and design of data structures without having to worry so much about type information.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Conclusion<\/p>\n<p>Once you get used to writing function templates, you&#8217;ll find they actually don&#8217;t take much longer to write than functions with actual types.  Function templates can significantly reduce code maintenance and errors by minimizing the amount of code that needs to be written and maintained.<\/p>\n<p>Function templates do have a few drawbacks, and we would be remiss not to mention them.  First, the compiler will create (and compile) a function for each function call with a unique set of argument types.  So while function templates are compact to write, they can expand into a crazy amount of code, which can lead to code bloat and slow compile times.  The bigger downside of function templates is that they tend to produce crazy-looking, borderline unreadable error messages that are much harder to decipher than those of regular functions.  These error messages can be quite intimidating, but once you understand what they are trying to tell you, the problems they are pinpointing are often quite straightforward to resolve.<\/p>\n<p>These drawbacks are fairly minor compared with the power and safety that templates bring to your programming toolkit, so use templates liberally anywhere you need type flexibility!  A good rule of thumb is to create normal functions at first, and then convert them into function templates if you find you need an overload for different parameter types.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Use function templates to write generic code that can work with a wide variety of types whenever you have the need.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-templates-with-multiple-template-types\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">11.8<\/span>Function templates with multiple template types\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-templates\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">11.6<\/span>Function templates\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the previous lesson (), we introduced function templates, and converted a normal max() function into a max&lt;T&gt; function template: template &lt;typename T&gt; T max(T x, T y) { return (x &lt; y) ? y : x; } In this lesson, we&#8217;ll focus on how function templates are used. Using &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/11255"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=11255"}],"version-history":[{"count":45,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/11255\/revisions"}],"predecessor-version":[{"id":11270,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/11255\/revisions\/11270"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=11255"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=11255"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=11255"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}