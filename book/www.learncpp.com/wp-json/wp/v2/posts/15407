{"id":15407,"date":"2023-09-11T14:43:36","date_gmt":"2023-09-11T21:43:36","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15407"},"modified":"2024-05-08T15:42:16","modified_gmt":"2024-05-08T22:42:16","slug":"array-indexing-and-length-using-enumerators","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/array-indexing-and-length-using-enumerators\/","title":{"rendered":"16.9 &#8212; Array indexing and length using enumerators"},"content":{"rendered":"<p>One of the bigger documentation problems with arrays is that integer indices do not provide any information to the programmer about the meaning of the index.<\/p>\n<p>Consider an array holding 5 test scores:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::vector testScores { 78, 94, 66, 77, 14 };\r\n\r\n    testScores[2] = 76; \/\/ who does this represent?\r\n}<\/code><\/pre>\n<p>Who is the student represented by <code>testScores[2]<\/code>?  It&#8217;s not clear.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using unscoped enumerators for indexing<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdvector-and-the-unsigned-length-and-subscript-problem\/\">16.3 -- std::vector and the unsigned length and subscript problem<\/a>, we spent a lot of time discussing how the index of <code>std::vector&lt;T&gt;::operator[]<\/code> (and the other C++ container classes that can be subscripted) has type <code>size_type<\/code>, which is generally an alias for <code>std::size_t<\/code>.  Therefore, our indices either need to be of type <code>std::size_t<\/code>, or a type that converts to <code>std::size_t<\/code>.<\/p>\n<p>Since unscoped enumerations will implicitly convert to a <code>std::size_t<\/code>, this means we can use unscoped enumerations as array indices to help document the meaning of the index:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;vector&gt;\r\n\r\nnamespace Students\r\n{\r\n    enum Names\r\n    {\r\n        kenny, \/\/ 0\r\n        kyle, \/\/ 1\r\n        stan, \/\/ 2\r\n        butters, \/\/ 3\r\n        cartman, \/\/ 4\r\n        max_students \/\/ 5\r\n    };\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector testScores { 78, 94, 66, 77, 14 };\r\n\r\n    testScores[Students::stan] = 76; \/\/ we are now updating the test score belonging to stan\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this way, it&#8217;s much clearer what each of the array elements represents.<\/p>\n<p>Because enumerators are implicitly constexpr, conversion of an enumerator to an unsigned integral type is not considered a narrowing conversion, thus avoiding signed\/unsigned indexing problems.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using a non-constexpr unscoped enumeration for indexing<\/p>\n<p>The underlying type of an unscoped enumeration is implementation defined (and thus, could be either a signed or unsigned integral type).  Because enumerators are implicitly constexpr, as long as we stick to indexing with unscoped enumerators, we won&#8217;t run into sign conversion issues.<\/p>\n<p>However, if we define a non-constexpr variable of the enumeration type, and then try to index our <code>std::vector<\/code> with that, we may get sign conversion warnings on any platform that defaults unscoped enumerations to a signed type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;vector&gt;\r\n\r\nnamespace Students\r\n{\r\n    enum Names\r\n    {\r\n        kenny, \/\/ 0\r\n        kyle, \/\/ 1\r\n        stan, \/\/ 2\r\n        butters, \/\/ 3\r\n        cartman, \/\/ 4\r\n        max_students \/\/ 5\r\n    };\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector testScores { 78, 94, 66, 77, 14 };\r\n    Students::Names name { Students::stan }; \/\/ non-constexpr\r\n\r\n    testScores[name] = 76; \/\/ may trigger a sign conversion warning if Student::Names defaults to a signed underlying type\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this particular case, we could make <code>name<\/code> constexpr (so that the conversion from a constexpr signed integral type to <code>std::size_t<\/code> is non-narrowing).  However, that won&#8217;t work when our initializer isn&#8217;t a constant expression.<\/p>\n<p>An alternate option is to explicitly specify the underlying type of the enumeration to be an unsigned int:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;vector&gt;\r\n\r\nnamespace Students\r\n{\r\n    enum Names : unsigned int \/\/ explicitly specifies the underlying type is unsigned int\r\n    {\r\n        kenny, \/\/ 0\r\n        kyle, \/\/ 1\r\n        stan, \/\/ 2\r\n        butters, \/\/ 3\r\n        cartman, \/\/ 4\r\n        max_students \/\/ 5\r\n    };\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector testScores { 78, 94, 66, 77, 14 };\r\n    Students::Names name { Students::stan }; \/\/ non-constexpr\r\n\r\n    testScores[name] = 76; \/\/ not a sign conversion since name is unsigned\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the example above, since <code>name<\/code> is now guaranteed to be an <code>unsigned int<\/code>, it can be converted to a <code>std::size_t<\/code> without sign conversion issues.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using a count enumerator<\/p>\n<p>Note that we have defined an extra enumerator at the end of the enumerator list named <code>max_students<\/code>.  If all the prior enumerators are using default values (which is recommended) this enumerator will have a default value matching the count of the preceding enumerators.  In the example above, <code>max_students<\/code> has value <code>5<\/code>, as there are 5 enumerators defined prior.  Informally, we&#8217;ll call this a <strong>count enumerator<\/strong>, as its value represents the count of previously defined enumerators.<\/p>\n<p>This count enumerator can then be used anywhere we need a count of the prior enumerators.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nnamespace Students\r\n{\r\n    enum Names\r\n    {\r\n        kenny, \/\/ 0\r\n        kyle, \/\/ 1\r\n        stan, \/\/ 2\r\n        butters, \/\/ 3\r\n        cartman, \/\/ 4\r\n        \/\/ add future enumerators here\r\n        max_students \/\/ 5\r\n    };\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector&lt;int&gt; testScores(Students::max_students); \/\/ Create a vector with 5 elements\r\n\r\n    testScores[Students::stan] = 76; \/\/ we are now updating the test score belonging to stan\r\n\r\n    std::cout &lt;&lt; \"The class has \" &lt;&lt; Students::max_students &lt;&lt; \" students\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>We use <code>max_students<\/code> in two places: first, we create a <code>std::vector<\/code> with a length of <code>max_students<\/code>, so the vector will have one element per student.  We also use <code>max_students<\/code> to print the number of students.<\/p>\n<p>This technique is also nice because if another enumerator is added later (just before <code>max_students<\/code>), then <code>max_students<\/code> will automatically become one larger, and all our arrays using <code>max_students<\/code> will update to use the new length without further modification.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;vector&gt;\r\n#include &lt;iostream&gt;\r\n\r\nnamespace Students\r\n{\r\n    enum Names\r\n    {\r\n        kenny, \/\/ 0\r\n        kyle, \/\/ 1\r\n        stan, \/\/ 2\r\n        butters, \/\/ 3\r\n        cartman, \/\/ 4\r\n        wendy, \/\/ 5 (added)\r\n        \/\/ add future enumerators here\r\n        max_students \/\/ now 6\r\n    };\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector&lt;int&gt; testScores(Students::max_students); \/\/ will now allocate 6 elements\r\n\r\n    testScores[Students::stan] = 76; \/\/ still works\r\n\r\n    std::cout &lt;&lt; \"The class has \" &lt;&lt; Students::max_students &lt;&lt; \" students\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Asserting on array length with a count enumerator<\/p>\n<p>More often, we&#8217;re creating an array using an initializer list of values, with the intent of indexing that array with enumerators.  In such cases, it can be useful to assert that the size of the container equals our count enumerator.  If this assert triggers, then either our enumerator list is incorrect somehow, or we have provided the wrong number of initializers.  This can easily happen when a new enumerator is added to the enumeration, but a new initialization value is not added to the array.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nenum StudentNames\r\n{\r\n    kenny, \/\/ 0\r\n    kyle, \/\/ 1\r\n    stan, \/\/ 2\r\n    butters, \/\/ 3\r\n    cartman, \/\/ 4\r\n    max_students \/\/ 5\r\n};\r\n\r\nint main()\r\n{\r\n    std::vector testScores { 78, 94, 66, 77, 14 };\r\n\r\n    \/\/ Ensure the number of test scores is the same as the number of students\r\n    assert(std::size(testScores) == max_students);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>If your array is constexpr, then you should <code>static_assert<\/code> instead.  <code>std::vector<\/code> doesn&#8217;t support constexpr, but <code>std::array<\/code> (and C-style arrays) do.<\/p>\n<p>We discuss this further in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/passing-and-returning-stdarray\/\">17.3 -- Passing and returning std::array<\/a>.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Use a <code>static_assert<\/code> to ensure the length of your constexpr array matches your count enumerator.<br \/>\nUse an <code>assert<\/code> to ensure the length of your non-constexpr array matches your count enumerator.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Arrays and enum classes<\/p>\n<p>Because unscoped enumerations pollute the namespace they are defined in with their enumerators, it is preferable to use enum classes in cases where the enum is not already contained in another scope region (e.g. a namespace or class).<\/p>\n<p>However, because enum classes don&#8217;t have an implicit conversion to integral types, we run into a problem when we try to use their enumerators as array indices:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nenum class StudentNames \/\/ now an enum class\r\n{\r\n    kenny, \/\/ 0\r\n    kyle, \/\/ 1\r\n    stan, \/\/ 2\r\n    butters, \/\/ 3\r\n    cartman, \/\/ 4\r\n    max_students \/\/ 5\r\n};\r\n\r\nint main()\r\n{\r\n    \/\/ compile error: no conversion from StudentNames to std::size_t\r\n    std::vector&lt;int&gt; testScores(StudentNames::max_students);\r\n\r\n    \/\/ compile error: no conversion from StudentNames to std::size_t\r\n    testScores[StudentNames::stan] = 76;\r\n\r\n    \/\/ compile error: no conversion from StudentNames to any type that operator&lt;&lt; can output\r\n    std::cout &lt;&lt; \"The class has \" &lt;&lt; StudentNames::max_students &lt;&lt; \" students\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>There are a couple of ways to address this.  Most obviously, we can <code>static_cast<\/code> the enumerator to an integer:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nenum class StudentNames\r\n{\r\n    kenny, \/\/ 0\r\n    kyle, \/\/ 1\r\n    stan, \/\/ 2\r\n    butters, \/\/ 3\r\n    cartman, \/\/ 4\r\n    max_students \/\/ 5\r\n};\r\n\r\nint main()\r\n{\r\n    std::vector&lt;int&gt; testScores(static_cast&lt;int&gt;(StudentNames::max_students));\r\n\r\n    testScores[static_cast&lt;int&gt;(StudentNames::stan)] = 76;\r\n\r\n    std::cout &lt;&lt; \"The class has \" &lt;&lt; static_cast&lt;int&gt;(StudentNames::max_students) &lt;&lt; \" students\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, this is not only a pain to type, it also clutters up our code significantly.<\/p>\n<p>A better option is to use the helper function that we introduced in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/scoped-enumerations-enum-classes\/#operatorplus\">13.6 -- Scoped enumerations (enum classes)<\/a>, which allows us to convert the enumerators of enum classes to integral values using unary <code>operator+<\/code>.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;type_traits&gt; \/\/ for std::underlying_type_t\r\n#include &lt;vector&gt;\r\n\r\nenum class StudentNames\r\n{\r\n    kenny, \/\/ 0\r\n    kyle, \/\/ 1\r\n    stan, \/\/ 2\r\n    butters, \/\/ 3\r\n    cartman, \/\/ 4\r\n    max_students \/\/ 5\r\n};\r\n\r\n\/\/ Overload the unary + operator to convert StudentNames to the underlying type\r\nconstexpr auto operator+(StudentNames a) noexcept\r\n{\r\n    return static_cast&lt;std::underlying_type_t&lt;StudentNames&gt;&gt;(a);\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector&lt;int&gt; testScores(+StudentNames::max_students);\r\n\r\n    testScores[+StudentNames::stan] = 76;\r\n\r\n    std::cout &lt;&lt; \"The class has \" &lt;&lt; +StudentNames::max_students &lt;&lt; \" students\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, if you&#8217;re going to be doing a lot of enumerator to integral conversions, it&#8217;s probably better to just use a standard enum inside a namespace (or class).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Create a program-defined enum (inside a namespace) containing the names of the following animals: chicken, dog, cat, elephant, duck, and snake.  Define an array with an element for each of these animals, and use an initializer list to initialize each element to hold the number of legs that animal has.  Assert that the array has the correct number of initializers.<\/p>\n<p>Write a main() function that prints the number of legs an elephant has, using the enumerator.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nnamespace Animals\r\n{\r\n    enum Animals\r\n    {\r\n        chicken,\r\n        dog,\r\n        cat,\r\n        elephant,\r\n        duck,\r\n        snake,\r\n        max_animals\r\n    };\r\n\r\n    const std::vector legs{ 2, 4, 4, 4, 2, 0 };\r\n}\r\n\r\nint main()\r\n{\r\n    \/\/ Ensure the number of legs is the same as the number of animals\r\n    assert(std::size(Animals::legs) == Animals::max_animals);\r\n\r\n    std::cout &lt;&lt; \"An elephant has \" &lt;&lt; Animals::legs[Animals::elephant] &lt;&lt; \" legs.\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdvector-resizing-and-capacity\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">16.10<\/span>std::vector resizing and capacity\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/range-based-for-loops-for-each\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">16.8<\/span>Range-based for loops (for-each)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>One of the bigger documentation problems with arrays is that integer indices do not provide any information to the programmer about the meaning of the index. Consider an array holding 5 test scores: #include &lt;vector&gt; int main() { std::vector testScores { 78, 94, 66, 77, 14 }; testScores[2] = 76; &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15407"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15407"}],"version-history":[{"count":13,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15407\/revisions"}],"predecessor-version":[{"id":17028,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15407\/revisions\/17028"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15407"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15407"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15407"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}