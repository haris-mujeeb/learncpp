{"id":15965,"date":"2023-10-23T13:50:10","date_gmt":"2023-10-23T20:50:10","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15965"},"modified":"2024-12-02T12:03:04","modified_gmt":"2024-12-02T20:03:04","slug":"chapter-5-summary-and-quiz","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-5-summary-and-quiz\/","title":{"rendered":"5.x &#8212; Chapter 5 summary and quiz"},"content":{"rendered":"<p class=\"cpp-section\">Chapter Review<\/p>\n<p>A <strong>constant<\/strong> is a value that may not be changed during the program&#8217;s execution.  C++ supports two types of constants: named constants, and literals.<\/p>\n<p>A <strong>named constant<\/strong> is a constant value that is associated with an identifier.  A <strong>Literal constant<\/strong> is a constant value not associated with an identifier.<\/p>\n<p>A variable whose value can not be changed is called a <strong>constant variable<\/strong>.  The <strong>const<\/strong> keyword can be used to make a variable constant.  Constant variables must be initialized.  Avoid using <code>const<\/code> when passing by value or returning by value.<\/p>\n<p>A <strong>type qualifier<\/strong> is a keyword that is applied to a type that modifies how that type behaves.  As of C++23, C++ only supports <code>const<\/code> and <code>volatile<\/code> as type qualifiers.<\/p>\n<p>A <strong>constant expression<\/strong> is an expression that can be evaluated at compile-time.  An expression that is not a constant expression is sometimes called a <strong>runtime expression<\/strong>.<\/p>\n<p>A <strong>compile-time constant<\/strong> is a constant whose value is known at compile-time.  A <strong>runtime constant<\/strong> is a constant whose initialization value isn&#8217;t known until runtime.<\/p>\n<p>A <strong>constexpr<\/strong> variable must be a compile-time constant, and initialized with a constant expression.  Function parameters cannot be constexpr.<\/p>\n<p><strong>Literals<\/strong> are values inserted directly into the code.  Literals have types, and literal suffixes can be used to change the type of a literal from the default type.<\/p>\n<p>A <strong>magic number<\/strong> is a literal (usually a number) that either has an unclear meaning or may need to be changed later.  Don&#8217;t use magic numbers in your code.  Instead, use symbolic constants.<\/p>\n<p>In everyday life, we count using <strong>decimal<\/strong> numbers, which have 10 digits.  Computers use <strong>binary<\/strong>, which only has 2 digits.  C++ also supports <strong>octal<\/strong> (base 8) and <strong>hexadecimal<\/strong> (base 16).  These are all examples of <strong>numeral systems<\/strong>, which are collections of symbols (digits) used to represent numbers.<\/p>\n<p>A <strong>string<\/strong> is a collection of sequential characters that is used to represent text (such as names, words, and sentences).  String literals are always placed between double quotes.  String literals in C++ are C-style strings, which have a strange type that is hard to work with.<\/p>\n<p><strong>std::string<\/strong> offers an easy and safe way to deal with text strings.  std::string lives in the &lt;string&gt; header.  <code>std::string<\/code> is expensive to initialize (or assign to) and copy.<\/p>\n<p><strong>std::string_view<\/strong> provides read-only access to an existing string (a C-style string literal, a std::string, or a char array) without making a copy.  A <code>std::string_view<\/code> that is viewing a string that has been destroyed is sometimes called a <strong>dangling<\/strong> view.  When a <code>std::string<\/code> is modified, all views into that <code>std::string<\/code> are <strong>invalidated<\/strong>, meaning those views are now invalid.  Using an invalidated view (other than to revalidate it) will produce undefined behavior.<\/p>\n<p>Because C-style string literals exist for the entire program, it is okay to set a <code>std::string_view<\/code> to a C-style string literal, and even return such a <code>std::string_view<\/code> from a function.<\/p>\n<p>A <strong>substring<\/strong> is a contiguous sequence of characters within an existing string.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Why are named constants often a better choice than literal constants?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>Using literal constants (a.k.a. magic numbers) in your program makes your program harder to understand and harder to modify.  Symbolic constants help document what the numbers actually represent, and changing a symbolic constant at its declaration changes the value everywhere it is used.\n<\/p><\/div>\n<p>Why are const\/constexpr variables usually a better choice than #defined symbolic constants?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p>#define constants do not show up in the debugger and are more likely to have naming conflicts.\n<\/p><\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>Find 3 issues in the following code:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cstdint&gt; \/\/ for std::uint8_t\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n  std::cout &lt;&lt; \"How old are you?\\n\";\r\n\r\n  std::uint8_t age{};\r\n  std::cin &gt;&gt; age;\r\n\r\n  std::cout &lt;&lt; \"Allowed to drive a car in Texas: \";\r\n\r\n  if (age &gt;= 16)\r\n      std::cout &lt;&lt; \"Yes\";\r\n  else\r\n      std::cout &lt;&lt; \"No\";\r\n\r\n  std::cout &lt;&lt; '.\\n';\r\n\r\n  return 0;\r\n}<\/code><\/pre>\n<p>Sample desired output:<\/p>\n<pre>\nHow old are you?\r\n6\r\nAllowed to drive a car in Texas: No\r\n<\/pre>\n<pre>\nHow old are you?\r\n19\r\nAllowed to drive a car in Texas: Yes\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<ol start=\"1\">\n<li>On line 8, <code>age<\/code> is defined as a <code>std::uint8_t<\/code>.  Because <code>std::uint8_t<\/code> is typically defined as a char type, using it here will cause the program to behave as if we&#8217;re inputting and outputting a char value rather than a numeric value.  For example, if the user entered their age as &#8220;18&#8221;, only the character <code>'1'<\/code> would be extracted.  Because <code>1<\/code> has ASCII value <code>49<\/code>, the user would be treated as if they were 49 years old.  A regular <code>int<\/code> should be used to store the age, as the age doesn&#8217;t require a specific minimum integer width.  We can also remove <code>#include &lt;cstdint&gt;<\/code>.\n<\/li>\n<li>On line 13, we use the magic number <code>16<\/code>.  Although the meaning of <code>16<\/code> is clear from the context it is used in, using a <code>constexpr<\/code> variable with the value <code>16<\/code> should be preferred instead.\n<\/li>\n<li>On line 18, <code>'.\\n'<\/code> is a multicharacter literal that will print the wrong value.  It should be double-quoted (<code>\".\\n\"<\/code>).\n<\/li>\n<\/ol>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #3<\/p>\n<p>What are the primary differences between <code>std::string<\/code> and <code>std::string_view<\/code>?<\/p>\n<p>What can go wrong when using a <code>std::string_view<\/code>?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<p><code>std::string<\/code> provides a modifiable string.  It is expensive to initialize and copy.<\/p>\n<p><code>std::string_view<\/code> provide a read-only view of a string that exists elsewhere.  It is inexpensive to initialize and copy.  <code>std::string_view<\/code> can be dangerous when the string being viewed is destroyed before the <code>std::string_view<\/code> that is viewing it.\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #4<\/p>\n<p>Write a program that asks for the name and age of two people, then prints which person is older.<\/p>\n<p>Here is the sample output from one run of the program:<\/p>\n<pre>\nEnter the name of person #1: John Bacon\r\nEnter the age of John Bacon: 37\r\nEnter the name of person #2: David Jenkins\r\nEnter the age of David Jenkins: 44\r\nDavid Jenkins (age 44) is older than John Bacon (age 37).\r\n<\/pre>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_0'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_0\" style=\"display:none; margin-bottom: 1em\">Hint: Input the person&#8217;s name using <code>std::getline()<\/code><\/div>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nstd::string getName(int num)\r\n{\r\n    std::cout &lt;&lt; \"Enter the name of person #\" &lt;&lt; num &lt;&lt; \": \";\r\n    std::string name{};\r\n    std::getline(std::cin &gt;&gt; std::ws, name); \/\/ read a full line of text into name\r\n\r\n    return name;\r\n}\r\n\r\nint getAge(std::string_view sv)\r\n{\r\n    std::cout &lt;&lt; \"Enter the age of \" &lt;&lt; sv &lt;&lt; \": \";\r\n    int age{};\r\n    std::cin &gt;&gt; age;\r\n\r\n    return age;\r\n}\r\n\r\nvoid printOlder(std::string_view name1, int age1, std::string_view name2, int age2)\r\n{\r\n    if (age1 &gt; age2)\r\n        std::cout &lt;&lt; name1 &lt;&lt; \" (age \" &lt;&lt; age1 &lt;&lt;\") is older than \" &lt;&lt; name2 &lt;&lt; \" (age \" &lt;&lt; age2 &lt;&lt;\").\\n\";\r\n    else\r\n        std::cout &lt;&lt; name2 &lt;&lt; \" (age \" &lt;&lt; age2 &lt;&lt;\") is older than \" &lt;&lt; name1 &lt;&lt; \" (age \" &lt;&lt; age1 &lt;&lt;\").\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    const std::string name1{ getName(1) };\r\n    const int age1 { getAge(name1) };\r\n    \r\n    const std::string name2{ getName(2) };\r\n    const int age2 { getAge(name2) };\r\n\r\n    printOlder(name1, age1, name2, age2);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #5<\/p>\n<p>In the solution to the above quiz, why can&#8217;t variable <code>age1<\/code> in <code>main<\/code> be constexpr?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_5'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_5\" style=\"display:none\">\n<p>A constexpr variable requires a constant expression initializer, and the call to <code>getAge()<\/code> isn&#8217;t allowed in a constant expression.  Therefore, we can only make the variable const.\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/operator-precedence-and-associativity\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">6.1<\/span>Operator precedence and associativity\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdstring_view-part-2\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">5.9<\/span>std::string_view (part 2)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Chapter Review A is a value that may not be changed during the program&#8217;s execution. C++ supports two types of constants: named constants, and literals. A is a constant value that is associated with an identifier. A is a constant value not associated with an identifier. A variable whose value &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15965"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15965"}],"version-history":[{"count":24,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15965\/revisions"}],"predecessor-version":[{"id":17941,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15965\/revisions\/17941"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15965"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15965"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15965"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}