{"id":1619,"date":"2015-04-16T15:54:28","date_gmt":"2015-04-16T23:54:28","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=1619"},"modified":"2025-03-04T02:37:48","modified_gmt":"2025-03-04T10:37:48","slug":"explicit-type-conversion-casting-and-static-cast","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/explicit-type-conversion-casting-and-static-cast\/","title":{"rendered":"10.6 &#8212; Explicit type conversion (casting) and static_cast"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/implicit-type-conversion\/\">10.1 -- Implicit type conversion<\/a>, we discussed that the compiler can use implicit type conversion to convert a value from one data type to another.  When you want to numerically promote a value from one data type to a wider data type, using implicit type conversion is fine.<\/p>\n<p>Many new C++ programmers try something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">double d = 10 \/ 4; \/\/ does integer division, initializes d with value 2.0<\/code><\/pre>\n<p>Because <code>10<\/code> and <code>4<\/code> are both of type <code>int<\/code>, integer division is performed, and the expression evaluates to <code>int<\/code> value <code>2<\/code>.  This value then undergoes numeric conversion to <code>double<\/code> value <code>2.0<\/code> before being used to initialize variable <code>d<\/code>.  Most likely, this isn&#8217;t what was intended.<\/p>\n<p>In the case where you are using literal operands, replacing one or both of the integer literals with double literals will cause floating point division to happen instead:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">double d = 10.0 \/ 4.0; \/\/ does floating point division, initializes d with value 2.5<\/code><\/pre>\n<p>But what if you are using variables instead of literals?  Consider this case:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int x { 10 };\r\nint y { 4 };\r\ndouble d = x \/ y; \/\/ does integer division, initializes d with value 2.0<\/code><\/pre>\n<p>Because integer division is used here, variable <code>d<\/code> will end up with the value of <code>2.0<\/code>.  How do we tell the compiler that we want to use floating point division instead of integer division in this case?  Literal suffixes can&#8217;t be used with variables.  We need some way to convert one (or both) of the variable operands to a floating point type, so that floating point division will be used instead.<\/p>\n<p>Fortunately, C++ comes with a number of different <strong>type casting operators<\/strong> (more commonly called <strong>casts<\/strong>) that can be used by the programmer to have the compiler perform type conversion.  Because casts are explicit requests by the programmer, this form of type conversion is often called an <strong>explicit type conversion<\/strong> (as opposed to implicit type conversion, where the compiler performs a type conversion automatically).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Type casting<\/p>\n<p>C++ supports 5 different types of casts: <code>static_cast<\/code>, <code>dynamic_cast<\/code>, <code>const_cast<\/code>, <code>reinterpret_cast<\/code>, and C-style casts.  The first four are sometimes referred to as <strong>named casts<\/strong>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<div class=\"cpp-table-wrapper\">\n<table class=\"cpp-table\">\n<tr>\n<th> Cast <\/th>\n<th> Description <\/th>\n<th> Safe? <\/th>\n<\/tr>\n<tr>\n<td> static_cast <\/td>\n<td> Performs compile-time type conversions between related types. <\/td>\n<td> Yes <\/td>\n<\/tr>\n<tr>\n<td> dynamic_cast <\/td>\n<td> Performs runtime type conversions on pointers or references in an polymorphic (inheritance) hierarchy <\/td>\n<td> Yes <\/td>\n<\/tr>\n<tr>\n<td> const_cast <\/td>\n<td> Adds or removes const. <\/td>\n<td> Only for adding const <\/td>\n<\/tr>\n<tr>\n<td> reinterpret_cast <\/td>\n<td> Reinterprets the bit-level representation of one type as if it were another type <\/td>\n<td> No <\/td>\n<\/tr>\n<tr>\n<td> C-style casts <\/td>\n<td> Performs some combination of <code>static_cast<\/code>, <code>const_cast<\/code>, or <code>reinterpret_cast<\/code>. <\/td>\n<td> No <\/td>\n<\/tr>\n<\/table>\n<\/div>\n<\/div>\n<p>Each cast works the same way.  As input, the cast takes an expression (that evaluates to a value or an object), and a target type.  As output, the cast returns the result of the conversion.<\/p>\n<p>Because they are the most commonly used casts, we&#8217;ll cover C-style casts and <code>static_cast<\/code> in this lesson.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We discuss <code>dynamic_cast<\/code> in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/dynamic-casting\/\">25.10 -- Dynamic casting<\/a>, after we&#8217;ve covered other prerequisite topics.\n<\/div>\n<p><code>const_cast<\/code> and <code>reinterpret_cast<\/code> should generally be avoided because they are only useful in rare cases and can be harmful if used incorrectly.<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Avoid <code>const_cast<\/code> and <code>reinterpret_cast<\/code> unless you have a very good reason to use them.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">C-style cast<\/p>\n<p>In standard C programming, casting is done via <code>operator()<\/code>, with the name of the type to convert to placed inside the parentheses, and the value to convert to placed immediately to the right of the closing parenthesis.  In C++, this type of cast is called a <strong>C-style cast<\/strong>.  You may still see these used in code that has been converted from C.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 10 };\r\n    int y { 4 };\r\n\r\n    std::cout &lt;&lt; (double)x \/ y &lt;&lt; '\\n'; \/\/ C-style cast of x to double\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above program, we use a C-style cast to tell the compiler to convert <code>x<\/code> to a <code>double<\/code>.  Because the left operand of <code>operator\/<\/code> now evaluates to a floating point value, the right operand will be converted to a floating point value as well, and the division will be done using floating point division instead of integer division.<\/p>\n<p>C++ also provides an alternative form of C-style cast known as a <strong>function-style cast<\/strong>, which resembles a function call:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    std::cout &lt;&lt; double(x) \/ y &lt;&lt; '\\n'; \/\/  \/\/ function-style cast of x to double<\/code><\/pre>\n<p>The function-style cast makes it a bit easier to tell what is being converted (as it looks like a standard function argument).<\/p>\n<p>There are a couple of significant reasons that C-style casts are generally avoided in modern C++.<\/p>\n<p>First, although a C-style cast appears to be a single cast, it can actually perform a variety of different conversions depending on how it is used.  This can include a static cast, a const cast, or a reinterpret cast (the latter two of which we mentioned above you should avoid).  A C-style cast does not make it clear which cast(s) will actual be performed, which not only makes your code that much harder to understand, but also opens the door for inadvertent misuse (where you think you&#8217;re implementing a simple cast and you end up doing something dangerous instead).  Often this will end up producing an error that isn&#8217;t discovered until runtime.<\/p>\n<p>Also, because C-style casts are just a type name, parenthesis, and variable or value, they are both difficult to identify (making your code harder to read) and even more difficult to search for.<\/p>\n<p>In contrast, the named casts are easy to spot and search for, make it clear what they are doing, are limited in their abilities, and will produce a compilation error if you try to misuse them.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Avoid using C-style casts.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>A C-style cast tries to perform the following C++ casts, in order:<\/p>\n<ul>\n<li><code>const_cast<\/code>\n<\/li>\n<li><code>static_cast<\/code>\n<\/li>\n<li><code>static_cast<\/code>, followed by <code>const_cast<\/code>\n<\/li>\n<li><code>reinterpret_cast<\/code>\n<\/li>\n<li><code>reinterpret_cast<\/code>, followed by <code>const_cast<\/code>\n<\/li>\n<\/ul>\n<p>There is one thing you can do with a C-style cast that you can&#8217;t do with C++ casts: C-style casts can convert a derived object to a base class that is inaccessible (e.g. because it was privately inherited).\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><code>static_cast<\/code> should be used to cast most values<\/p>\n<p>By far the most used cast in C++ is the <strong>static cast<\/strong> operator, which is accessed via the <code>static_cast<\/code> keyword.  <code>static_cast<\/code> is used when we want to explicitly convert a value of one type into a value of another type.<\/p>\n<p>You&#8217;ve previously seen <code>static_cast<\/code> used to convert a <code>char<\/code> into an <code>int<\/code> so that <code>std::cout<\/code> prints it as an integer instead of a character:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    char c { 'a' };\r\n    std::cout &lt;&lt; static_cast&lt;int&gt;(c) &lt;&lt; '\\n'; \/\/ prints 97 rather than a\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>To perform a static cast, we start with the <code>static_cast<\/code> keyword, and then place the type to convert to inside angled brackets.  Then inside parenthesis, we place the expression whose value will be converted.  Note how much the syntax looks like a function call to a function named <code>static_cast&lt;type&gt;()<\/code> with the expression whose value will be converted provided as an argument!  Static casting a value to another type of value returns a temporary object that has been direct-initialized with the converted value.<\/p>\n<p>Here&#8217;s how we&#8217;d use <code>static_cast<\/code> to solve the problem we introduced in the introduction of this lesson:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 10 };\r\n    int y { 4 };\r\n\r\n    \/\/ static cast x to a double so we get floating point division\r\n    std::cout &lt;&lt; static_cast&lt;double&gt;(x) \/ y &lt;&lt; '\\n'; \/\/ prints 2.5\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><code>static_cast&lt;double&gt;(x)<\/code> returns a temporary <code>double<\/code> object containing the converted value <code>10.0<\/code>.  This temporary is then used as the left-operand of the floating point division.<\/p>\n<p>There are two important properties of <code>static_cast<\/code>.<\/p>\n<p>First, <code>static_cast<\/code> provides compile-time type checking.  If we try to convert a value to a type and the compiler doesn&#8217;t know how to perform that conversion, we will get a compilation error.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    \/\/ a C-style string literal can't be converted to an int, so the following is an invalid conversion\r\n    int x { static_cast&lt;int&gt;(\"Hello\") }; \/\/ invalid: will produce compilation error<\/code><\/pre>\n<p>Second, <code>static_cast<\/code> is (intentionally) less powerful than a C-style cast, as it will prevent certain kinds of dangerous conversions (such as those that require reinterpretation or discarding const).<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Favor <code>static_cast<\/code> when you need to convert a value from one type to another type.\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Since static_cast uses direct initialization, any explicit constructors of the target class type will be considered when initializing the temporary object to be returned.  We discuss explicit constructors in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/converting-constructors-and-the-explicit-keyword\/\">14.16 -- Converting constructors and the explicit keyword<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using <code>static_cast<\/code> to make narrowing conversions explicit<\/p>\n<p>Compilers will often issue warnings when a potentially unsafe (narrowing) implicit type conversion is performed.  For example, consider the following snippet:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int i { 48 };\r\nchar ch = i; \/\/ implicit narrowing conversion<\/code><\/pre>\n<p>Casting an <code>int<\/code> (2 or 4 bytes) to a <code>char<\/code> (1 byte) is potentially unsafe (as the compiler can&#8217;t tell whether the integer value will overflow the range of the <code>char<\/code> or not), and so the compiler will typically print a warning.  If we used list initialization, the compiler would yield an error.<\/p>\n<p>To get around this, we can use a static cast to explicitly convert our integer to a <code>char<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int i { 48 };\r\n\r\n\/\/ explicit conversion from int to char, so that a char is assigned to variable ch\r\nchar ch { static_cast&lt;char&gt;(i) };<\/code><\/pre>\n<p>When we do this, we&#8217;re explicitly telling the compiler that this conversion is intended, and we accept responsibility for the consequences (e.g. overflowing the range of a <code>char<\/code> if that happens).  Since the output of this static cast is of type <code>char<\/code>, the initialization of variable <code>ch<\/code> doesn&#8217;t generate any type mismatches, and hence no warnings or errors.<\/p>\n<p>Here&#8217;s another example where the compiler will typically complain that converting a <code>double<\/code> to an <code>int<\/code> may result in loss of data:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int i { 100 };\r\ni = i \/ 2.5;<\/code><\/pre>\n<p>To tell the compiler that we explicitly mean to do this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int i { 100 };\r\ni = static_cast&lt;int&gt;(i \/ 2.5);<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We discuss more uses of static_cast in relation to class types in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/temporary-class-objects\/\">14.13 -- Temporary class objects<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Casting vs initializing a temporary object<\/p>\n<p>Let&#8217;s say we have some variable <code>x<\/code> that we need to convert to an <code>int<\/code>.  There are two conventional ways we can do this:<\/p>\n<ol start=\"1\">\n<li><code>static_cast&lt;int&gt;(x)<\/code>, which returns a temporary <code>int<\/code> object <em>direct-initialized<\/em> with <code>x<\/code>.\n<\/li>\n<li><code>int { x }<\/code>, which creates a temporary <code>int<\/code> object <em>direct-list-initialized<\/em> with <code>x<\/code>.\n<\/li>\n<\/ol>\n<p>We should avoid <code>int ( x )<\/code>, which is a C-style cast.  This will return a temporary <code>int<\/code> direct-initialized with the value of <code>x<\/code> (like we&#8217;d expect from the syntax), but it also has the other downsides mentioned in the C-style cast section (like allowing the possibility of performing a dangerous conversion).<\/p>\n<p>There are (at least) three notable differences between the <code>static_cast<\/code> and the direct-list-initialized temporary:<\/p>\n<ol start=\"1\">\n<li><code>int { x }<\/code> uses list initialization, which disallows narrowing conversions.  This is great when initializing a variable, because we rarely intend to lose data in such cases.  But when using a cast, it is presumed we know what we&#8217;re doing, and if we want to do a cast that might lose some data, we should be able to do that.  The narrowing conversion restriction can be an impediment in this case.\n<\/li>\n<\/ol>\n<p>Let&#8217;s show an example of this, including how it can lead to platform-specific issues:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 10 };\r\n    int y { 4 };\r\n\r\n    \/\/ We want to do floating point division, so one of the operands needs to be a floating point type\r\n    std::cout &lt;&lt; double{x} \/ y &lt;&lt; '\\n'; \/\/ okay if int is 32-bit, narrowing if x is 64-bit\r\n}<\/code><\/pre>\n<p>In this example, we have decided to convert <code>x<\/code> to a <code>double<\/code> so we can do floating-point division rather than integer division.  On a 32-bit architecture, this will work fine (because a <code>double<\/code> can represent all the values that can be stored in a 32-bit <code>int<\/code>, so it isn&#8217;t a narrowing conversion).  But on a 64-bit architecture, this is not the case, so converting a 64-bit <code>int<\/code> to a <code>double<\/code> is a narrowing conversion.  And since list initialization disallows narrowing conversions, this won&#8217;t compile on architectures where <code>int<\/code> is 64-bits.<\/p>\n<ol start=\"2\">\n<li><code>static_cast<\/code> makes it clearer that we are intending to perform a conversion.  Although the <code>static_cast<\/code> is more verbose than the direct-list-initialized alternative, in this case, that&#8217;s a good thing, as it makes the conversion easier to spot and search for.  That ultimately makes your code safer and easier to understand.\n<\/li>\n<li>Direct-list-initializion of a temporary only allows single-word type names.  Due to a weird syntax quirk, there are several places within C++ where only single-word type names are allowed (the C++ standard calls these names &#8220;simple type specifiers&#8221;).  So while <code>int { x }<\/code> is a valid conversion syntax, <code>unsigned int { x }<\/code> is not.\n<\/li>\n<\/ol>\n<p>You can see this for yourself in the following example, which produces a compile error:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    unsigned char c { 'a' };\r\n    std::cout &lt;&lt; unsigned int { c } &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>There are simple ways to work around this, the easiest of which is to use a single-word type alias:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    unsigned char c { 'a' };\r\n    using uint = unsigned int;\r\n    std::cout &lt;&lt; uint { c } &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>But why go to the trouble when you can just <code>static_cast<\/code>?<\/p>\n<p>For all these reasons, we generally prefer <code>static_cast<\/code> over direct-list-initialization of a temporary.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Prefer <code>static_cast<\/code> over initializing a temporary object when a conversion is desired.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>What&#8217;s the difference between implicit and explicit type conversion?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>Implicit type conversion is automatically performed whenever one data type is expected, but a different data type is supplied.<br \/>\nExplicit type conversion happens when the programmer uses a type cast to explicitly convert a value from one type to another type.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/typedefs-and-type-aliases\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">10.7<\/span>Typedefs and type aliases\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/arithmetic-conversions\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">10.5<\/span>Arithmetic conversions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we discussed that the compiler can use implicit type conversion to convert a value from one data type to another. When you want to numerically promote a value from one data type to a wider data type, using implicit type conversion is fine. Many new C++ programmers &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1619"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=1619"}],"version-history":[{"count":43,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1619\/revisions"}],"predecessor-version":[{"id":18236,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1619\/revisions\/18236"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=1619"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=1619"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=1619"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}