{"id":15374,"date":"2023-09-11T13:08:21","date_gmt":"2023-09-11T20:08:21","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15374"},"modified":"2024-05-03T12:27:51","modified_gmt":"2024-05-03T19:27:51","slug":"chapter-15-summary-and-quiz","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-15-summary-and-quiz\/","title":{"rendered":"15.x &#8212; Chapter 15 summary and quiz"},"content":{"rendered":"<p class=\"cpp-section\">Chapter Review<\/p>\n<p>Inside every (non-static) member function, the keyword <strong>this<\/strong> is a const pointer that holds the address of the current implicit object.  We can have functions return <code>*this<\/code> by reference in order to enable <strong>method chaining<\/strong>, where several member functions can be called on the same object in a single expression.<\/p>\n<p>Prefer to put your class definitions in a header file with the same name as the class.  Trivial member functions (such as access functions, constructors with empty bodies, etc\u2026) can be defined inside the class definition.<\/p>\n<p>Prefer to define non-trivial member functions in a source file with the same name as the class.<\/p>\n<p>A type that is defined inside a class type is called a <strong>nested type<\/strong> (or <strong>member type<\/strong>).  Type aliases can also be nested.<\/p>\n<p>Member functions defined inside a class template definition can use the template parameters of the class template itself.  Member functions defined outside the class template definition must resupply a template parameter declaration, and should be defined (in the same file) just below the class template definition.<\/p>\n<p><strong>Static member variables<\/strong> are static duration members that are shared by all objects of the class.  Static members exist even if no objects of the class have been instantiated.  Prefer to access them using the class name, the scope resolution operator, and the members name.<\/p>\n<p>Making static members <code>inline<\/code> allows them to be initialized inside the class definition.<\/p>\n<p><strong>Static member functions<\/strong> are member functions that can be called with no object.  They do not have a <code>*this<\/code> pointer, and cannot access non-static data members.<\/p>\n<p>Inside the body of a class, a <strong>friend declaration<\/strong> (using the <code>friend<\/code> keyword) can be used to tell the compiler that some other class or function is now a friend.  A <strong>friend<\/strong> is a class or function (member or non-member) that has been granted full access to the private and protected members of another class.  A <strong>friend function<\/strong> is a function (member or non-member) that can access the private and protected members of a class as though it were a member of that class.  A <strong>friend class<\/strong> is a class that can access the private and protected members of another class.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Let&#8217;s create a random monster generator.  This one should be fun.<\/p>\n<p>a) First, let&#8217;s create an scoped enumeration of monster types named <code>MonsterType<\/code>.  Include the following monster types: Dragon, Goblin, Ogre, Orc, Skeleton, Troll, Vampire, and Zombie.  Add an additional maxMonsterTypes enumerator so we can count how many enumerators there are.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">enum class MonsterType\r\n{\r\n\tdragon,\r\n\tgoblin,\r\n\togre,\r\n\torc,\r\n\tskeleton,\r\n\ttroll,\r\n\tvampire,\r\n\tzombie,\r\n\tmaxMonsterTypes,\r\n};<\/code><\/pre>\n<\/div>\n<p>b) Now, let&#8217;s create our <code>Monster<\/code> class.  Our <code>Monster<\/code> will have 4 attributes (member variables): a type (<code>MonsterType<\/code>), a name (<code>std::string<\/code>), a roar (<code>std::string<\/code>) and the number of hit points (<code>int<\/code>).<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n\r\nenum class MonsterType\r\n{\r\n\tdragon,\r\n\tgoblin,\r\n\togre,\r\n\torc,\r\n\tskeleton,\r\n\ttroll,\r\n\tvampire,\r\n\tzombie,\r\n\tmaxMonsterTypes,\r\n};\r\n\r\nclass Monster\r\n{\r\nprivate:\r\n\tMonsterType m_type{};\r\n\tstd::string m_name{\"???\"};\r\n\tstd::string m_roar{\"???\"};\r\n\tint m_hitPoints{};\r\n};<\/code><\/pre>\n<\/div>\n<p>c) <code>enum class MonsterType<\/code> is specific to <code>Monster<\/code>, so make <code>MonsterType<\/code> a nested unscoped enum inside <code>Monster<\/code> and rename it to <code>Type<\/code>.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n\r\nclass Monster\r\n{\r\npublic:\r\n\tenum Type\r\n\t{\r\n\t\tdragon,\r\n\t\tgoblin,\r\n\t\togre,\r\n\t\torc,\r\n\t\tskeleton,\r\n\t\ttroll,\r\n\t\tvampire,\r\n\t\tzombie,\r\n\t\tmaxMonsterTypes,\r\n\t};\r\n\r\nprivate:\r\n\r\n\tType m_type{};\r\n\tstd::string m_name{\"???\"};\r\n\tstd::string m_roar{\"???\"};\r\n\tint m_hitPoints{};\r\n};<\/code><\/pre>\n<\/div>\n<p>d) Create a constructor that allows you to initialize all of the member variables.<\/p>\n<p>The following program should compile:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n\tMonster skeleton{ Monster::skeleton, \"Bones\", \"*rattle*\", 4 };\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Monster\r\n{\r\npublic:\r\n\tenum Type\r\n\t{\r\n\t\tdragon,\r\n\t\tgoblin,\r\n\t\togre,\r\n\t\torc,\r\n\t\tskeleton,\r\n\t\ttroll,\r\n\t\tvampire,\r\n\t\tzombie,\r\n\t\tmaxMonsterTypes,\r\n\t};\r\n\r\nprivate:\r\n\r\n\tType m_type{};\r\n\tstd::string m_name{\"???\"};\r\n\tstd::string m_roar{\"???\"};\r\n\tint m_hitPoints{};\r\n\r\npublic:\r\n\tMonster(Type type, std::string_view name, std::string_view roar, int hitPoints)\r\n\t\t: m_type{ type }, m_name{ name }, m_roar{ roar }, m_hitPoints{ hitPoints }\r\n\t{\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tMonster skeleton{ Monster::skeleton, \"Bones\", \"*rattle*\", 4 };\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>e) Now we want to be able to print our monster so we can validate it&#8217;s correct.  Write two functions: One called <code>getTypeString()<\/code> that returns the monster&#8217;s type as a string, and one called <code>print()<\/code> that matches the output in the sample program below.<\/p>\n<p>The following program should compile:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n\tMonster skeleton{ Monster::skeleton, \"Bones\", \"*rattle*\", 4 };\r\n\tskeleton.print();\r\n\r\n\tMonster vampire{ Monster::vampire, \"Nibblez\", \"*hiss*\", 0 };\r\n\tvampire.print();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>and print:<\/p>\n<pre>\nBones the skeleton has 4 hit points and says *rattle*.\r\nNibblez the vampire is dead.\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Monster\r\n{\r\npublic:\r\n\tenum Type\r\n\t{\r\n\t\tdragon,\r\n\t\tgoblin,\r\n\t\togre,\r\n\t\torc,\r\n\t\tskeleton,\r\n\t\ttroll,\r\n\t\tvampire,\r\n\t\tzombie,\r\n\t\tmaxMonsterTypes,\r\n\t};\r\n\r\nprivate:\r\n\r\n\tType m_type{};\r\n\tstd::string m_name{\"???\"};\r\n\tstd::string m_roar{\"???\"};\r\n\tint m_hitPoints{};\r\n\r\npublic:\r\n\tMonster(Type type, std::string_view name, std::string_view roar, int hitPoints)\r\n\t\t: m_type{ type }, m_name{ name }, m_roar{ roar }, m_hitPoints{ hitPoints }\r\n\t{\r\n\r\n\t}\r\n\r\n\tconstexpr std::string_view getTypeString() const\r\n\t{\r\n\t\tswitch (m_type)\r\n\t\t{\r\n\t\tcase dragon:   return \"dragon\";\r\n\t\tcase goblin:   return \"goblin\";\r\n\t\tcase ogre:     return \"ogre\";\r\n\t\tcase orc:      return \"orc\";\r\n\t\tcase skeleton: return \"skeleton\";\r\n\t\tcase troll:    return \"troll\";\r\n\t\tcase vampire:  return \"vampire\";\r\n\t\tcase zombie:   return \"zombie\";\r\n\t\tdefault:       return \"???\";\r\n\t\t}\r\n\t}\r\n\r\n\tvoid print() const\r\n\t{\r\n\t\tstd::cout &lt;&lt; m_name &lt;&lt; \" the \" &lt;&lt; getTypeString();\r\n\r\n\t\tif (m_hitPoints &lt;= 0)\r\n\t\t\tstd::cout &lt;&lt; \" is dead.\\n\";\r\n\t\telse\r\n\t\t\tstd::cout &lt;&lt; \" has \" &lt;&lt; m_hitPoints &lt;&lt; \" hit points and says \" &lt;&lt; m_roar &lt;&lt; \".\\n\";\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tMonster skeleton{ Monster::skeleton, \"Bones\", \"*rattle*\", 4 };\r\n\tskeleton.print();\r\n\r\n\tMonster vampire{ Monster::vampire, \"Nibblez\", \"*hiss*\", 0 };\r\n\tvampire.print();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>f) Now we can create a random monster generator.  Let&#8217;s consider how our <code>MonsterGenerator<\/code> will work.  Ideally, we&#8217;ll ask it to give us a <code>Monster<\/code>, and it will create a random one for us.  Because <code>MonsterGenerator<\/code> doesn&#8217;t have any state, this is a good candidate for a namespace.<\/p>\n<p>Create a <code>MonsterGenerator<\/code> namespace.  Create function within named <code>generate()<\/code>.  This should return a <code>Monster<\/code>.  For now, make it return <code>Monster{ Monster::skeleton, \"Bones\", \"*rattle*\", 4}<\/code>;<\/p>\n<p>The following program should compile:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n\tMonster m{ MonsterGenerator::generate() };\r\n\tm.print();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>and print:<\/p>\n<pre>\nBones the skeleton has 4 hit points and says *rattle*\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_5'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_5\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Monster\r\n{\r\npublic:\r\n\tenum Type\r\n\t{\r\n\t\tdragon,\r\n\t\tgoblin,\r\n\t\togre,\r\n\t\torc,\r\n\t\tskeleton,\r\n\t\ttroll,\r\n\t\tvampire,\r\n\t\tzombie,\r\n\t\tmaxMonsterTypes,\r\n\t};\r\n\r\nprivate:\r\n\r\n\tType m_type{};\r\n\tstd::string m_name{};\r\n\tstd::string m_roar{};\r\n\tint m_hitPoints{};\r\n\r\npublic:\r\n\tMonster(Type type, std::string_view name, const std::string&amp; roar, int hitPoints)\r\n\t\t: m_type{ type }, m_name{ name }, m_roar{ roar }, m_hitPoints{ hitPoints }\r\n\t{\r\n\r\n\t}\r\n\r\n\tconstexpr std::string_view getTypeString() const\r\n\t{\r\n\t\tswitch (m_type)\r\n\t\t{\r\n\t\tcase Type::dragon: return \"dragon\";\r\n\t\tcase Type::goblin: return \"goblin\";\r\n\t\tcase Type::ogre: return \"ogre\";\r\n\t\tcase Type::orc: return \"orc\";\r\n\t\tcase Type::skeleton: return \"skeleton\";\r\n\t\tcase Type::troll: return \"troll\";\r\n\t\tcase Type::vampire: return \"vampire\";\r\n\t\tcase Type::zombie: return \"zombie\";\r\n\t\tdefault: return \"???\";\r\n\t\t}\r\n\t}\r\n\r\n\tvoid print() const\r\n\t{\r\n\t\tif (m_hitPoints &lt;= 0)\r\n\t\t\tstd::cout &lt;&lt; m_name &lt;&lt; \" is dead.\\n\";\r\n\t\telse\r\n\t\t\tstd::cout &lt;&lt; m_name &lt;&lt; \" the \" &lt;&lt; getTypeString() &lt;&lt; \" has \" &lt;&lt; m_hitPoints &lt;&lt; \" hit points and says \" &lt;&lt; m_roar &lt;&lt; \".\\n\";\r\n\t}\r\n};\r\n\r\nnamespace MonsterGenerator\r\n{\r\n\tMonster generate()\r\n\t{\r\n\t\treturn Monster{ Monster::skeleton, \"Bones\", \"*rattle*\", 4 };\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tMonster m{ MonsterGenerator::generate() };\r\n\tm.print();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>g) Add two more functions to the <code>MonsterGenerator<\/code> namespace.  <code>getName(int)<\/code> will take a number between 0 and 5 (inclusive) and return a name of your choice.  <code>getRoar(int)<\/code> will also take a number between 0 and 5 (inclusive) and return a roar of your choice.  Also update your <code>generate()<\/code> function to call <code>getName(0)<\/code> and <code>getRoar(0)<\/code>.<\/p>\n<p>The following program should compile:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n\tMonster m{ MonsterGenerator::generate() };\r\n\tm.print();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>and print:<\/p>\n<pre>\nBlarg the skeleton has 4 hit points and says *ROAR*\r\n<\/pre>\n<p>Your name and sound will vary based on what you chose.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_6'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_6\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Monster\r\n{\r\npublic:\r\n\tenum Type\r\n\t{\r\n\t\tdragon,\r\n\t\tgoblin,\r\n\t\togre,\r\n\t\torc,\r\n\t\tskeleton,\r\n\t\ttroll,\r\n\t\tvampire,\r\n\t\tzombie,\r\n\t\tmaxMonsterTypes,\r\n\t};\r\n\r\nprivate:\r\n\r\n\tType m_type{};\r\n\tstd::string m_name{\"???\"};\r\n\tstd::string m_roar{\"???\"};\r\n\tint m_hitPoints{};\r\n\r\npublic:\r\n\tMonster(Type type, std::string_view name, std::string_view roar, int hitPoints)\r\n\t\t: m_type{ type }, m_name{ name }, m_roar{ roar }, m_hitPoints{ hitPoints }\r\n\t{\r\n\r\n\t}\r\n\r\n\tconstexpr std::string_view getTypeString() const\r\n\t{\r\n\t\tswitch (m_type)\r\n\t\t{\r\n\t\tcase dragon:   return \"dragon\";\r\n\t\tcase goblin:   return \"goblin\";\r\n\t\tcase ogre:     return \"ogre\";\r\n\t\tcase orc:      return \"orc\";\r\n\t\tcase skeleton: return \"skeleton\";\r\n\t\tcase troll:    return \"troll\";\r\n\t\tcase vampire:  return \"vampire\";\r\n\t\tcase zombie:   return \"zombie\";\r\n\t\tdefault: return \"???\";\r\n\t\t}\r\n\t}\r\n\r\n\tvoid print() const\r\n\t{\r\n\t\tstd::cout &lt;&lt; m_name &lt;&lt; \" the \" &lt;&lt; getTypeString();\r\n\r\n\t\tif (m_hitPoints &lt;= 0)\r\n\t\t\tstd::cout &lt;&lt; \" is dead.\\n\";\r\n\t\telse\r\n\t\t\tstd::cout &lt;&lt; \" has \" &lt;&lt; m_hitPoints &lt;&lt; \" hit points and says \" &lt;&lt; m_roar &lt;&lt; \".\\n\";\r\n\t}\r\n};\r\n\r\nnamespace MonsterGenerator\r\n{\r\n    std::string_view getName(int n)\r\n\t{\r\n        switch (n)\r\n        {\r\n            case 0:  return \"Blarg\";\r\n            case 1:  return \"Moog\";\r\n            case 2:  return \"Pksh\";\r\n            case 3:  return \"Tyrn\";\r\n            case 4:  return \"Mort\";\r\n            case 5:  return \"Hans\";\r\n            default: return \"???\";\r\n        }\r\n    }\r\n\r\n    std::string_view getRoar(int n)\r\n\t{\r\n        switch (n)\r\n        {\r\n            case 0:  return \"*ROAR*\";\r\n            case 1:  return \"*peep*\";\r\n            case 2:  return \"*squeal*\";\r\n            case 3:  return \"*whine*\";\r\n            case 4:  return \"*growl*\";\r\n            case 5:  return \"*burp*\";\r\n            default: return \"???\";\r\n        }\r\n    }\r\n\r\n\tMonster generate()\r\n\t{\r\n\t\treturn Monster{ Monster::skeleton, getName(0), getRoar(0), 4 };\r\n\t}\r\n\r\n};\r\n\r\nint main()\r\n{\r\n\tMonster m{ MonsterGenerator::generate() };\r\n\tm.print();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>h) Now we&#8217;ll randomize our generated monster.  Grab the &#8220;Random.h&#8221; code from <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/global-random-numbers-random-h\/#RandomH\">8.15 -- Global random numbers (Random.h)<\/a> and save it as Random.h.  Then use <code>Random::get()<\/code> to generate a random monster type, random name, random roar, and random hit points (between 1 and 100).<\/p>\n<p>The following program should compile:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"Random.h\"\r\n\r\nint main()\r\n{\r\n\tMonster m{ MonsterGenerator::generate() };\r\n\tm.print();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>and print something like this:<\/p>\n<pre>\nMort the zombie has 61 hit points and says *growl*\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_7'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_7\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"Random.h\"\r\n#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Monster\r\n{\r\npublic:\r\n\tenum Type\r\n\t{\r\n\t\tdragon,\r\n\t\tgoblin,\r\n\t\togre,\r\n\t\torc,\r\n\t\tskeleton,\r\n\t\ttroll,\r\n\t\tvampire,\r\n\t\tzombie,\r\n\t\tmaxMonsterTypes,\r\n\t};\r\n\r\nprivate:\r\n\r\n\tType m_type{};\r\n\tstd::string m_name{\"???\"};\r\n\tstd::string m_roar{\"???\"};\r\n\tint m_hitPoints{};\r\n\r\npublic:\r\n\tMonster(Type type, std::string_view name, std::string_view roar, int hitPoints)\r\n\t\t: m_type{ type }, m_name{ name }, m_roar{ roar }, m_hitPoints{ hitPoints }\r\n\t{\r\n\r\n\t}\r\n\r\n\tconstexpr std::string_view getTypeString() const\r\n\t{\r\n\t\tswitch (m_type)\r\n\t\t{\r\n\t\tcase dragon:   return \"dragon\";\r\n\t\tcase goblin:   return \"goblin\";\r\n\t\tcase ogre:     return \"ogre\";\r\n\t\tcase orc:      return \"orc\";\r\n\t\tcase skeleton: return \"skeleton\";\r\n\t\tcase troll:    return \"troll\";\r\n\t\tcase vampire:  return \"vampire\";\r\n\t\tcase zombie:   return \"zombie\";\r\n\t\tdefault: return \"???\";\r\n\t\t}\r\n\t}\r\n\r\n\tvoid print() const\r\n\t{\r\n\t\tstd::cout &lt;&lt; m_name &lt;&lt; \" the \" &lt;&lt; getTypeString();\r\n\r\n\t\tif (m_hitPoints &lt;= 0)\r\n\t\t\tstd::cout &lt;&lt; \" is dead.\\n\";\r\n\t\telse\r\n\t\t\tstd::cout &lt;&lt; \" has \" &lt;&lt; m_hitPoints &lt;&lt; \" hit points and says \" &lt;&lt; m_roar &lt;&lt; \".\\n\";\r\n\t}\r\n};\r\n\r\nnamespace MonsterGenerator\r\n{\r\n    std::string_view getName(int n)\r\n\t{\r\n        switch (n)\r\n        {\r\n            case 0:  return \"Blarg\";\r\n            case 1:  return \"Moog\";\r\n            case 2:  return \"Pksh\";\r\n            case 3:  return \"Tyrn\";\r\n            case 4:  return \"Mort\";\r\n            case 5:  return \"Hans\";\r\n            default: return \"???\";\r\n        }\r\n    }\r\n\r\n    std::string_view getRoar(int n)\r\n\t{\r\n        switch (n)\r\n        {\r\n            case 0:  return \"*ROAR*\";\r\n            case 1:  return \"*peep*\";\r\n            case 2:  return \"*squeal*\";\r\n            case 3:  return \"*whine*\";\r\n            case 4:  return \"*growl*\";\r\n            case 5:  return \"*burp*\";\r\n            default: return \"???\";\r\n        }\r\n    }\r\n\r\n    Monster generate()\r\n    {\r\n        return Monster{\r\n            static_cast&lt;Monster::Type&gt;(Random::get(0, Monster::maxMonsterTypes-1)),\r\n            getName(Random::get(0,5)),\r\n            getRoar(Random::get(0,5)),\r\n            Random::get(1, 100)\r\n            };\r\n\t}\r\n\r\n};\r\n\r\nint main()\r\n{\r\n\tMonster m{ MonsterGenerator::generate() };\r\n\tm.print();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-containers-and-arrays\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">16.1<\/span>Introduction to containers and arrays\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/ref-qualifiers\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">15.10<\/span>Ref qualifiers\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Chapter Review Inside every (non-static) member function, the keyword is a const pointer that holds the address of the current implicit object. We can have functions return *this by reference in order to enable , where several member functions can be called on the same object in a single expression. &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15374"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15374"}],"version-history":[{"count":18,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15374\/revisions"}],"predecessor-version":[{"id":17002,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15374\/revisions\/17002"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15374"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15374"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15374"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}