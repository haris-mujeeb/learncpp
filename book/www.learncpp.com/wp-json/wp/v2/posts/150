{"id":150,"date":"2007-11-04T08:52:55","date_gmt":"2007-11-04T16:52:55","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/911-the-copy-constructor-and-overloading-the-assignment-operator\/"},"modified":"2024-12-19T22:09:06","modified_gmt":"2024-12-20T06:09:06","slug":"introduction-to-the-copy-constructor","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-the-copy-constructor\/","title":{"rendered":"14.14 &#8212; Introduction to the copy constructor"},"content":{"rendered":"<p>Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n \r\nclass Fraction\r\n{\r\nprivate:\r\n    int m_numerator{ 0 };\r\n    int m_denominator{ 1 };\r\n \r\npublic:\r\n    \/\/ Default constructor\r\n    Fraction(int numerator=0, int denominator=1)\r\n        : m_numerator{numerator}, m_denominator{denominator}\r\n    {\r\n    }\r\n\r\n    void print() const\r\n    {\r\n        std::cout &lt;&lt; \"Fraction(\" &lt;&lt; m_numerator &lt;&lt; \", \" &lt;&lt; m_denominator &lt;&lt; \")\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Fraction f { 5, 3 };  \/\/ Calls Fraction(int, int) constructor\r\n    Fraction fCopy { f }; \/\/ What constructor is used here?\r\n\r\n    f.print();\r\n    fCopy.print();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>You might be surprised to find that this program compiles just fine, and produces the result:<\/p>\n<pre>\nFraction(5, 3)\r\nFraction(5, 3)\r\n<\/pre>\n<p>Let&#8217;s take a closer look at how this program works.<\/p>\n<p>The initialization of variable <code>f<\/code> is just a standard brace initialization that calls the <code>Fraction(int, int)<\/code> constructor.<\/p>\n<p>But what about the next line?  The initialization of variable <code>fCopy<\/code> is also clearly an initialization, and you know that constructor functions are used to initialize classes.  So what constructor is this line calling?<\/p>\n<p>The answer is: the copy constructor.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The copy constructor<\/p>\n<p>A <strong>copy constructor<\/strong> is a constructor that is used to initialize an object with an existing object of the same type.  After the copy constructor executes, the newly created object should be a copy of the object passed in as the initializer.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">An implicit copy constructor<\/p>\n<p>If you do not provide a copy constructor for your classes, C++ will create a public <strong>implicit copy constructor<\/strong> for you.  In the above example, the statement <code>Fraction fCopy { f };<\/code> is invoking the implicit copy constructor to initialize <code>fCopy<\/code> with <code>f<\/code>.<\/p>\n<p>By default, the implicit copy constructor will do memberwise initialization.  This means each member will be initialized using the corresponding member of the class passed in as the initializer.  In the example above, <code>fCopy.m_numerator<\/code> is initialized using <code>f.m_numerator<\/code> (which has value <code>5<\/code>), and <code>fCopy.m_denominator<\/code> is initialized using <code>f.m_denominator<\/code> (which has value <code>3<\/code>).<\/p>\n<p>After the copy constructor has executed, the members of <code>f<\/code> and <code>fCopy<\/code> have the same values, so <code>fCopy<\/code> is a copy of <code>f<\/code>.  Thus calling <code>print()<\/code> on either has the same result.  <\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Defining your own copy constructor<\/p>\n<p>We can also explicitly define our own copy constructor.  In this lesson, we&#8217;ll make our copy constructor print a message, so we can show you that it is indeed executing when copies are made.<\/p>\n<p>The copy constructor looks just like you&#8217;d expect it to:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n \r\nclass Fraction\r\n{\r\nprivate:\r\n    int m_numerator{ 0 };\r\n    int m_denominator{ 1 };\r\n \r\npublic:\r\n    \/\/ Default constructor\r\n    Fraction(int numerator=0, int denominator=1)\r\n        : m_numerator{numerator}, m_denominator{denominator}\r\n    {\r\n    }\r\n\r\n    \/\/ Copy constructor\r\n    Fraction(const Fraction&amp; fraction)\r\n        \/\/ Initialize our members using the corresponding member of the parameter\r\n        : m_numerator{ fraction.m_numerator }\r\n        , m_denominator{ fraction.m_denominator }\r\n    {\r\n        std::cout &lt;&lt; \"Copy constructor called\\n\"; \/\/ just to prove it works\r\n    }\r\n\r\n    void print() const\r\n    {\r\n        std::cout &lt;&lt; \"Fraction(\" &lt;&lt; m_numerator &lt;&lt; \", \" &lt;&lt; m_denominator &lt;&lt; \")\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Fraction f { 5, 3 };  \/\/ Calls Fraction(int, int) constructor\r\n    Fraction fCopy { f }; \/\/ Calls Fraction(const Fraction&amp;) copy constructor\r\n\r\n    f.print();\r\n    fCopy.print();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When this program is run, you get:<\/p>\n<pre>\nCopy constructor called\r\nFraction(5, 3)\r\nFraction(5, 3)\r\n<\/pre>\n<p>The copy constructor we defined above is functionally equivalent to the one we&#8217;d get by default, except we&#8217;ve added an output statement to prove the copy constructor is actually being called.   This copy constructor is invoked when <code>fCopy<\/code> is initialized with <code>f<\/code>. <\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">A reminder<\/p>\n<p>Access controls work on a per-class basis (not a per-object basis).  This means the member functions of a class can access the private members of any class object of the same type (not just the implicit object).<\/p>\n<p>We use that to our advantage in the <code>Fraction<\/code> copy constructor above in order to directly access the private members of the <code>fraction<\/code> parameter.  Otherwise, we would have no way to access those members directly (without adding access functions, which we might not want to do).\n<\/div>\n<p>A copy constructor should not do anything other than copy an object.  This is because the compiler may optimize the copy constructor out in certain cases.  If you are relying on the copy constructor for some behavior other than just copying, that behavior may or may not occur.  We discuss this further in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-initialization-and-copy-elision\/\">14.15 -- Class initialization and copy elision<\/a>.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Copy constructors should have no side effects beyond copying.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Prefer the implicit copy constructor<\/p>\n<p>Unlike the implicit default constructor, which does nothing (and thus is rarely what we want), the memberwise initialization performed by the implicit copy constructor is usually exactly what we want.  Therefore, in most cases, using the implicit copy constructor is perfectly fine.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Prefer the implicit copy constructor, unless you have a specific reason to create your own.\n<\/p><\/div>\n<p>We&#8217;ll see cases where the copy constructor needs to be overwritten when we discuss dynamic memory allocation (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/shallow-vs-deep-copying\/\">21.13 -- Shallow vs. deep copying<\/a>).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The copy constructor&#8217;s parameter must be a reference<\/p>\n<p>It is a requirement that the parameter of a copy constructor be an lvalue reference or const lvalue reference.  Because the copy constructor should not be modifying the parameter, using a const lvalue reference is preferred.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>If you write your own copy constructor, the parameter should be a const lvalue reference.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Pass by value and the copy constructor<\/p>\n<p>When an object is passed by value, the argument is copied into the parameter.  When the argument and parameter are the same class type, the copy is made by implicitly invoking the copy constructor.<\/p>\n<p>This is illustrated in the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Fraction\r\n{\r\nprivate:\r\n    int m_numerator{ 0 };\r\n    int m_denominator{ 1 };\r\n\r\npublic:\r\n    \/\/ Default constructor\r\n    Fraction(int numerator = 0, int denominator = 1)\r\n        : m_numerator{ numerator }, m_denominator{ denominator }\r\n    {\r\n    }\r\n\r\n    \/\/ Copy constructor\r\n    Fraction(const Fraction&amp; fraction)\r\n        : m_numerator{ fraction.m_numerator }\r\n        , m_denominator{ fraction.m_denominator }\r\n    {\r\n        std::cout &lt;&lt; \"Copy constructor called\\n\";\r\n    }\r\n\r\n    void print() const\r\n    {\r\n        std::cout &lt;&lt; \"Fraction(\" &lt;&lt; m_numerator &lt;&lt; \", \" &lt;&lt; m_denominator &lt;&lt; \")\\n\";\r\n    }\r\n};\r\n\r\nvoid printFraction(Fraction f) \/\/ f is pass by value\r\n{\r\n    f.print();\r\n}\r\n\r\nint main()\r\n{\r\n    Fraction f{ 5, 3 };\r\n\r\n    printFraction(f); \/\/ f is copied into the function parameter using copy constructor\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>On the author&#8217;s machine, this example prints:<\/p>\n<pre>\nCopy constructor called\r\nFraction(5, 3)\r\n<\/pre>\n<p>In the above example, the call to <code>printFraction(f)<\/code> is passing <code>f<\/code> by value.  The copy constructor is invoked to copy <code>f<\/code> from <code>main<\/code> into the <code>f<\/code> parameter of function <code>printFraction()<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Return by value and the copy constructor<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-local-scope\/\">2.5 -- Introduction to local scope<\/a>, we noted that return by value creates a temporary object (holding a copy of the return value) that is passed back to the caller.  When the return type and the return value are the same class type, the temporary object is initialized by implicitly invoking the copy constructor.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Fraction\r\n{\r\nprivate:\r\n    int m_numerator{ 0 };\r\n    int m_denominator{ 1 };\r\n\r\npublic:\r\n    \/\/ Default constructor\r\n    Fraction(int numerator = 0, int denominator = 1)\r\n        : m_numerator{ numerator }, m_denominator{ denominator }\r\n    {\r\n    }\r\n\r\n    \/\/ Copy constructor\r\n    Fraction(const Fraction&amp; fraction)\r\n        : m_numerator{ fraction.m_numerator }\r\n        , m_denominator{ fraction.m_denominator }\r\n    {\r\n        std::cout &lt;&lt; \"Copy constructor called\\n\";\r\n    }\r\n\r\n    void print() const\r\n    {\r\n        std::cout &lt;&lt; \"Fraction(\" &lt;&lt; m_numerator &lt;&lt; \", \" &lt;&lt; m_denominator &lt;&lt; \")\\n\";\r\n    }\r\n};\r\n\r\nvoid printFraction(Fraction f) \/\/ f is pass by value\r\n{\r\n    f.print();\r\n}\r\n\r\nFraction generateFraction(int n, int d)\r\n{\r\n    Fraction f{ n, d };\r\n    return f;\r\n}\r\n\r\nint main()\r\n{\r\n    Fraction f2 { generateFraction(1, 2) }; \/\/ Fraction is returned using copy constructor\r\n\r\n    printFraction(f2); \/\/ f2 is copied into the function parameter using copy constructor\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When <code>generateFraction<\/code> returns a <code>Fraction<\/code> back to <code>main<\/code>, a temporary <code>Fraction<\/code> object is created and initialized using the copy constructor.<\/p>\n<p>Because this temporary is used to initialize <code>Fraction f2<\/code>, this invokes the copy constructor again to copy the temporary into <code>f2<\/code>.<\/p>\n<p>And when <code>f2<\/code> is passed to <code>printFraction()<\/code>, the copy constructor is called a third time.<\/p>\n<p>Thus, on the author&#8217;s machine, this example prints:<\/p>\n<pre>\nCopy constructor called\r\nCopy constructor called\r\nCopy constructor called\r\nFraction(1, 2)\r\n<\/pre>\n<p>If you compile and execute the above example, you may find that only two calls to the copy constructor occur.  This is a compiler optimization known as <em>copy elision<\/em>.  We discuss copy elision further in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-initialization-and-copy-elision\/\">14.15 -- Class initialization and copy elision<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using <code>= default<\/code> to generate a default copy constructor<\/p>\n<p>If a class has no copy constructor, the compiler will implicitly generate one for us.  If we prefer, we can explicitly request the compiler create a default copy constructor for us using the <code>= default<\/code> syntax:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n \r\nclass Fraction\r\n{\r\nprivate:\r\n    int m_numerator{ 0 };\r\n    int m_denominator{ 1 };\r\n \r\npublic:\r\n    \/\/ Default constructor\r\n    Fraction(int numerator=0, int denominator=1)\r\n        : m_numerator{numerator}, m_denominator{denominator}\r\n    {\r\n    }\r\n\r\n    \/\/ Explicitly request default copy constructor\r\n    Fraction(const Fraction&amp; fraction) = default;\r\n\r\n    void print() const\r\n    {\r\n        std::cout &lt;&lt; \"Fraction(\" &lt;&lt; m_numerator &lt;&lt; \", \" &lt;&lt; m_denominator &lt;&lt; \")\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Fraction f { 5, 3 };\r\n    Fraction fCopy { f };\r\n\r\n    f.print();\r\n    fCopy.print();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using <code>= delete<\/code> to prevent copies<\/p>\n<p>Occasionally we run into cases where we do not want objects of a certain class to be copyable.  We can prevent this by marking the copy constructor function as deleted, using the <code>= delete<\/code> syntax:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n \r\nclass Fraction\r\n{\r\nprivate:\r\n    int m_numerator{ 0 };\r\n    int m_denominator{ 1 };\r\n \r\npublic:\r\n    \/\/ Default constructor\r\n    Fraction(int numerator=0, int denominator=1)\r\n        : m_numerator{numerator}, m_denominator{denominator}\r\n    {\r\n    }\r\n\r\n    \/\/ Delete the copy constructor so no copies can be made\r\n    Fraction(const Fraction&amp; fraction) = delete;\r\n\r\n    void print() const\r\n    {\r\n        std::cout &lt;&lt; \"Fraction(\" &lt;&lt; m_numerator &lt;&lt; \", \" &lt;&lt; m_denominator &lt;&lt; \")\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Fraction f { 5, 3 };\r\n    Fraction fCopy { f }; \/\/ compile error: copy constructor has been deleted\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the example, when the compiler goes to find a constructor to initialize <code>fCopy<\/code> with <code>f<\/code>, it will see that the copy constructor has been deleted.  This will cause it to emit a compile error.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>You can also prevent the public from making copies of class object by making the copy constructor private (as private functions can&#8217;t be used by the public).  However, a private copy constructor <em>can<\/em> still be used by other members of the class, so this solution is not advised unless that is desired.\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>The <strong>rule of three<\/strong> is a well known C++ principle that states that if a class requires a user-defined copy constructor, destructor, or copy assignment operator, then it probably requires all three.  In C++11, this was expanded to the <strong>rule of five<\/strong>, which adds the move constructor and move assignment operator to the list.<\/p>\n<p>Not following the rule of three\/rule of five is likely to lead to malfunctioning code.  We&#8217;ll revisit the rule of three and rule of five when we cover dynamic memory allocation.<\/p>\n<p>We discuss destructors in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-destructors\/\">15.4 -- Introduction to destructors<\/a> and <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/destructors\/\">19.3 -- Destructors<\/a>, and copy assignment in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-the-assignment-operator\/\">21.12 -- Overloading the assignment operator<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>In the lesson above, we noted that the parameter for a copy constructor must be a (const) reference.  Why aren&#8217;t we allowed to use pass by value?<\/p>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_0'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_0\" style=\"display:none; margin-bottom: 1em\">Hint: Think about what happens when we pass a class type argument by value.<\/div>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>When we pass a class type argument by value, the copy constructor is implicitly invoked to copy the argument into the parameter.<\/p>\n<p>If the copy constructor used pass by value, the copy constructor would need to call itself to copy the initializer argument into the copy constructor parameter.  But that call to the copy constructor would also be pass by value, so the copy constructor would be invoked again to copy the argument into the function parameter.  This would lead to an infinite chain of calls to the copy constructor.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-initialization-and-copy-elision\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.15<\/span>Class initialization and copy elision\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/temporary-class-objects\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.13<\/span>Temporary class objects\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Consider the following program: #include &lt;iostream&gt; class Fraction { private: int m_numerator{ 0 }; int m_denominator{ 1 }; public: \/\/ Default constructor Fraction(int numerator=0, int denominator=1) : m_numerator{numerator}, m_denominator{denominator} { } void print() const { std::cout &lt;&lt; &#8220;Fraction(&#8221; &lt;&lt; m_numerator &lt;&lt; &#8220;, &#8221; &lt;&lt; m_denominator &lt;&lt; &#8220;)\\n&#8221;; } }; int &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/150"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=150"}],"version-history":[{"count":51,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/150\/revisions"}],"predecessor-version":[{"id":18004,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/150\/revisions\/18004"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=150"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=150"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=150"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}