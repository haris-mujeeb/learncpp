{"id":9389,"date":"2020-01-03T10:40:09","date_gmt":"2020-01-03T18:40:09","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=9389"},"modified":"2024-12-11T21:54:11","modified_gmt":"2024-12-12T05:54:11","slug":"external-linkage-and-variable-forward-declarations","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/external-linkage-and-variable-forward-declarations\/","title":{"rendered":"7.7 &#8212; External linkage and variable forward declarations"},"content":{"rendered":"<p>In the prior lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/internal-linkage\/\">7.6 -- Internal linkage<\/a>), we discussed how <code>internal linkage<\/code> limits the use of an identifier to a single file.  In this lesson, we&#8217;ll explore the concept of <code>external linkage<\/code>.<\/p>\n<p>An identifier with <strong>external linkage<\/strong> can be seen and used both from the file in which it is defined, and from other code files (via a forward declaration).  In this sense, identifiers with external linkage are truly &#8220;global&#8221; in that they can be used anywhere in your program!<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Identifiers with external linkage are visible to the linker.  This allows the linker to do two things:<\/p>\n<ul>\n<li>Connect an identifier used in one translation unit with the appropriate definition in another translation unit.\n<\/li>\n<li>Deduplicate inline identifiers so one canonical definition remains.  We discuss inline variables and functions in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/inline-functions-and-variables\/\">7.9 -- Inline functions and variables<\/a>.\n<\/li>\n<\/ul>\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Functions have external linkage by default<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/programs-with-multiple-code-files\/\">2.8 -- Programs with multiple code files<\/a>, you learned that you can call a function defined in one file from another file.  This is because functions have external linkage by default.<\/p>\n<p>In order to call a function defined in another file, you must place a <code>forward declaration<\/code> for the function in any other files wishing to use the function.  The forward declaration tells the compiler about the existence of the function, and the linker connects the function calls to the actual function definition.<\/p>\n<p>Here&#8217;s an example:<\/p>\n<p>a.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid sayHi() \/\/ this function has external linkage, and can be seen by other files\r\n{\r\n    std::cout &lt;&lt; \"Hi!\\n\";\r\n}<\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void sayHi(); \/\/ forward declaration for function sayHi, makes sayHi accessible in this file\r\n\r\nint main()\r\n{\r\n    sayHi(); \/\/ call to function defined in another file, linker will connect this call to the function definition\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The above program prints:<\/p>\n<pre>\r\nHi!\r\n<\/pre>\n<p>In the above example, the forward declaration of function <code>sayHi()<\/code> in <code>main.cpp<\/code> allows <code>main.cpp<\/code> to access the <code>sayHi()<\/code> function defined in <code>a.cpp<\/code>.  The forward declaration satisfies the compiler, and the linker is able to link the function call to the function definition.<\/p>\n<p>If function <code>sayHi()<\/code> had internal linkage instead, the linker would not be able to connect the function call to the function definition, and a linker error would result.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Global variables with external linkage<\/p>\n<p>Global variables with external linkage are sometimes called <strong>external variables<\/strong>.  To make a global variable external (and thus accessible by other files), we can use the <code>extern<\/code> keyword to do so:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int g_x { 2 }; \/\/ non-constant globals are external by default (no need to use extern)\r\n\r\nextern const int g_y { 3 }; \/\/ const globals can be defined as extern, making them external\r\nextern constexpr int g_z { 3 }; \/\/ constexpr globals can be defined as extern, making them external (but this is pretty useless, see the warning in the next section)\r\n\r\nint main()\r\n{\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Non-const global variables are external by default, so we don&#8217;t need to mark them as <code>extern<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Variable forward declarations via the extern keyword<\/p>\n<p>To actually use an external global variable that has been defined in another file, you also must place a <code>forward declaration<\/code> for the global variable in any other files wishing to use the variable.  For variables, creating a forward declaration is also done via the <code>extern<\/code> keyword (with no initialization value).<\/p>\n<p>Here is an example of using variable forward declarations:<\/p>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nextern int g_x;       \/\/ this extern is a forward declaration of a variable named g_x that is defined somewhere else\r\nextern const int g_y; \/\/ this extern is a forward declaration of a const variable named g_y that is defined somewhere else\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; g_x &lt;&lt; ' ' &lt;&lt; g_y &lt;&lt; '\\n'; \/\/ prints 2 3\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Here&#8217;s the definitions for those variables:<\/p>\n<p>a.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ global variable definitions\r\nint g_x { 2 };              \/\/ non-constant globals have external linkage by default\r\nextern const int g_y { 3 }; \/\/ this extern gives g_y external linkage<\/code><\/pre>\n<p>In the above example, <code>a.cpp<\/code> and <code>main.cpp<\/code> both reference the same global variable named <code>g_x<\/code>.  So even though <code>g_x<\/code> is defined and initialized in <code>a.cpp<\/code>, we are able to use its value in <code>main.cpp<\/code> via the forward declaration of <code>g_x<\/code>.<\/p>\n<p>Note that the <code>extern<\/code> keyword has different meanings in different contexts.  In some contexts, <code>extern<\/code> means &#8220;give this variable external linkage&#8221;.  In other contexts, <code>extern<\/code> means &#8220;this is a forward declaration for an external variable that is defined somewhere else&#8221;.  Yes, this is confusing, so we summarize all of these usages in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/scope-duration-and-linkage-summary\/\">7.12 -- Scope, duration, and linkage summary<\/a>.<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>If you want to define an uninitialized non-const global variable, do not use the extern keyword, otherwise C++ will think you&#8217;re trying to make a forward declaration for the variable.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Although constexpr variables can be given external linkage via the <code>extern<\/code> keyword, they can not be forward declared as constexpr.  This is because the compiler needs to know the value of the constexpr variable (at compile time). If that value is defined in some other file, the compiler has no visibility on what value was defined in that other file.<\/p>\n<p>However, you can forward declare a constexpr variable as const, which the compiler will treat as a runtime const.  This isn&#8217;t particularly useful.\n<\/p><\/div>\n<p>Note that function forward declarations don&#8217;t need the <code>extern<\/code> keyword -- the compiler is able to tell whether you&#8217;re defining a new function or making a forward declaration based on whether you supply a function body or not.  Variables forward declarations <em>do<\/em> need the <code>extern<\/code> keyword to help differentiate uninitialized variables definitions from variable forward declarations (they look otherwise identical):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ non-constant \r\nint g_x;        \/\/ variable definition (no initializer)\r\nint g_x { 1 };  \/\/ variable definition (w\/ initializer)\r\nextern int g_x; \/\/ forward declaration (no initializer)\r\n\r\n\/\/ constant\r\nextern const int g_y { 1 }; \/\/ variable definition (const requires initializers)\r\nextern const int g_y;       \/\/ forward declaration (no initializer)<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Avoid using <code>extern<\/code> on a non-const global variable with an initializer<\/p>\n<p>The following two lines are semantically equivalent:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int g_x { 1 };        \/\/ extern by default\r\nextern int g_x { 1 }; \/\/ explicitly extern (may cause compiler warning)<\/code><\/pre>\n<p>However, your compiler may issue a warning about the latter statement, even though it is technically valid.<\/p>\n<p>Remember when we said compilers have the leeway to issue a diagnostic for things they find suspicious?  This is one of those cases.  Conventionally, <code>extern<\/code> is applied to a non-const variable when we want a forward declaration.  However, adding an initializer makes the statement a definition instead.  The compiler is telling you that something seems amiss.  To correct it, either remove the initializer (if you intended a forward declaration) or remove the <code>extern<\/code> (if you intended a definition).<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Only use <code>extern<\/code> for global variable forward declarations or const global variable definitions.<br \/>\nDo not use <code>extern<\/code> for non-const global variable definitions (they are implicitly <code>extern<\/code>).\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quick summary<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Global variable forward declarations (extern w\/ no initializer):\r\nextern int g_y;                 \/\/ forward declaration for non-constant global variable\r\nextern const int g_y;           \/\/ forward declaration for const global variable\r\nextern constexpr int g_y;       \/\/ not allowed: constexpr variables can't be forward declared\r\n\r\n\/\/ External global variable definitions (no extern)\r\nint g_x;                        \/\/ defines non-initialized external global variable (zero initialized by default)\r\nint g_x { 1 };                  \/\/ defines initialized external global variable\r\n\r\n\/\/ External const global variable definitions (extern w\/ initializer)\r\nextern const int g_x { 2 };     \/\/ defines initialized const external global variable\r\nextern constexpr int g_x { 3 }; \/\/ defines initialized constexpr external global variable<\/code><\/pre>\n<p>We provide a comprehensive summary in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/scope-duration-and-linkage-summary\/\">7.12 -- Scope, duration, and linkage summary<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #1<\/p>\n<p>\nWhat&#8217;s the difference between a variable&#8217;s scope, duration, and linkage?  What kind of scope, duration, and linkage do global variables have?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>Scope determines where a variable is accessible.  Duration determines when a variable is created and destroyed.  Linkage determines whether the variable can be exported to another file or not.<\/p>\n<p>Global variables have global scope (a.k.a. file scope), which means they can be accessed from the point of declaration to the end of the file in which they are declared.<\/p>\n<p>Global variables have static duration, which means they are created when the program is started, and destroyed when it ends.<\/p>\n<p>Global variables can have either internal or external linkage, via the static and extern keywords respectively.\n<\/p><\/div>\n<\/p>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/why-non-const-global-variables-are-evil\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.8<\/span>Why (non-const) global variables are evil\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/internal-linkage\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.6<\/span>Internal linkage\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the prior lesson (), we discussed how internal linkage limits the use of an identifier to a single file. In this lesson, we&#8217;ll explore the concept of external linkage. An identifier with can be seen and used both from the file in which it is defined, and from other &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9389"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=9389"}],"version-history":[{"count":24,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9389\/revisions"}],"predecessor-version":[{"id":17979,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9389\/revisions\/17979"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=9389"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=9389"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=9389"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}