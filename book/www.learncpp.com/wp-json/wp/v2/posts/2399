{"id":2399,"date":"2015-08-18T13:52:55","date_gmt":"2015-08-18T21:52:55","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=2399"},"modified":"2023-11-20T10:30:58","modified_gmt":"2023-11-20T18:30:58","slug":"dynamically-allocating-arrays","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/dynamically-allocating-arrays\/","title":{"rendered":"19.2 &#8212; Dynamically allocating arrays"},"content":{"rendered":"<p>In addition to dynamically allocating single values, we can also dynamically allocate arrays of variables.  Unlike a fixed array, where the array size must be fixed at compile time, dynamically allocating an array allows us to choose an array length at runtime (meaning our length does not need to be constexpr).<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>In these lessons, we&#8217;ll be dynamically allocating C-style arrays, which is the most common type of dynamically allocated array.<\/p>\n<p>While you can dynamically allocate a <code>std::array<\/code>, you&#8217;re usually better off using a non-dynamically allocated <code>std::vector<\/code> in this case.\n<\/div>\n<p>To allocate an array dynamically, we use the array form of new and delete (often called new[] and delete[]):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cstddef&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter a positive integer: \";\r\n    std::size_t length{};\r\n    std::cin &gt;&gt; length;\r\n\r\n    int* array{ new int[length]{} }; \/\/ use array new.  Note that length does not need to be constant!\r\n\r\n    std::cout &lt;&lt; \"I just allocated an array of integers of length \" &lt;&lt; length &lt;&lt; '\\n';\r\n\r\n    array[0] = 5; \/\/ set element 0 to value 5\r\n\r\n    delete[] array; \/\/ use array delete to deallocate array\r\n\r\n    \/\/ we don't need to set array to nullptr\/0 here because it's going out of scope immediately after this anyway\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because we are allocating an array, C++ knows that it should use the array version of new instead of the scalar version of new.   Essentially, the new[] operator is called, even though the [] isn&#8217;t placed next to the new keyword.<\/p>\n<p>The length of dynamically allocated arrays has type <code>std::size_t<\/code>. If you are using a non-constexpr int, you&#8217;ll need to <code>static_cast<\/code> to <code>std::size_t<\/code> since that is considered a narrowing conversion and your compiler will warn otherwise.<\/p>\n<p>Note that because this memory is allocated from a different place than the memory used for fixed arrays, the size of the array can be quite large.  You can run the program above and allocate an array of length 1,000,000 (or probably even 100,000,000) without issue.  Try it!  Because of this, programs that need to allocate a lot of memory in C++ typically do so dynamically.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Dynamically deleting arrays<\/p>\n<p>When deleting a dynamically allocated array, we have to use the array version of delete, which is delete[].<\/p>\n<p>This tells the CPU that it needs to clean up multiple variables instead of a single variable.  One of the most common mistakes that new programmers make when dealing with dynamic memory allocation is to use delete instead of delete[] when deleting a dynamically allocated array.  Using the scalar version of delete on an array will result in undefined behavior, such as data corruption, memory leaks, crashes, or other problems.<\/p>\n<p>One often asked question of array delete[] is, &#8220;How does array delete know how much memory to delete?&#8221;  The answer is that array new[] keeps track of how much memory was allocated to a variable, so that array delete[] can delete the proper amount.  Unfortunately, this size\/length isn&#8217;t accessible to the programmer.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Dynamic arrays are almost identical to fixed arrays<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/c-style-array-decay\/\">17.8 -- C-style array decay<\/a>, you learned that a fixed array holds the memory address of the first array element.  You also learned that a fixed array can decay into a pointer that points to the first element of the array.  In this decayed form, the length of the fixed array is not available (and therefore neither is the size of the array via sizeof()), but otherwise there is little difference.<\/p>\n<p>A dynamic array starts its life as a pointer that points to the first element of the array.  Consequently, it has the same limitations in that it doesn&#8217;t know its length or size.  A dynamic array functions identically to a decayed fixed array, with the exception that the programmer is responsible for deallocating the dynamic array via the delete[] keyword.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Initializing dynamically allocated arrays<\/p>\n<p>If you want to initialize a dynamically allocated array to 0, the syntax is quite simple:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int* array{ new int[length]{} };<\/code><\/pre>\n<p>Prior to C++11, there was no easy way to initialize a dynamic array to a non-zero value (initializer lists only worked for fixed arrays).  This means you had to loop through the array and assign element values explicitly.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int* array = new int[5];\r\narray[0] = 9;\r\narray[1] = 7;\r\narray[2] = 5;\r\narray[3] = 3;\r\narray[4] = 1;<\/code><\/pre>\n<p>Super annoying!<\/p>\n<p>However, starting with C++11, it&#8217;s now possible to initialize dynamic arrays using initializer lists!<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int fixedArray[5] = { 9, 7, 5, 3, 1 }; \/\/ initialize a fixed array before C++11\r\nint* array{ new int[5]{ 9, 7, 5, 3, 1 } }; \/\/ initialize a dynamic array since C++11\r\n\/\/ To prevent writing the type twice, we can use auto. This is often done for types with long names.\r\nauto* array{ new int[5]{ 9, 7, 5, 3, 1 } };<\/code><\/pre>\n<p>Note that this syntax has no operator= between the array length and the initializer list.<\/p>\n<p>For consistency, fixed arrays can also be initialized using uniform initialization:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int fixedArray[]{ 9, 7, 5, 3, 1 }; \/\/ initialize a fixed array in C++11\r\nchar fixedArray[]{ \"Hello, world!\" }; \/\/ initialize a fixed array in C++11<\/code><\/pre>\n<p>Explicitly stating the size of the array is optional.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Resizing arrays<\/p>\n<p>Dynamically allocating an array allows you to set the array length at the time of allocation.  However, C++ does not provide a built-in way to resize an array that has already been allocated.  It is possible to work around this limitation by dynamically allocating a new array, copying the elements over, and deleting the old array.  However, this is error prone, especially when the element type is a class (which have special rules governing how they are created).<\/p>\n<p>Consequently, we recommend avoiding doing this yourself.  Use <code>std::vector<\/code> instead.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #1<\/p>\n<p>Write a program that:<\/p>\n<ul>\n<li>Asks the user how many names they wish to enter.\n<\/li>\n<li>Dynamically allocates a <code>std::string<\/code> array.\n<\/li>\n<li>Asks the user to enter each name.\n<\/li>\n<li>Calls <code>std::sort<\/code> to sort the names (See <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/sorting-an-array-using-selection-sort\/#stdsort\">18.1 -- Sorting an array using selection sort<\/a> and <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pointer-arithmetic-and-subscripting\/\">17.9 -- Pointer arithmetic and subscripting<\/a>)\n<\/li>\n<li>Prints the sorted list of names.\n<\/li>\n<\/ul>\n<p><code>std::string<\/code> supports comparing strings via the comparison operators &lt; and &gt;. You don&#8217;t need to implement string comparison by hand.<\/p>\n<p>Your output should match this:<\/p>\n<pre>\r\nHow many names would you like to enter? 5\r\nEnter name #1: Jason\r\nEnter name #2: Mark\r\nEnter name #3: Alex\r\nEnter name #4: Chris\r\nEnter name #5: John\r\n\r\nHere is your sorted list:\r\nName #1: Alex\r\nName #2: Chris\r\nName #3: Jason\r\nName #4: John\r\nName #5: Mark\r\n<\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">A reminder<\/p>\n<p>You can use <code>std::getline()<\/code> to read in names that contain spaces (see lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdstring\/\">5.7 -- Introduction to std::string<\/a>).\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">A reminder<\/p>\n<p>To use <code>std::sort()<\/code> with a pointer to an array, calculate begin and end manually<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::sort(array, array + arrayLength);<\/code><\/pre>\n<\/div>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt; \/\/ std::sort\r\n#include &lt;cstddef&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nstd::size_t getNameCount()\r\n{\r\n    std::cout &lt;&lt; \"How many names would you like to enter? \";\r\n    std::size_t length{};\r\n    std::cin &gt;&gt; length;\r\n\r\n    return length;\r\n}\r\n\r\n\/\/ Asks user to enter all the names\r\nvoid getNames(std::string* names, std::size_t length)\r\n{\r\n    for (std::size_t i{ 0 }; i &lt; length; ++i)\r\n    {\r\n        std::cout &lt;&lt; \"Enter name #\" &lt;&lt; i + 1 &lt;&lt; \": \";\r\n        std::getline(std::cin &gt;&gt; std::ws, names[i]);\r\n    }\r\n}\r\n\r\n\/\/ Prints the sorted names\r\nvoid printNames(std::string* names, std::size_t length)\r\n{\r\n    std::cout &lt;&lt; \"\\nHere is your sorted list:\\n\";\r\n\r\n    for (std::size_t i{ 0 }; i &lt; length; ++i)\r\n        std::cout &lt;&lt; \"Name #\" &lt;&lt; i + 1 &lt;&lt; \": \" &lt;&lt; names[i] &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::size_t length{ getNameCount() };\r\n\r\n    \/\/ Allocate an array to hold the names\r\n    auto* names{ new std::string[length]{} };\r\n\r\n    getNames(names, length);\r\n\r\n    \/\/ Sort the array\r\n    std::sort(names, names + length);\r\n\r\n    printNames(names, length);\r\n\r\n    \/\/ don't forget to use array delete\r\n    delete[] names;\r\n    \/\/ we don't need to set names to nullptr\/0 here because it's going to go out\r\n    \/\/ of scope immediately after this anyway.\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/destructors\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">19.3<\/span>Destructors\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/dynamic-memory-allocation-with-new-and-delete\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">19.1<\/span>Dynamic memory allocation with new and delete\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In addition to dynamically allocating single values, we can also dynamically allocate arrays of variables. Unlike a fixed array, where the array size must be fixed at compile time, dynamically allocating an array allows us to choose an array length at runtime (meaning our length does not need to be &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/2399"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=2399"}],"version-history":[{"count":66,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/2399\/revisions"}],"predecessor-version":[{"id":16106,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/2399\/revisions\/16106"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=2399"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=2399"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=2399"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}