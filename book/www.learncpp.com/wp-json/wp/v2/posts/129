{"id":129,"date":"2007-09-06T09:14:27","date_gmt":"2007-09-06T17:14:27","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/86-destructors\/"},"modified":"2023-11-30T12:46:45","modified_gmt":"2023-11-30T20:46:45","slug":"destructors","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/destructors\/","title":{"rendered":"19.3 &#8212; Destructors"},"content":{"rendered":"<p>A <strong>destructor<\/strong> is another special kind of class member function that is executed when an object of that class is destroyed.  Whereas constructors are designed to initialize a class, destructors are designed to help clean up.<\/p>\n<p>When an object goes out of scope normally, or a dynamically allocated object is explicitly deleted using the delete keyword, the class destructor is automatically called (if it exists) to do any necessary clean up before the object is removed from memory.  For simple classes (those that just initialize the values of normal member variables), a destructor is not needed because C++ will automatically clean up the memory for you.<\/p>\n<p>However, if your class object is holding any resources (e.g. dynamic memory, or a file or database handle), or if you need to do any kind of maintenance before the object is destroyed, the destructor is the perfect place to do so, as it is typically the last thing to happen before the object is destroyed.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Destructor naming<\/p>\n<p>Like constructors, destructors have specific naming rules:<\/p>\n<ol start=\"1\">\n<li>The destructor must have the same name as the class, preceded by a tilde (~).\n<\/li>\n<li>The destructor can not take arguments.\n<\/li>\n<li>The destructor has no return type.\n<\/li>\n<\/ol>\n<p>A class can only have a single destructor.<\/p>\n<p>Generally you should not call a destructor explicitly (as it will be called automatically when the object is destroyed), since there are rarely cases where you&#8217;d want to clean up an object more than once.  However, destructors may safely call other member functions since the object isn&#8217;t destroyed until after the destructor executes.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A destructor example<\/p>\n<p>Let&#8217;s take a look at a simple class that uses a destructor:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;cassert&gt;\r\n#include &lt;cstddef&gt;\r\n\r\nclass IntArray\r\n{\r\nprivate:\r\n\tint* m_array{};\r\n\tint m_length{};\r\n\r\npublic:\r\n\tIntArray(int length) \/\/ constructor\r\n\t{\r\n\t\tassert(length &gt; 0);\r\n\r\n\t\tm_array = new int[static_cast&lt;std::size_t&gt;(length)]{};\r\n\t\tm_length = length;\r\n\t}\r\n\r\n\t~IntArray() \/\/ destructor\r\n\t{\r\n\t\t\/\/ Dynamically delete the array we allocated earlier\r\n\t\tdelete[] m_array;\r\n\t}\r\n\r\n\tvoid setValue(int index, int value) { m_array[index] = value; }\r\n\tint getValue(int index) { return m_array[index]; }\r\n\r\n\tint getLength() { return m_length; }\r\n};\r\n\r\nint main()\r\n{\r\n\tIntArray ar ( 10 ); \/\/ allocate 10 integers\r\n\tfor (int count{ 0 }; count &lt; ar.getLength(); ++count)\r\n\t\tar.setValue(count, count+1);\r\n\r\n\tstd::cout &lt;&lt; \"The value of element 5 is: \" &lt;&lt; ar.getValue(5) &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n} \/\/ ar is destroyed here, so the ~IntArray() destructor function is called here<\/code><\/pre>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>If you compile the above example and get the following error:<\/p>\n<pre>\r\nerror: 'class IntArray' has pointer data members [-Werror=effc++]|\r\nerror:   but does not override 'IntArray(const IntArray&amp;)' [-Werror=effc++]|\r\nerror:   or 'operator=(const IntArray&amp;)' [-Werror=effc++]|\r\n<\/pre>\n<p>Then you can either remove the &#8220;-Weffc++&#8221; flag from your compile settings for this example, or you can add the following two lines to the class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\tIntArray(const IntArray&amp;) = delete;\r\n\tIntArray&amp; operator=(const IntArray&amp;) = delete;<\/code><\/pre>\n<p>We discuss <code>=delete<\/code> for members in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-the-copy-constructor\/\">14.14 -- Introduction to the copy constructor<\/a>\n<\/div>\n<p>This program produces the result:<\/p>\n<pre>\r\nThe value of element 5 is: 6\r\n<\/pre>\n<p>On the first line of main(), we instantiate a new IntArray class object called ar, and pass in a length of 10.  This calls the constructor, which dynamically allocates memory for the array member.  We must use dynamic allocation here because we do not know at compile time what the length of the array is (the caller decides that).<\/p>\n<p>At the end of main(), ar goes out of scope.  This causes the ~IntArray() destructor to be called, which deletes the array that we allocated in the constructor!<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">A reminder<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdvector-and-list-constructors\/\">16.2 -- Introduction to std::vector and list constructors<\/a>, we note that parentheses based initialization should be used when initializing an array\/container\/list class with a length (as opposed to a list of elements).  For this reason, we initialize IntArray using <code>IntArray ar ( 10 );<\/code>.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constructor and destructor timing<\/p>\n<p>As mentioned previously, the constructor is called when an object is created, and the destructor is called when an object is destroyed.  In the following example, we use cout statements inside the constructor and destructor to show this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Simple\r\n{\r\nprivate:\r\n    int m_nID{};\r\n\r\npublic:\r\n    Simple(int nID)\r\n        : m_nID{ nID }\r\n    {\r\n        std::cout &lt;&lt; \"Constructing Simple \" &lt;&lt; nID &lt;&lt; '\\n';\r\n    }\r\n\r\n    ~Simple()\r\n    {\r\n        std::cout &lt;&lt; \"Destructing Simple\" &lt;&lt; m_nID &lt;&lt; '\\n';\r\n    }\r\n\r\n    int getID() { return m_nID; }\r\n};\r\n\r\nint main()\r\n{\r\n    \/\/ Allocate a Simple on the stack\r\n    Simple simple{ 1 };\r\n    std::cout &lt;&lt; simple.getID() &lt;&lt; '\\n';\r\n\r\n    \/\/ Allocate a Simple dynamically\r\n    Simple* pSimple{ new Simple{ 2 } };\r\n    \r\n    std::cout &lt;&lt; pSimple-&gt;getID() &lt;&lt; '\\n';\r\n\r\n    \/\/ We allocated pSimple dynamically, so we have to delete it.\r\n    delete pSimple;\r\n\r\n    return 0;\r\n} \/\/ simple goes out of scope here<\/code><\/pre>\n<p>This program produces the following result:<\/p>\n<pre>\r\nConstructing Simple 1\r\n1\r\nConstructing Simple 2\r\n2\r\nDestructing Simple 2\r\nDestructing Simple 1\r\n<\/pre>\n<p>Note that &#8220;Simple 1&#8221; is destroyed after &#8220;Simple 2&#8221; because we deleted pSimple before the end of the function, whereas simple was not destroyed until the end of main().<\/p>\n<p>Global variables are constructed before main() and destroyed after main().<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">RAII<\/p>\n<p>RAII (Resource Acquisition Is Initialization) is a programming technique whereby resource use is tied to the lifetime of objects with automatic duration (e.g. non-dynamically allocated objects).  In C++, RAII is implemented via classes with constructors and destructors.  A resource (such as memory, a file or database handle, etc&#8230;) is typically acquired in the object&#8217;s constructor (though it can be acquired after the object is created if that makes sense).  That resource can then be used while the object is alive.  The resource is released in the destructor, when the object is destroyed.  The primary advantage of RAII is that it helps prevent resource leaks (e.g. memory not being deallocated) as all resource-holding objects are cleaned up automatically.<\/p>\n<p>The IntArray class at the top of this lesson is an example of a class that implements RAII -- allocation in the constructor, deallocation in the destructor.  std::string and std::vector are examples of classes in the standard library that follow RAII -- dynamic memory is acquired on initialization, and cleaned up automatically on destruction.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A warning about the std::exit() function<\/p>\n<p>Note that if you use the std::exit() function, your program will terminate and no destructors will be called.  Be wary if you&#8217;re relying on your destructors to do necessary cleanup work (e.g. write something to a log file or database before exiting).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Summary<\/p>\n<p>As you can see, when constructors and destructors are used together, your classes can initialize and clean up after themselves without the programmer having to do any special work!  This reduces the probability of making an error, and makes classes easier to use.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pointers-to-pointers\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">19.4<\/span>Pointers to pointers and dynamic multidimensional arrays\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/dynamically-allocating-arrays\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">19.2<\/span>Dynamically allocating arrays\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>A destructor is another special kind of class member function that is executed when an object of that class is destroyed. Whereas constructors are designed to initialize a class, destructors are designed to help clean up. When an object goes out of scope normally, or a dynamically allocated object is &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/129"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=129"}],"version-history":[{"count":33,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/129\/revisions"}],"predecessor-version":[{"id":16163,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/129\/revisions\/16163"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=129"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=129"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=129"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}