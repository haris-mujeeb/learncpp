{"id":126,"date":"2007-09-04T14:17:11","date_gmt":"2007-09-04T22:17:11","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/83-public-vs-private-access-functions-and-encapsulation\/"},"modified":"2024-07-03T19:03:29","modified_gmt":"2024-07-04T02:03:29","slug":"public-and-private-members-and-access-specifiers","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/public-and-private-members-and-access-specifiers\/","title":{"rendered":"14.5 &#8212; Public and private members and access specifiers"},"content":{"rendered":"<p>Let&#8217;s say you&#8217;re walking down the street on a brisk autumn day, eating a burrito.  You want somewhere to sit, so you look around.  To your left is a park, with mowed grass and shade trees, a few uncomfortable benches, and screaming kids on the nearby playground.  To your right is a stranger&#8217;s residence.  Through the window, you see a comfy reclining chair and a crackling fireplace.<\/p>\n<p>With a heavy sigh, you choose the park.<\/p>\n<p>The key determinant for your choice is that the park is a public space, whereas the residence is private.  You (and anyone else) are allowed to freely access public spaces.  But only the members of the residence (or those given explicit permission to enter) are permitted to access the private residence.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Member access<\/p>\n<p>A similar concept applies to the members of a class type.  Each member of a class type has a property called an <strong>access level<\/strong> that determines who can access that member.<\/p>\n<p>C++ has three different access levels: <em>public<\/em>, <em>private<\/em>, and <em>protected<\/em>.  In this lesson, we&#8217;ll cover the two commonly used access levels: public and private.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We discuss the protected access level in the chapter on inheritance (lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/inheritance-and-access-specifiers\/\">24.5 -- Inheritance and access specifiers<\/a>).\n<\/p><\/div>\n<p>Whenever a member is accessed, the compiler checks whether the access level of the member permits that member to be accessed.  If the access is not permitted, the compiler will generate a compilation error.  This access level system is sometimes informally called <strong>access controls<\/strong>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The members of a struct are public by default<\/p>\n<p>Members that have the <em>public<\/em> access level are called <em>public members<\/em>.  <strong>Public members<\/strong> are members of a class type that do not have any restrictions on how they can be accessed.  Much like the park in our opening analogy, public members can be accessed by anyone (as long as they are in scope).<\/p>\n<p>Public members can be accessed by other members of the same class.  Notably, public members can also be accessed by <strong>the public<\/strong>, which is what we call code that exists <em>outside<\/em> the members of a given class type.  Examples of <em>the public<\/em> include non-member functions, as well as the members of other class types.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>The members of a struct are public by default.  Public members can be accessed by other members of the class type, and by the public.<\/p>\n<p>The term &#8220;the public&#8221; is used to refer to code that exists outside of the members of a given class type.  This includes non-member functions, as well as the members of other class types.\n<\/p><\/div>\n<p>By default, all members of a struct are public members.<\/p>\n<p>Consider the following struct:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Date\r\n{\r\n    \/\/ struct members are public by default, can be accessed by anyone\r\n    int year {};       \/\/ public by default\r\n    int month {};      \/\/ public by default\r\n    int day {};        \/\/ public by default\r\n\r\n    void print() const \/\/ public by default\r\n    {\r\n        \/\/ public members can be accessed in member functions of the class type\r\n        std::cout &lt;&lt; year &lt;&lt; '\/' &lt;&lt; month &lt;&lt; '\/' &lt;&lt; day;\r\n    }\r\n};\r\n\r\n\/\/ non-member function main is part of \"the public\"\r\nint main()\r\n{\r\n    Date today { 2020, 10, 14 }; \/\/ aggregate initialize our struct\r\n\r\n    \/\/ public members can be accessed by the public\r\n    today.day = 16; \/\/ okay: the day member is public\r\n    today.print();  \/\/ okay: the print() member function is public\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this example, members are accessed in three places:<\/p>\n<ul>\n<li>Within member function <code>print()<\/code>, we access the <code>year<\/code>, <code>month<\/code>, and <code>day<\/code> members of the implicit object.\n<\/li>\n<li>In <code>main()<\/code>, we directly access <code>today.day<\/code> to set its value.\n<\/li>\n<li>In <code>main()<\/code>, we call member function <code>today.print()<\/code>.\n<\/li>\n<\/ul>\n<p>All three of these accesses are allowed because public members can be accessed from anywhere.<\/p>\n<p>Because <code>main()<\/code> is not a member of <code>Date<\/code>, it is considered to be part of <em>the public<\/em>.  However, because <em>the public<\/em> has access to public members, <code>main()<\/code> can directly access the members of <code>Date<\/code> (which includes the call to <code>today.print()<\/code>).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The members of a class are private by default<\/p>\n<p>Members that have the <em>private<\/em> access level are called <em>private members<\/em>.  <strong>Private members<\/strong> are members of a class type that can only be accessed by other members of the same class.<\/p>\n<p>Consider the following example, which is almost identical to the one above:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Date \/\/ now a class instead of a struct\r\n{\r\n    \/\/ class members are private by default, can only be accessed by other members\r\n    int m_year {};     \/\/ private by default\r\n    int m_month {};    \/\/ private by default\r\n    int m_day {};      \/\/ private by default\r\n\r\n    void print() const \/\/ private by default\r\n    {\r\n        \/\/ private members can be accessed in member functions\r\n        std::cout &lt;&lt; m_year &lt;&lt; '\/' &lt;&lt; m_month &lt;&lt; '\/' &lt;&lt; m_day;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Date today { 2020, 10, 14 }; \/\/ compile error: can no longer use aggregate initialization\r\n\r\n    \/\/ private members can not be accessed by the public\r\n    today.m_day = 16; \/\/ compile error: the m_day member is private\r\n    today.print();    \/\/ compile error: the print() member function is private\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this example, members are accessed in the same three places:<\/p>\n<ul>\n<li>Within member function <code>print()<\/code>, we access the <code>m_year<\/code>, <code>m_month<\/code>, and <code>m_day<\/code> members of the implicit object.\n<\/li>\n<li>In <code>main()<\/code>, we directly access <code>today.m_day<\/code> to set its value.\n<\/li>\n<li>In <code>main()<\/code>, we call member function <code>today.print()<\/code>.\n<\/li>\n<\/ul>\n<p>However, if you compile this program, you will note that three compilation errors are generated.<\/p>\n<p>Within <code>main()<\/code>, the statements <code>today.m_day = 16<\/code> and <code>today.print()<\/code> now both generate compilation errors.  This is because <code>main()<\/code> is part of the public, and the public is not allowed to directly access private members.<\/p>\n<p>Within <code>print()<\/code>, access to members <code>m_year<\/code>, <code>m_month<\/code>, and <code>m_day<\/code> is allowed.  This is because <code>print()<\/code> is a member of the class, and members of the class are allowed to access private members.<\/p>\n<p>So where does the third compilation error come from?  Perhaps surprisingly, the initialization of <code>today<\/code> now causes a compilation error.  In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/struct-aggregate-initialization\/\">13.8 -- Struct aggregate initialization<\/a>, we noted that an aggregate can have &#8220;no private or protected non-static data members.&#8221;  Our <code>Date<\/code> class has private data members (because the members of classes are private by default), so our <code>Date<\/code> class does not qualify as an aggregate.  Therefore, we can not use aggregate initialization to initialize it any more.<\/p>\n<p>We&#8217;ll discuss how to properly initialize classes (which are generally non-aggregates) in upcoming lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-constructors\/\">14.9 -- Introduction to constructors<\/a>.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>The members of a class are private by default.  Private members can be accessed by other members of the class, but can not be accessed by the public.<\/p>\n<p>A class with private members is no longer an aggregate, and therefore can no longer use aggregate initialization.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Naming your private member variables<\/p>\n<p>In C++, it is a common convention to name private data members starting with an &#8220;m_&#8221; prefix.  This is done for a couple of important reasons.<\/p>\n<p>Consider the following member function of some class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Some member function that sets private member m_name to the value of the name parameter\r\nvoid setName(std::string_view name)\r\n{\r\n    m_name = name;\r\n}<\/code><\/pre>\n<p>First, the &#8220;m_&#8221; prefix allows us to easily differentiate data members from function parameters or local variables within a member function.  We can easily see that &#8220;m_name&#8221; is a member, and &#8220;name&#8221; is not.  This helps make it clear that this function is changing the state of the class.  And that is important because when we change the value of a data member, it persists beyond the scope of the member function (whereas changes to function parameters or local variables typically do not).<\/p>\n<p>This is the same reason we recommend using &#8220;s_&#8221; prefixes for local static variables, and &#8220;g_&#8221; prefixes for globals.<\/p>\n<p>Second, the &#8220;m_&#8221; prefix helps prevent naming collisions between private member variables and the names of local variables, function parameters, and member functions.<\/p>\n<p>If we had named our private member <code>name<\/code> instead of <code>m_name<\/code>, then:<\/p>\n<ul>\n<li>Our <code>name<\/code> function parameter would have shadowed the <code>name<\/code> private data member.\n<\/li>\n<li>If we had a member function named <code>name<\/code>, we&#8217;d get a compile error due to a redefinition of identifier <code>name<\/code>.\n<\/li>\n<\/ul>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Consider naming your private data members starting with an &#8220;m_&#8221; prefix to help distinguish them from the names of local variables, function parameters, and member functions.<\/p>\n<p>Public members of classes may also follow this convention if desired.  However, the public members of structs typically do not use this prefix since structs generally do not have many member functions (if any).\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Setting access levels via access specifiers<\/p>\n<p>By default, the members of structs (and unions) are public, and the members of classes are private.<\/p>\n<p>However, we can explicitly set the access level of our members by using an <strong>access specifier<\/strong>.  An access specifier sets the access level of <em>all members<\/em> that follow the specifier.  C++ provides three access specifiers: <code>public:<\/code>, <code>private:<\/code>, and <code>protected:<\/code>.<\/p>\n<p>In the following example, we use both the <code>public:<\/code> access specifier to make sure the <code>print()<\/code> member function can be used by the public, and the <code>private:<\/code> access specifier to make our data members private.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Date\r\n{\r\n\/\/ Any members defined here would default to private\r\n\r\npublic: \/\/ here's our public access specifier\r\n\r\n    void print() const \/\/ public due to above public: specifier\r\n    {\r\n        \/\/ members can access other private members\r\n        std::cout &lt;&lt; m_year &lt;&lt; '\/' &lt;&lt; m_month &lt;&lt; '\/' &lt;&lt; m_day;\r\n    }\r\n\r\nprivate: \/\/ here's our private access specifier \r\n\r\n    int m_year { 2020 };  \/\/ private due to above private: specifier\r\n    int m_month { 14 }; \/\/ private due to above private: specifier\r\n    int m_day { 10 };   \/\/ private due to above private: specifier\r\n};\r\n\r\nint main()\r\n{\r\n    Date d{};\r\n    d.print();  \/\/ okay, main() allowed to access public members\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This example compiles.  Because <code>print()<\/code> is a public member due to the <code>public:<\/code> access specifier, <code>main()<\/code> (which is part of the public) is allowed to access it.<\/p>\n<p>Because we have private members, we can not aggregate initialize <code>d<\/code>.  For this example, we&#8217;re using default member initialization instead (as a temporary workaround).<\/p>\n<p>Since classes default to private access, you can omit a leading <code>private:<\/code> access specifier:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Foo\r\n{\r\n\/\/ private access specifier not required here since classes default to private members\r\n    int m_something {};  \/\/ private by default\r\n};<\/code><\/pre>\n<p>However, because classes and structs have different access level defaults, many developers prefer to be explicit:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Foo\r\n{\r\nprivate: \/\/ redundant, but makes it clear that what follows is private\r\n    int m_something {};  \/\/ private by default\r\n};<\/code><\/pre>\n<p>Although this is technically redundant, use of an explicit <code>private:<\/code> specifier makes it clear that the following members are private, without having to infer what the default access level is based on whether <code>Foo<\/code> was defined as a class or a struct.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Access level summary<\/p>\n<p>Here&#8217;s a quick summary table of the different access levels:<\/p>\n<div class=\"cpp-table-wrapper\">\n<table class=\"cpp-table\">\n<tr>\n<th> Access level <\/th>\n<th> Access specifier <\/th>\n<th> Member access <\/th>\n<th> Derived class access <\/th>\n<th> Public access <\/th>\n<\/tr>\n<tr>\n<td> Public    <\/td>\n<td> public:    <\/td>\n<td> yes <\/td>\n<td> yes <\/td>\n<td> yes <\/td>\n<\/tr>\n<tr>\n<td> Protected <\/td>\n<td> protected: <\/td>\n<td> yes <\/td>\n<td> yes <\/td>\n<td> no  <\/td>\n<\/tr>\n<tr>\n<td> Private   <\/td>\n<td> private:   <\/td>\n<td> yes <\/td>\n<td> no  <\/td>\n<td> no  <\/td>\n<\/tr>\n<\/table>\n<\/div>\n<p>A class type is allowed to use any number of access specifiers in any order, and they can be used repeatedly (e.g. you can have some public members, then some private ones, then more public ones).<\/p>\n<p>Most classes make use of both the private and public access specifiers for various members.  We&#8217;ll see an example of this in the next section.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Access level best practices for structs and classes<\/p>\n<p>Now that we&#8217;ve covered what access levels are, let&#8217;s talk about how we should use them.<\/p>\n<p>Structs should avoid access specifiers altogether, meaning all struct members will be public by default.  We want our structs to be aggregates, and aggregates can only have public members.  Using the <code>public:<\/code> access specifier would be redundant with the default, and using <code>private:<\/code> or <code>protected:<\/code> would make the struct a non-aggregate.<\/p>\n<p>Classes should generally only have private (or protected) data members (either by using the default private access level, or the <code>private:<\/code> (or <code>protected:<\/code>) access specifier).  We&#8217;ll discuss the rationale for this in the next lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/access-functions\/\">14.6 -- Access functions<\/a>.  <\/p>\n<p>Classes normally have public member functions (so those member functions can be used by the public after the object is created).  However, occasionally member functions are made private (or protected) if they are not intended to be used by the public.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Classes should generally make member variables private (or protected), and member functions public.<\/p>\n<p>Structs should generally avoid using access specifiers (all members will default to public).\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Access levels work on a per-class basis<\/p>\n<p>One nuance of C++ access levels that is often missed or misunderstood is that access to members is defined on a per-class basis, not on a per-object basis.<\/p>\n<p>You already know that a member function can directly access private members (of the implicit object).  However, because access levels are per-class, not per-object, a member function can also directly access the private members of ANY other object of the same class type that is in scope.<\/p>\n<p>Let&#8217;s illustrate this with an example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Person\r\n{\r\nprivate:\r\n    std::string m_name{};\r\n\r\npublic:\r\n    void kisses(const Person&amp; p) const\r\n    {\r\n        std::cout &lt;&lt; m_name &lt;&lt; \" kisses \" &lt;&lt; p.m_name &lt;&lt; '\\n';\r\n    }\r\n\r\n    void setName(std::string_view name)\r\n    {\r\n        m_name = name;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Person joe;\r\n    joe.setName(\"Joe\");\r\n    \r\n    Person kate;\r\n    kate.setName(\"Kate\");\r\n\r\n    joe.kisses(kate);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nJoe kisses Kate\r\n<\/pre>\n<p>There are a few things to note here.<\/p>\n<p>First, <code>m_name<\/code> has been made private, so it can only be accessed by members of the <code>Person<\/code> class (not the public).<\/p>\n<p>Second, because our class has private members, it is not an aggregate, and we can&#8217;t use aggregate initialization to initialize our Person objects.  As a workaround (until we cover a proper solution to this issue), we&#8217;ve created a public member function named <code>setName()<\/code> that allows us to assign a name to our Person objects.<\/p>\n<p>Third, because <code>kisses()<\/code> is a member function, it has direct access to private member <code>m_name<\/code>.  However, you might be surprised to see that it also has direct access to <code>p.m_name<\/code>!  This works because <code>p<\/code> is a <code>Person<\/code> object, and <code>kisses()<\/code> can access the private members of any <code>Person<\/code> object in scope!<\/p>\n<p>We&#8217;ll see additional examples where we make use of this in the chapter on operator overloading.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The technical and practical difference between structs and classes<\/p>\n<p>Now that we&#8217;ve covered access levels, we can finally discuss the technical differences between structs and classes.  Ready?<\/p>\n<p>A class defaults its members to private, whereas a struct defaults its members to public.<\/p>\n<p>&#8230;<\/p>\n<p>Yup, that&#8217;s it.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>To be pedantic, there&#8217;s one more minor difference -- structs inherit from other class types publicly and classes inherit privately.  We&#8217;ll cover what this means in the chapter on inheritance, but this particular point is practically irrelevant since you shouldn&#8217;t rely on the defaults for inheritance anyway.\n<\/p><\/div>\n<p>In practice, we use structs and classes differently.<\/p>\n<p>As a rule of thumb, use a struct when all of the following are true:<\/p>\n<ul>\n<li>You have a simple collection of data that doesn&#8217;t benefit from restricting access.\n<\/li>\n<li>Aggregate initialization is sufficient.\n<\/li>\n<li>You have no class invariants, setup needs, or cleanup needs.\n<\/li>\n<\/ul>\n<p>A few examples of where structs might be used: constexpr global program data, a point struct (a simple collection of int members that don&#8217;t benefit from being made private), structs used to return a set of data from a function.<\/p>\n<p>Use a class otherwise.<\/p>\n<p>We want our structs to be aggregates.  So if you use any capabilities that makes your struct a non-aggregate, you should probably be using a class instead (and following all of the best practices for classes).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>a) What is a public member?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\nA public member is a member of a class that can be accessed by anyone, including other members of the same class and the public.<\/div>\n<p>b) What is a private member?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\nA private member is a member of a class that can only be accessed by other members of the class.<\/div>\n<p>c) What is an access specifier?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\nAn access specifier determines who has access to the members that follow the specifier.<\/div>\n<p>d) How many access specifiers are there, and what are they?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\nThree.  Public, private, and protected.<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>a) Write a class named <code>Point3d<\/code>.  The class should contain:<\/p>\n<ul>\n<li>Three private member variables of type <code>int<\/code> named <code>m_x<\/code>, <code>m_y<\/code>, and <code>m_z<\/code>;\n<\/li>\n<li>A public member function named <code>setValues()<\/code> that allows you to set values for <code>m_x<\/code>, <code>m_y<\/code>, and <code>m_z<\/code>.\n<\/li>\n<li>A public member function named <code>print()<\/code> that prints the Point in the following format: &lt;m_x, m_y, m_z&gt;\n<\/li>\n<\/ul>\n<p>Make sure the following program executes correctly:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    Point3d point;\r\n    point.setValues(1, 2, 3);\r\n\r\n    point.print();\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This should print:<\/p>\n<pre>\n&lt;1, 2, 3&gt;\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Point3d\r\n{\r\nprivate:\r\n    int m_x {};\r\n    int m_y {};\r\n    int m_z {};\r\n\r\npublic:\r\n\tvoid setValues(int x, int y, int z)\r\n\t{\r\n\t\tm_x = x;\r\n\t\tm_y = y;\r\n\t\tm_z = z;\r\n\t}\r\n\r\n\tvoid print() const\r\n\t{\r\n\t\tstd::cout &lt;&lt; '&lt;' &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \", \" &lt;&lt; m_z &lt;&lt; '&gt;';\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n    Point3d point;\r\n    point.setValues(1, 2, 3);\r\n\r\n    point.print();\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>b) Add a function named <code>isEqual()<\/code> to your Point3d class.  The following code should run correctly:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n\tPoint3d point1{};\r\n\tpoint1.setValues(1, 2, 3);\r\n\r\n\tPoint3d point2{};\r\n\tpoint2.setValues(1, 2, 3);\r\n\r\n\tstd::cout &lt;&lt; \"point 1 and point 2 are\" &lt;&lt; (point1.isEqual(point2) ? \"\" : \" not\") &lt;&lt; \" equal\\n\";\r\n\r\n\tPoint3d point3{};\r\n\tpoint3.setValues(3, 4, 5);\r\n\r\n\tstd::cout &lt;&lt; \"point 1 and point 3 are\" &lt;&lt; (point1.isEqual(point3) ? \"\" : \" not\") &lt;&lt; \" equal\\n\";\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This should print:<\/p>\n<pre>\npoint 1 and point 2 are equal\r\npoint 1 and point 3 are not equal\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_5'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_5\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Point3d\r\n{\r\nprivate:\r\n\tint m_x {};\r\n\tint m_y {};\r\n\tint m_z {};\r\n\r\npublic:\r\n\tvoid setValues(int x, int y, int z)\r\n\t{\r\n\t\tm_x = x;\r\n\t\tm_y = y;\r\n\t\tm_z = z;\r\n\t}\r\n\r\n\tvoid print() const\r\n\t{\r\n\t\tstd::cout &lt;&lt; '&lt;' &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \", \" &lt;&lt; m_z &lt;&lt; '&gt;';\r\n\t}\r\n\r\n\t\/\/ We can use the fact that access controls work on a per-class basis here\r\n\t\/\/ to directly access the private members of Point3d parameter p\r\n\tbool isEqual(const Point3d&amp; p) const\r\n\t{\r\n\t\treturn (m_x == p.m_x) &amp;&amp; (m_y == p.m_y) &amp;&amp; (m_z == p.m_z);\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tPoint3d point1{};\r\n\tpoint1.setValues(1, 2, 3);\r\n\r\n\tPoint3d point2{};\r\n\tpoint2.setValues(1, 2, 3);\r\n\r\n\tstd::cout &lt;&lt; \"point 1 and point 2 are\" &lt;&lt; (point1.isEqual(point2) ? \"\" : \" not\") &lt;&lt; \" equal\\n\";\r\n\r\n\tPoint3d point3{};\r\n\tpoint3.setValues(3, 4, 5);\r\n\r\n\tstd::cout &lt;&lt; \"point 1 and point 3 are\" &lt;&lt; (point1.isEqual(point3) ? \"\" : \" not\") &lt;&lt; \" equal\\n\";\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/access-functions\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.6<\/span>Access functions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/const-class-objects-and-const-member-functions\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.4<\/span>Const class objects and const member functions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Let&#8217;s say you&#8217;re walking down the street on a brisk autumn day, eating a burrito. You want somewhere to sit, so you look around. To your left is a park, with mowed grass and shade trees, a few uncomfortable benches, and screaming kids on the nearby playground. To your right &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/126"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=126"}],"version-history":[{"count":59,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/126\/revisions"}],"predecessor-version":[{"id":2488,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/126\/revisions\/2488"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=126"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=126"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=126"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}