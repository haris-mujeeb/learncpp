{"id":7892,"date":"2019-02-01T09:56:41","date_gmt":"2019-02-01T17:56:41","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=7892"},"modified":"2024-11-29T15:21:13","modified_gmt":"2024-11-29T23:21:13","slug":"uninitialized-variables-and-undefined-behavior","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/uninitialized-variables-and-undefined-behavior\/","title":{"rendered":"1.6 &#8212; Uninitialized variables and undefined behavior"},"content":{"rendered":"<p class=\"cpp-section\">Uninitialized variables<\/p>\n<p>Unlike some programming languages, C\/C++ does not automatically initialize most variables to a given value (such as zero).  When a variable that is not initialized is given a memory address to use to store data, the default value of that variable is whatever (garbage) value happens to already be in that memory address!  A variable that has not been given a known value (through initialization or assignment) is called an <strong>uninitialized variable<\/strong>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Nomenclature<\/p>\n<p>Many readers expect the terms &#8220;initialized&#8221; and &#8220;uninitialized&#8221; to be strict opposites, but they aren&#8217;t quite!  In common language, &#8220;initialized&#8221; means the object was provided with an initial value at the point of definition.  &#8220;Uninitialized&#8221; means the object has not been given a known value yet (through any means, including assignment).  Therefore, an object that is not initialized but is then assigned a value is no longer <em>uninitialized<\/em> (because it has been given a known value).<\/p>\n<p>To recap:<\/p>\n<ul>\n<li>Initialized = The object is given a known value at the point of definition.\n<\/li>\n<li>Assignment = The object is given a known value beyond the point of definition.\n<\/li>\n<li>Uninitialized = The object has not been given a known value yet.\n<\/li>\n<\/ul>\n<p>Relatedly, consider this variable definition:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int x;<\/code><\/pre>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/variable-assignment-and-initialization\/\">1.4 -- Variable assignment and initialization<\/a>, we noted that when no initializer is provided, the variable is default-initialized.  In most cases (such as this one), default-initialization performs no actual initialization.  Thus we&#8217;d say <code>x<\/code> is uninitialized.  We&#8217;re focused on the outcome (the object has not been given a known value), not the process.\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>This lack of initialization is a performance optimization inherited from C, back when computers were slow.  Imagine a case where you were going to read in 100,000 values from a file.  In such case, you might create 100,000 variables, then fill them with data from the file.<\/p>\n<p>If C++ initialized all of those variables with default values upon creation, this would result in 100,000 initializations (which would be slow), and for little benefit (since you&#8217;re overwriting those values anyway).<\/p>\n<p>For now, you should always initialize your variables because the cost of doing so is minuscule compared to the benefit.  Once you are more comfortable with the language, there may be certain cases where you omit the initialization for optimization purposes.  But this should always be done selectively and intentionally.\n<\/p><\/div>\n<p>Using the values of uninitialized variables can lead to unexpected results.  Consider the following short program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    \/\/ define an integer variable named x\r\n    int x; \/\/ this variable is uninitialized because we haven't given it a value\r\n    \r\n    \/\/ print the value of x to the screen\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n'; \/\/ who knows what we'll get, because x is uninitialized\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this case, the computer will assign some unused memory to <em>x<\/em>.  It will then send the value residing in that memory location to <em>std::cout<\/em>, which will print the value (interpreted as an integer).  But what value will it print?  The answer is &#8220;who knows!&#8221;, and the answer may (or may not) change every time you run the program.  When the author ran this program in Visual Studio, <em>std::cout<\/em> printed the value <code>7177728<\/code> one time, and <code>5277592<\/code> the next.  Feel free to compile and run the program yourself (your computer won&#8217;t explode).<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Some compilers, such as Visual Studio, <em>will<\/em> initialize the contents of memory to some preset value when you&#8217;re using a debug build configuration.  This will not happen when using a release build configuration.  Therefore, if you want to run the above program yourself, make sure you&#8217;re using a <em>release build configuration<\/em> (see lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/configuring-your-compiler-build-configurations\/\">0.9 -- Configuring your compiler: Build configurations<\/a> for a reminder on how to do that).<\/p>\n<p>For example, if you run the above program in a Visual Studio debug configuration, it will consistently print -858993460, because that&#8217;s the value (interpreted as an integer) that Visual Studio initializes memory with in debug configurations.\n<\/p><\/div>\n<p>Most modern compilers will attempt to detect if a variable is being used without being given a value.  If they are able to detect this, they will generally issue a compile-time warning or error.  For example, compiling the above program on Visual Studio produced the following warning:<\/p>\n<p><code>c:\\VCprojects\\test\\test.cpp(11) : warning C4700: uninitialized local variable 'x' used<\/code><\/p>\n<p>If your compiler won&#8217;t let you compile and run the above program (e.g. because it treats the issue as an error), here is a possible solution to get around this issue:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid doNothing(int&amp;) \/\/ Don't worry about what &amp; is for now, we're just using it to trick the compiler into thinking variable x is used\r\n{\r\n}\r\n\r\nint main()\r\n{\r\n    \/\/ define an integer variable named x\r\n    int x; \/\/ this variable is uninitialized\r\n\r\n    doNothing(x); \/\/ make the compiler think we're assigning a value to this variable\r\n\r\n    \/\/ print the value of x to the screen (who knows what we'll get, because x is uninitialized)\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Using uninitialized variables is one of the most common mistakes that novice programmers make, and unfortunately, it can also be one of the most challenging to debug (because the program may run fine anyway if the uninitialized variable happened to get assigned to a spot of memory that had a reasonable value in it, like 0).<\/p>\n<p>This is the primary reason for the &#8220;always initialize your variables&#8221; best practice.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Undefined behavior<\/p>\n<p>Using the value from an uninitialized variable is our first example of undefined behavior.  <strong>Undefined behavior<\/strong> (often abbreviated <strong>UB<\/strong>) is the result of executing code whose behavior is not well-defined by the C++ language.  In this case, the C++ language doesn&#8217;t have any rules determining what happens if you use the value of a variable that has not been given a known value.  Consequently, if you actually do this, undefined behavior will result.<\/p>\n<p>Code implementing undefined behavior may exhibit <em>any<\/em> of the following symptoms:<\/p>\n<ul>\n<li>Your program produces different results every time it is run.<\/li>\n<li>Your program consistently produces the same incorrect result.<\/li>\n<li>Your program behaves inconsistently (sometimes produces the correct result, sometimes not).<\/li>\n<li>Your program seems like it&#8217;s working but produces incorrect results later in the program.<\/li>\n<li>Your program crashes, either immediately or later.<\/li>\n<li>Your program works on some compilers but not others.<\/li>\n<li>Your program works until you change some other seemingly unrelated code.<\/li>\n<\/ul>\n<p>Or, your code may actually produce the correct behavior anyway.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>Undefined behavior is like a box of chocolates.  You never know what you&#8217;re going to get!\n<\/p><\/div>\n<p>C++ contains many cases that can result in undefined behavior if you&#8217;re not careful.  We&#8217;ll point these out in future lessons whenever we encounter them.  Take note of where these cases are and make sure you avoid them.<\/p>\n<div class=\"cpp-note cpp-lightpurplebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Rule<\/p>\n<p>Take care to avoid all situations that result in undefined behavior, such as using uninitialized variables.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>One of the most common types of comment we get from readers says, &#8220;You said I couldn&#8217;t do X, but I did it anyway and my program works!  Why?&#8221;.<\/p>\n<p>There are two common answers.  The most common answer is that your program is actually exhibiting undefined behavior, but that undefined behavior just happens to be producing the result you wanted anyway&#8230; for now.  Tomorrow (or on another compiler or machine) it might not.<\/p>\n<p>Alternatively, sometimes compiler authors take liberties with the language requirements when those requirements may be more restrictive than needed.  For example, the standard may say, &#8220;you must do X before Y&#8221;, but a compiler author may feel that&#8217;s unnecessary, and make Y work even if you don&#8217;t do X first.  This shouldn&#8217;t affect the operation of correctly written programs, but may cause incorrectly written programs to work anyway.  So an alternate answer to the above question is that your compiler may simply be not following the standard!  It happens.  You can avoid much of this by making sure you&#8217;ve turned compiler extensions off, as described in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/configuring-your-compiler-compiler-extensions\/\">0.10 -- Configuring your compiler: Compiler extensions<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Implementation-defined behavior and unspecified behavior<\/p>\n<p>A specific compiler and the associated standard library it comes with are called an <strong>implementation<\/strong> (as these are what actually implements the C++ language).  In some cases, the C++ language standard allows the implementation to determine how some aspect of the language will behave, so that the compiler can choose a behavior that is efficient for a given platform.  Behavior that is defined by the implementation is called <strong>implementation-defined behavior<\/strong>.  Implementation-defined behavior must be documented and consistent for a given implementation.<\/p>\n<p>Let&#8217;s look at a simple example of implementation-defined behavior:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; sizeof(int) &lt;&lt; '\\n'; \/\/ print how many bytes of memory an int value takes\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>On most platforms, this will produce <code>4<\/code>, but on others it may produce <code>2<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We discuss <code>sizeof()<\/code> in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/object-sizes-and-the-sizeof-operator\/\">4.3 -- Object sizes and the sizeof operator<\/a>.\n<\/div>\n<p><strong>Unspecified behavior<\/strong> is almost identical to implementation-defined behavior in that the behavior is left up to the implementation to define, but the implementation is not required to document the behavior.<\/p>\n<p>We generally want to avoid implementation-defined and unspecified behavior, as it means our program may not work as expected if compiled on a different compiler (or even on the same compiler if we change project settings that affect how the implementation behaves!)<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Avoid implementation-defined and unspecified behavior whenever possible, as they may cause your program to malfunction on other implementations.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We show examples of unspecified behavior in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/operator-precedence-and-associativity\/#unspecified\">6.1 -- Operator precedence and associativity<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #1<\/p>\n<p>What is an uninitialized variable?  Why should you avoid using them?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>An uninitialized variable is a variable that has not been given a value by the program (generally through initialization or assignment).  Using the value stored in an uninitialized variable will result in undefined behavior.\n<\/p><\/div>\n<\/p>\n<\/div>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #2<\/p>\n<p>What is undefined behavior, and what can happen if you do something that exhibits undefined behavior?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p>Undefined behavior is the result of executing code whose behavior is not well defined by the language.  The result can be almost anything, including something that behaves correctly.\n<\/p><\/div>\n<\/p>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/keywords-and-naming-identifiers\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">1.7<\/span>Keywords and naming identifiers\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-iostream-cout-cin-and-endl\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">1.5<\/span>Introduction to iostream: cout, cin, and endl\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Unlike some programming languages, C\/C++ does not automatically initialize most variables to a given value (such as zero). When a variable that is not initialized is given a memory address to use to store data, the default value of that variable is whatever (garbage) value happens to already be in &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/7892"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=7892"}],"version-history":[{"count":31,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/7892\/revisions"}],"predecessor-version":[{"id":17921,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/7892\/revisions\/17921"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=7892"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=7892"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=7892"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}