{"id":536,"date":"2011-09-11T15:44:00","date_gmt":"2011-09-11T23:44:00","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=536"},"modified":"2023-01-27T10:27:10","modified_gmt":"2023-01-27T18:27:10","slug":"stl-iterators-overview","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/stl-iterators-overview\/","title":{"rendered":"21.3 &#8212; STL iterators overview"},"content":{"rendered":"<p>An <strong>Iterator<\/strong> is an object that can traverse (iterate over) a container class without the user having to know how the container is implemented.  With many classes (particularly lists and the associative classes), iterators are the primary way elements of these classes are accessed.<\/p>\n<p>An iterator is best visualized as a pointer to a given element in the container, with a set of overloaded operators to provide a set of well-defined functions:<\/p>\n<ul>\n<li><strong>Operator*<\/strong> -- Dereferencing the iterator returns the element that the iterator is currently pointing at.\n<li><strong>Operator++<\/strong> -- Moves the iterator to the next element in the container.  Most iterators also provide <code>Operator--<\/code> to move to the previous element.\n<li><strong>Operator== and Operator!=<\/strong> -- Basic comparison operators to determine if two iterators point to the same element.  To compare the values that two iterators are pointing at, dereference the iterators first, and then use a comparison operator.\n<li><strong>Operator=<\/strong> -- Assign the iterator to a new position (typically the start or end of the container&#8217;s elements).  To assign the value of the element the iterator is pointing at, dereference the iterator first, then use the assign operator.\n<\/ul>\n<p>Each container includes four basic member functions for use with Operator=:<\/p>\n<ul>\n<li><strong>begin()<\/strong> returns an iterator representing the beginning of the elements in the container.\n<li><strong>end()<\/strong> returns an iterator representing the element just past the end of the elements.\n<li><strong>cbegin()<\/strong> returns a const (read-only) iterator representing the beginning of the elements in the container.\n<li><strong>cend()<\/strong> returns a const (read-only) iterator representing the element just past the end of the elements.\n<\/ul>\n<p>It might seem weird that end() doesn&#8217;t point to the last element in the list, but this is done primarily to make looping easy: iterating over the elements can continue until the iterator reaches end(), and then you know you&#8217;re done.<\/p>\n<p>Finally, all containers provide (at least) two types of iterators:<\/p>\n<ul>\n<li><strong>container::iterator<\/strong> provides a read\/write iterator\n<li><strong>container::const_iterator<\/strong> provides a read-only iterator\n<\/ul>\n<p>Lets take a look at some examples of using iterators.<\/p>\n<p><strong>Iterating through a vector<\/strong><\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::vector&lt;int&gt; vect;\r\n    for (int count=0; count &lt; 6; ++count)\r\n        vect.push_back(count);\r\n\r\n    std::vector&lt;int&gt;::const_iterator it; \/\/ declare a read-only iterator\r\n    it = vect.cbegin(); \/\/ assign it to the start of the vector\r\n    while (it != vect.cend()) \/\/ while it hasn't reach the end\r\n    {\r\n        std::cout &lt;&lt; *it &lt;&lt; ' '; \/\/ print the value of the element it points to\r\n        ++it; \/\/ and iterate to the next element\r\n    }\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n}<\/code><\/pre>\n<p>This prints the following:<\/p>\n<pre>\n0 1 2 3 4 5\r\n<\/pre>\n<p><strong>Iterating through a list<\/strong><\/p>\n<p>Now let&#8217;s do the same thing with a list:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;list&gt;\r\n\r\nint main()\r\n{\r\n\r\n    std::list&lt;int&gt; li;\r\n    for (int count=0; count &lt; 6; ++count)\r\n        li.push_back(count);\r\n\r\n    std::list&lt;int&gt;::const_iterator it; \/\/ declare an iterator\r\n    it = li.cbegin(); \/\/ assign it to the start of the list\r\n    while (it != li.cend()) \/\/ while it hasn't reach the end\r\n    {\r\n        std::cout &lt;&lt; *it &lt;&lt; ' '; \/\/ print the value of the element it points to\r\n        ++it; \/\/ and iterate to the next element\r\n    }\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n0 1 2 3 4 5\r\n<\/pre>\n<p>Note the code is almost identical to the vector case, even though vectors and lists have almost completely different internal implementations!<\/p>\n<p><strong>Iterating through a set<\/strong><\/p>\n<p>In the following example, we&#8217;re going to create a set from 6 numbers and use an iterator to print the values in the set:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;set&gt;\r\n\r\nint main()\r\n{\r\n    std::set&lt;int&gt; myset;\r\n    myset.insert(7);\r\n    myset.insert(2);\r\n    myset.insert(-6);\r\n    myset.insert(8);\r\n    myset.insert(1);\r\n    myset.insert(-4);\r\n\r\n    std::set&lt;int&gt;::const_iterator it; \/\/ declare an iterator\r\n    it = myset.cbegin(); \/\/ assign it to the start of the set\r\n    while (it != myset.cend()) \/\/ while it hasn't reach the end\r\n    {\r\n        std::cout &lt;&lt; *it &lt;&lt; ' '; \/\/ print the value of the element it points to\r\n        ++it; \/\/ and iterate to the next element\r\n    }\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n}<\/code><\/pre>\n<p>This program produces the following result:<\/p>\n<pre>\n-6 -4 1 2 7 8\r\n<\/pre>\n<p>Note that although populating the set differs from the way we populate the vector and list, the code used to iterate through the elements of the set was essentially identical.<\/p>\n<p><strong>Iterating through a map<\/strong><\/p>\n<p>This one is a little trickier.  Maps and multimaps take pairs of elements (defined as a std::pair).  We use the make_pair() helper function to easily create pairs.  std::pair allows access to the elements of the pair via the first and second members.  In our map, we use first as the key, and second as the value.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;map&gt;\r\n#include &lt;string&gt;\r\n\r\nint main()\r\n{\r\n\tstd::map&lt;int, std::string&gt; mymap;\r\n\tmymap.insert(std::make_pair(4, \"apple\"));\r\n\tmymap.insert(std::make_pair(2, \"orange\"));\r\n\tmymap.insert(std::make_pair(1, \"banana\"));\r\n\tmymap.insert(std::make_pair(3, \"grapes\"));\r\n\tmymap.insert(std::make_pair(6, \"mango\"));\r\n\tmymap.insert(std::make_pair(5, \"peach\"));\r\n\r\n\tauto it{ mymap.cbegin() }; \/\/ declare a const iterator and assign to start of vector\r\n\twhile (it != mymap.cend()) \/\/ while it hasn't reach the end\r\n\t{\r\n\t\tstd::cout &lt;&lt; it-&gt;first &lt;&lt; '=' &lt;&lt; it-&gt;second &lt;&lt; ' '; \/\/ print the value of the element it points to\r\n\t\t++it; \/\/ and iterate to the next element\r\n\t}\r\n\r\n\tstd::cout &lt;&lt; '\\n';\r\n}<\/code><\/pre>\n<p>This program produces the result:<\/p>\n<pre>\n1=banana 2=orange 3=grapes 4=apple 5=peach 6=mango\r\n<\/pre>\n<p>Notice here how easy iterators make it to step through each of the elements of the container.  You don&#8217;t have to care at all how map stores its data!<\/p>\n<p><strong>Conclusion<\/strong><\/p>\n<p>Iterators provide an easy way to step through the elements of a container class without having to understand how the container class is implemented.  When combined with STL&#8217;s algorithms and the member functions of the container classes, iterators become even more powerful.  In the next lesson, you&#8217;ll see an example of using an iterator to insert elements into a list (which doesn&#8217;t provide an overloaded operator[] to access its elements directly).<\/p>\n<p>One point worth noting: Iterators must be implemented on a per-class basis, because the iterator does need to know how a class is implemented.  Thus iterators are always tied to specific container classes.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stl-algorithms-overview\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.4<\/span>STL algorithms overview\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stl-containers-overview\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.2<\/span>STL containers overview\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>An Iterator is an object that can traverse (iterate over) a container class without the user having to know how the container is implemented. With many classes (particularly lists and the associative classes), iterators are the primary way elements of these classes are accessed. An iterator is best visualized as &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/536"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=536"}],"version-history":[{"count":17,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/536\/revisions"}],"predecessor-version":[{"id":14022,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/536\/revisions\/14022"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=536"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=536"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=536"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}