{"id":42,"date":"2007-06-09T15:34:05","date_gmt":"2007-06-09T23:34:05","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=42"},"modified":"2025-02-04T20:46:34","modified_gmt":"2025-02-05T04:46:34","slug":"boolean-values","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/boolean-values\/","title":{"rendered":"4.9 &#8212; Boolean values"},"content":{"rendered":"<p>In real-life, it&#8217;s common to ask or be asked questions that can be answered with &#8220;yes&#8221; or &#8220;no&#8221;.  &#8220;Is an apple a fruit?&#8221;  Yes.  &#8220;Do you like asparagus?&#8221;  No.<\/p>\n<p>Now consider a similar statement that can be answered with a &#8220;true&#8221; or &#8220;false&#8221;: &#8220;Apples are a fruit&#8221;.  It&#8217;s clearly true.  Or how about, &#8220;I like asparagus&#8221;.  Absolutely false (yuck!).<\/p>\n<p>These kinds of sentences that have only two possible outcomes: yes\/true, or no\/false are so common, that many programming languages include a special type for dealing with them.  That type is called a <strong>Boolean<\/strong> type (note: Boolean is properly capitalized in the English language because it&#8217;s named after its inventor, George Boole).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Boolean variables<\/p>\n<p>Boolean variables are variables that can have only two possible values: <code>true<\/code>, and <code>false<\/code>.<\/p>\n<p>To declare a Boolean variable, we use the keyword <code>bool<\/code>.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">bool b;<\/code><\/pre>\n<p>To initialize or assign a <code>true<\/code> or <code>false<\/code> value to a Boolean variable, we use the keywords <code>true<\/code> and <code>false<\/code>.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">bool b1 { true };\r\nbool b2 { false };\r\nb1 = false;\r\nbool b3 {}; \/\/ default initialize to false<\/code><\/pre>\n<p>Just as the unary minus operator (-) can be used to make an integer negative, the logical NOT operator (!) can be used to flip a Boolean value from <code>true<\/code> to <code>false<\/code>, or <code>false<\/code> to <code>true<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">bool b1 { !true }; \/\/ b1 will be initialized with the value false\r\nbool b2 { !false }; \/\/ b2 will be initialized with the value true<\/code><\/pre>\n<p>Boolean values are not actually stored in Boolean variables as the words &#8220;true&#8221; or &#8220;false&#8221;.  Instead, they are stored as integral values: <code>true<\/code> is stored as integer <code>1<\/code>, and <code>false<\/code> is stored as integer <code>0<\/code>.  Similarly, when Boolean values are evaluated, they don&#8217;t actually evaluate to &#8220;true&#8221; or &#8220;false&#8221;.  They evaluate to the integers <code>0<\/code> (false) or <code>1<\/code> (true).  Because Booleans store integral values, they are considered to be an integral type.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Printing Boolean values<\/p>\n<p>When we print Boolean values, <code>std::cout<\/code> prints <code>0<\/code> for <code>false<\/code>, and <code>1<\/code> for <code>true<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; true &lt;&lt; '\\n'; \/\/ true evaluates to 1\r\n    std::cout &lt;&lt; !true &lt;&lt; '\\n'; \/\/ !true evaluates to 0\r\n\r\n    bool b {false};\r\n    std::cout &lt;&lt; b &lt;&lt; '\\n'; \/\/ b is false, which evaluates to 0\r\n    std::cout &lt;&lt; !b &lt;&lt; '\\n'; \/\/ !b is true, which evaluates to 1\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Outputs:<\/p>\n<pre>\n1\r\n0\r\n0\r\n1\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Use <code>std::boolalpha<\/code> to print <code>true<\/code> or <code>false<\/code><\/p>\n<p>If you want <code>std::cout<\/code> to print <code>true<\/code> or <code>false<\/code> instead of <code>0<\/code> or <code>1<\/code>, you can output <code>std::boolalpha<\/code>.  This doesn&#8217;t output anything, but manipulates the way <code>std::cout<\/code> outputs <code>bool<\/code> values.<\/p>\n<p>Here&#8217;s an example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; true &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; false &lt;&lt; '\\n';\r\n\r\n    std::cout &lt;&lt; std::boolalpha; \/\/ print bools as true or false\r\n\r\n    std::cout &lt;&lt; true &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; false &lt;&lt; '\\n';\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n1\r\n0\r\ntrue\r\nfalse\r\n<\/pre>\n<p>You can use <code>std::noboolalpha<\/code> to turn it back off.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Integer to Boolean conversion<\/p>\n<p>When using uniform initialization, you can initialize a variable using integer literals <code>0<\/code> (for <code>false<\/code>) and <code>1<\/code> (for <code>true<\/code>) (but you really should be using <code>false<\/code> and <code>true<\/code> instead).  Other integer literals cause compilation errors:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tbool bFalse { 0 }; \/\/ okay: initialized to false\r\n\tbool bTrue  { 1 }; \/\/ okay: initialized to true\r\n\tbool bNo    { 2 }; \/\/ error: narrowing conversions disallowed\r\n\r\n\tstd::cout &lt;&lt; bFalse &lt;&lt; bTrue &lt;&lt; bNo &lt;&lt; '\\n';\r\n\t\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>However, in any context where an integer can be converted to a Boolean, the integer <code>0<\/code> is converted to <code>false<\/code>, and any other integer is converted to <code>true<\/code>.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; std::boolalpha; \/\/ print bools as true or false\r\n\r\n\tbool b1 = 4 ; \/\/ copy initialization allows implicit conversion from int to bool\r\n\tstd::cout &lt;&lt; b1 &lt;&lt; '\\n';\r\n\r\n\tbool b2 = 0 ; \/\/ copy initialization allows implicit conversion from int to bool\r\n\tstd::cout &lt;&lt; b2 &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\ntrue\r\nfalse\r\n<\/pre>\n<p>Note: <code>bool b1 = 4;<\/code> may generate a warning.  If so you&#8217;ll have to disable treating warnings as errors to compile the example.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Inputting Boolean values<\/p>\n<p>Inputting Boolean values using <code>std::cin<\/code> sometimes trips new programmers up.<\/p>\n<p>Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tbool b{}; \/\/ default initialize to false\r\n\tstd::cout &lt;&lt; \"Enter a boolean value: \";\r\n\tstd::cin &gt;&gt; b;\r\n\tstd::cout &lt;&lt; \"You entered: \" &lt;&lt; b &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<pre>\nEnter a Boolean value: true\r\nYou entered: 0\r\n<\/pre>\n<p>Wait, what?<\/p>\n<p>By default, <code>std::cin<\/code> only accepts numeric input for Boolean variables: <code>0<\/code> is <code>false<\/code>, and <code>1<\/code> is <code>true<\/code>.  Any other numeric value will be interpreted as <code>true<\/code>, and will cause <code>std::cin<\/code> to enter failure mode.  Any non-numeric value will be interpreted as <code>false<\/code> and will cause <code>std::cin<\/code> to enter failure mode.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We discuss failure mode (and how to get out of it) in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdcin-and-handling-invalid-input\/\">9.5 -- std::cin and handling invalid input<\/a>.\n<\/p><\/div>\n<p>In this case, because we entered <code>true<\/code>, <code>std::cin<\/code> silently failed and set <code>b<\/code> to <code>false<\/code>.  Consequently, when <code>std::cout<\/code> prints a value for <code>b<\/code>, it prints <code>0<\/code>.<\/p>\n<p>To allow <code>std::cin<\/code> to accept the words <code>false<\/code> and <code>true<\/code> as inputs, you must first input to <code>std::boolalpha<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tbool b{};\r\n\tstd::cout &lt;&lt; \"Enter a boolean value: \";\r\n\r\n\t\/\/ Allow the user to input 'true' or 'false' for boolean values\r\n\t\/\/ This is case-sensitive, so True or TRUE will not work\r\n\tstd::cin &gt;&gt; std::boolalpha;\r\n\tstd::cin &gt;&gt; b;\r\n\r\n\t\/\/ Let's also output bool values as `true` or `false`\r\n\tstd::cout &lt;&lt; std::boolalpha;\r\n\tstd::cout &lt;&lt; \"You entered: \" &lt;&lt; b &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>However, when <code>std::boolalpha<\/code> is enabled for input, numeric values will no longer be accepted (they evaluate to <code>false<\/code> and cause std::cin to enter failure mode).<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Enabling <code>std::boolalpha<\/code> for input will only allow lower-cased <code>false<\/code> or <code>true<\/code> to be accepted.  Variations with capital letters will not be accepted.  <code>0<\/code> and <code>1<\/code> will also no longer be accepted.\n<\/div>\n<p>Note that we use <code>std::cin &gt;&gt; std::boolalpha;<\/code> to input bool values as <code>true<\/code> or <code>false<\/code>, and <code>std::cout &lt;&lt; std::boolalpha;<\/code> to output bool values as <code>true<\/code> or <code>false<\/code>.  These are independent controls that can be turned on (using <code>std::boolalpha<\/code>) or off (using <code>std::noboolalpha<\/code>) separately.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Boolean return values<\/p>\n<p>Boolean values are often used as the return values for functions that check whether something is true or not.  Such functions are typically named starting with the word <em>is<\/em> (e.g. isEqual) or <em>has<\/em> (e.g. hasCommonDivisor).<\/p>\n<p>Consider the following example, which is quite similar to the above:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ returns true if x and y are equal, false otherwise\r\nbool isEqual(int x, int y)\r\n{\r\n    return x == y; \/\/ operator== returns true if x equals y, and false otherwise\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter an integer: \";\r\n    int x{};\r\n    std::cin &gt;&gt; x;\r\n\r\n    std::cout &lt;&lt; \"Enter another integer: \";\r\n    int y{};\r\n    std::cin &gt;&gt; y;\r\n\r\n    std::cout &lt;&lt; std::boolalpha; \/\/ print bools as true or false\r\n    \r\n    std::cout &lt;&lt; x &lt;&lt; \" and \" &lt;&lt; y &lt;&lt; \" are equal? \";\r\n    std::cout &lt;&lt; isEqual(x, y) &lt;&lt; '\\n'; \/\/ will return true or false\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Here&#8217;s output from two runs of this program:<\/p>\n<pre>\nEnter an integer: 5\r\nEnter another integer: 5\r\n5 and 5 are equal? true\r\n<\/pre>\n<pre>\nEnter an integer: 6\r\nEnter another integer: 4\r\n6 and 4 are equal? false\r\n<\/pre>\n<p>How does this work?  First we read in integer values for <code>x<\/code> and <code>y<\/code>.  Next, the expression <code>isEqual(x, y)<\/code> is evaluated.  In the first run, this results in a function call to <code>isEqual(5, 5)<\/code>.  Inside that function, <code>5 == 5<\/code> is evaluated, producing the value <code>true<\/code>.  The value <code>true<\/code> is returned back to the caller to be printed by <code>std::cout<\/code>.  In the second run, the call to <code>isEqual(6, 4)<\/code> returns the value <code>false<\/code>.<\/p>\n<p>Boolean values take a little bit of getting used to, but once you get your mind wrapped around them, they&#8217;re quite refreshing in their simplicity!  Boolean values are also a huge part of the language -- you&#8217;ll end up using them more than all the other fundamental types put together!<\/p>\n<p>We&#8217;ll continue our exploration of Boolean values in the next lesson.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-if-statements\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">4.10<\/span>Introduction to if statements\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/floating-point-numbers\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">4.8<\/span>Floating point numbers\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In real-life, it&#8217;s common to ask or be asked questions that can be answered with &#8220;yes&#8221; or &#8220;no&#8221;. &#8220;Is an apple a fruit?&#8221; Yes. &#8220;Do you like asparagus?&#8221; No. Now consider a similar statement that can be answered with a &#8220;true&#8221; or &#8220;false&#8221;: &#8220;Apples are a fruit&#8221;. It&#8217;s clearly true. &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/42"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=42"}],"version-history":[{"count":62,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/42\/revisions"}],"predecessor-version":[{"id":18161,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/42\/revisions\/18161"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=42"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=42"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=42"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}