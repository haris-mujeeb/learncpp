{"id":85,"date":"2007-07-06T16:50:47","date_gmt":"2007-07-07T00:50:47","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/65-multidimensional-arrays\/"},"modified":"2023-11-24T09:59:18","modified_gmt":"2023-11-24T17:59:18","slug":"multidimensional-c-style-arrays","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/multidimensional-c-style-arrays\/","title":{"rendered":"17.12 &#8212; Multidimensional C-style Arrays"},"content":{"rendered":"<p>Consider a game like <a href=\"https:\/\/en.wikipedia.org\/wiki\/Tic-tac-toe\">Tic-tac-toe<\/a>.  The standard board for this game is a 3&#215;3 grid, with players taking turns placing &#8216;X&#8217; and &#8216;O&#8217; symbols.  The first to get three symbols in a row wins.<\/p>\n<p>While you could store the board data as 9 individual variables, we know that when you have multiple instances of an element, it&#8217;s better to use an array:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int ttt[9]; \/\/ a C-style array of ints (value 0 = empty, 1 = player 1, 2 = player 2)<\/code><\/pre>\n<p>This defines a C-style array with 9 elements arranged sequentially in memory.  We can imagine these elements laid out as a single row of values, like this:<\/p>\n<pre>\n\/\/ ttt[0] ttt[1] ttt[2] ttt[3] ttt[4] ttt[5] ttt[6] ttt[7] ttt[8]\r\n<\/pre>\n<p>The <strong>dimension<\/strong> of an array is the number of indices needed to select an element.  An array containing only a single dimension is called a <strong>single-dimensional array<\/strong> or a <strong>one-dimensional array<\/strong> (sometimes abbreviated as a <strong>1d array<\/strong>).  <code>ttt<\/code> above is an example of a one-dimensional array, as elements can be selected with a single index (e.g. <code>ttt[2]<\/code>).<\/p>\n<p>But note that our one-dimensional array doesn&#8217;t look much like our tic-tac-toe board, which exists in two dimensions.  We can do better.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Two-dimensional arrays<\/p>\n<p>In previous lessons, we noted that the elements of an array can be of any object type.  This means the element type of an array can be another array!  Defining such an array is simple:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int a[3][5]; \/\/ a 3-element array of 5-element arrays of int<\/code><\/pre>\n<p>An array of arrays is called a <strong>two-dimensional array<\/strong> (sometimes abbreviated as a <strong>2d array<\/strong>) because it has two subscripts.<\/p>\n<p>With a two-dimensional array, it is convenient to think of the first (left) subscript as selecting the row, and the second (right) subscript as selecting the column.  Conceptually, we can imagine this two-dimensional array laid out as follows:<\/p>\n<pre>\n\/\/ col 0    col 1    col 2    col 3    col 4\r\n\/\/ a[0][0]  a[0][1]  a[0][2]  a[0][3]  a[0][4]  row 0\r\n\/\/ a[1][0]  a[1][1]  a[1][2]  a[1][3]  a[1][4]  row 1\r\n\/\/ a[2][0]  a[2][1]  a[2][2]  a[2][3]  a[2][4]  row 2\r\n<\/pre>\n<p>To access the elements of a two-dimensional array, we simply use two subscripts:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">a[2][3] = 7; \/\/ a[row][col], where row = 2 and col = 3<\/code><\/pre>\n<p>Thus, for a Tic-tac-toe board, we can define a 2d array like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int ttt[3][3];<\/code><\/pre>\n<p>And now we have a 3&#215;3 grid of elements that we can easily manipulate using row and column indices!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Multidimensional arrays<\/p>\n<p>Arrays with more than one dimension are called <strong>multidimensional arrays<\/strong>.<\/p>\n<p>C++ even supports multidimensional arrays with more than 2 dimensions:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int threedee[4][4][4]; \/\/ a 4x4x4 array (an array of 4 arrays of 4 arrays of 4 ints)<\/code><\/pre>\n<p>For example, the terrain in Minecraft is divided into 16x16x16 blocks (called chunk sections).<\/p>\n<p>Arrays with dimensions higher than 3 are supported, but rare.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">How 2d arrays are laid out in memory<\/p>\n<p>Memory is linear (1-dimensional), so multidimensional arrays are actually stored as a sequential list of elements.<\/p>\n<p>There are two possible ways for the following array to be stored in memory:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ col 0   col 1   col 2   col 3   col 4\r\n\/\/ [0][0]  [0][1]  [0][2]  [0][3]  [0][4]  row 0\r\n\/\/ [1][0]  [1][1]  [1][2]  [1][3]  [1][4]  row 1\r\n\/\/ [2][0]  [2][1]  [2][2]  [2][3]  [2][4]  row 2<\/code><\/pre>\n<p>C++ uses <strong>row-major order<\/strong>, where elements are sequentially placed in memory row-by-row, ordered from left to right, top to bottom:<\/p>\n<pre>\n[0][0] [0][1] [0][2] [0][3] [0][4] [1][0] [1][1] [1][2] [1][3] [1][4] [2][0] [2][1] [2][2] [2][3] [2][4]\r\n<\/pre>\n<p>Some other languages (like Fortran) use <strong>column-major order<\/strong>, elements are sequentially placed in memory column-by-column, from top to bottom, left to right:<\/p>\n<pre>\n[0][0] [1][0] [2][0] [0][1] [1][1] [2][1] [0][2] [1][2] [2][2] [0][3] [1][3] [2][3] [0][4] [1][4] [2][4]\r\n<\/pre>\n<p>In C++, when initializing an array, elements are initialized in row-major order.  And when traversing an array, it is most efficient to access elements in the order they are laid out in memory.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Initializing two-dimensional arrays<\/p>\n<p>To initialize a two-dimensional array, it is easiest to use nested braces, with each set of numbers representing a row:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int array[3][5]\r\n{\r\n  { 1, 2, 3, 4, 5 },     \/\/ row 0\r\n  { 6, 7, 8, 9, 10 },    \/\/ row 1\r\n  { 11, 12, 13, 14, 15 } \/\/ row 2\r\n};<\/code><\/pre>\n<p>Although some compilers will let you omit the inner braces, we highly recommend you include them anyway for readability purposes.<\/p>\n<p>When using inner braces, missing initializers will be value-initialized:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int array[3][5]\r\n{\r\n  { 1, 2 },          \/\/ row 0 = 1, 2, 0, 0, 0\r\n  { 6, 7, 8 },       \/\/ row 1 = 6, 7, 8, 0, 0\r\n  { 11, 12, 13, 14 } \/\/ row 2 = 11, 12, 13, 14, 0\r\n};<\/code><\/pre>\n<p>An initialized multidimensional array can omit (only) the leftmost length specification:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int array[][5]\r\n{\r\n  { 1, 2, 3, 4, 5 },\r\n  { 6, 7, 8, 9, 10 },\r\n  { 11, 12, 13, 14, 15 }\r\n};<\/code><\/pre>\n<p>In such cases, the compiler can do the math to figure out what the leftmost length is from the number of initializers.<\/p>\n<p>Omitting non-leftmost dimensions is not allowed:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int array[][] \r\n{\r\n  { 1, 2, 3, 4 },\r\n  { 5, 6, 7, 8 }\r\n};<\/code><\/pre>\n<p>Just like normal arrays, multidimensional arrays can still be initialized to 0 as follows:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int array[3][5] {};<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Two-dimensional arrays and loops<\/p>\n<p>With a one-dimensional array, we can use a single loop to iterate through all of the elements in the array:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int arr[] { 1, 2, 3, 4, 5 };\r\n\r\n    \/\/ for-loop with index\r\n    for (std::size_t i{0}; i &lt; std::size(arr); ++i)\r\n        std::cout &lt;&lt; arr[i] &lt;&lt; ' ';\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    \/\/ range-based for-loop\r\n    for (auto e: arr)\r\n        std::cout &lt;&lt; e &lt;&lt; ' ';\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>With a two-dimensional array, we need two loops: one to select the row, and another to select the column.<\/p>\n<p>And with two loops, we also need to determine which loop will be the outer loop, and which will be the inner loop.  It is most efficient to access elements in the order they are laid out in memory.  Since C++ uses row-major order, the row selector should be the outer loop, and the column selector should be the inner loop.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int arr[3][4] { \r\n        { 1, 2, 3, 4 },\r\n        { 5, 6, 7, 8 },\r\n        { 9, 10, 11, 12 }};\r\n\r\n    \/\/ double for-loop with indices\r\n    for (std::size_t row{0}; row &lt; std::size(arr); ++row) \/\/ std::size(arr) returns the number of rows\r\n    {\r\n        for (std::size_t col{0}; col &lt; std::size(arr[0]); ++col) \/\/ std::size(arr[0]) returns the number of columns\r\n            std::cout &lt;&lt; arr[row][col] &lt;&lt; ' ';\r\n\r\n        std::cout &lt;&lt; '\\n';\r\n    }\r\n\r\n    \/\/ double range-based for-loop\r\n    for (const auto&amp; arow: arr)   \/\/ get each array row\r\n    {\r\n        for (const auto&amp; e: arow) \/\/ get each element of the row\r\n            std::cout &lt;&lt; e &lt;&lt; ' ';\r\n\r\n        std::cout &lt;&lt; '\\n';\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A two-dimensional array example<\/p>\n<p>Let&#8217;s take a look at a practical example of a two-dimensional array:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    constexpr int numRows{ 10 };\r\n    constexpr int numCols{ 10 };\r\n\r\n    \/\/ Declare a 10x10 array\r\n    int product[numRows][numCols]{};\r\n\r\n    \/\/ Calculate a multiplication table\r\n    \/\/ We don't need to calc row and col 0 since mult by 0 always is 0\r\n    for (std::size_t row{ 1 }; row &lt; numRows; ++row)\r\n    {\r\n        for (std::size_t col{ 1 }; col &lt; numCols; ++col)\r\n        {\r\n            product[row][col] = static_cast&lt;int&gt;(row * col);\r\n        }\r\n     }\r\n\r\n    for (std::size_t row{ 1 }; row &lt; numRows; ++row)\r\n    {\r\n        for (std::size_t col{ 1 }; col &lt; numCols; ++col)\r\n        {\r\n            std::cout &lt;&lt; product[row][col] &lt;&lt; '\\t';\r\n        }\r\n\r\n        std::cout &lt;&lt; '\\n';\r\n     }\r\n\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program calculates and prints a multiplication table for all values between 1 and 9 (inclusive).  Note that when printing the table, the for loops start from 1 instead of 0.  This is to omit printing the 0 column and 0 row, which would just be a bunch of 0s!  Here is the output:<\/p>\n<pre>\n1    2    3    4    5    6    7    8    9\r\n2    4    6    8    10   12   14   16   18\r\n3    6    9    12   15   18   21   24   27\r\n4    8    12   16   20   24   28   32   36\r\n5    10   15   20   25   30   35   40   45\r\n6    12   18   24   30   36   42   48   54\r\n7    14   21   28   35   42   49   56   63\r\n8    16   24   32   40   48   56   64   72\r\n9    18   27   36   45   54   63   72   81\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Cartesian coordinates vs Array indices<\/p>\n<p>In geometry, the <a href=\"https:\/\/en.wikipedia.org\/wiki\/Cartesian_coordinate_system\">Cartesian coordinate system<\/a> is often used to describe the position of objects.  In two dimensions, we have two coordinate axes, conventionally named &#8220;x&#8221; and &#8220;y&#8221;.  &#8220;x&#8221; is the horizontal axis, and &#8220;y&#8221; is the vertical axis.<\/p>\n<div class=\"cpp-image-wrapper\"><img src=\"https:\/\/www.learncpp.com\/images\/CppTutorial\/Cartesian-coordinate-system-min.png\" alt=\"Cartesian Coordinate System Diagram\" \/><\/div>\n<p>In two dimensions, the Cartesian position of an object can be described as an { x, y } pair, where x-coordinate and y-coordinate are values indicating how far to the right of the x-axis and how far above the y-axis an object is positioned.  Sometimes the y-axis is flipped (so that the y-coordinate describes how far below the y-axis something is).<\/p>\n<p>Now let&#8217;s take a look at our 2d array layout in C++:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ col 0   col 1   col 2   col 3   col 4\r\n\/\/ [0][0]  [0][1]  [0][2]  [0][3]  [0][4]  row 0\r\n\/\/ [1][0]  [1][1]  [1][2]  [1][3]  [1][4]  row 1\r\n\/\/ [2][0]  [2][1]  [2][2]  [2][3]  [2][4]  row 2<\/code><\/pre>\n<p>This is also a two-dimensional coordinate system, where the position of an element can be described as &#091;row&#093;&#091;col&#093; (where the col-axis is flipped).<\/p>\n<p>While each of these coordinate systems is fairly easy to understand independently, converting from Cartesian { x, y } to Array indices &#091;row&#093;&#091;col&#093; is a bit counter-intuitive.<\/p>\n<p>The key insight is that the x-coordinate in a Cartesian system describes which <em>column<\/em> is being selected in the array indexing system.  Conversely, the y-coordinate describes which <em>row<\/em> is being selected.  Therefore, an { x, y } Cartesian coordinate translates to an &#091;y&#093;[x&#093; array coordinate, which is backwards from what we might expect!<\/p>\n<p>This leads to 2d loops that look like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    for (std::size_t y{0}; y &lt; std::size(arr); ++y) \/\/ outer loop is rows \/ y\r\n    {\r\n        for (std::size_t x{0}; x &lt; std::size(arr[0]); ++x) \/\/ inner loop is columns \/ x\r\n            std::cout &lt;&lt; arr[y][x] &lt;&lt; ' '; \/\/ index with y (row) first, then x (col)<\/code><\/pre>\n<p>Note that in this case, we index the array as <code>a[y][x]<\/code>, which is probably backwards from the alphabetic ordering you were expecting.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/multidimensional-stdarray\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.13<\/span>Multidimensional std::array\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/c-style-string-symbolic-constants\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.11<\/span>C-style string symbolic constants\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Consider a game like Tic-tac-toe. The standard board for this game is a 3&#215;3 grid, with players taking turns placing &#8216;X&#8217; and &#8216;O&#8217; symbols. The first to get three symbols in a row wins. While you could store the board data as 9 individual variables, we know that when you &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/85"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=85"}],"version-history":[{"count":23,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/85\/revisions"}],"predecessor-version":[{"id":16127,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/85\/revisions\/16127"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=85"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=85"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=85"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}