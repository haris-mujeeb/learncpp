{"id":136,"date":"2007-09-20T14:04:57","date_gmt":"2007-09-20T22:04:57","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/813-friend-functions-and-classes\/"},"modified":"2024-05-08T10:47:28","modified_gmt":"2024-05-08T17:47:28","slug":"friend-non-member-functions","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/friend-non-member-functions\/","title":{"rendered":"15.8 &#8212; Friend non-member functions"},"content":{"rendered":"<p>For much of this chapter and last, we&#8217;ve been preaching the virtues of access controls, which provide a mechanism for controlling who can access the various members of a class.  Private members can only be accessed by other members of the class and public members can be accessed by everyone.  In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/access-functions\/\">14.6 -- Access functions<\/a>, we discussed the benefits of keeping your data private, and creating a public interface for non-members to use.<\/p>\n<p>However, there are situations where this arrangement is either not sufficient or not ideal.<\/p>\n<p>For example, consider a storage class that is focused on managing some set of data.  Now lets say you also want to display that data, but the code that handles the display will have lots of options and is therefore complex.  You could put both the storage management functions and the display management functions in the same class, but that would clutter things up and make for a complex interface.  You could also keep them separate: the storage class manages storage, and some other display class manages all of the display capabilities.  That creates a nice separation of responsibility.  But the display class would then be unable to access the private members of the storage class, and might not be able to do its job.<\/p>\n<p>Alternatively, there are cases where syntactically we might prefer to use a non-member function over a member function (we&#8217;ll show an example of this below).  This is commonly the case when overloading operators, a topic we&#8217;ll discuss in future lessons.  But non-member functions have the same issue -- they can&#8217;t access the private members of the class.<\/p>\n<p>If access functions (or other public member functions) already exist and are sufficient for whatever capability we&#8217;re trying to implement, then great -- we can (and should) just use those.  But in some cases, those functions don&#8217;t exist.  What then?<\/p>\n<p>One option would be to add new member functions to the class, to allow other classes or non-member functions to do whatever job they would be otherwise unable to do.  But we might not want to allow public access to such things -- perhaps those things are highly implementation dependent, or prone to misuse.<\/p>\n<p>What we really need is some way to subvert the access control system on a case by case basis.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Friendship is magic<\/p>\n<p>The answer to our challenge is friendship.<\/p>\n<p>Inside the body of a class, a <strong>friend declaration<\/strong> (using the <code>friend<\/code> keyword) can be used to tell the compiler that some other class or function is now a friend.  In C++, a <strong>friend<\/strong> is a class or function (member or non-member) that has been granted full access to the private and protected members of another class.  In this way, a class can selectively give other classes or functions full access to their members without impacting anything else.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Friendship is always granted by the class whose members will be accessed (not by the class or function desiring access).  Between access controls and granting friendship, a class always retains the ability to control who can access its members.\n<\/p><\/div>\n<p>For example, if our storage class made the display class a friend, then the display class would be able to access all members of the storage class directly.  The display class could use this direct access to implement display of the storage class, while remaining structurally separate.<\/p>\n<p>The friend declaration is not affected by access controls, so it does not matter where within the class body it is placed.<\/p>\n<p>Now that we know what a friend is, let&#8217;s take a look at specific examples where friendship is granted to non-member functions, member functions, and other classes.  We&#8217;ll discuss friend non-members functions in this lesson, and then take a look at friend classes and friend member functions in the next lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/friend-classes-and-friend-member-functions\/\">15.9 -- Friend classes and friend member functions<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Friend non-member functions<\/p>\n<p>A <strong>friend function<\/strong> is a function (member or non-member) that can access the private and protected members of a class as though it were a member of that class.  In all other regards, the friend function is a normal function.  <\/p>\n<p>Let&#8217;s take a look at an example of a simple class making a non-member function a friend:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Accumulator\r\n{\r\nprivate:\r\n    int m_value { 0 };\r\n\r\npublic:\r\n    void add(int value) { m_value += value; }\r\n\r\n    \/\/ Here is the friend declaration that makes non-member function void print(const Accumulator&amp; accumulator) a friend of Accumulator\r\n    friend void print(const Accumulator&amp; accumulator);\r\n};\r\n\r\nvoid print(const Accumulator&amp; accumulator)\r\n{\r\n    \/\/ Because print() is a friend of Accumulator\r\n    \/\/ it can access the private members of Accumulator\r\n    std::cout &lt;&lt; accumulator.m_value;\r\n}\r\n\r\nint main()\r\n{\r\n    Accumulator acc{};\r\n    acc.add(5); \/\/ add 5 to the accumulator\r\n\r\n    print(acc); \/\/ call the print() non-member function\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this example, we&#8217;ve declared a non-member function named <code>print()<\/code> that takes an object of class <code>Accumulator<\/code>.  Because <code>print()<\/code> is not a member of the Accumulator class, it would normally not be able to access private member <code>m_value<\/code>.  However, the Accumulator class has a friend declaration making <code>print(const Accumulator&amp; accumulator)<\/code> a friend, this is now allowed.<\/p>\n<p>Note that because <code>print()<\/code> is a non-member function (and thus does not have an implicit object), we must explicitly pass an <code>Accumulator<\/code> object to <code>print()<\/code> to work with.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Defining a friend non-member inside a class<\/p>\n<p>Much like member functions can be defined inside a class if desired, friend non-member functions can also be defined inside a class.  The following example defines friend non-member function <code>print()<\/code> inside the <code>Accumulator<\/code> class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Accumulator\r\n{\r\nprivate:\r\n    int m_value { 0 };\r\n\r\npublic:\r\n    void add(int value) { m_value += value; }\r\n\r\n    \/\/ Friend functions defined inside a class are non-member functions\r\n    friend void print(const Accumulator&amp; accumulator)\r\n    {\r\n        \/\/ Because print() is a friend of Accumulator\r\n        \/\/ it can access the private members of Accumulator\r\n        std::cout &lt;&lt; accumulator.m_value;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Accumulator acc{};\r\n    acc.add(5); \/\/ add 5 to the accumulator\r\n\r\n    print(acc); \/\/ call the print() non-member function\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Although you might assume that because <code>print()<\/code> is defined inside <code>Accumulator<\/code>, that makes <code>print()<\/code> a member of <code>Accumulator<\/code>, this is not the case.  Because <code>print()<\/code> is defined as a friend, it is instead treated as a non-member function (as if it had been defined outside <code>Accumulator<\/code>). <\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Syntactically preferring a friend non-member function<\/p>\n<p>In the introduction to this lesson, we mentioned that there were times we might prefer to use a non-member function over a member function.  Let&#8217;s show an example of that now.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Value\r\n{\r\nprivate:\r\n    int m_value{};\r\n\r\npublic:\r\n    explicit Value(int v): m_value { v }  { }\r\n\r\n    bool isEqualToMember(const Value&amp; v) const;\r\n    friend bool isEqualToNonmember(const Value&amp; v1, const Value&amp; v2);\r\n};\r\n\r\nbool Value::isEqualToMember(const Value&amp; v) const\r\n{\r\n    return m_value == v.m_value;\r\n}\r\n\r\nbool isEqualToNonmember(const Value&amp; v1, const Value&amp; v2)\r\n{\r\n    return v1.m_value == v2.m_value;\r\n}\r\n\r\nint main()\r\n{\r\n    Value v1 { 5 };\r\n    Value v2 { 6 };\r\n\r\n    std::cout &lt;&lt; v1.isEqualToMember(v2) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; isEqualToNonmember(v1, v2) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this example, we&#8217;ve defined two similar functions that check whether two <code>Value<\/code> objects are equal.  <code>isEqualToMember()<\/code> is a member function, and <code>isEqualToNonmember()<\/code> is a non-member function.  Let&#8217;s focus on how these functions are defined.<\/p>\n<p>In <code>isEqualToMember()<\/code>, we&#8217;re passing one object implicitly and the other explicitly.  The implementation of the function reflects this, and we have to mentally reconcile that <code>m_value<\/code> belongs to the implicit object whereas <code>v.m_value<\/code> belongs to the explicit parameter.<\/p>\n<p>In <code>isEqualToNonmember()<\/code>, both objects are passed explicitly.  This leads to better parallelism in the implementation of the function, as the <code>m_value<\/code> member is always explicitly prefixed with an explicit parameter.<\/p>\n<p>You may still prefer the calling syntax <code>v1.isEqualToMember(v2)<\/code> over <code>isEqualToNonmember(v1, v2)<\/code>.  But when we cover operator overloading, we&#8217;ll see this topic come up again.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Multiple friends<\/p>\n<p>A function can be a friend of more than one class at the same time.  For example, consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Humidity; \/\/ forward declaration of Humidity\r\n\r\nclass Temperature\r\n{\r\nprivate:\r\n    int m_temp { 0 };\r\npublic:\r\n    explicit Temperature(int temp) : m_temp { temp } { }\r\n\r\n    friend void printWeather(const Temperature&amp; temperature, const Humidity&amp; humidity); \/\/ forward declaration needed for this line\r\n};\r\n\r\nclass Humidity\r\n{\r\nprivate:\r\n    int m_humidity { 0 };\r\npublic:\r\n    explicit Humidity(int humidity) : m_humidity { humidity } {  }\r\n\r\n    friend void printWeather(const Temperature&amp; temperature, const Humidity&amp; humidity);\r\n};\r\n\r\nvoid printWeather(const Temperature&amp; temperature, const Humidity&amp; humidity)\r\n{\r\n    std::cout &lt;&lt; \"The temperature is \" &lt;&lt; temperature.m_temp &lt;&lt;\r\n       \" and the humidity is \" &lt;&lt; humidity.m_humidity &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    Humidity hum { 10 };\r\n    Temperature temp { 12 };\r\n\r\n    printWeather(temp, hum);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>There are three things worth noting about this example.  First, because <code>printWeather()<\/code> uses both <code>Humidity<\/code> and <code>Temperature<\/code> equally, it doesn&#8217;t really make sense to have it be a member of either.  A non-member function works better.  Second, because <code>printWeather()<\/code> is a friend of both <code>Humidity<\/code> and <code>Temperature<\/code>, it can access the private data from objects of both classes.  Finally, note the following line at the top of the example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Humidity;<\/code><\/pre>\n<p>This is a forward declaration for <code>class Humidity<\/code>.  Class forward declarations serve the same role as function forward declarations -- they tell the compiler about an identifier that will be defined later.  However, unlike functions, classes have no return types or parameters, so class forward declarations are always simply <code>class ClassName<\/code> (unless they are class templates).<\/p>\n<p>Without this line, the compiler would tell us it doesn&#8217;t know what a <code>Humidity<\/code> is when parsing the friend declaration inside <code>Temperature<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Doesn&#8217;t friendship violate the principle of data hiding?<\/p>\n<p>No.  Friendship is granted by the class doing the data hiding with the expectation that the friend will access its private members.  Think of a friend as an extension of the class itself, with all the same access rights.  As such, access is expected, not a violation.<\/p>\n<p>Used properly, friendship can make a program more maintainable by allowing functionality to be separated when it makes sense from a design perspective (as opposed to having to keep it together for access control reasons).  Or when it makes more sense to use a non-member function instead of a member function.<\/p>\n<p>However, because friends have direct access to the implementation of a class, changes to the implementation of the class will typically necessitate changes to the friends as well.  If a class has many friends (or those friends have friends), this can lead to a ripple effect.<\/p>\n<p>When implementing a friend function, prefer to use the public interface over direct access to members whenever possible.  This will help insulate your friend function from future implementation changes and lead to less code needing to be modified and\/or retested later.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>A friend function should prefer to use the class interface over direct access whenever possible.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Prefer non-friend functions to friend functions<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/the-benefits-of-data-hiding-encapsulation\/\">14.8 -- The benefits of data hiding (encapsulation)<\/a>, we mentioned that we should prefer non-member functions over member functions.  For the same reasons given there, we should prefer non-friend functions over friend functions.<\/p>\n<p>For example, in the following example, if the implementation of <code>Accumulator<\/code> is changed (e.g. we rename <code>m_value<\/code>), the implementation of <code>print()<\/code> will need to be changed as well:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Accumulator\r\n{\r\nprivate:\r\n    int m_value { 0 }; \/\/ if we rename this\r\n\r\npublic:\r\n    void add(int value) { m_value += value; } \/\/ we need to modify this\r\n\r\n    friend void print(const Accumulator&amp; accumulator);\r\n};\r\n\r\nvoid print(const Accumulator&amp; accumulator)\r\n{\r\n    std::cout &lt;&lt; accumulator.m_value; \/\/ and we need to modify this\r\n}\r\n\r\nint main()\r\n{\r\n    Accumulator acc{};\r\n    acc.add(5); \/\/ add 5 to the accumulator\r\n\r\n    print(acc); \/\/ call the print() non-member function\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>A better idea is as follows:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Accumulator\r\n{\r\nprivate:\r\n    int m_value { 0 };\r\n\r\npublic:\r\n    void add(int value) { m_value += value; }\r\n    int value() const { return m_value; } \/\/ added this reasonable access function\r\n};\r\n\r\nvoid print(const Accumulator&amp; accumulator) \/\/ no longer a friend of Accumulator\r\n{\r\n    std::cout &lt;&lt; accumulator.value(); \/\/ use access function instead of direct access\r\n}\r\n\r\nint main()\r\n{\r\n    Accumulator acc{};\r\n    acc.add(5); \/\/ add 5 to the accumulator\r\n\r\n    print(acc); \/\/ call the print() non-member function\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this example, <code>print()<\/code> uses access function <code>value()<\/code> to get the value of <code>m_value<\/code> instead of accessing <code>m_value<\/code> directly.  Now if the implementation of <code>Accumulator<\/code> is ever changed, <code>print()<\/code> will not need to be updated.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Prefer to implement a function as a non-friend when possible and reasonable.\n<\/p><\/div>\n<p>Be cautious when adding new members to the public interface of an existing class, as every function (even trivial ones) adds some level of clutter and complexity.  In the case of <code>Accumulator<\/code> above, it&#8217;s totally reasonable to have an access function to get the current accumulated value.  In more complex cases, it may be preferable to use friendship instead of adding many new access functions to the interface of a class.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/friend-classes-and-friend-member-functions\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">15.9<\/span>Friend classes and friend member functions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/static-member-functions\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">15.7<\/span>Static member functions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>For much of this chapter and last, we&#8217;ve been preaching the virtues of access controls, which provide a mechanism for controlling who can access the various members of a class. Private members can only be accessed by other members of the class and public members can be accessed by everyone. &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/136"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=136"}],"version-history":[{"count":66,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/136\/revisions"}],"predecessor-version":[{"id":2596,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/136\/revisions\/2596"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=136"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=136"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=136"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}