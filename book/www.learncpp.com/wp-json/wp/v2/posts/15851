{"id":15851,"date":"2023-10-05T12:55:56","date_gmt":"2023-10-05T19:55:56","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15851"},"modified":"2024-03-29T16:50:43","modified_gmt":"2024-03-29T23:50:43","slug":"member-functions-returning-references-to-data-members","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/member-functions-returning-references-to-data-members\/","title":{"rendered":"14.7 &#8212; Member functions returning references to data members"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/return-by-reference-and-return-by-address\/\">12.12 -- Return by reference and return by address<\/a>, we covered return by reference.  In particular, we noted, &#8220;The object being returned by reference must exist after the function returns&#8221;.  This means we should not return local variables by reference, as the reference will be left dangling after the local variable is destroyed.  However, it is generally okay to return by reference either function parameters passed by reference, or variables with static duration (either static local variables or global variables), as they will generally not be destroyed after the function returns.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Takes two std::string objects, returns the one that comes first alphabetically\r\nconst std::string&amp; firstAlphabetical(const std::string&amp; a, const std::string&amp; b)\r\n{\r\n\treturn (a &lt; b) ? a : b; \/\/ We can use operator&lt; on std::string to determine which comes first alphabetically\r\n}\r\n\r\nint main()\r\n{\r\n\tstd::string hello { \"Hello\" };\r\n\tstd::string world { \"World\" };\r\n\r\n\tstd::cout &lt;&lt; firstAlphabetical(hello, world); \/\/ either hello or world will be returned by reference\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Member functions can also return by reference, and they follow the same rules for when it is safe to return by reference as non-member functions.  However, member functions have one additional case we need to discuss: member functions that return data members by reference.<\/p>\n<p>This is most commonly seen with getter access functions, so we&#8217;ll illustrate this topic using getter member functions.  But note that this topic applies to any member function returning a reference to a data member.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Returning data members by value can be expensive<\/p>\n<p>Consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nclass Employee\r\n{\r\n\tstd::string m_name{};\r\n\r\npublic:\r\n\tvoid setName(std::string_view name) { m_name = name; }\r\n\tstd::string getName() const { return m_name; } \/\/  getter returns by value\r\n};\r\n\r\nint main()\r\n{\r\n\tEmployee joe{};\r\n\tjoe.setName(\"Joe\");\r\n\tstd::cout &lt;&lt; joe.getName();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In this example, the <code>getName()<\/code> access function returns <code>std::string m_name<\/code> by value.<\/p>\n<p>While this is the safest thing to do, it also means that an expensive copy of <code>m_name<\/code> will be made every time <code>getName()<\/code> is called.  Since access functions tend to be called a lot, this is generally not the best choice.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Returning data members by lvalue reference<\/p>\n<p>Member functions can also return data members by (const) lvalue reference.<\/p>\n<p>Data members have the same lifetime as the object containing them.  Since member functions are always called on an object, and that object must exist in the scope of the caller, it is generally safe for a member function to return a data member by (const) lvalue reference (as the member being returned by reference will still exist in the scope of the caller when the function returns).<\/p>\n<p>Let&#8217;s update the example above so that <code>getName()<\/code> returns <code>m_name<\/code> by const lvalue reference:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nclass Employee\r\n{\r\n\tstd::string m_name{};\r\n\r\npublic:\r\n\tvoid setName(std::string_view name) { m_name = name; }\r\n\tconst std::string&amp; getName() const { return m_name; } \/\/  getter returns by const reference\r\n};\r\n\r\nint main()\r\n{\r\n\tEmployee joe{}; \/\/ joe exists until end of function\r\n\tjoe.setName(\"Joe\");\r\n\r\n\tstd::cout &lt;&lt; joe.getName(); \/\/ returns joe.m_name by reference\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Now when <code>joe.getName()<\/code> is invoked, <code>joe.m_name<\/code> is returned by reference to the caller, avoiding having to make a copy.  The caller then uses this reference to print <code>joe.m_name<\/code> to the console.<\/p>\n<p>Because <code>joe<\/code> exists in the scope of the caller until the end of the <code>main()<\/code> function, the reference to <code>joe.m_name<\/code> is also valid for the same duration.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>It is okay to return a (const) lvalue reference to a data member.  The implicit object (containing the data member) still exists in the scope of the caller after the function returns, so any returned references will be valid.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The return type of a member function returning a reference to a data member should match the data member&#8217;s type<\/p>\n<p>In general, the return type of a member function returning by reference should match the type of the data member being returned.  In the above example, <code>m_name<\/code> is of type <code>std::string<\/code>, so <code>getName()<\/code> returns <code>const std::string&amp;<\/code>.<\/p>\n<p>Returning a <code>std::string_view<\/code> would require a temporary <code>std::string_view<\/code> to be created and returned every time the function was called.  That&#8217;s needlessly inefficient.  If the caller wants a <code>std::string_view<\/code>, they can do the conversion themselves.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>A member function returning a reference should return a reference of the same type as the data member being returned, to avoid unnecessary conversions.\n<\/p><\/div>\n<p>For getters, using <code>auto<\/code> to have the compiler deduce the return type from the member being returned is a useful way to ensure that no conversions occur:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nclass Employee\r\n{\r\n\tstd::string m_name{};\r\n\r\npublic:\r\n\tvoid setName(std::string_view name) { m_name = name; }\r\n\tconst auto&amp; getName() const { return m_name; } \/\/ uses `auto` to deduce return type from m_name\r\n};\r\n\r\nint main()\r\n{\r\n\tEmployee joe{}; \/\/ joe exists until end of function\r\n\tjoe.setName(\"Joe\");\r\n\r\n\tstd::cout &lt;&lt; joe.getName(); \/\/ returns joe.m_name by reference\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover <code>auto<\/code> return types in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/type-deduction-for-functions\/\">10.9 -- Type deduction for functions<\/a>.\n<\/div>\n<p>However, using an <code>auto<\/code> return type obscures the return type of the getter from a documentation perspective.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\tconst auto&amp; getName() const { return m_name; } \/\/ uses `auto` to deduce return type from m_name<\/code><\/pre>\n<p>It&#8217;s unclear what kind of string this function actually returns (it could be a <code>std::string<\/code>, <code>std::string_view<\/code>, <code>C-style string<\/code>, or something else entirely!).<\/p>\n<p>For this reason, we&#8217;ll generally prefer explicit return types.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Rvalue implicit objects and return by reference<\/p>\n<p>There&#8217;s one case we need to be a little careful with.  In the above example, <code>joe<\/code> is an lvalue object that exists until the end of the function.  Therefore, the reference returned by <code>joe.getName()<\/code> will also be valid until the end of the function.<\/p>\n<p>But what if our implicit object is an rvalue instead (such as the return value of some function that returns by value)?  Rvalue objects are destroyed at the end of the full expression in which they are created.  When an rvalue object is destroyed, any references to members of that rvalue will be invalidated and left dangling, and use of such references will produce undefined behavior.<\/p>\n<p>Therefore, a reference to a member of an rvalue object can only be safely used within the full expression where the rvalue object is created.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>We covered what a full expression is in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-expressions\/\">1.10 -- Introduction to expressions<\/a>.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>An rvalue object is destroyed at the end of the full expression in which it is created.  Any references to members of the rvalue object are left dangling at that point.<\/p>\n<p>A reference to a member of an rvalue object can only be safely used within the full expression where the rvalue object is created.\n<\/p><\/div>\n<p>Let&#8217;s explore some cases related to this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Employee\r\n{\r\n\tstd::string m_name{};\r\n\r\npublic:\r\n\tvoid setName(std::string_view name) { m_name = name; }\r\n\tconst std::string&amp; getName() const { return m_name; } \/\/  getter returns by const reference\r\n};\r\n\r\n\/\/ createEmployee() returns an Employee by value (which means the returned value is an rvalue)\r\nEmployee createEmployee(std::string_view name)\r\n{\r\n\tEmployee e;\r\n\te.setName(name);\r\n\treturn e;\r\n}\r\n\r\nint main()\r\n{\r\n\t\/\/ Case 1: okay: use returned reference to member of rvalue class object in same expression\r\n\tstd::cout &lt;&lt; createEmployee(\"Frank\").getName();\r\n\r\n\t\/\/ Case 2: bad: save returned reference to member of rvalue class object for use later\r\n\tconst std::string&amp; ref { createEmployee(\"Garbo\").getName() }; \/\/ reference becomes dangling when return value of createEmployee() is destroyed\r\n\tstd::cout &lt;&lt; ref; \/\/ undefined behavior\r\n\r\n\t\/\/ Case 3: okay: copy referenced value to local variable for use later\r\n\tstd::string val { createEmployee(\"Hans\").getName() }; \/\/ makes copy of referenced member\r\n\tstd::cout &lt;&lt; val; \/\/ okay: val is independent of referenced member\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>When <code>createEmployee()<\/code> is called, it will return an <code>Employee<\/code> object by value.  This returned <code>Employee<\/code> object is an rvalue that will exist until the end of the full expression containing the call to <code>createEmployee()<\/code>.  When that rvalue object is destroyed, any references to members of that object will become dangling.<\/p>\n<p>In case 1, we call <code>createEmployee(\"Frank\")<\/code>, which returns an rvalue <code>Employee<\/code> object.  We then call <code>getName()<\/code> on this rvalue object, which returns a reference to <code>m_name<\/code>.  This reference is then used immediately to print the name to the console.  At this point, the full expression containing the call to <code>createEmployee(\"Frank\")<\/code> ends, and the rvalue object and its members are destroyed.  Since neither the rvalue object or its members are used beyond this point, this case is fine.<\/p>\n<p>In case 2, we run into problems.  First, <code>createEmployee(\"Garbo\")<\/code> returns an rvalue object.  We then call <code>getName()<\/code> to get a reference to the <code>m_name<\/code> member of this rvalue.  This <code>m_name<\/code> member is then used to initialize <code>ref<\/code>.  At this point, the full expression containing the call to <code>createEmployee(\"Garbo\")<\/code> ends, and the rvalue object and its members are destroyed.  This leaves <code>ref<\/code> dangling.  Thus, when we use <code>ref<\/code> in the subsequent statement, we&#8217;re accessing a dangling reference, and undefined behavior results.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>The evaluation of a full expression ends <em>after<\/em> any uses of that full expression as an initializer.  This allows objects to be initialized with an rvalue of the same type (as the rvalue won&#8217;t be destroyed until after initialization occurs).\n<\/div>\n<p>But what if we want to save a value from a function that returns a member by reference for use later?  Instead of using the returned reference to initialize a local reference variable, we can instead use the returned reference to initialize a non-reference local variable.<\/p>\n<p>In case 3, we&#8217;re using the returned reference to initialize non-reference local variable <code>val<\/code>.  This will cause the member being referenced to be copied into <code>val<\/code>.  After initialization, <code>val<\/code> exists independently of the reference.  So when the rvalue object is subsequently destroyed, <code>val<\/code> is not impacted by this.  Thus <code>val<\/code> can be output in future statements without issue.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using member functions that return by reference safely<\/p>\n<p>Despite the potential danger with rvalue implicit objects, it is conventional for getters to return types that are expensive to copy by const reference, not by value.<\/p>\n<p>Given that, let&#8217;s talk about how we can use the return values from such functions safely.  The three cases in the example above illustrate the three key points:<\/p>\n<ul>\n<li>Prefer to use the return value of a member function that returns by reference immediately (illustrated in case 1).  Since this works with both lvalue and rvalue objects, if you always do this, you will avoid trouble.\n<\/li>\n<li>Do not &#8220;save&#8221; a returned reference to use later (illustrated in case 2), unless you are sure the implicit object is an lvalue.  If you do this with an rvalue implicit object, undefined behavior will result when you use the now-dangling reference.\n<\/li>\n<li>If you do need to persist a returned reference for use later and aren&#8217;t sure that the implicit object is an lvalue, using the returned reference as the initializer for a non-reference local variable, which will make a copy of the member being referenced into the local variable (illustrated in case 3).\n<\/li>\n<\/ul>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Prefer to use the return value of a member function that returns by reference immediately, to avoid issues with dangling references when the implicit object is an rvalue.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Do not return non-const references to private data members<\/p>\n<p>Because a reference acts just like the object being referenced, a member function that returns a non-const reference provides direct access to that member (even if the member is private).<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Foo\r\n{\r\nprivate:\r\n    int m_value{ 4 }; \/\/ private member\r\n\r\npublic:\r\n    int&amp; value() { return m_value; } \/\/ returns a non-const reference (don't do this)\r\n};\r\n\r\nint main()\r\n{\r\n    Foo f{};                \/\/ f.m_value is initialized to default value 4\r\n    f.value() = 5;          \/\/ The equivalent of m_value = 5\r\n    std::cout &lt;&lt; f.value(); \/\/ prints 5\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because <code>value()<\/code> returns a non-const reference to <code>m_value<\/code>, the caller is able to use that reference to directly access (and change the value of) <code>m_value<\/code>.<\/p>\n<p>This allows the caller to subvert the access control system.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Const member functions can&#8217;t return non-const references to data members<\/p>\n<p>A const member function is not allowed to return a non-const reference to members.  This makes sense -- a const member function is not allowed to modify the state of the object, nor is it allowed to call functions that would modify the state of the object.  It should not be doing anything that might lead to the modification of the object.<\/p>\n<p>If a const member function was allowed to return a non-const reference to a member, it would be handing the caller a way to directly modify that member.  This violates the intent of a const member function.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/the-benefits-of-data-hiding-encapsulation\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.8<\/span>The benefits of data hiding (encapsulation)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/access-functions\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.6<\/span>Access functions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we covered return by reference. In particular, we noted, &#8220;The object being returned by reference must exist after the function returns&#8221;. This means we should not return local variables by reference, as the reference will be left dangling after the local variable is destroyed. However, it is &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15851"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15851"}],"version-history":[{"count":7,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15851\/revisions"}],"predecessor-version":[{"id":16190,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15851\/revisions\/16190"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15851"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15851"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15851"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}