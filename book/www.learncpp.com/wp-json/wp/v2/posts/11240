{"id":11240,"date":"2021-06-17T17:40:23","date_gmt":"2021-06-18T01:40:23","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=11240"},"modified":"2024-11-11T11:13:18","modified_gmt":"2024-11-11T19:13:18","slug":"arithmetic-conversions","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/arithmetic-conversions\/","title":{"rendered":"10.5 &#8212; Arithmetic conversions"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/operator-precedence-and-associativity\/\">6.1 -- Operator precedence and associativity<\/a>, we discussed how expressions are evaluated according to the precedence and associativity of their operators.<\/p>\n<p>Consider the following expression:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int x { 2 + 3 };<\/code><\/pre>\n<p>Binary <code>operator+<\/code> is given two operands, both of type <code>int<\/code>.  Because both operands are of the same type, that type will be used to perform the calculation, and the value returned will also be of this same type.  Thus, <code>2 + 3<\/code> will evaluate to <code>int<\/code> value <code>5<\/code>.<\/p>\n<p>But what happens when the operands of a binary operator are of different types?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">??? y { 2 + 3.5 };<\/code><\/pre>\n<p>In this case, <code>operator+<\/code> is being given one operand of type <code>int<\/code> and another of type <code>double<\/code>.  Should the result of the operator be returned as an <code>int<\/code>, a <code>double<\/code>, or possibly something else altogether?<\/p>\n<p>In C++, certain operators require that their operands be of the same type.  If one of these operators is invoked with operands of different types, one or both of the operands will be implicitly converted to matching types using a set of rules called the <strong>usual arithmetic conversions<\/strong>.  The matching type produced as a result of the usual arithmetic conversion rules is called the <strong>common type<\/strong> of the operands.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The operators that require operands of the same type<\/p>\n<p>The following operators require their operands to be of the same type:<\/p>\n<ul>\n<li>The binary arithmetic operators: +, -, *, \/, %<\/li>\n<li>The binary relational operators: &lt;, &gt;, &lt;=, &gt;=, ==, !=<\/li>\n<li>The binary bitwise arithmetic operators: &#038;, ^, |<\/li>\n<li>The conditional operator ?: (excluding the condition, which is expected to be of type <code>bool<\/code>)<\/li>\n<\/ul>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Overloaded operators are not subject to the usual arithmetic conversion rules.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The usual arithmetic conversion rules<\/p>\n<p>The usual arithmetic conversion rules are somewhat complex, so we&#8217;ll simplify a bit.  The compiler has a ranked list of types that looks something like this:<\/p>\n<ul>\n<li>long double (highest rank)\n<\/li>\n<li>double\n<\/li>\n<li>float\n<\/li>\n<li>long long\n<\/li>\n<li>long\n<\/li>\n<li>int (lowest rank)\n<\/li>\n<\/ul>\n<p>The following rules are applied to find a matching type:<\/p>\n<p>Step 1:<\/p>\n<ul>\n<li>If one operand is an integral type and the other a floating point type, the integral operand is converted to the type of the floating point operand (no integral promotion takes place).\n<\/li>\n<li>Otherwise, any integral operands are numerically promoted (see <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/floating-point-and-integral-promotion\/\">10.2 -- Floating-point and integral promotion<\/a>).\n<\/li>\n<\/ul>\n<p>Step 2:<\/p>\n<ul>\n<li>After promotion, if one operand is signed and the other unsigned, special rules apply (see below)\n<\/li>\n<li>Otherwise, the operand with lower rank is converted to the type of the operand with higher rank.\n<\/li>\n<\/ul>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>The special matching rules for integral operands with different signs:<\/p>\n<ul>\n<li>If the rank of the unsigned operand is greater than or equal to the rank of the signed operand, the signed operand is converted to the type of the unsigned operand.\n<\/li>\n<li>If the type of the signed operand can represent all the values of the type of the unsigned operand, the type of the unsigned operand is converted to the type of the signed operand.\n<\/li>\n<li>Otherwise both operands are converted to the corresponding unsigned type of the signed operand.\n<\/li>\n<\/ul>\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>You can find the full rules for the usual arithmetic conversions <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/language\/usual_arithmetic_conversions\">here<\/a>.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Some examples<\/p>\n<p>In the following examples, we&#8217;ll use the <code>typeid<\/code> operator (included in the &lt;typeinfo&gt; header), to show the resulting type of an expression.<\/p>\n<p>First, let&#8217;s add an <code>int<\/code> and a <code>double<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;typeinfo&gt; \/\/ for typeid()\r\n\r\nint main()\r\n{\r\n    int i{ 2 };\r\n    std::cout &lt;&lt; typeid(i).name() &lt;&lt; '\\n'; \/\/ show us the name of the type for i\r\n\r\n    double d{ 3.5 };\r\n    std::cout &lt;&lt; typeid(d).name() &lt;&lt; '\\n'; \/\/ show us the name of the type for d\r\n\r\n    std::cout &lt;&lt; typeid(i + d).name() &lt;&lt; ' ' &lt;&lt; i + d &lt;&lt; '\\n'; \/\/ show us the type of i + d\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this case, the <code>double<\/code> operand has the highest priority, so the lower priority operand (of type <code>int<\/code>) is type converted to <code>double<\/code> value <code>2.0<\/code>.  Then <code>double<\/code> values <code>2.0<\/code> and <code>3.5<\/code> are added to produce <code>double<\/code> result <code>5.5<\/code>.<\/p>\n<p>On the author&#8217;s machine, this prints:<\/p>\n<pre>\nint\r\ndouble\r\ndouble 5.5\r\n<\/pre>\n<p>Note that your compiler may display something slightly different, as the names output by <code>typeid.name()<\/code> are implementation-specific.<\/p>\n<p>Now let&#8217;s add two values of type <code>short<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;typeinfo&gt; \/\/ for typeid()\r\n\r\nint main()\r\n{\r\n    short a{ 4 };\r\n    short b{ 5 };\r\n    std::cout &lt;&lt; typeid(a + b).name() &lt;&lt; ' ' &lt;&lt; a + b &lt;&lt; '\\n'; \/\/ show us the type of a + b\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because neither operand appears on the priority list, both operands undergo integral promotion to type <code>int<\/code>.  The result of adding two <code>ints<\/code> is an <code>int<\/code>, as you would expect:<\/p>\n<pre>\nint 9\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Signed and unsigned issues<\/p>\n<p>This prioritization hierarchy and conversion rules can cause some problematic issues when mixing signed and unsigned values.  For example, take a look at the following code:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;typeinfo&gt; \/\/ for typeid()\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; typeid(5u-10).name() &lt;&lt; ' ' &lt;&lt; 5u - 10 &lt;&lt; '\\n'; \/\/ 5u means treat 5 as an unsigned integer\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>You might expect the expression <code>5u - 10<\/code> to evaluate to <code>-5<\/code> since <code>5 - 10<\/code> = <code>-5<\/code>.  But here&#8217;s what actually results:<\/p>\n<pre>\nunsigned int 4294967291\r\n<\/pre>\n<p>Due to the conversion rules, the <code>int<\/code> operand is converted to an <code>unsigned int<\/code>.  And since the value <code>-5<\/code> is out of range of an <code>unsigned int<\/code>, we get a result we don&#8217;t expect.<\/p>\n<p>Here&#8217;s another example showing a counterintuitive result:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; (-3 &lt; 5u) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>While it&#8217;s clear to us that <code>5<\/code> is greater than <code>-3<\/code>, when this expression evaluates, <code>-3<\/code> is converted to a large <code>unsigned int<\/code> that is larger than <code>5<\/code>.  Thus, the above prints <code>false<\/code> rather than the expected result of <code>true<\/code>.<\/p>\n<p>This is one of the primary reasons to avoid unsigned integers -- when you mix them with signed integers in arithmetic expressions, you&#8217;re at risk for unexpected results.  And the compiler probably won&#8217;t even issue a warning.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><code>std::common_type<\/code> and <code>std::common_type_t<\/code><\/p>\n<p>In future lessons, we&#8217;ll encounter cases where it is useful to know what the common type of two type is.   <code>std::common_type<\/code> and the useful type alias <code>std::common_type_t<\/code> (both defined in the &lt;type_traits&gt; header) can be used for just this purpose.<\/p>\n<p>For example, <code>std::common_type_t&lt;int, double&gt;<\/code> returns the common type of <code>int<\/code> and <code>double<\/code>, and <code>std::common_type_t&lt;unsigned int, long&gt;<\/code> returns the common type of <code>unsigned int<\/code> and <code>long<\/code>.<\/p>\n<p>We&#8217;ll show an example where this is useful in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-templates-with-multiple-template-types\/\">11.8 -- Function templates with multiple template types<\/a>.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/explicit-type-conversion-casting-and-static-cast\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">10.6<\/span>Explicit type conversion (casting) and static_cast\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/narrowing-conversions-list-initialization-and-constexpr-initializers\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">10.4<\/span>Narrowing conversions, list initialization, and constexpr initializers\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we discussed how expressions are evaluated according to the precedence and associativity of their operators. Consider the following expression: int x { 2 + 3 }; Binary operator+ is given two operands, both of type int. Because both operands are of the same type, that type will &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/11240"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=11240"}],"version-history":[{"count":20,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/11240\/revisions"}],"predecessor-version":[{"id":17845,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/11240\/revisions\/17845"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=11240"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=11240"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=11240"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}