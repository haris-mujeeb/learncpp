{"id":87,"date":"2007-06-28T18:36:09","date_gmt":"2007-06-29T02:36:09","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/a1-static-and-dynamic-libraries\/"},"modified":"2023-09-21T11:51:14","modified_gmt":"2023-09-21T18:51:14","slug":"a1-static-and-dynamic-libraries","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/a1-static-and-dynamic-libraries\/","title":{"rendered":"A.1 &#8212; Static and dynamic libraries"},"content":{"rendered":"<p>A <strong>library<\/strong> is a package of code that is meant to be reused by many programs.  Typically, a C++ library comes in two pieces:<\/p>\n<ol start=\"1\">\n<li>A header file that defines the functionality the library is exposing (offering) to the programs using it.\n<\/li>\n<li>A precompiled binary that contains the implementation of that functionality pre-compiled into machine language.\n<\/li>\n<\/ol>\n<p>Some libraries may be split into multiple files and\/or have multiple header files.<\/p>\n<p>Libraries are precompiled for several reasons.  First, since libraries rarely change, they do not need to be recompiled often.  It would be a waste of time to recompile the library every time you wrote a program that used them. Second, because precompiled objects are in machine language, it prevents people from accessing or changing the source code, which is important to businesses or people who don&#8217;t want to make their source code available for intellectual property reasons.<\/p>\n<p>There are two types of libraries: static libraries and dynamic libraries.<\/p>\n<p>A <strong>static library<\/strong> (also known as an <strong>archive<\/strong>) consists of routines that are compiled and linked directly into your program.  When you compile a program that uses a static library, all the functionality of the static library that your program uses becomes part of your executable.  On Windows, static libraries typically have a .lib extension, whereas on Linux, static libraries typically have an .a (archive) extension.  One advantage of static libraries is that you only have to distribute the executable in order for users to run your program.  Because the library becomes part of your program, this ensures that the right version of the library is always used with your program.  Also, because static libraries become part of your program, you can use them just like functionality you&#8217;ve written for your own program.  On the downside, because a copy of the library becomes part of every executable that uses it, this can cause a lot of wasted space.  Static libraries also can not be upgraded easy -- to update the library, the entire executable needs to be replaced.<\/p>\n<p>A <strong>dynamic library<\/strong> (also called a <strong>shared library<\/strong>) consists of routines that are loaded into your application at run time.  When you compile a program that uses a dynamic library, the library does not become part of your executable -- it remains as a separate unit.  On Windows, dynamic libraries typically have a .dll (dynamic link library) extension, whereas on Linux, dynamic libraries typically have a .so (shared object) extension.  One advantage of dynamic libraries is that many programs can share one copy, which saves space.  Perhaps a bigger advantage is that the dynamic library can be upgraded to a newer version without replacing all of the executables that use it.<\/p>\n<p>Because dynamic libraries are not linked into your program, programs using dynamic libraries must explicitly load and interface with the dynamic library.  This mechanism can be confusing, and makes interfacing with a dynamic library awkward.  To make dynamic libraries easier to use, an import library can be used.<\/p>\n<p>An <strong>import library<\/strong> is a library that automates the process of loading and using a dynamic library.  On Windows, this is typically done via a small static library (.lib) of the same name as the dynamic library (.dll).  The static library is linked into the program at compile time, and then the functionality of the dynamic library can effectively be used as if it were a static library.  On Linux, the shared object (.so) file works as both a dynamic library and an import library.  Most linkers can build an import library for a dynamic library when the dynamic library is created.<\/p>\n<p><strong>Installing and using libraries<\/strong><\/p>\n<p>Now that you know about the different kinds of libraries, let&#8217;s talk about how to actually use libraries in your program.  Installing a library in C++ typically involves 4 steps:<\/p>\n<ol start=\"1\">\n<li>Acquire the library.  The best option is to download a precompiled package for your operating system (if it exists) so you do not have to compile the library yourself.  If there is not one provided for your operating system, you will have to download a source-code-only package and compile it yourself (which is outside of the scope of this lesson).  On Windows, libraries are typically distributed as .zip files.  On Linux, libraries are typically distributed as packages (e.g. .RPM).  Your package manager may have some of the more popular libraries (e.g. SDL) listed already for easy installation, so check there first.\n<\/li>\n<li>Install the library.  On Linux, this typically involves invoking the package manager and letting it do all the work.  On Windows, this typically involves unzipping the library to a directory of your choice.  We recommend keeping all your libraries in one location for easy access.  For example, use a directory called C:\\Libs, and put each library in it&#8217;s own subdirectory.\n<\/li>\n<li>Make sure the compiler knows where to look for the header file(s) for the library.  On Windows, typically this is the include subdirectory of the directory you installed the library files to (e.g. if you installed your library to C:\\libs\\SDL-1.2.11, the header files are probably in C:\\libs\\SDL-1.2.11\\include).  On Linux, header files are typically installed to \/usr\/include, which should already be part of your include file search path.  However, if the files are installed elsewhere, you will have to tell the compiler where to find them.\n<\/li>\n<li>Tell the linker where to look for the library file(s).  As with step 3, this typically involves adding a directory to the list of places the linker looks for libraries.  On Windows, this is typically the \/lib subdirectory of the directory you installed the library files to.  On Linux, libraries are typically installed to \/usr\/lib, which should already be a part of your library search path.\n<\/li>\n<\/ol>\n<p>Once the library is installed and the IDE knows where to look for it, the following 3 steps typically need to be performed for each project that wants to use the library:<\/p>\n<ol start=\"5\">\n<li>If using static libraries or import libraries, tell the linker which library files to link.\n<\/li>\n<li>#include the library&#8217;s header file(s) in your program.  This tells the compiler about all of the functionality the library is offering so that your program will compile properly.\n<\/li>\n<li>If using dynamic libraries, make sure the program knows where to find them.  Under Linux, libraries are typically installed to \/usr\/lib, which is in the default search path after the paths in the <code>LD_LIBRARY_PATH<\/code> environment variable.  On Windows, the default search path includes the directory the program is run from, directories set by calling SetDllDirectory(), the Windows, System, and System32 directories, and directories in the PATH environment variable.  The easiest way to use a .dll is to copy the .dll to the location of the executable.  Since you&#8217;ll typically distribute the .dll with your executable, it makes sense to keep them together anyway.\n<\/li>\n<\/ol>\n<p>Steps 3-5 involve configuring your IDE -- fortunately, almost all IDEs work the same way when it comes to doing these things.  Unfortunately, because each IDE has a different interface, the most difficult part of this process is simply locating <em>where<\/em> the proper place to perform each of these steps is.  Consequently, in the next few lessons in this section, we&#8217;ll cover how to do all of these steps for both Visual Studio and Code::Blocks.  If you are using another IDE, read both -- by the time you&#8217;re done, you should have enough information to do the same with your own IDE with a little searching.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/a2-using-libraries-with-visual-studio-2005-express\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">A.2<\/span>Using libraries with Visual Studio\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/random-file-io\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">28.7<\/span>Random file I\/O\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>A library is a package of code that is meant to be reused by many programs. Typically, a C++ library comes in two pieces: A header file that defines the functionality the library is exposing (offering) to the programs using it. A precompiled binary that contains the implementation of that &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/87"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=87"}],"version-history":[{"count":15,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/87\/revisions"}],"predecessor-version":[{"id":15703,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/87\/revisions\/15703"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=87"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=87"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=87"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}