{"id":3251,"date":"2015-11-24T16:15:28","date_gmt":"2015-11-25T00:15:28","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=3251"},"modified":"2024-01-10T19:22:56","modified_gmt":"2024-01-11T03:22:56","slug":"stdvector-resizing-and-capacity","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/stdvector-resizing-and-capacity\/","title":{"rendered":"16.10 &#8212; std::vector resizing and capacity"},"content":{"rendered":"<p>In the previous lessons in this chapter, we introduced containers, arrays, and <code>std::vector<\/code>.  We also discussed topics such as how to access array elements, get the length of an array, and how to traverse an array.  While we used <code>std::vector<\/code> in our examples, the concepts that we have discussed are generally applicable to all of the array types.<\/p>\n<p>In the remaining lessons in this chapter, we&#8217;re going to focus on the one thing that makes <code>std::vector<\/code> significantly different than most of the other array types: the ability to resize itself after it has been instantiated.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Fixed-size arrays vs dynamic arrays<\/p>\n<p>Most array types have a significant limitation: the length of the array must be known at the point of instantiation, and then cannot be changed.  Such arrays are called <strong>fixed-size arrays<\/strong> or <strong>fixed-length arrays<\/strong>.  Both <code>std::array<\/code> and <code>C-style arrays<\/code> are fixed-size array types.  We&#8217;ll discuss these further next chapter.<\/p>\n<p>On the other hand, <code>std::vector<\/code> is a dynamic array.  A <strong>dynamic array<\/strong> (also called a <strong>resizable array<\/strong>) is an array whose size can be changed after instantiation.  This ability to be resized is what makes <code>std::vector<\/code> special.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Resizing a <code>std::vector<\/code> at runtime<\/p>\n<p>A <code>std::vector<\/code> can be resized after instantiation by calling the <code>resize()<\/code> member function with the new desired length:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::vector v{ 0, 1, 2 }; \/\/ create vector with 3 elements\r\n    std::cout &lt;&lt; \"The length is: \" &lt;&lt; v.size() &lt;&lt; '\\n';\r\n\r\n    v.resize(5);              \/\/ resize to 5 elements\r\n    std::cout &lt;&lt; \"The length is: \" &lt;&lt; v.size() &lt;&lt; '\\n';\r\n\r\n    for (auto i : v)\r\n        std::cout &lt;&lt; i &lt;&lt; ' ';\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nThe length is: 3\r\nThe length is: 5\r\n0 1 2 0 0\r\n<\/pre>\n<p>There are two things to note here.  First, when we resized the vector, the existing element values were preserved!  Second, the new elements are value-initialized (which performs default-initialization for class types, and zero-initialization for other types).  Thus the two new elements of type <code>int<\/code> were zero-initialized to value <code>0<\/code>.<\/p>\n<p>Vectors may also be resized to be smaller:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nvoid printLength(const std::vector&lt;int&gt;&amp; v)\r\n{\r\n\tstd::cout &lt;&lt; \"The length is: \"\t&lt;&lt; v.size() &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector v{ 0, 1, 2, 3, 4 }; \/\/ length is initially 5\r\n    printLength(v);\r\n\r\n    v.resize(3);                    \/\/ resize to 3 elements\r\n    printLength(v);\r\n\r\n    for (int i : v)\r\n        std::cout &lt;&lt; i &lt;&lt; ' ';\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\nThe length is: 5\r\nThe length is: 3\r\n0 1 2\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The length vs capacity of a <code>std::vector<\/code><\/p>\n<p>Consider a row of 12 houses.  We&#8217;d say that the count of houses (or the length of the row of houses) is 12.  If we wanted to know which of those houses were currently being occupied&#8230; we&#8217;d have to determine that in some other way (e.g. ring the doorbell and see if anybody answered).  When we only have a length, we only know how many things exist.<\/p>\n<p>Now consider a carton of eggs that currently has 5 eggs in it.  We&#8217;d say that the count of eggs is 5.  But in this context, there&#8217;s another dimension we care about: how many eggs the carton could hold if it were full.  We&#8217;d say that the capacity of the carton of eggs is 12.  The carton has room for 12 eggs, and only 5 are being used -- therefore, we could add 7 more eggs without overflowing the carton.  When we have both a length and a capacity, we can differentiate how many things currently exist from how many things there is space for.<\/p>\n<p>Up to this point, we&#8217;ve only talked about the length of a <code>std::vector<\/code>.  But <code>std::vector<\/code> also has a capacity.  In the context of a <code>std::vector<\/code>, <strong>capacity<\/strong> is how many elements the <code>std::vector<\/code> has allocated storage for, and <strong>length<\/strong> is how many elements are currently being used.<\/p>\n<p>A <code>std::vector<\/code> with a capacity of 5 has allocated space for 5 elements.  If the vector contains 2 elements in active use, the length (size) of the vector is 2.  The 3 remaining elements have memory allocated for them, but they are not considered to be in active use.  They can be used later without overflowing the vector.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>The length of a vector is how many elements are &#8220;in use&#8221;.<br \/>\nThe capacity of a vector is how many elements have been allocated in memory.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Getting the capacity of a <code>std::vector<\/code><\/p>\n<p>We can ask a <code>std::vector<\/code> for its capacity via the <code>capacity()<\/code> member function.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nvoid printCapLen(const std::vector&lt;int&gt;&amp; v)\r\n{\r\n\tstd::cout &lt;&lt; \"Capacity: \" &lt;&lt; v.capacity() &lt;&lt; \" Length:\"\t&lt;&lt; v.size() &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector v{ 0, 1, 2 }; \/\/ length is initially 3\r\n\r\n    printCapLen(v);\r\n\r\n    for (auto i : v)\r\n        std::cout &lt;&lt; i &lt;&lt; ' ';\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    v.resize(5); \/\/ resize to 5 elements\r\n\r\n    printCapLen(v);\r\n\r\n    for (auto i : v)\r\n        std::cout &lt;&lt; i &lt;&lt; ' ';\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>On the author&#8217;s machine, this prints the following:<\/p>\n<pre>\nCapacity: 3  Length: 3\r\n0 1 2\r\nCapacity: 5  Length: 5\r\n0 1 2 0 0\r\n<\/pre>\n<p>First, we&#8217;ve initialized the vector with 3 elements.  This causes the vector to allocate storage for 3 elements (capacity is 3), and all 3 elements are considered to be in active use (length = 3).<\/p>\n<p>We then call <code>resize(5)<\/code>, meaning we now want a vector with a length of 5.  Since the vector only has storage for 3 elements, but it needs 5, the vector needs to get more storage to hold the additional elements.<\/p>\n<p>After the call to <code>resize()<\/code> has completed, we can see that the vector now has space for 5 elements (capacity is 5), and that all 5 elements are now considered to be in use (length is 5).<\/p>\n<p>Most of the time you won&#8217;t need to use the <code>capacity()<\/code> function, but we&#8217;ll use it a lot in the following examples so we can see what&#8217;s happening to the storage of the vector.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Reallocation of storage, and why it is expensive<\/p>\n<p>When a <code>std::vector<\/code> changes the amount of storage it is managing, this process is called <strong>reallocation<\/strong>.  Informally, the reallocation process goes something like this:<\/p>\n<ul>\n<li>The <code>std::vector<\/code> acquires new memory with capacity for the desired number of elements.  These elements are value-initialized.\n<\/li>\n<li>The elements in the old memory are copied (or moved, if possible) into the new memory.  The old memory is then returned to the system.\n<\/li>\n<li>The capacity and length of the <code>std::vector<\/code> are set to the new values.\n<\/li>\n<\/ul>\n<p>From the outside, it looks like the <code>std::vector<\/code> has been resized.  But internally, the memory (and all of the elements) have actually been replaced!<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>The process of acquiring new memory at runtime is called dynamic memory allocation.  We cover this in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/dynamic-memory-allocation-with-new-and-delete\/\">19.1 -- Dynamic memory allocation with new and delete<\/a>.\n<\/p><\/div>\n<p>Because reallocation typically requires every element in the array to be copied, reallocation is an expensive process.  As a result, we want to avoid reallocation as much as reasonable.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Reallocation is typically expensive.  Avoid unnecessary reallocations.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Why differentiate length and capacity?<\/p>\n<p>A <code>std::vector<\/code> will reallocate its storage if needed, but like Melville&#8217;s Bartleby, it would prefer not to, because reallocating storage is computationally expensive.<\/p>\n<p>If a <code>std::vector<\/code> only kept track of its length, then every <code>resize()<\/code> request would result in an expensive reallocation to the new length.  Separating length and capacity gives the <code>std::vector<\/code> the ability to be smarter about when reallocations are needed.<\/p>\n<p>The following example illustrates this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nvoid printCapLen(const std::vector&lt;int&gt;&amp; v)\r\n{\r\n\tstd::cout &lt;&lt; \"Capacity: \" &lt;&lt; v.capacity() &lt;&lt; \" Length:\"\t&lt;&lt; v.size() &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    \/\/ Create a vector with length 5\r\n    std::vector v{ 0, 1, 2, 3, 4 };\r\n    v = { 0, 1, 2, 3, 4 }; \/\/ okay, array length = 5\r\n    printCapLen(v);\r\n\r\n    for (auto i : v)\r\n        std::cout &lt;&lt; i &lt;&lt; ' ';\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    \/\/ Resize vector to 3 elements\r\n    v.resize(3); \/\/ we could also assign a list of 3 elements here\r\n    printCapLen(v);\r\n\r\n    for (auto i : v)\r\n        std::cout &lt;&lt; i &lt;&lt; ' ';\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    \/\/ Resize vector back to 5 elements\r\n    v.resize(5);\r\n    printCapLen(v);\r\n\r\n    for (auto i : v)\r\n        std::cout &lt;&lt; i &lt;&lt; ' ';\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This produces the following:<\/p>\n<pre>\nCapacity: 5  Length: 5\r\n0 1 2 3 4 \r\nCapacity: 5  Length: 3\r\n0 1 2 \r\nCapacity: 5  Length: 5\r\n0 1 2 0 0\r\n<\/pre>\n<p>When we initialized our vector with 5 elements, the capacity was set to 5, indicating that our vector initially allocated space for 5 elements.  The length was also set to 5, indicating that all of those elements are in use.<\/p>\n<p>After we called <code>v.resize(3)<\/code>, the length was changed to 3 to fulfill our request for a smaller array.  However, note that the capacity is still 5, meaning that the vector did not do a reallocation!<\/p>\n<p>Finally, we called <code>v.resize(5)<\/code>.  Because the vector already had a capacity of 5, it did not need to reallocate.  It simply changed the length back to 5, and value-initialized the last two elements.<\/p>\n<p>By separating length and capacity, in this example we avoided 2 reallocations that would have otherwise occurred.  In the next lesson, we&#8217;ll see examples where we are adding elements to a vector one by one.  In such cases, the ability to not reallocate every time length changes is even more important.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Tracking capacity separately from length allows the <code>std::vector<\/code> to avoid some reallocations when length is changed.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Vector indexing is based on length, not capacity<\/p>\n<p>You may be surprised to find that the valid indices for the subscript operator (<code>operator[]<\/code>) and <code>at()<\/code> member function is based on the vector&#8217;s length, not the capacity.<\/p>\n<p>In the example above, when <code>v<\/code> has capacity 5 and length 3, only indices from 0 and 2 are valid.  Even though the elements with indices between the length of 3 (inclusive) and capacity of 5 (exclusive) exist, their indices are considered to be out of bounds.<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>A subscript is only valid if it is between 0 and the vector&#8217;s length (not its capacity)!\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Shrinking a <code>std::vector<\/code><\/p>\n<p>Resizing a vector to be larger will increase the vector&#8217;s length, and will increase its capacity if required.  However, resizing a vector to be smaller will only decrease its length, and not its capacity.<\/p>\n<p>Reallocating a vector just to reclaim the memory from a small number of elements that are no longer needed is a poor choice.  However, in the case where we have a vector with a large number of elements that we no longer need, the memory waste could be substantive.<\/p>\n<p>To help address this situation, <code>std::vector<\/code> has a member function called <code>shrink_to_fit()<\/code> that requests that the vector shrink its capacity to match its length.  This request is non-binding, meaning the implementation is free to ignore it.  Depending on what the implementation thinks is best, an implementation may decide to fulfill the request, may partially fulfill it (e.g. reduce the capacity but not all the way), or may completely ignore the request.<\/p>\n<p>Here&#8217;s an example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nvoid printCapLen(const std::vector&lt;int&gt;&amp; v)\r\n{\r\n\tstd::cout &lt;&lt; \"Capacity: \" &lt;&lt; v.capacity() &lt;&lt; \" Length:\"\t&lt;&lt; v.size() &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n\r\n\tstd::vector&lt;int&gt; v(1000); \/\/ allocate room for 1000 elements\r\n\tprintCapLen(v);\r\n\r\n\tv.resize(0); \/\/ resize to 0 elements\r\n\tprintCapLen(v);\r\n\r\n\tv.shrink_to_fit();\r\n\tprintCapLen(v);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>On the author&#8217;s machine, this produces the following result:<\/p>\n<pre>\nCapacity: 1000  Length: 1000\r\nCapacity: 1000  Length: 0\r\nCapacity: 0  Length: 0\r\n<\/pre>\n<p>As you can see, when <code>v.shrink_to_fit()<\/code> was called, the vector reallocated its capacity to 0, freeing up the memory for 1000 elements.<\/p>\n<p><p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p><p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p><\/p>\n<p>What do the length and capacity of a std::vector represent?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>Length is the number of elements currently in use.<br \/>\nCapacity is the number of elements that have storage allocated.\n<\/p><\/div>\n<p>Why are length and capacity separate values?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p>Capacity is tracked separately so that the vector can avoid some reallocations when the length is changed.\n<\/p><\/div>\n<p>Are the valid indices for <code>std::vector<\/code> based on length or capacity?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<p>Length.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdvector-and-stack-behavior\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">16.11<\/span>std::vector and stack behavior\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/array-indexing-and-length-using-enumerators\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">16.9<\/span>Array indexing and length using enumerators\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the previous lessons in this chapter, we introduced containers, arrays, and std::vector. We also discussed topics such as how to access array elements, get the length of an array, and how to traverse an array. While we used std::vector in our examples, the concepts that we have discussed are &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/3251"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=3251"}],"version-history":[{"count":38,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/3251\/revisions"}],"predecessor-version":[{"id":16504,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/3251\/revisions\/16504"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=3251"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=3251"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=3251"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}