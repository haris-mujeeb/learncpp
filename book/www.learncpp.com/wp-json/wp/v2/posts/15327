{"id":15327,"date":"2023-09-11T11:55:26","date_gmt":"2023-09-11T18:55:26","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15327"},"modified":"2024-09-23T18:23:44","modified_gmt":"2024-09-24T01:23:44","slug":"introduction-to-destructors","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-destructors\/","title":{"rendered":"15.4 &#8212; Introduction to destructors"},"content":{"rendered":"<p class=\"cpp-section\">The cleanup problem<\/p>\n<p>Let&#8217;s say that you are writing a program that needs to send some data over a network.  However, establishing a connection to the server is expensive, so you want to collect a bunch of data and then send it all at once.  Such a class might be structured like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ This example won't compile because it is (intentionally) incomplete\r\nclass NetworkData\r\n{\r\nprivate:\r\n    std::string m_serverName{};\r\n    DataStore m_dataQueue{};\r\n\r\npublic:\r\n\tNetworkData(std::string_view serverName)\r\n\t\t: m_serverName { serverName }\r\n\t{\r\n\t}\r\n\r\n\tvoid addData(std::string_view data)\r\n\t{\r\n\t\tm_dataQueue.add(data);\r\n\t}\r\n\r\n\tvoid sendData()\r\n\t{\r\n\t\t\/\/ connect to server\r\n\t\t\/\/ send all data\r\n\t\t\/\/ clear data\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n    NetworkData n(\"someipAddress\");\r\n\r\n    n.addData(\"somedata1\");\r\n    n.addData(\"somedata2\");\r\n\r\n    n.sendData();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, this <code>NetworkData<\/code> has a potential issue.  It relies on <code>sendData()<\/code> being explicitly called before the program is shut down.  If the user of <code>NetworkData<\/code> forgets to do this, the data will not be sent to the server, and will be lost when the program exits.  Now, you might say, &#8220;well, it&#8217;s not hard to remember to do this!&#8221;, and in this particular case, you&#8217;d be right.  But consider a slightly more complex example, like this function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">bool someFunction()\r\n{\r\n    NetworkData n(\"someipAddress\");\r\n\r\n    n.addData(\"somedata1\");\r\n    n.addData(\"somedata2\");\r\n\r\n    if (someCondition)\r\n        return false;\r\n\r\n    n.sendData();\r\n    return true;\r\n}<\/code><\/pre>\n<p>In this case, if <code>someCondition<\/code> is <code>true<\/code>, then the function will return early, and <code>sendData()<\/code> will not be called.  This is an easier mistake to make, because the <code>sendData()<\/code> call is present, the program just isn&#8217;t pathing to it in all cases.<\/p>\n<p>To generalize this issue, classes that use a resource (most often memory, but sometimes files, databases, network connections, etc&#8230;) often need to be explicitly sent or closed before the class object using them is destroyed.  In other cases, we may want to do some record-keeping prior to the destruction of the object, such as writing information to a log file, or sending a piece of telemetry to a server.  The term &#8220;clean up&#8221; is often used to refer to any set of tasks that a class must perform before an object of the class is destroyed in order to behave as expected.  If we have to rely on the user of such a class to ensure that the function that performs clean up is called prior to the object being destroyed, we are likely to run into errors somewhere.<\/p>\n<p>But why are we even requiring the user to ensure this?  If the object is being destroyed, then we know that cleanup needs to be performed at that point.  Should that cleanup happen automatically?<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Destructors to the rescue<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-constructors\/\">14.9 -- Introduction to constructors<\/a> we covered constructors, which are special member functions that are called when an object of a non-aggregate class type is created.  Constructors are used to initialize members variables, and do any other set up tasks required to ensure objects of the class are ready for use.<\/p>\n<p>Analogously, classes have another type of special member function that is called automatically when an object of a non-aggregate class type is destroyed.  This function is called a <strong>destructor<\/strong>.  Destructors are designed to allow a class to do any necessary clean up before an object of the class is destroyed.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Destructor naming<\/p>\n<p>Like constructors, destructors have specific naming rules:<\/p>\n<ol start=\"1\">\n<li>The destructor must have the same name as the class, preceded by a tilde (~).\n<\/li>\n<li>The destructor can not take arguments.\n<\/li>\n<li>The destructor has no return type.\n<\/li>\n<\/ol>\n<p>A class can only have a single destructor.<\/p>\n<p>Generally you should not call a destructor explicitly (as it will be called automatically when the object is destroyed), since there are rarely cases where you&#8217;d want to clean up an object more than once.<\/p>\n<p>Destructors may safely call other member functions since the object isn&#8217;t destroyed until after the destructor executes.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A destructor example<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Simple\r\n{\r\nprivate:\r\n    int m_id {};\r\n\r\npublic:\r\n    Simple(int id)\r\n        : m_id { id }\r\n    {\r\n        std::cout &lt;&lt; \"Constructing Simple \" &lt;&lt; m_id &lt;&lt; '\\n';\r\n    }\r\n\r\n    ~Simple() \/\/ here's our destructor\r\n    {\r\n        std::cout &lt;&lt; \"Destructing Simple \" &lt;&lt; m_id &lt;&lt; '\\n';\r\n    }\r\n\r\n    int getID() const { return m_id; }\r\n};\r\n\r\nint main()\r\n{\r\n    \/\/ Allocate a Simple\r\n    Simple simple1{ 1 };\r\n    {\r\n        Simple simple2{ 2 };\r\n    } \/\/ simple2 dies here\r\n\r\n    return 0;\r\n} \/\/ simple1 dies here<\/code><\/pre>\n<p>This program produces the following result:<\/p>\n<pre>\r\nConstructing Simple 1\r\nConstructing Simple 2\r\nDestructing Simple 2\r\nDestructing Simple 1\r\n<\/pre>\n<p>Note that when each <code>Simple<\/code> object is destroyed, the destructor is called, which prints a message.  &#8220;Destructing Simple 1&#8221; is printed after &#8220;Destructing Simple 2&#8221; because <code>simple2<\/code> was destroyed before the end of the function, whereas <code>simple1<\/code> was not destroyed until the end of <code>main()<\/code>.<\/p>\n<p>Remember that static variables (including global variables and static local variables) are constructed at program startup and destroyed at program shutdown.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Improving the NetworkData program<\/p>\n<p>Back to our example at the top of the lesson, we can remove the need for the user to explicitly call <code>sendData()<\/code> by having a destructor call that function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class NetworkData\r\n{\r\nprivate:\r\n    std::string m_serverName{};\r\n    DataStore m_dataQueue{};\r\n\r\npublic:\r\n\tNetworkData(std::string_view serverName)\r\n\t\t: m_serverName { serverName }\r\n\t{\r\n\t}\r\n\r\n\t~NetworkData()\r\n\t{\r\n\t\tsendData(); \/\/ make sure all data is sent before object is destroyed\r\n\t}\r\n\r\n\tvoid addData(std::string_view data)\r\n\t{\r\n\t\tm_dataQueue.add(data);\r\n\t}\r\n\r\n\tvoid sendData()\r\n\t{\r\n\t\t\/\/ connect to server\r\n\t\t\/\/ send all data\r\n\t\t\/\/ clear data\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n    NetworkData n(\"someipAddress\");\r\n\r\n    n.addData(\"somedata1\");\r\n    n.addData(\"somedata2\");\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>With such a destructor, our <code>NetworkData<\/code> object will always send whatever data it has before the object is destroyed!  The cleanup happens automatically, which means less chance for errors, and less things to think about.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">An implicit destructor<\/p>\n<p>If a non-aggregate class type object has no user-declared destructor, the compiler will generate a destructor with an empty body.  This destructor is called an implicit destructor, and it is effectively just a placeholder.<\/p>\n<p>If your class does not need to do any cleanup on destruction, it&#8217;s fine to not define a destructor at all, and let the compiler generate an implicit destructor for your class.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A warning about the <code>std::exit()<\/code> function<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/halts-exiting-your-program-early\/\">8.12 -- Halts (exiting your program early)<\/a>, we discussed the <code>std::exit()<\/code> function, can be used to terminate your program immediately.  When the program is terminated immediately, the program just ends.  Local variables are not destroyed first, and because of this, no destructors will be called.  Be wary if you&#8217;re relying on your destructors to do necessary cleanup work in such a case.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Unhandled exceptions will also cause the program to terminate, and may not unwind the stack before doing so.  If stack unwinding does not happen, destructors will not be called prior to the termination of the program.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-templates-with-member-functions\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">15.5<\/span>Class templates with member functions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/nested-types-member-types\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">15.3<\/span>Nested types (member types)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>The cleanup problem Let&#8217;s say that you are writing a program that needs to send some data over a network. However, establishing a connection to the server is expensive, so you want to collect a bunch of data and then send it all at once. Such a class might be &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15327"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15327"}],"version-history":[{"count":10,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15327\/revisions"}],"predecessor-version":[{"id":15765,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15327\/revisions\/15765"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15327"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15327"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15327"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}