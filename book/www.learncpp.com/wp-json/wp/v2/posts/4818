{"id":4818,"date":"2016-11-19T13:10:23","date_gmt":"2016-11-19T21:10:23","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=4818"},"modified":"2024-10-28T22:02:45","modified_gmt":"2024-10-29T05:02:45","slug":"object-slicing","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/object-slicing\/","title":{"rendered":"25.9 &#8212; Object slicing"},"content":{"rendered":"<p>Let&#8217;s go back to an example we looked at previously:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Base\r\n{\r\nprotected:\r\n    int m_value{};\r\n \r\npublic:\r\n    Base(int value)\r\n        : m_value{ value }\r\n    {\r\n    }\r\n\r\n    virtual ~Base() = default;\r\n\r\n    virtual std::string_view getName() const { return \"Base\"; }\r\n    int getValue() const { return m_value; }\r\n};\r\n \r\nclass Derived: public Base\r\n{\r\npublic:\r\n    Derived(int value)\r\n        : Base{ value }\r\n    {\r\n    }\r\n \r\n   std::string_view getName() const override { return \"Derived\"; }\r\n};\r\n\r\nint main()\r\n{\r\n    Derived derived{ 5 };\r\n    std::cout &lt;&lt; \"derived is a \" &lt;&lt; derived.getName() &lt;&lt; \" and has value \" &lt;&lt; derived.getValue() &lt;&lt; '\\n';\r\n \r\n    Base&amp; ref{ derived };\r\n    std::cout &lt;&lt; \"ref is a \" &lt;&lt; ref.getName() &lt;&lt; \" and has value \" &lt;&lt; ref.getValue() &lt;&lt; '\\n';\r\n \r\n    Base* ptr{ &amp;derived };\r\n    std::cout &lt;&lt; \"ptr is a \" &lt;&lt; ptr-&gt;getName() &lt;&lt; \" and has value \" &lt;&lt; ptr-&gt;getValue() &lt;&lt; '\\n';\r\n \r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, ref references and ptr points to derived, which has a Base part, and a Derived part.  Because ref and ptr are of type Base, ref and ptr can only see the Base part of derived -- the Derived part of derived still exists, but simply can&#8217;t be seen through ref or ptr.  However, through use of virtual functions, we can access the most-derived version of a function.  Consequently, the above program prints:<\/p>\n<pre>\nderived is a Derived and has value 5\r\nref is a Derived and has value 5\r\nptr is a Derived and has value 5\r\n<\/pre>\n<p>But what happens if instead of setting a Base reference or pointer to a Derived object, we simply <em>assign<\/em> a Derived object to a Base object?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    Derived derived{ 5 };\r\n    Base base{ derived }; \/\/ what happens here?\r\n    std::cout &lt;&lt; \"base is a \" &lt;&lt; base.getName() &lt;&lt; \" and has value \" &lt;&lt; base.getValue() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Remember that derived has a Base part and a Derived part.  When we assign a Derived object to a Base object, only the Base portion of the Derived object is copied.  The Derived portion is not.  In the example above, base receives a copy of the Base portion of derived, but not the Derived portion.  That Derived portion has effectively been &#8220;sliced off&#8221;.  Consequently, the assigning of a Derived class object to a Base class object is called <strong>object slicing<\/strong> (or slicing for short).<\/p>\n<p>Because base was and still is just a Base, Base&#8217;s virtual pointer still points to Base.  Thus, base.getName() resolves to Base::getName().<\/p>\n<p>The above example prints:<\/p>\n<pre>\nbase is a Base and has value 5\r\n<\/pre>\n<p>Used conscientiously, slicing can be benign.  However, used improperly, slicing can cause unexpected results in quite a few different ways.  Let&#8217;s examine some of those cases.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Slicing and functions<\/p>\n<p>Now, you might think the above example is a bit silly.  After all, why would you assign derived to base like that?  You probably wouldn&#8217;t.  However, slicing is much more likely to occur accidentally with functions.<\/p>\n<p>Consider the following function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void printName(const Base base) \/\/ note: base passed by value, not reference\r\n{\r\n    std::cout &lt;&lt; \"I am a \" &lt;&lt; base.getName() &lt;&lt; '\\n';\r\n}<\/code><\/pre>\n<p>This is a pretty simple function with a const base object parameter that is passed by value.  If we call this function like such:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    Derived d{ 5 };\r\n    printName(d); \/\/ oops, didn't realize this was pass by value on the calling end\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When you wrote this program, you may not have noticed that base is a value parameter, not a reference.  Therefore, when called as printName(d), while we might have expected base.getName() to call virtualized function getName() and print &#8220;I am a Derived&#8221;, that is not what happens.  Instead, Derived object d is sliced and only the Base portion is copied into the base parameter.  When base.getName() executes, even though the getName() function is virtualized, there&#8217;s no Derived portion of the class for it to resolve to.  Consequently, this program prints:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">I am a Base<\/code><\/pre>\n<p>In this case, it&#8217;s pretty obvious what happened, but if your functions don&#8217;t actually print any identifying information like this, tracking down the error can be challenging.<\/p>\n<p>Of course, slicing here can all be easily avoided by making the function parameter a reference instead of a pass by value (yet another reason why passing classes by reference instead of value is a good idea).<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void printName(const Base&amp; base) \/\/ note: base now passed by reference\r\n{\r\n    std::cout &lt;&lt; \"I am a \" &lt;&lt; base.getName() &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    Derived d{ 5 };\r\n    printName(d);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nI am a Derived\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Slicing vectors<\/p>\n<p>Yet another area where new programmers run into trouble with slicing is trying to implement polymorphism with std::vector.  Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n\tstd::vector&lt;Base&gt; v{};\r\n\tv.push_back(Base{ 5 });    \/\/ add a Base object to our vector\r\n\tv.push_back(Derived{ 6 }); \/\/ add a Derived object to our vector\r\n\r\n        \/\/ Print out all of the elements in our vector\r\n\tfor (const auto&amp; element : v)\r\n\t\tstd::cout &lt;&lt; \"I am a \" &lt;&lt; element.getName() &lt;&lt; \" with value \" &lt;&lt; element.getValue() &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This program compiles just fine.  But when run, it prints:<\/p>\n<pre>\nI am a Base with value 5\r\nI am a Base with value 6\r\n<\/pre>\n<p>Similar to the previous examples, because the std::vector was declared to be a vector of type Base, when Derived(6) was added to the vector, it was sliced.<\/p>\n<p>Fixing this is a little more difficult.  Many new programmers try creating a std::vector of references to an object, like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::vector&lt;Base&amp;&gt; v{};<\/code><\/pre>\n<p>Unfortunately, this won&#8217;t compile.  The elements of std::vector must be assignable, whereas references can&#8217;t be reassigned (only initialized).<\/p>\n<p>One way to address this is to make a vector of pointers:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n\tstd::vector&lt;Base*&gt; v{};\r\n\t\r\n\tBase b{ 5 }; \/\/ b and d can't be anonymous objects\r\n\tDerived d{ 6 };\r\n\r\n\tv.push_back(&amp;b); \/\/ add a Base object to our vector\r\n\tv.push_back(&amp;d); \/\/ add a Derived object to our vector\r\n\r\n\t\/\/ Print out all of the elements in our vector\r\n\tfor (const auto* element : v)\r\n\t\tstd::cout &lt;&lt; \"I am a \" &lt;&lt; element-&gt;getName() &lt;&lt; \" with value \" &lt;&lt; element-&gt;getValue() &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nI am a Base with value 5\r\nI am a Derived with value 6\r\n<\/pre>\n<p>which works!  A few comments about this.  First, nullptr is now a valid option, which may or may not be desirable.  Second, you now have to deal with pointer semantics, which can be awkward.  But the upside is that using pointers allows us to put dynamically allocated objects in the vector (just don&#8217;t forget to explicitly delete them).<\/p>\n<p>Another option is to use std::reference_wrapper, which is a class that mimics an reassignable reference:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;functional&gt; \/\/ for std::reference_wrapper\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n#include &lt;vector&gt;\r\n\r\nclass Base\r\n{\r\nprotected:\r\n    int m_value{};\r\n\r\npublic:\r\n    Base(int value)\r\n        : m_value{ value }\r\n    {\r\n    }\r\n    virtual ~Base() = default;\r\n\r\n    virtual std::string_view getName() const { return \"Base\"; }\r\n    int getValue() const { return m_value; }\r\n};\r\n\r\nclass Derived : public Base\r\n{\r\npublic:\r\n    Derived(int value)\r\n        : Base{ value }\r\n    {\r\n    }\r\n\r\n    std::string_view getName() const override { return \"Derived\"; }\r\n};\r\n\r\nint main()\r\n{\r\n\tstd::vector&lt;std::reference_wrapper&lt;Base&gt;&gt; v{}; \/\/ a vector of reassignable references to Base\r\n\r\n\tBase b{ 5 }; \/\/ b and d can't be anonymous objects\r\n\tDerived d{ 6 };\r\n\r\n\tv.push_back(b); \/\/ add a Base object to our vector\r\n\tv.push_back(d); \/\/ add a Derived object to our vector\r\n\r\n\t\/\/ Print out all of the elements in our vector\r\n\t\/\/ we use .get() to get our element out of the std::reference_wrapper\r\n\tfor (const auto&amp; element : v) \/\/ element has type const std::reference_wrapper&lt;Base&gt;&amp;\r\n\t\tstd::cout &lt;&lt; \"I am a \" &lt;&lt; element.get().getName() &lt;&lt; \" with value \" &lt;&lt; element.get().getValue() &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The Frankenobject<\/p>\n<p>In the above examples, we&#8217;ve seen cases where slicing lead to the wrong result because the derived class had been sliced off.  Now let&#8217;s take a look at another dangerous case where the derived object still exists!<\/p>\n<p>Consider the following code:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    Derived d1{ 5 };\r\n    Derived d2{ 6 };\r\n    Base&amp; b{ d2 };\r\n\r\n    b = d1; \/\/ this line is problematic\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The first three lines in the function are pretty straightforward.  Create two Derived objects, and set a Base reference to the second one.<\/p>\n<p>The fourth line is where things go astray.  Since b points at d2, and we&#8217;re assigning d1 to b, you might think that the result would be that d1 would get copied into d2 -- and it would, if b were a Derived.  But b is a Base, and the operator= that C++ provides for classes isn&#8217;t virtual by default.  Consequently, the assignment operator that copies a Base is invoked, and only the Base portion of d1 is copied into d2.<\/p>\n<p>As a result, you&#8217;ll discover that d2 now has the Base portion of d1 and the Derived portion of d2.  In this particular example, that&#8217;s not a problem (because the Derived class has no data of its own), but in most cases, you&#8217;ll have just created a Frankenobject -- composed of parts of multiple objects.<\/p>\n<p>Worse, there&#8217;s no easy way to prevent this from happening (other than avoiding assignments like this as much as possible).<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>If the Base class is not designed to be instantiated by itself (e.g. it is just an interface class), slicing can be avoided by making the Base class non-copyable (by deleting the Base copy constructor and Base assignment operator).\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Conclusion<\/p>\n<p>Although C++ supports assigning derived objects to base objects via object slicing, in general, this is likely to cause nothing but headaches, and you should generally try to avoid slicing.  Make sure your function parameters are references (or pointers) and try to avoid any kind of pass-by-value when it comes to derived classes.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/dynamic-casting\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">25.10<\/span>Dynamic casting\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/virtual-base-classes\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">25.8<\/span>Virtual base classes\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Let&#8217;s go back to an example we looked at previously: #include &lt;iostream&gt; #include &lt;string_view&gt; class Base { protected: int m_value{}; public: Base(int value) : m_value{ value } { } virtual ~Base() = default; virtual std::string_view getName() const { return &#8220;Base&#8221;; } int getValue() const { return m_value; } }; class &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4818"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=4818"}],"version-history":[{"count":29,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4818\/revisions"}],"predecessor-version":[{"id":17814,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4818\/revisions\/17814"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=4818"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=4818"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=4818"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}