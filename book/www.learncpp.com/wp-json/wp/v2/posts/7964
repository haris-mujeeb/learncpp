{"id":7964,"date":"2019-02-01T12:03:17","date_gmt":"2019-02-01T20:03:17","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=7964"},"modified":"2024-10-14T22:12:37","modified_gmt":"2024-10-15T05:12:37","slug":"finding-issues-before-they-become-problems","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/finding-issues-before-they-become-problems\/","title":{"rendered":"3.10 &#8212; Finding issues before they become problems"},"content":{"rendered":"<p>When you make a semantic error, that error may or may not be immediately noticeable when you run your program.  An issue may lurk undetected in your code for a long time before newly introduced code or changed circumstances cause it to manifest as a program malfunction.  The longer an error sits in the code base before it is found, the more likely it is to be hard to find, and something that may have been easy to fix originally turns into a debugging adventure that eats up time and energy.<\/p>\n<p>So what can we do about that?<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Don&#8217;t make errors<\/p>\n<p>Well, the best thing is to not make errors in the first place.  Here&#8217;s a list of things that can help avoid making errors:<\/p>\n<ul>\n<li>Follow best practices.\n<\/li>\n<li>Don&#8217;t program when tired or frustrated.  Take a break and come back later.\n<\/li>\n<li>Understand where the common pitfalls are in a language (all those things we warn you not to do).\n<\/li>\n<li>Don&#8217;t let your functions get too long.\n<\/li>\n<li>Prefer using the standard library to writing your own code, when possible.\n<\/li>\n<li>Comment your code liberally.\n<\/li>\n<li>Start with simple solutions, then layer in complexity incrementally.\n<\/li>\n<li>Avoid clever\/non-obvious solutions.\n<\/li>\n<li>Optimize for readability and maintainability, not performance.\n<\/li>\n<\/ul>\n<blockquote><p>Everyone knows that debugging is twice as hard as writing a program in the first place. So if you&#8217;re as clever as you can be when you write it, how will you ever debug it?<\/p>\n<footer>\u2014Brian Kernighan, <cite>&#8220;The Elements of Programming Style&#8221;, 2nd edition<\/cite><\/footer>\n<\/blockquote>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Refactoring your code<\/p>\n<p>As you add new capabilities to your programs (&#8220;behavioral changes&#8221;), you will find that some of your functions grow in length.  As functions get longer, they get both more complex and harder to understand.<\/p>\n<p>One way to address this is to break a single long function into multiple shorter functions.  This process of making structural changes to your code without changing its behavior is called <strong>refactoring<\/strong>.  The goal of refactoring is to make your program less complex by increasing its organization and modularity.<\/p>\n<p>So how long is too long for a function?  A function that takes up one vertical screen worth of code is generally regarded as too long -- if you have to scroll to read the whole function, the function&#8217;s comprehensibility drops significantly.  Ideally, a function should be less than ten lines.  Functions that are less than five lines are even better.<\/p>\n<p>Remember that the goal here is to maximize comprehension and maintainability, not to minimize function length -- abandoning best practices or using obscure coding techniques to save a line or two doesn&#8217;t do your code any favors.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>When making changes to your code, make behavioral changes OR structural changes, and then retest for correctness.  Making behavioral and structural changes at the same time tends to lead to more errors as well as errors that are harder to find.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">An introduction to defensive programming<\/p>\n<p>Errors can be not only of your own making (e.g. incorrect logic), but also occur when your users use the application in a way that you did not anticipate.  For example, if you ask the user to enter an integer, and they enter a letter instead, how does your program behave in such a case?  Unless you anticipated this, and added some error handling for this case, probably not very well.<\/p>\n<p><strong>Defensive programming<\/strong> is a practice whereby the programmer tries to anticipate all of the ways the software could be misused, either by end-users, or by other developers (including the programmer themselves) using the code.  These misuses can often be detected and then mitigated (e.g. by asking a user who entered bad input to try again).  <\/p>\n<p>We&#8217;ll explore topics related to error handling in future lessons.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Finding errors fast<\/p>\n<p>Since not making errors is difficult in large programs, the next best thing is to catch errors you do make quickly.<\/p>\n<p>The best way to do this is to program a little bit at a time, and then test your code and make sure it works.<\/p>\n<p>However, there are a few other techniques we can also use.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">An introduction to testing functions<\/p>\n<p>One common way to help uncover issues with your program is to write testing functions to &#8220;exercise&#8221; the code you&#8217;ve written.  Here&#8217;s a primitive attempt, more for illustrative purposes than anything:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y)\r\n{\r\n\treturn x + y;\r\n}\r\n\r\nvoid testadd()\r\n{\r\n\tstd::cout &lt;&lt; \"This function should print: 2 0 0 -2\\n\";\r\n\tstd::cout &lt;&lt; add(1, 1) &lt;&lt; ' ';\r\n\tstd::cout &lt;&lt; add(-1, 1) &lt;&lt; ' ';\r\n\tstd::cout &lt;&lt; add(1, -1) &lt;&lt; ' ';\r\n\tstd::cout &lt;&lt; add(-1, -1) &lt;&lt; ' ';\r\n}\r\n\r\nint main()\r\n{\r\n\ttestadd();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>The testadd() function tests the add() function by calling it with different values.  If all the values match our expectations, then we can be reasonably confident the function works.  Even better, we can keep this function around, and run it any time we change function <em>add<\/em> to ensure we haven&#8217;t accidentally broken it.<\/p>\n<p>This is a primitive form of <strong>unit testing<\/strong>, which is a software testing method by which small units of source code are tested to determine whether they are correct.<\/p>\n<p>As with logging frameworks, there are many 3rd party unit testing frameworks that can be used.  It&#8217;s also possible to write your own, though we&#8217;ll need more language features at our disposal to do the topic justice.  We&#8217;ll come back to some of this in a future lesson.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">An introduction to constraints<\/p>\n<p>Constraints-based techniques involve the addition of some extra code (that can be compiled out in a non-debug build, if desired) to check that some set of assumptions or expectations are not violated.<\/p>\n<p>For example, if we were writing a function to calculate the factorial of a number, which expects a non-negative argument, the function could check to make sure the caller passed in a non-negative number before proceeding.  If the caller passes in a negative number, then the function could immediately error out rather than producing some indeterminate result, helping ensure the problem is caught immediately.<\/p>\n<p>One common method of doing this is via <em>assert<\/em> and <em>static_assert<\/em>, which we cover in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/assert-and-static_assert\/\">9.6 -- Assert and static_assert<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Shotgunning for general issues<\/p>\n<p>Programmers tend to make certain kinds of common mistakes, and some of those mistakes can be discovered by programs trained to look for them.  These programs, generally known as <strong>static analysis tools<\/strong> (sometimes informally called <em>linters<\/em>) are programs that analyze your source code to identify specific semantic issues (in this context, <em>static<\/em> means that these tools analyze the source code without executing it).  The issues found by static analysis tools may or may not be the cause of any particular problem you are having, but may help point out fragile areas of code or issues that can be problematic in certain circumstances.<\/p>\n<p>You already have one static analysis tool at your disposal -- your compiler!  In addition to ensuring your program is syntactically correct, most modern C++ compilers will do some light static analysis to identify some common problems.  For example, many compilers will warn you if you try to use a variable that has not been initialized.  If you haven&#8217;t already, turning up your compiler warning and error levels (see lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/configuring-your-compiler-warning-and-error-levels\/\">0.11 -- Configuring your compiler: Warning and error levels<\/a>) can help surface these.<\/p>\n<p><a href=\"https:\/\/en.wikipedia.org\/wiki\/List_of_tools_for_static_code_analysis#C,_C++\">Many static analysis tools exist<\/a>, some of which can identify over 300 types of programming errors.  On our small academic programs, use of a static analysis tool is optional, but using one may help you find areas where your code is non-compliant with best practices.  On large programs, use of a static analysis tool is highly recommended, as it can surface tens or hundreds of potential issues.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Use a static analysis tool on your programs to help find areas where your code is non-compliant with best practices.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightyellowbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For Visual Studio users<\/p>\n<p>Visual Studio 2019 onward comes with a built-in static analysis tool.  You can access it via <em>Build > Run Code Analysis on Solution (Alt+F11)<\/em>.\n<\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>Some commonly recommended static analysis tools include:<\/p>\n<p>Free:<\/p>\n<ul>\n<li><a href=\"https:\/\/clang.llvm.org\/extra\/clang-tidy\/\">clang-tidy<\/a>\n<\/li>\n<li><a href=\"https:\/\/github.com\/cpplint\/cpplint\">cpplint<\/a>\n<\/li>\n<li><a href=\"https:\/\/cppcheck.sourceforge.io\/\">cppcheck<\/a> (already integrated into Code::Blocks)\n<\/li>\n<li><a href=\"https:\/\/www.sonarsource.com\/open-source-editions\/\">SonarLint<\/a>\n<\/li>\n<\/ul>\n<p>Most of these have extensions that allow them to integrate into your IDE.  For example, <a href=\"https:\/\/marketplace.visualstudio.com\/items?itemName=caphyon.ClangPowerTools\">Clang Power Tools extension<\/a>.<\/p>\n<p>Paid (may be free for Open Source projects):<\/p>\n<ul>\n<li><a href=\"https:\/\/www.synopsys.com\/software-integrity\/security-testing\/static-analysis-sast.html\">Coverity<\/a>\n<\/li>\n<li><a href=\"https:\/\/www.sonarsource.com\/products\/sonarqube\/\">SonarQube<\/a>\n<\/li>\n<\/ul>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-3-summary-and-quiz\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">3.x<\/span>Chapter 3 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/using-an-integrated-debugger-the-call-stack\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">3.9<\/span>Using an integrated debugger: The call stack\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>When you make a semantic error, that error may or may not be immediately noticeable when you run your program. An issue may lurk undetected in your code for a long time before newly introduced code or changed circumstances cause it to manifest as a program malfunction. The longer an &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/7964"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=7964"}],"version-history":[{"count":21,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/7964\/revisions"}],"predecessor-version":[{"id":17751,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/7964\/revisions\/17751"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=7964"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=7964"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=7964"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}