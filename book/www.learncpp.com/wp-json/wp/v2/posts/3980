{"id":3980,"date":"2016-04-21T13:01:20","date_gmt":"2016-04-21T21:01:20","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=3980"},"modified":"2025-01-29T22:16:45","modified_gmt":"2025-01-30T06:16:45","slug":"stdcin-and-handling-invalid-input","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/stdcin-and-handling-invalid-input\/","title":{"rendered":"9.5 &#8212; std::cin and handling invalid input"},"content":{"rendered":"<p>Most programs that have a user interface of some kind need to handle user input.  In the programs that you have been writing, you have been using std::cin to ask the user to enter text input.  Because text input is so free-form (the user can enter anything), it&#8217;s very easy for the user to enter input that is not expected.<\/p>\n<p>As you write programs, you should always consider how users will (unintentionally or otherwise) misuse your programs.  A well-written program will anticipate how users will misuse it, and either handle those cases gracefully or prevent them from happening in the first place (if possible).  A program that handles error cases well is said to be <strong>robust<\/strong>.<\/p>\n<p>In this lesson, we&#8217;ll take a look specifically at ways the user can enter invalid text input via std::cin, and show you some different ways to handle those cases.<\/p>\n<p style=\"clear: both\">\n<p> <!-- break around image --><\/p>\n<p>Before we discuss how <code>std::cin<\/code> and <code>operator&gt;&gt;<\/code> can fail, let&#8217;s recap how they work.  We discussed this material in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-iostream-cout-cin-and-endl\/#extraction\">1.5 -- Introduction to iostream: cout, cin, and endl<\/a>.<\/p>\n<p>Here&#8217;s a simplified view of how <code>operator&gt;&gt;<\/code> works for input:<\/p>\n<ol start=\"1\">\n<li>First, leading whitespace (spaces, tabs, and newlines at the front of the buffer) is discarded from the input buffer.  This will discard any unextracted newline character remaining from a prior line of input.\n<\/li>\n<li>If the input buffer is now empty, <code>operator&gt;&gt;<\/code> will wait for the user to enter more data.  Leading whitespace is again discarded.\n<\/li>\n<li><code>operator&gt;&gt;<\/code> then extracts as many consecutive characters as it can, until it encounters either a newline character (representing the end of the line of input) or a character that is not valid for the variable being extracted to.\n<\/li>\n<\/ol>\n<p>The result of the extraction is as follows:<\/p>\n<ul>\n<li>If any characters were extracted in step 3 above, extraction is a success.  The extracted characters are converted into a value that is then assigned to the variable.\n<\/li>\n<li>If no characters could be extracted in step 3 above, extraction has failed.  The object being extracted to is assigned the value <code>0<\/code> (as of C++11), and any future extractions will immediately fail (until <code>std::cin<\/code> is cleared).\n<\/li>\n<\/ul>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Validating input<\/p>\n<p>The process of checking whether user input conforms to what the program is expecting is called <strong>input validation<\/strong>.<\/p>\n<p>There are three basic ways to do input validation:<\/p>\n<p>Inline (as the user types):<\/p>\n<ol start=\"1\">\n<li>Prevent the user from typing invalid input in the first place.\n<\/li>\n<\/ol>\n<p>Post-entry (after the user types):<\/p>\n<ol start=\"2\">\n<li>Let the user enter whatever they want into a string, then validate whether the string is correct, and if so, convert the string to the final variable format.\n<\/li>\n<li>Let the user enter whatever they want, let std::cin and operator&gt;&gt; try to extract it, and handle the error cases.\n<\/li>\n<\/ol>\n<p>Some graphical user interfaces and advanced text interfaces will let you validate input as the user enters it (character by character).  Generally speaking, the programmer provides a validation function that accepts the input the user has entered so far, and returns true if the input is valid, and false otherwise.  This function is called every time the user presses a key.  If the validation function returns true, the key the user just pressed is accepted.  If the validation function returns false, the character the user just input is discarded (and not shown on the screen).  Using this method, you can ensure that any input the user enters is guaranteed to be valid, because any invalid keystrokes are discovered and discarded immediately.  Unfortunately, std::cin does not support this style of validation.<\/p>\n<p>Since strings do not have any restrictions on what characters can be entered, extraction is guaranteed to succeed (though remember that std::cin stops extracting at the first non-leading whitespace character).  Once a string is entered, the program can then parse the string to see if it is valid or not.  However, parsing strings and converting string input to other types (e.g. numbers) can be challenging, so this is only done in rare cases.<\/p>\n<p>Most often, we let std::cin and the extraction operator do the hard work.  Under this method, we let the user enter whatever they want, have std::cin and operator&gt;&gt; try to extract it, and deal with the fallout if it fails.  This is the easiest method, and the one we&#8217;ll talk more about below.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A sample program<\/p>\n<p>Consider the following calculator program that has no error handling:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n \r\ndouble getDouble()\r\n{\r\n    std::cout &lt;&lt; \"Enter a decimal number: \";\r\n    double x{};\r\n    std::cin &gt;&gt; x;\r\n    return x;\r\n}\r\n \r\nchar getOperator()\r\n{\r\n    std::cout &lt;&lt; \"Enter one of the following: +, -, *, or \/: \";\r\n    char op{};\r\n    std::cin &gt;&gt; op;\r\n    return op;\r\n}\r\n \r\nvoid printResult(double x, char operation, double y)\r\n{\r\n    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; operation &lt;&lt; ' ' &lt;&lt; y &lt;&lt; \" is \";\r\n\r\n    switch (operation)\r\n    {\r\n    case '+':\r\n        std::cout &lt;&lt; x + y &lt;&lt; '\\n';\r\n        return;\r\n    case '-':\r\n        std::cout &lt;&lt; x - y &lt;&lt; '\\n';\r\n        return;\r\n    case '*':\r\n        std::cout &lt;&lt; x * y &lt;&lt; '\\n';\r\n        return;\r\n    case '\/':\r\n        std::cout &lt;&lt; x \/ y &lt;&lt; '\\n';\r\n        return;\r\n    }\r\n}\r\n \r\nint main()\r\n{\r\n    double x{ getDouble() };\r\n    char operation{ getOperator() };\r\n    double y{ getDouble() };\r\n\r\n    printResult(x, operation, y);\r\n \r\n    return 0;\r\n}<\/code><\/pre>\n<p>This simple program asks the user to enter two numbers and a mathematical operator.<\/p>\n<pre>\r\nEnter a decimal number: 5\r\nEnter one of the following: +, -, *, or \/: *\r\nEnter a decimal number: 7\r\n5 * 7 is 35\r\n<\/pre>\n<p>Now, consider where invalid user input might break this program.<\/p>\n<p>First, we ask the user to enter some numbers.  What if they enter something other than a number (e.g. &#8216;q&#8217;)?  In this case, extraction will fail.<\/p>\n<p>Second, we ask the user to enter one of four possible symbols.  What if they enter a character other than one of the symbols we&#8217;re expecting?  We&#8217;ll be able to extract the input, but we don&#8217;t currently handle what happens afterward.<\/p>\n<p>Third, what if we ask the user to enter a symbol and they enter a string like <code>\"*q hello\"<\/code>.  Although we can extract the <code>'*'<\/code> character we need, there&#8217;s additional input left in the buffer that could cause problems down the road.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Types of invalid text input<\/p>\n<p>We can generally separate input text errors into four types:<\/p>\n<ul>\n<li>Input extraction succeeds but the input is meaningless to the program (e.g. entering &#8216;k&#8217; as your mathematical operator).<\/li>\n<li>Input extraction succeeds but the user enters additional input (e.g. entering &#8216;*q hello&#8217; as your mathematical operator).<\/li>\n<li>Input extraction fails (e.g. trying to enter &#8216;q&#8217; into a numeric input).<\/li>\n<li>Input extraction succeeds but the user overflows a numeric value.<\/li>\n<\/ul>\n<\/ul>\n<p>Thus, to make our programs robust, whenever we ask the user for input, we ideally should determine whether each of the above can possibly occur, and if so, write code to handle those cases.<\/p>\n<p>Let&#8217;s dig into each of these cases, and how to handle them using std::cin.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Error case 1: Extraction succeeds but input is meaningless<\/p>\n<p>This is the simplest case.  Consider the following execution of the above program:<\/p>\n<pre>\r\nEnter a decimal number: 5\r\nEnter one of the following: +, -, *, or \/: k\r\nEnter a decimal number: 7\r\n<\/pre>\n<p>In this case, we asked the user to enter one of four symbols, but they entered &#8216;k&#8217; instead.  &#8216;k&#8217; is a valid character, so <code>std::cin<\/code> happily extracts it to variable <code>op<\/code>, and this gets returned to <code>main<\/code>.  But our program wasn&#8217;t expecting this to happen, so it doesn&#8217;t properly deal with this case.  As a result, it outputs:<\/p>\n<pre>\n5 k 7 is\r\n<\/pre>\n<p>The solution here is simple: do input validation.  This usually consists of 3 steps:<\/p>\n<ol start=\"1\">\n<li>Check whether the user&#8217;s input was what you were expecting.\n<\/li>\n<li>If so, return the value to the caller.\n<\/li>\n<li>If not, tell the user something went wrong and have them try again.\n<\/li>\n<\/ol>\n<p>Here&#8217;s an updated getOperator() function that does input validation.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">char getOperator()\r\n{\r\n    while (true) \/\/ Loop until user enters a valid input\r\n    {\r\n        std::cout &lt;&lt; \"Enter one of the following: +, -, *, or \/: \";\r\n        char operation{};\r\n        std::cin &gt;&gt; operation;\r\n\r\n        \/\/ Check whether the user entered meaningful input\r\n        switch (operation)\r\n        {\r\n        case '+':\r\n        case '-':\r\n        case '*':\r\n        case '\/':\r\n            return operation; \/\/ return it to the caller\r\n        default: \/\/ otherwise tell the user what went wrong\r\n            std::cout &lt;&lt; \"Oops, that input is invalid.  Please try again.\\n\";\r\n        }\r\n    } \/\/ and try again\r\n}<\/code><\/pre>\n<p>As you can see, we&#8217;re using a while loop to continuously loop until the user provides valid input.  If they don&#8217;t, we ask them to try again until they either give us valid input, shutdown the program, or destroy their computer.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Error case 2: Extraction succeeds but with extraneous input<\/p>\n<p>Consider the following execution of the above program:<\/p>\n<pre>\nEnter a decimal number: 5*7\r\n<\/pre>\n<p>What do you think happens next?<\/p>\n<pre>\nEnter a decimal number: 5*7\r\nEnter one of the following: +, -, *, or \/: Enter a decimal number: 5 * 7 is 35\r\n<\/pre>\n<p>The program prints the right answer, but the formatting is all messed up.  Let&#8217;s take a closer look at why.<\/p>\n<p>When the user enters <code>5*7<\/code> as input, that input goes into the buffer.  Then <code>operator&gt;&gt;<\/code> extracts the 5 to variable x, leaving <code>*7\\n<\/code> in the buffer.  Next, the program prints &#8220;Enter one of the following: +, -, &#42;, or \/:&#8221;.  However, when the extraction operator was called, it sees <code>*7\\n<\/code> waiting in the buffer to be extracted, so it uses that instead of asking the user for more input.  Consequently, it extracts the &#8216;*&#8217; character, leaving <code>7\\n<\/code> in the buffer.<\/p>\n<p>After asking the user to enter another decimal number, the <code>7<\/code> in the buffer gets extracted without asking the user.  Since the user never had an opportunity to enter additional data and hit enter (causing a newline), the output prompts all run together on the same line.<\/p>\n<p>Although the above program works, the execution is messy.  It would be better if any extraneous characters entered were simply ignored.  Fortunately, it&#8217;s easy to ignore characters:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::cin.ignore(100, '\\n');  \/\/ clear up to 100 characters out of the buffer, or until a '\\n' character is removed<\/code><\/pre>\n<p>This call would remove up to 100 characters, but if the user entered more than 100 characters we&#8217;ll get messy output again. To ignore all characters up to the next &#8216;\\n&#8217;, we can pass <code>std::numeric_limits&lt;std::streamsize&gt;::max()<\/code> to <code>&gt;std::cin.ignore()<\/code>. <code>std::numeric_limits&lt;std::streamsize&gt;::max()<\/code> returns the largest value that can be stored in a variable of type <code>std::streamsize<\/code>. Passing this value to <code>std::cin.ignore()<\/code> causes it to disable the count check.<\/p>\n<p>To ignore everything up to and including the next &#8216;\\n&#8217; character, we call<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');<\/code><\/pre>\n<p>Because this line is quite long for what it does, it&#8217;s handy to wrap it in a function which can be called in place of <code>std::cin.ignore()<\/code>.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;limits&gt; \/\/ for std::numeric_limits\r\n\r\nvoid ignoreLine()\r\n{\r\n    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\r\n}<\/code><\/pre>\n<p>Since the last character the user entered is typically a &#8216;\\n&#8217;, we can tell <code>std::cin<\/code> to ignore buffered characters until it finds a newline character (which is removed as well).<\/p>\n<p>Let&#8217;s update our getDouble() function to ignore any extraneous input:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">double getDouble()\r\n{\r\n    std::cout &lt;&lt; \"Enter a decimal number: \";\r\n    double x{};\r\n    std::cin &gt;&gt; x;\r\n\r\n    ignoreLine();\r\n    return x;\r\n}<\/code><\/pre>\n<p>Now our program will work as expected, even if we enter <code>5*7<\/code> for the first input -- the 5 will be extracted, and the rest of the characters will be removed from the input buffer.  Since the input buffer is now empty, the user will be properly asked for input the next time an extraction operation is performed!<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>In certain cases, it may be better to treat extraneous input as a failure case (rather than just ignoring it).  We can then ask the user to re-enter their input.<\/p>\n<p>Here&#8217;s a variation of <code>getDouble()<\/code> that asks the user to re-enter their input if there is any extraneous input entered:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ returns true if std::cin has unextracted input on the current line, false otherwise\r\nbool hasUnextractedInput()\r\n{\r\n    return !std::cin.eof() &amp;&amp; std::cin.peek() != '\\n';\r\n}\r\n\r\ndouble getDouble()\r\n{\r\n    while (true) \/\/ Loop until user enters a valid input\r\n    {\r\n        std::cout &lt;&lt; \"Enter a decimal number: \";\r\n        double x{};\r\n        std::cin &gt;&gt; x;\r\n\r\n        \/\/ NOTE: YOU SHOULD CHECK FOR A FAILED EXTRACTION HERE (see section below)\r\n\r\n        \/\/ If there is extraneous input, treat as failure case\r\n        if (hasUnextractedInput())\r\n        {\r\n            ignoreLine(); \/\/ remove extraneous input\r\n            continue;\r\n        }\r\n    \r\n        return x;\r\n    }\r\n}<\/code><\/pre>\n<p>The above snippet makes use of two functions we haven&#8217;t seen before:<\/p>\n<ul>\n<li>The <code>std::cin.eof()<\/code> function returns <code>true<\/code> if the last input operation (in this case the extraction to <code>x<\/code>) reached the end of the input stream.\n<\/li>\n<li>The <code>std::cin.peek()<\/code> function allows us to peek at the next character in the input stream without extracting it.\n<\/li>\n<\/ul>\n<p>Here&#8217;s how this function works.  After the user&#8217;s input has been extracted to <code>x<\/code>, there may or may not be additional (unextracted) characters left in <code>std::cin<\/code>.  <\/p>\n<p>First, we call <code>std::cin.eof()<\/code> to see if the extraction to <code>x<\/code> reached the end of the input stream.  If so, then we know all characters were extracted, which is a success case.<\/p>\n<p>Otherwise, there must be additional characters still inside <code>std::cin<\/code> waiting to be extracted.  In that case, we call <code>std::cin.peek()<\/code> to peek at the next character waiting to be extracted without actually extracting it.  If that next character is a <code>'\\n'<\/code>, that means we&#8217;ve already extracted all of the characters on this line of input to <code>x<\/code>.  This is also a success case.<\/p>\n<p>However, if the next character is something other than <code>'\\n'<\/code>, then the user must have entered extraneous input that wasn&#8217;t extracted to <code>x<\/code>.  That&#8217;s our failure case.  We clear out all of that extraneous input, and <code>continue<\/code> back to the top of the loop to try again.<\/p>\n<p>If you&#8217;re having trouble deciphering how the boolean expression in <code>hasUnextractedInput()<\/code> evaluates, that&#8217;s not surprising -- boolean expressions with negations can be difficult to understand.  In such cases, using de Morgan&#8217;s law can help.  An equivalent statement is <code>return !(std::cin.eof() || std::cin.peek() == '\\n');<\/code>.  This makes it clearer that we are testing for EOF or a newline.  If either are true, then we&#8217;ve extracted all the input.  We then apply <code>operator!<\/code> to tell us whether we haven&#8217;t extracted all the input, meaning there is still unextracted input.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Error case 3: Extraction fails<\/p>\n<p>Extraction fails when no input can be extracted to the specified variable.<\/p>\n<p>Now consider the following execution of our updated calculator program:<\/p>\n<pre>\r\nEnter a decimal number: a\r\n<\/pre>\n<p>You shouldn&#8217;t be surprised that the program doesn&#8217;t perform as expected, but how it fails is interesting:<\/p>\n<pre>\r\nEnter a decimal number: a\r\nEnter one of the following: +, -, *, or \/: Oops, that input is invalid.  Please try again.\r\nEnter one of the following: +, -, *, or \/: Oops, that input is invalid.  Please try again.\r\nEnter one of the following: +, -, *, or \/: Oops, that input is invalid.  Please try again.\r\n<\/pre>\n<p>and that last line keeps printing until the program is closed.<\/p>\n<p>This looks pretty similar to the extraneous input case, but it&#8217;s a little different.  Let&#8217;s take a closer look.<\/p>\n<p>When the user enters &#8216;a&#8217;, that character is placed in the buffer.  Then operator>> tries to extract &#8216;a&#8217; to variable x, which is of type double.  Since &#8216;a&#8217; can&#8217;t be converted to a double, <code>operator&gt;&gt;<\/code> can&#8217;t do the extraction.  Two things happen at this point: &#8216;a&#8217; is left in the buffer, and std::cin goes into &#8220;failure mode&#8221;.<\/p>\n<p>Once in &#8220;failure mode&#8221;, future requests for input extraction will silently fail.  Thus in our calculator program, the output prompts still print, but any requests for further extraction are ignored.  This means that instead waiting for us to enter an operation, the input prompt is skipped, and we get stuck in an infinite loop because there is no way to reach one of the valid cases.<\/p>\n<p>In order to get <code>std::cin<\/code> working properly again, we typically need to do three things:<\/p>\n<ul>\n<li>Detect that a prior extraction has failed.\n<\/li>\n<li>Put <code>std::cin<\/code> back in normal operation mode.\n<\/li>\n<li>Remove the input that caused the failure (so the next extraction request doesn&#8217;t fail in an identical manner).\n<\/li>\n<\/ul>\n<p>Here&#8217;s what that looks like:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">if (std::cin.fail()) \/\/ If the previous extraction failed\r\n{\r\n    \/\/ Let's handle the failure\r\n    std::cin.clear(); \/\/ Put us back in 'normal' operation mode\r\n    ignoreLine();     \/\/ And remove the bad input\r\n}<\/code><\/pre>\n<p>Because <code>std::cin<\/code> has a Boolean conversion indicating whether the last input succeeded, it&#8217;s more idiomatic to write the above as following:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">if (!std::cin) \/\/ If the previous extraction failed\r\n{\r\n    \/\/ Let's handle the failure\r\n    std::cin.clear(); \/\/ Put us back in 'normal' operation mode\r\n    ignoreLine();     \/\/ And remove the bad input\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Once an extraction has failed, future requests for input extraction (including calls to <code>ignore()<\/code>) will silently fail until the <code>clear()<\/code> function is called.  Thus, after detecting a failed extraction, calling <code>clear()<\/code> is usually the first thing you should do.\n<\/div>\n<p>Let&#8217;s integrate that into our getDouble() function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">double getDouble()\r\n{\r\n    while (true) \/\/ Loop until user enters a valid input\r\n    {\r\n        std::cout &lt;&lt; \"Enter a decimal number: \";\r\n        double x{};\r\n        std::cin &gt;&gt; x;\r\n\r\n        if (!std::cin) \/\/ If the previous extraction failed\r\n        {\r\n            \/\/ Let's handle the failure\r\n            std::cin.clear(); \/\/ Put us back in 'normal' operation mode\r\n            ignoreLine();     \/\/ And remove the bad input\r\n            continue;\r\n        }\r\n\r\n        \/\/ Our extraction succeeded\r\n        ignoreLine(); \/\/ Ignore any additional input on this line\r\n        return x;     \/\/ Return the value we extracted\r\n    }\r\n}<\/code><\/pre>\n<p>For fundamental types, a failed extraction due to invalid input will cause the variable to be assigned the value <code>0<\/code> (or whatever value <code>0<\/code> converts to in the variable&#8217;s type).<\/p>\n<p>It is fine to call <code>clear()<\/code> even when extraction hasn&#8217;t failed -- it won&#8217;t do anything.  In cases where we are going to call <code>ignoreLine()<\/code> regardless of whether we succeeded or failed, we can essentially combine the two cases:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">double getDouble()\r\n{\r\n    while (true) \/\/ Loop until user enters a valid input\r\n    {\r\n        std::cout &lt;&lt; \"Enter a decimal number: \";\r\n        double x{};\r\n        std::cin &gt;&gt; x;\r\n\r\n        bool success { std::cin }; \/\/ Remember whether we had a successful extraction\r\n        std::cin.clear();          \/\/ Put us back in 'normal' operation mode (in case we failed)\r\n        ignoreLine();              \/\/ Ignore any additional input on this line (regardless)\r\n\r\n        if (success)               \/\/ If we actually extracted a value\r\n            return x;              \/\/ Return it (otherwise, we go back to top of loop)\r\n    }\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Checking for EOF<\/p>\n<p>There&#8217;s another case that we need to address.<\/p>\n<p>An end-of-file (EOF) is a special error state that means &#8220;No more data available&#8221;.  This is normally generated <strong>after<\/strong> an input operation fails due to no data being available.  For example, if you were reading the contents of a file on disk, and then try to read in more data after you&#8217;ve already reached the end of the file, an EOF will be generated to tell you that no more data is available.  In the case of file input, this is no problem -- we can just close the file and move on.<\/p>\n<p>Now consider <code>std::cin<\/code>.  If we try to extract input from <code>std::cin<\/code> and there is none, by design it won&#8217;t generate an EOF -- it will just wait for the user to enter more input.  However, <code>std::cin<\/code> can generate an EOF in certain cases -- most commonly when the user enters a special key combination for their OS.  Both Unix (via ctrl-D) and Windows (via ctrl-Z + ENTER) support entering an &#8220;EOF character&#8221; from the keyboard.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>In C++, EOF is an error state, not a character.  Different OSes have special character combinations that are treated as a &#8220;user-entered EOF request&#8221;.  These are sometimes called &#8220;EOF characters&#8221;.\n<\/p><\/div>\n<p>When extracting data to <code>std::cin<\/code> and the user enters an EOF character, the behavior is OS-specific.  Here&#8217;s what typically happens:<\/p>\n<ul>\n<li>If the EOF is not the first character of input: All input prior to the EOF will be flushed, and the EOF character is ignored.  On Windows, any characters entered after the EOF are ignored, except for the newline.\n<\/li>\n<li>If the EOF is the first character entered: The EOF error will be set.  The input stream may (or may not) be disconnected.\n<\/li>\n<\/ul>\n<p>Although <code>std::cin.clear()<\/code> will clear an EOF error, if the input stream is disconnected, the next input request will generate another EOF error.  This is problematic when our input is inside a <code>while(true)<\/code> loop, as we will get stuck in an infinite loop of EOF errors.<\/p>\n<p>Since the intent of an keyboard-entered <code>EOF<\/code> character is to terminate the input stream, the best thing to do is detect the EOF (via <code>std::cin.eof()<\/code>) and then terminate the program.<\/p>\n<p>Because clearing a failed input stream is something we&#8217;re likely to be checking for a lot, this is a good candidate for a reusable function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;limits&gt; \/\/ for std::numeric_limits\r\n\r\nvoid ignoreLine()\r\n{\r\n    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\r\n}\r\n\r\n\/\/ returns true if extraction failed, false otherwise\r\nbool clearFailedExtraction()\r\n{\r\n    \/\/ Check for failed extraction\r\n    if (!std::cin) \/\/ If the previous extraction failed\r\n    {\r\n        if (std::cin.eof()) \/\/ If the user entered an EOF\r\n        {\r\n            std::exit(0); \/\/ Shut down the program now\r\n        }\r\n\r\n        \/\/ Let's handle the failure\r\n        std::cin.clear(); \/\/ Put us back in 'normal' operation mode\r\n        ignoreLine();     \/\/ And remove the bad input\r\n\r\n        return true;\r\n    }\r\n    \r\n    return false;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Error case 4: Extraction succeeds but the user overflows a numeric value<\/p>\n<p>Consider the following simple example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cstdint&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::int16_t x{}; \/\/ x is 16 bits, holds from -32768 to 32767\r\n    std::cout &lt;&lt; \"Enter a number between -32768 and 32767: \";\r\n    std::cin &gt;&gt; x;\r\n\r\n    std::int16_t y{}; \/\/ y is 16 bits, holds from -32768 to 32767\r\n    std::cout &lt;&lt; \"Enter another number between -32768 and 32767: \";\r\n    std::cin &gt;&gt; y;\r\n\r\n    std::cout &lt;&lt; \"The sum is: \" &lt;&lt; x + y &lt;&lt; '\\n';\r\n    return 0;\r\n}<\/code><\/pre>\n<p>What happens if the user enters a number that is too large (e.g. 40000)?<\/p>\n<pre>\nEnter a number between -32768 and 32767: 40000\r\nEnter another number between -32768 and 32767: The sum is: 32767\r\n<\/pre>\n<p>In the above case, <code>std::cin<\/code> goes immediately into &#8220;failure mode&#8221;, but also assigns the closest in-range value to the variable.  When the entered value is larger than the largest possible value for the type, the closest in-range value is the largest possible value for the type.  Consequently, <code>x<\/code> is left with the assigned value of <code>32767<\/code>.  Additional inputs are skipped, leaving <code>y<\/code> with the initialized value of <code>0<\/code>.  We can handle this kind of error in the same way as a failed extraction.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Putting it all together<\/p>\n<p>Here&#8217;s our example calculator, updated with a few additional bits of error checking:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cstdlib&gt; \/\/ for std::exit\r\n#include &lt;iostream&gt;\r\n#include &lt;limits&gt; \/\/ for std::numeric_limits\r\n\r\nvoid ignoreLine()\r\n{\r\n    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\r\n}\r\n\r\n\/\/ returns true if extraction failed, false otherwise\r\nbool clearFailedExtraction()\r\n{\r\n    \/\/ Check for failed extraction\r\n    if (!std::cin) \/\/ If the previous extraction failed\r\n    {\r\n        if (std::cin.eof()) \/\/ If the stream was closed\r\n        {\r\n            std::exit(0); \/\/ Shut down the program now\r\n        }\r\n\r\n        \/\/ Let's handle the failure\r\n        std::cin.clear(); \/\/ Put us back in 'normal' operation mode\r\n        ignoreLine();     \/\/ And remove the bad input\r\n\r\n        return true;\r\n    }\r\n    \r\n    return false;\r\n}\r\n\r\ndouble getDouble()\r\n{\r\n    while (true) \/\/ Loop until user enters a valid input\r\n    {\r\n        std::cout &lt;&lt; \"Enter a decimal number: \";\r\n        double x{};\r\n        std::cin &gt;&gt; x;\r\n\r\n        if (clearFailedExtraction())\r\n        {\r\n            std::cout &lt;&lt; \"Oops, that input is invalid.  Please try again.\\n\";\r\n            continue;\r\n        }\r\n\r\n        ignoreLine(); \/\/ Remove any extraneous input\r\n        return x;     \/\/ Return the value we extracted\r\n    }\r\n}\r\n\r\nchar getOperator()\r\n{\r\n    while (true) \/\/ Loop until user enters a valid input\r\n    {\r\n        std::cout &lt;&lt; \"Enter one of the following: +, -, *, or \/: \";\r\n        char operation{};\r\n        std::cin &gt;&gt; operation;\r\n\r\n        if (!clearFailedExtraction()) \/\/ we'll handle error messaging if extraction failed below\r\n             ignoreLine(); \/\/ remove any extraneous input (only if extraction succeded)\r\n\r\n        \/\/ Check whether the user entered meaningful input\r\n        switch (operation)\r\n        {\r\n        case '+':\r\n        case '-':\r\n        case '*':\r\n        case '\/':\r\n            return operation; \/\/ Return the entered char to the caller\r\n        default: \/\/ Otherwise tell the user what went wrong\r\n            std::cout &lt;&lt; \"Oops, that input is invalid.  Please try again.\\n\";\r\n        }\r\n    }\r\n}\r\n \r\nvoid printResult(double x, char operation, double y)\r\n{\r\n    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; operation &lt;&lt; ' ' &lt;&lt; y &lt;&lt; \" is \";\r\n\r\n    switch (operation)\r\n    {\r\n    case '+':\r\n        std::cout &lt;&lt; x + y &lt;&lt; '\\n';\r\n        return;\r\n    case '-':\r\n        std::cout &lt;&lt; x - y &lt;&lt; '\\n';\r\n        return;\r\n    case '*':\r\n        std::cout &lt;&lt; x * y &lt;&lt; '\\n';\r\n        return;\r\n    case '\/':\r\n        if (y == 0.0)\r\n            break;\r\n\r\n        std::cout &lt;&lt; x \/ y &lt;&lt; '\\n';\r\n        return;\r\n    }\r\n\r\n    std::cout &lt;&lt; \"???\";  \/\/ Being robust means handling unexpected parameters as well, even though getOperator() guarantees operation is valid in this particular program\r\n}\r\n \r\nint main()\r\n{\r\n    double x{ getDouble() };\r\n    char operation{ getOperator() };\r\n    double y{ getDouble() };\r\n\r\n    \/\/ Handle division by 0\r\n    while (operation == '\/' &amp;&amp; y == 0.0) \r\n    {\r\n        std::cout &lt;&lt; \"The denominator cannot be zero.  Try again.\\n\";\r\n        y = getDouble();\r\n    }\r\n \r\n    printResult(x, operation, y);\r\n \r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Conclusion<\/p>\n<p>As you write your programs, consider how users will misuse your program, especially around text input.  For each point of text input, consider:<\/p>\n<ul>\n<li>Could extraction fail?\n<\/li>\n<li>Could the user enter more input than expected?\n<\/li>\n<li>Could the user enter meaningless input?\n<\/li>\n<li>Could the user overflow an input?\n<\/li>\n<\/ul>\n<p>You can use if statements and boolean logic to test whether input is expected and meaningful.<\/p>\n<p>The following code will clear any extraneous input:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;limits&gt; \/\/ for std::numeric_limits\r\n\r\nvoid ignoreLine()\r\n{\r\n    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\r\n}<\/code><\/pre>\n<p>The following code will test for and fix failed extractions or overflow (and remove extraneous input):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ returns true if extraction failed, false otherwise\r\nbool clearFailedExtraction()\r\n{\r\n    \/\/ Check for failed extraction\r\n    if (!std::cin) \/\/ If the previous extraction failed\r\n    {\r\n        if (std::cin.eof()) \/\/ If the stream was closed\r\n        {\r\n            std::exit(0); \/\/ Shut down the program now\r\n        }\r\n\r\n        \/\/ Let's handle the failure\r\n        std::cin.clear(); \/\/ Put us back in 'normal' operation mode\r\n        ignoreLine();     \/\/ And remove the bad input\r\n\r\n        return true;\r\n    }\r\n    \r\n    return false;\r\n}<\/code><\/pre>\n<p>We can test to see if there is an unextracted input (other than a newline) as follows:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ returns true if std::cin has unextracted input on the current line, false otherwise\r\nbool hasUnextractedInput()\r\n{\r\n    return !std::cin.eof() &amp;&amp; std::cin.peek() != '\\n';\r\n}<\/code><\/pre>\n<p>Finally, use loops to ask the user to re-enter input if the original input was invalid.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>Input validation is important and useful, but it also tends to make examples more complicated and harder to follow.  Accordingly, in future lessons, we will generally not do any kind of input validation unless it&#8217;s relevant to something we&#8217;re trying to teach.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/assert-and-static_assert\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">9.6<\/span>Assert and static_assert\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/detecting-and-handling-errors\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">9.4<\/span>Detecting and handling errors\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Most programs that have a user interface of some kind need to handle user input. In the programs that you have been writing, you have been using std::cin to ask the user to enter text input. Because text input is so free-form (the user can enter anything), it&#8217;s very easy &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/3980"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=3980"}],"version-history":[{"count":108,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/3980\/revisions"}],"predecessor-version":[{"id":18146,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/3980\/revisions\/18146"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=3980"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=3980"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=3980"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}