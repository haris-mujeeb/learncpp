{"id":132,"date":"2007-09-11T08:50:47","date_gmt":"2007-09-11T16:50:47","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/89-class-code-and-header-files\/"},"modified":"2025-01-03T17:14:17","modified_gmt":"2025-01-04T01:14:17","slug":"classes-and-header-files","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/classes-and-header-files\/","title":{"rendered":"15.2 &#8212; Classes and header files"},"content":{"rendered":"<p>All of the classes that we have written so far have been simple enough that we have been able to implement the member functions directly inside the class definition itself.  For example, here&#8217;s a simple <code>Date<\/code> class where all member functions are defined inside the <code>Date<\/code> class definition:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Date\r\n{\r\nprivate:\r\n    int m_year{};\r\n    int m_month{};\r\n    int m_day{};\r\n \r\npublic:\r\n    Date(int year, int month, int day)\r\n        : m_year { year }\r\n        , m_month { month }\r\n        , m_day { day}\r\n    {\r\n    }\r\n\r\n    void print() const { std::cout &lt;&lt; \"Date(\" &lt;&lt; m_year &lt;&lt; \", \" &lt;&lt; m_month &lt;&lt; \", \" &lt;&lt; m_day &lt;&lt; \")\\n\"; }\r\n\r\n    int getYear() const { return m_year; }\r\n    int getMonth() const { return m_month; }\r\n    int getDay() const { return m_day; }\r\n};\r\n\r\nint main()\r\n{\r\n    Date d { 2015, 10, 14 };\r\n    d.print();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, as classes get longer and more complicated, having all the member function definitions inside the class can make the class harder to manage and work with.  Using an already-written class only requires understanding its public interface (the public member functions), not how the class works underneath the hood.  The member function implementations clutter up the public interface with details that aren&#8217;t relevant to actually using the class.<\/p>\n<p>To help address this, C++ allows us to separate the &#8220;declaration&#8221; portion of the class from the &#8220;implementation&#8221; portion by defining member functions outside of the class definition.<\/p>\n<p>Here is the same <code>Date<\/code> class as above, with the constructor and <code>print()<\/code> member functions defined outside the class definition.  Note that the prototypes for these member functions still exist inside the class definition (as these functions need to be declared as part of the class type definition), but the actual implementation has been moved outside:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Date\r\n{\r\nprivate:\r\n    int m_year{};\r\n    int m_month{};\r\n    int m_day{};\r\n\r\npublic:\r\n    Date(int year, int month, int day); \/\/ constructor declaration\r\n\r\n    void print() const; \/\/ print function declaration\r\n\r\n    int getYear() const { return m_year; }\r\n    int getMonth() const { return m_month; }\r\n    int getDay() const  { return m_day; }\r\n};\r\n\r\nDate::Date(int year, int month, int day) \/\/ constructor definition\r\n    : m_year{ year }\r\n    , m_month{ month }\r\n    , m_day{ day }\r\n{\r\n}\r\n\r\nvoid Date::print() const \/\/ print function definition\r\n{\r\n    std::cout &lt;&lt; \"Date(\" &lt;&lt; m_year &lt;&lt; \", \" &lt;&lt; m_month &lt;&lt; \", \" &lt;&lt; m_day &lt;&lt; \")\\n\";\r\n};\r\n\r\nint main()\r\n{\r\n    const Date d{ 2015, 10, 14 };\r\n    d.print();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Member functions can be defined outside the class definition just like non-member functions.  The only difference is that we must prefix the member function names with the name of the class type (in this case, <code>Date::<\/code>) so the compiler knows we&#8217;re defining a member of that class type rather than a non-member.<\/p>\n<p>Note that we left the access functions defined inside the class definition.  Because access functions are typically only one line, defining these functions inside the class definition adds minimal clutter, whereas moving them outside the class definition would result in many extra lines of code.  For this reason, the definitions of access functions (and other trivial, one-line functions) are often left inside the class definition.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Putting class definitions in a header file<\/p>\n<p>If you define a class inside a source (.cpp) file, that class is only usable within that particular source file.  In larger programs, it&#8217;s common that we&#8217;ll want to use the classes we write in multiple source files.<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/header-files\/\">2.11 -- Header files<\/a>, you learned that you can put function declarations in a header files.  Then you can #include those functions declarations into multiple code files (or even multiple projects).  Classes are no different.  A class definitions can be put in a header files, and then #included into any other files that want to use the class type.<\/p>\n<p>Unlike functions, which only need a forward declaration to be used, the compiler typically needs to see the full definition of a class (or any program-defined type) in order for the type to be used.  This is because the compiler needs to understand how members are declared in order to ensure they are used properly, and it needs to be able to calculate how large objects of that type are in order to instantiate them.  So our header files usually contain the full definition of a class rather than just a forward declaration of the class.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Naming your class header and code files<\/p>\n<p>Most often, classes are defined in header files of the same name as the class, and any member functions defined outside of the class are put in a .cpp file of the same name as the class.<\/p>\n<p>Here&#8217;s our Date class again, broken into a .cpp and .h file:<\/p>\n<p>Date.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef DATE_H\r\n#define DATE_H\r\n\r\nclass Date\r\n{\r\nprivate:\r\n    int m_year{};\r\n    int m_month{};\r\n    int m_day{};\r\n \r\npublic:\r\n    Date(int year, int month, int day);\r\n\r\n    void print() const;\r\n\r\n    int getYear() const { return m_year; }\r\n    int getMonth() const { return m_month; }\r\n    int getDay() const { return m_day; }\r\n};\r\n\r\n#endif<\/code><\/pre>\n<p>Date.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"Date.h\"\r\n\r\nDate::Date(int year, int month, int day) \/\/ constructor definition\r\n    : m_year{ year }\r\n    , m_month{ month }\r\n    , m_day{ day }\r\n{\r\n}\r\n\r\nvoid Date::print() const \/\/ print function definition\r\n{\r\n    std::cout &lt;&lt; \"Date(\" &lt;&lt; m_year &lt;&lt; \", \" &lt;&lt; m_month &lt;&lt; \", \" &lt;&lt; m_day &lt;&lt; \")\\n\";\r\n};<\/code><\/pre>\n<p>Now any other header or code file that wants to use the <code>Date<\/code> class can simply <code>#include \"Date.h\"<\/code>.  Note that <em>Date.cpp<\/em> also needs to be compiled into any project that uses <em>Date.h<\/em> so that the linker can connect calls to the member functions to their definitions.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Prefer to put your class definitions in a header file with the same name as the class.  Trivial member functions (such as access functions, constructors with empty bodies, etc&#8230;) can be defined inside the class definition.<\/p>\n<p>Prefer to define non-trivial member functions in a source file with the same name as the class.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Doesn&#8217;t defining a class in a header file violate the one-definition rule if the header is #included more than once?<\/p>\n<p>Types are exempt from the part of the one-definition rule (ODR) that says you can only have one definition per program.  Therefore, there isn&#8217;t an issue #including class definitions into multiple translation units.  If there was, classes wouldn&#8217;t be of much use.<\/p>\n<p>Including a class definition more than once into a single translation unit is still an ODR violation.   However, header guards (or <code>#pragma once<\/code>) will prevent this from happening.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Inline member functions<\/p>\n<p>Member functions are not exempt from the ODR, so you may be wondering how we avoid ODR violations when member functions are defined in a header file (that may then be included into more than one translation unit).<\/p>\n<p>Member functions defined <em>inside<\/em> the class definition are implicitly inline.  Inline functions are exempt from the one definition per program part of the one-definition rule.<\/p>\n<p>Member functions defined <em>outside<\/em> the class definition are not implicitly inline (and thus are subject to the one definition per program part of the one-definition rule).  This is why such functions are usually defined in a code file (where they will only have one definition across the whole program).<\/p>\n<p>Alternatively, member functions defined outside the class definition can be left in the header file if they are made inline (using the <code>inline<\/code> keyword).  Here&#8217;s our <em>Date.h<\/em> header again, with the member functions defined outside the class marked as <code>inline<\/code>:<\/p>\n<p>Date.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef DATE_H\r\n#define DATE_H\r\n\r\n#include &lt;iostream&gt;\r\n\r\nclass Date\r\n{\r\nprivate:\r\n    int m_year{};\r\n    int m_month{};\r\n    int m_day{};\r\n \r\npublic:\r\n    Date(int year, int month, int day);\r\n\r\n    void print() const;\r\n\r\n    int getYear() const { return m_year; }\r\n    int getMonth() const { return m_month; }\r\n    int getDay() const { return m_day; }\r\n};\r\n\r\ninline Date::Date(int year, int month, int day) \/\/ now inline\r\n    : m_year{ year }\r\n    , m_month{ month }\r\n    , m_day{ day }\r\n{\r\n}\r\n\r\ninline void Date::print() const \/\/ now inline\r\n{\r\n    std::cout &lt;&lt; \"Date(\" &lt;&lt; m_year &lt;&lt; \", \" &lt;&lt; m_month &lt;&lt; \", \" &lt;&lt; m_day &lt;&lt; \")\\n\";\r\n};\r\n\r\n#endif<\/code><\/pre>\n<p>This <em>Date.h<\/em> can be included into multiple translation units without issue.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Functions defined inside the class definition are implicitly inline, which allows them to be #included into multiple code files without violating the ODR.<\/p>\n<p>Functions defined outside the class definition are not implicitly inline.  They can be made inline by using the <code>inline<\/code> keyword.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Inline expansion of member functions<\/p>\n<p>The compiler must be able to see a full definition of a function in order to perform inline expansion.  Most often, such functions (e.g. access functions) are defined inside the class definition.  However, if you want to define a member function outside the class definition, but still want it to be eligible for inline expansion, you can define it as an inline function just below the class definition (in the same header file).  That way the definition of the function is accessible to anybody who #includes the header.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">So why not put everything in a header file?<\/p>\n<p>You might be tempted to put all of your member function definitions into the header file, either inside the class definition, or as inline functions below the class definition.  While this will compile, there are a couple of downsides to doing so.<\/p>\n<p>First, as mentioned above, defining members inside the class definition clutters up your class definition.<\/p>\n<p>Second, if you change any of the code in the header, then you&#8217;ll need to recompile every file that includes that header.  This can have a ripple effect, where one minor change causes the entire program to need to recompile.  The cost of recompilation can vary significantly: a small project may only take a minute or less to build, whereas a large commercial project can take hours.<\/p>\n<p>Conversely, if you change the code in a .cpp file, only that .cpp file needs to be recompiled.  Therefore, given the choice, it&#8217;s generally better to put non-trivial code in a .cpp file when you can.<\/p>\n<p>There are a few cases where it might make sense to violate the best practice of putting the class definition in a header and non-trivial member functions in a code file.<\/p>\n<p>First, for a small class that is used in only one code file and not intended for general reuse, you may prefer to define the class (and all member functions) directly in the single .cpp file it is used in.  This helps make it clear that the class is only used within that single file, and is not intended for wider use.  You can always move the class to a separate header\/code file later if you later find you want to use it in more than one file, or are finding that the class and member function definitions are cluttering your source file.<\/p>\n<p>Second, if a class only has a small number of non-trivial member functions that are unlikely to change, creating a .cpp file that contains only one or two definitions may not be worth the effort (as it clutters your project).  In such cases, it may be preferable to make the member functions <code>inline<\/code> and place them beneath the class definition in the header.<\/p>\n<p>Third, in modern C++, classes or libraries are increasingly being distributed as &#8220;header-only&#8221;, meaning all of the code for the class or library is placed in a header file.  This is done primarily to make distributing and using such files easier, as a header only needs to be #included, whereas a code file needs to be explicitly added to every project that uses it, so that it can be compiled.  If intentionally creating a header-only class or library for distribution, all non-trivial member functions can be made <code>inline<\/code> and placed in the header file beneath the class definition.<\/p>\n<p>Finally, for template classes, template member functions defined outside the class are almost always defined inside the header file, beneath the class definition.  Just like non-member template functions, the compiler needs to see the full template definition in order to instantiate it.  We cover template member functions in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-templates-with-member-functions\/\">15.5 -- Class templates with member functions<\/a>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>In future lessons, most of our classes will be defined in a single .cpp file, with all the functions implemented directly in the class definition.  This is done to keep the examples concise and easy to compile yourself.  In real projects, it is much more common for classes to be put in their own code and header files, and you should get used to doing so.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Default arguments for member functions<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/default-arguments\/\">11.5 -- Default arguments<\/a>, we discussed the best practice for default arguments of non-member functions: &#8220;If the function has a forward declaration (especially one in a header file), put the default argument there. Otherwise, put the default argument in the function definition.&#8221;<\/p>\n<p>Because member functions are always declared (or defined) as part of the class definition, the best practice for member functions is actually simpler: always put the default argument inside the class definition.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Put any default arguments for member functions inside the class definition.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Libraries<\/p>\n<p>Throughout your programs, you&#8217;ve used classes that are part of the standard library, such as <code>std::string<\/code>.  To use these classes, you simply need to #include the relevant header (such as <code>#include &lt;string&gt;<\/code>).  Note that you haven&#8217;t needed to add any code files (such as <code>string.cpp<\/code> or <code>iostream.cpp<\/code>) into your projects.  <\/p>\n<p>The header files provide the declarations that the compiler requires in order to validate that the programs you&#8217;re writing are syntactically correct.  However, the implementations for the classes that belong to the C++ standard library are contained in a precompiled file that is linked in automatically at the link stage.  You never see the code.<\/p>\n<p>Many open source software packages provide both .h and .cpp files for you to compile into your program.  However, most commercial libraries provide only .h files and a precompiled library file.  There are several reasons for this: 1) It&#8217;s faster to link a precompiled library than to recompile it every time you need it, 2) A single copy of a precompiled library can be shared by many applications, whereas compiled code gets compiled into every executable that uses it (inflating file sizes), and 3) Intellectual property reasons (you don&#8217;t want people stealing your code).<\/p>\n<p>We discuss how to include 3rd party precompiled libraries into your projects in the appendix.<\/p>\n<p>While you probably won&#8217;t be creating and distributing your own libraries for a while, separating your classes into header files and source files is not only good form, it also makes creating your own custom libraries easier.  Creating your own libraries is beyond the scope of these tutorials, but separating your declaration and implementation is a prerequisite to doing so if you want to distribute precompiled binaries.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>h\/t to reader &#8220;learnccp lesson reviewer&#8221; for these quiz questions.<\/p>\n<p>What is the purpose of defining member functions outside the class definition?<br \/>\na) To make the class definition shorter and easier to manage.<br \/>\nb) To separate the public interface from the implementation details.<br \/>\nc) When defined in a source file, to minimize recompilation times when an implementation detail changes.<br \/>\nd) All of the above.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\nd) All of the above.<\/div>\n<p>How do you define a member function outside the class definition?<br \/>\na) Simply define the function as a normal function without any class prefix.<br \/>\nb) Define the function with the class name prefixed using the scope resolution operator (::).<br \/>\nc) Declare the function inside the class definition and define it outside using the friend keyword.<br \/>\nd) None of the above.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\nb) Define the function with the class name prefixed using the scope resolution operator (::).<\/div>\n<p>When should trivial member functions be defined inside the class definition?<br \/>\na) Always, to improve performance.<br \/>\nb) When the functions have a single line of code.<br \/>\nc) When the functions are called frequently.<br \/>\nd) It is not recommended to define any member functions inside the class definition.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\nb) When the functions have a single line of code.<\/div>\n<p>Where should the class definition be placed to facilitate reuse in multiple files or projects?<br \/>\na) In a .cpp file with the same name as the class.<br \/>\nb) In a separate header file with the same name as the class.<br \/>\nc) In a .cpp file that includes the header file.<br \/>\nd) Anywhere in the code, as long as the functions are defined outside the class.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\nb) In a separate header file with the same name as the class.<\/div>\n<p>Which of the following is true about the one-definition rule for classes and member functions?<br \/>\na) It prohibits defining a class in a header file.<br \/>\nb) It allows including the class definition multiple times in the same file.<br \/>\nc) Member functions defined inside the class definition are exempt from the one-definition rule.<br \/>\nd) Non-trivial member functions should always be defined in the header file.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\nc). Member functions defined inside the class definition are implicitly inline, and thus exempt from the one-definition rule.<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/nested-types-member-types\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">15.3<\/span>Nested types (member types)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/the-hidden-this-pointer-and-member-function-chaining\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">15.1<\/span>The hidden &#8220;this&#8221; pointer and member function chaining\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>All of the classes that we have written so far have been simple enough that we have been able to implement the member functions directly inside the class definition itself. For example, here&#8217;s a simple Date class where all member functions are defined inside the Date class definition: #include &lt;iostream&gt; &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/132"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=132"}],"version-history":[{"count":39,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/132\/revisions"}],"predecessor-version":[{"id":18079,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/132\/revisions\/18079"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=132"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=132"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=132"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}