{"id":262,"date":"2009-09-05T15:00:09","date_gmt":"2009-09-05T23:00:09","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=262"},"modified":"2025-01-06T15:35:29","modified_gmt":"2025-01-06T23:35:29","slug":"how-to-design-your-first-programs","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/how-to-design-your-first-programs\/","title":{"rendered":"2.13 &#8212; How to design your first programs"},"content":{"rendered":"<p>Now that you&#8217;ve learned some basics about programs, let&#8217;s look more closely at <em>how<\/em> to design a program.  <\/p>\n<p>When you sit down to write a program, generally you have some kind of idea, which you&#8217;d like to write a program for.  New programmers often have trouble figuring out how to convert that idea into actual code.  But it turns out, you have many of the problem solving skills you need already, acquired from everyday life.<\/p>\n<p>The most important thing to remember (and hardest thing to do) is to design your program <i>before you start coding<\/i>.  In many regards, programming is like architecture.  What would happen if you tried to build a house without following an architectural plan?  Odds are, unless you were very talented, you&#8217;d end up with a house that had a lot of problems: walls that weren&#8217;t straight, a leaky roof, etc&#8230;  Similarly, if you try to program before you have a good game-plan moving forward, you&#8217;ll likely find that your code has a lot of problems, and you&#8217;ll have to spend a lot of time fixing problems that could have been avoided altogether with a little thinking ahead.<\/p>\n<p>A little up-front planning will save you both time and frustration in the long run.<\/p>\n<p>In this lesson, we&#8217;ll lay out a generalized approach for converting ideas into simple functional programs.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Design step 1: Define your goal<\/p>\n<p>In order to write a successful program, you first need to define what your goal is.  Ideally, you should be able to state this in a sentence or two.  It is often useful to express this as a user-facing outcome.  For example:<\/p>\n<ul>\n<li>Allow the user to organize a list of names and associated phone numbers.<\/li>\n<li>Generate randomized dungeons that will produce interesting looking caverns.<\/li>\n<li>Generate a list of stock recommendations for stocks that have high dividends.<\/li>\n<li>Model how long it takes for a ball dropped off a tower to hit the ground.<\/li>\n<\/ul>\n<p>Although this step seems obvious, it&#8217;s also highly important.  The worst thing you can do is write a program that doesn&#8217;t actually do what you (or your boss) wanted!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Design step 2: Define requirements<\/p>\n<p>While defining your problem helps you determine <em>what<\/em> outcome you want, it&#8217;s still vague.  The next step is to think about requirements.<\/p>\n<p>Requirements is a fancy word for both the constraints that your solution needs to abide by (e.g. budget, timeline, space, memory, etc&#8230;), as well as the capabilities that the program must exhibit in order to meet the users&#8217; needs.  Note that your requirements should similarly be focused on the &#8220;what&#8221;, not the &#8220;how&#8221;.<\/p>\n<p>For example:<\/p>\n<ul>\n<li>Phone numbers should be saved, so they can be recalled later.<\/li>\n<li>The randomized dungeon should always contain a way to get from the entrance to an exit.<\/li>\n<li>The stock recommendations should leverage historical pricing data.<\/li>\n<li>The user should be able to enter the height of the tower.<\/li>\n<li>We need a testable version within 7 days.<\/li>\n<li>The program should produce results within 10 seconds of the user submitting their request.<\/li>\n<li>The program should crash in less than 0.1% of user sessions.<\/li>\n<\/ul>\n<p>A single problem may yield many requirements, and the solution isn&#8217;t &#8220;done&#8221; until it satisfies all of them.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Design step 3: Define your tools, targets, and backup plan<\/p>\n<p>When you are an experienced programmer, there are many other steps that typically would take place at this point, including:<\/p>\n<ul>\n<li>Defining what target architecture and\/or OS your program will run on.<\/li>\n<li>Determining what set of tools you will be using.<\/li>\n<li>Determining whether you will write your program alone or as part of a team.<\/li>\n<li>Defining your testing\/feedback\/release strategy.<\/li>\n<li>Determining how you will back up your code.<\/li>\n<\/ul>\n<p>However, as a new programmer, the answers to these questions are typically simple: You are writing a program for your own use, alone, on your own system, using an IDE you downloaded, and your code is probably not used by anybody but you.  This makes things easy.<\/p>\n<p>That said, if you are going to work on anything of non-trivial complexity, you should have a plan to backup your code.  It&#8217;s not enough to zip or copy your source directory to another location on the same storage device -- if your storage device dies or becomes corrupted, you&#8217;ll lose everything.  Copying or zipping to removable storage (e.g. a flash drive) is better, though you still risk losing everything in the event of theft, fire, or a significant natural disaster.<\/p>\n<p>The best backup strategy involves getting a copy of your code onto a machine that exists in a different physical location.  There are lots of easy ways to do this: Zip it up and email it to yourself, upload it to a cloud storage service (e.g. Dropbox), use a file transfer protocol (e.g. SFTP) to upload it to a server you control, or use a version control system residing on another machine or in the cloud (e.g. github).  Version control systems have the added advantage of not only being able to restore your files, but also to roll them back to a previous version.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Design step 4: Break hard problems down into easy problems<\/p>\n<p>In real life, we often need to perform tasks that are very complex.  Trying to figure out how to do these tasks can be very challenging.  In such cases, we often make use of the <strong>top down<\/strong> method of problem solving.  That is, instead of solving a single complex task, we break that task into multiple subtasks, each of which is individually easier to solve.  If those subtasks are still too difficult to solve, they can be broken down further.  By continuously splitting complex tasks into simpler ones, you can eventually get to a point where each individual task is manageable, if not trivial.<\/p>\n<p>Let&#8217;s take a look at an example of this.  Let&#8217;s say we want to clean our house.  Our task hierarchy currently looks like this:<\/p>\n<ul>\n<li>Clean the house<\/li>\n<\/ul>\n<p>Cleaning the entire house is a pretty big task to do in one sitting, so let&#8217;s break it into subtasks:<\/p>\n<ul>\n<li>Clean the house<\/li>\n<ul>\n<li>Vacuum the carpets<\/li>\n<li>Clean the bathrooms<\/li>\n<li>Clean the kitchen<\/li>\n<\/ul>\n<\/ul>\n<p>That&#8217;s more manageable, as we now have subtasks that we can focus on individually.  However, we can break some of these down even further:<\/p>\n<ul>\n<li>Clean the house<\/li>\n<ul>\n<li>Vacuum the carpets<\/li>\n<li>Clean the bathrooms<\/li>\n<ul>\n<li>Scrub the toilet (yuck!)<\/li>\n<li>Wash the sink<\/li>\n<\/ul>\n<li>Clean the kitchen<\/li>\n<ul>\n<li>Clear the countertops<\/li>\n<li>Clean the countertops<\/li>\n<li>Scrub the sink<\/li>\n<li>Take out the trash<\/li>\n<\/ul>\n<\/ul>\n<\/ul>\n<p>Now we have a hierarchy of tasks, none of them particularly hard.  By completing each of these relatively manageable sub-items, we can complete the more difficult overall task of cleaning the house.<\/p>\n<p>The other way to create a hierarchy of tasks is to do so from the <strong>bottom up<\/strong>.  In this method, we&#8217;ll start from a list of easy tasks, and construct the hierarchy by grouping them.<\/p>\n<p>As an example, many people have to go to work or school on weekdays, so let&#8217;s say we want to solve the problem of &#8220;go to work&#8221;.  If you were asked what tasks you did in the morning to get from bed to work, you might come up with the following list:<\/p>\n<ul>\n<li>Pick out clothes<\/li>\n<li>Get dressed<\/li>\n<li>Eat breakfast<\/li>\n<li>Travel to work<\/li>\n<li>Brush your teeth<\/li>\n<li>Get out of bed<\/li>\n<li>Prepare breakfast<\/li>\n<li>Get on your bicycle<\/li>\n<li>Take a shower<\/li>\n<\/ul>\n<p>Using the bottom up method, we can organize these into a hierarchy of items by looking for ways to group items with similarities together:<\/p>\n<ul>\n<li>Get from bed to work<\/li>\n<ul>\n<li>Bedroom things<\/li>\n<ul>\n<li>Turn off alarm<\/li>\n<li>Get out of bed<\/li>\n<li>Pick out clothes<\/li>\n<\/ul>\n<li>Bathroom things<\/li>\n<ul>\n<li>Take a shower<\/li>\n<li>Get dressed<\/li>\n<li>Brush your teeth<\/li>\n<\/ul>\n<li>Breakfast things<\/li>\n<ul>\n<li>Make coffee or tea<\/li>\n<li>Eat cereal<\/li>\n<\/ul>\n<li>Transportation things<\/li>\n<ul>\n<li>Get on your bicycle<\/li>\n<li>Travel to work<\/li>\n<\/ul>\n<\/ul>\n<\/ul>\n<p>As it turns out, these task hierarchies are extremely useful in programming, because once you have a task hierarchy, you have essentially defined the structure of your overall program.  The top level task (in this case, &#8220;Clean the house&#8221; or &#8220;Go to work&#8221;) becomes main() (because it is the main problem you are trying to solve).  The subitems become functions in the program.<\/p>\n<p>If it turns out that one of the items (functions) is too difficult to implement, simply split that item into multiple sub-items\/sub-functions.  Eventually you should reach a point where each function in your program is trivial to implement.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Design step 5: Figure out the sequence of events<\/p>\n<p>Now that your program has a structure, it&#8217;s time to determine how to link all the tasks together.  The first step is to determine the sequence of events that will be performed.  For example, when you get up in the morning, what order do you do the above tasks?  It might look like this:<\/p>\n<ul>\n<li>Bedroom things<\/li>\n<li>Bathroom things<\/li>\n<li>Breakfast things<\/li>\n<li>Transportation things<\/li>\n<\/ul>\n<p>If we were writing a calculator, we might do things in this order:<\/p>\n<ul>\n<li>Get first number from user<\/li>\n<li>Get mathematical operation from user<\/li>\n<li>Get second number from user<\/li>\n<li>Calculate result<\/li>\n<li>Print result<\/li>\n<\/ul>\n<p>At this point, we&#8217;re ready for implementation.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Implementation step 1: Outlining your main function<\/p>\n<p>Now we&#8217;re ready to start implementation.  The above sequences can be used to outline your main program.  Don&#8217;t worry about inputs and outputs for the time being.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n\/\/    doBedroomThings();\r\n\/\/    doBathroomThings();\r\n\/\/    doBreakfastThings();\r\n\/\/    doTransportationThings();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Or in the case of the calculator:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    \/\/ Get first number from user\r\n\/\/    getUserInput();\r\n\r\n    \/\/ Get mathematical operation from user\r\n\/\/    getMathematicalOperation();\r\n\r\n    \/\/ Get second number from user\r\n\/\/    getUserInput();\r\n\r\n    \/\/ Calculate result\r\n\/\/    calculateResult();\r\n\r\n    \/\/ Print result\r\n\/\/    printResult();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Note that if you&#8217;re going to use this &#8220;outline&#8221; method for constructing your programs, your functions won&#8217;t compile because the definitions don&#8217;t exist yet.  Commenting out the function calls until you&#8217;re ready to implement the function definitions is one way to address this (and the way we&#8217;ll show here).  Alternatively, you can <em>stub out<\/em> your functions (create placeholder functions with empty bodies) so your program will compile.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Implementation step 2: Implement each function<\/p>\n<p>In this step, for each function, you&#8217;ll do three things:<\/p>\n<ol>\n<li>Define the function prototype (inputs and outputs)<\/li>\n<li>Write the function<\/li>\n<li>Test the function<\/li>\n<\/ol>\n<p>If your functions are granular enough, each function should be fairly simple and straightforward.  If a given function still seems overly-complex to implement, perhaps it needs to be broken down into subfunctions that can be more easily implemented (or it&#8217;s possible you did something in the wrong order, and need to revisit your sequencing of events).<\/p>\n<p>Let&#8217;s do the first function from the calculator example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ Full implementation of the getUserInput function\r\nint getUserInput()\r\n{\r\n    std::cout &lt;&lt; \"Enter an integer: \";\r\n    int input{};\r\n    std::cin &gt;&gt; input;\r\n\r\n    return input;\r\n}\r\n\r\nint main()\r\n{\r\n    \/\/ Get first number from user\r\n    int value{ getUserInput() }; \/\/ Note we've included code here to test the return value!\r\n    std::cout &lt;&lt; value &lt;&lt; '\\n'; \/\/ debug code to ensure getUserInput() is working, we'll remove this later\r\n\r\n    \/\/ Get mathematical operation from user\r\n\/\/    getMathematicalOperation();\r\n\r\n    \/\/ Get second number from user\r\n\/\/    getUserInput();\r\n\r\n    \/\/ Calculate result\r\n\/\/    calculateResult();\r\n\r\n    \/\/ Print result\r\n\/\/    printResult();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>First, we&#8217;ve determined that the <em>getUserInput<\/em> function takes no arguments, and will return an int value back to the caller.  That gets reflected in the function prototype having a return value of int and no parameters.  Next, we&#8217;ve written the body of the function, which is a straightforward 4 statements.  Finally, we&#8217;ve implemented some temporary code in function <em>main<\/em> to test that function <em>getUserInput<\/em> (including its return value) is working correctly.<\/p>\n<p>We can run this program many times with different input values and make sure that the program is behaving as we expect at this point.  If we find something that doesn&#8217;t work, we know the problem is in the code we&#8217;ve just written.<\/p>\n<p>Once we&#8217;re convinced the program is working as intended up to this point, we can remove the temporary testing code, and proceed to implementation of the next function (function <em>getMathematicalOperation<\/em>).  We won&#8217;t finish the program in this lesson, as we need to cover some additional topics first.<\/p>\n<p>Remember: Don&#8217;t implement your entire program in one go.  Work on it in steps, testing each step along the way before proceeding.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover testing in more detail in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-testing-your-code\/\">9.1 -- Introduction to testing your code<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Implementation step 3: Final testing<\/p>\n<p>Once your program is &#8220;finished&#8221;, the last step is to test the whole program and ensure it works as intended.  If it doesn&#8217;t work, fix it.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Words of advice when writing programs<\/p>\n<p><strong>Keep your programs simple to start<\/strong>.  Often new programmers have a grand vision for all the things they want their program to do.  &#8220;I want to write a role-playing game with graphics and sound and random monsters and dungeons, with a town you can visit to sell the items that you find in the dungeon&#8221;.  If you try to write something too complex to start, you will become overwhelmed and discouraged at your lack of progress.   Instead, make your first goal as simple as possible, something that is definitely within your reach.  For example, &#8220;I want to be able to display a 2-dimensional field on the screen&#8221;.<\/p>\n<p><strong>Add features over time<\/strong>.  Once you have your simple program working and working well, then you can add features to it.  For example, once you can display your field, add a character who can walk around.  Once you can walk around, add walls that can impede your progress.  Once you have walls, build a simple town out of them.  Once you have a town, add merchants.  By adding each feature incrementally your program will get progressively more complex without overwhelming you in the process.<\/p>\n<p><strong>Focus on one area at a time<\/strong>.  Don&#8217;t try to code everything at once, and don&#8217;t divide your attention across multiple tasks.  Focus on one task at a time.  It is much better to have one working task and five that haven&#8217;t been started yet than six partially-working tasks.  If you split your attention, you are more likely to make mistakes and forget important details.<\/p>\n<p><strong>Test each piece of code as you go<\/strong>.  New programmers will often write the entire program in one pass.  Then when they compile it for the first time, the compiler reports hundreds of errors.  This can not only be intimidating, if your code doesn&#8217;t work, it may be hard to figure out why.  Instead, write a piece of code, and then compile and test it immediately.  If it doesn&#8217;t work, you&#8217;ll know exactly where the problem is, and it will be easy to fix.  Once you are sure that the code works, move to the next piece and repeat.  It may take longer to finish writing your code, but when you are done the whole thing should work, and you won&#8217;t have to spend twice as long trying to figure out why it doesn&#8217;t.<\/p>\n<p><strong>Don&#8217;t invest in perfecting early code<\/strong>.  The first draft of a feature (or program) is rarely good.  Furthermore, programs tend to evolve over time, as you add capabilities and find better ways to structure things.  If you invest too early in polishing your code (adding lots of documentation, full compliance with best practices, making optimizations), you risk losing all of that investment when a code change is necessary.  Instead, get your features minimally working and then move on.  As you gain confidence in your solutions, apply successive layers of polish.  Don&#8217;t aim for perfect -- non-trivial programs are never perfect, and there&#8217;s always something more that could be done to improve them.  Get to &#8220;good enough&#8221; and move on.<\/p>\n<p><strong>Optimize for maintainability, not performance<\/strong>.  There is a famous quote (by Donald Knuth) that says &#8220;premature optimization is the root of all evil&#8221;.  New programmers often spend far too much time thinking about how to micro-optimize their code (e.g. trying to figure out which of 2 statements is faster).  This rarely matters.  Most performance benefits come from good program structure, using the right tools and capabilities for the problem at hand, and following best practices.  Additional time should be used to improve the maintainability of your code.  Find redundancy and remove it.  Split up long functions into shorter ones.  Replace awkward or hard to use code with something better.  The end result will be code that is easier to improve and optimize later (after you&#8217;ve determined where optimization is actually needed) and fewer bugs.  We offer some additional suggestions in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/finding-issues-before-they-become-problems\/\">3.10 -- Finding issues before they become problems<\/a>.<\/p>\n<blockquote><p>A complex system that works is invariably found to have evolved from a simple system that worked<\/p>\n<footer>\u2014John Gall, <cite>Systemantics: How Systems Really Work and How They Fail p. 71<\/cite><\/footer>\n<\/blockquote>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Conclusion<\/p>\n<p>Many new programmers shortcut the design process (because it seems like a lot of work and\/or it&#8217;s not as much fun as writing the code).  However, for any non-trivial project, following these steps will save you a lot of time in the long run.  A little planning up front saves a lot of debugging at the end.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Spending a little time up front thinking about how to structure your program will lead to better code and less time spent finding and fixing errors.<\/p>\n<blockquote><p>I would say this is arguably the most important thing in programming and some of us, like me at first, took it for granted.<\/p>\n<footer>\u2014Reader Emeka Daniel, <cite>comment on learncpp.com<\/cite><\/footer>\n<\/blockquote>\n<\/div>\n<p>As you become more comfortable with these concepts and tips, they will start coming more naturally to you.  Eventually you will get to the point where you can write entire functions (and short programs) with minimal pre-planning.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-2-summary-and-quiz\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">2.x<\/span>Chapter 2 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/header-guards\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">2.12<\/span>Header guards\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Now that you&#8217;ve learned some basics about programs, let&#8217;s look more closely at how to design a program. When you sit down to write a program, generally you have some kind of idea, which you&#8217;d like to write a program for. New programmers often have trouble figuring out how to &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/262"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=262"}],"version-history":[{"count":55,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/262\/revisions"}],"predecessor-version":[{"id":18092,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/262\/revisions\/18092"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=262"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=262"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=262"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}