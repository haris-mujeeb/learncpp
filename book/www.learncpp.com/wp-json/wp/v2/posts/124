{"id":124,"date":"2007-08-23T10:54:40","date_gmt":"2007-08-23T18:54:40","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/81-welcome-to-object-oriented-programming\/"},"modified":"2023-09-15T12:13:04","modified_gmt":"2023-09-15T19:13:04","slug":"introduction-to-object-oriented-programming","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-object-oriented-programming\/","title":{"rendered":"14.1 &#8212; Introduction to object-oriented programming"},"content":{"rendered":"<p class=\"cpp-section\">Procedural programming<\/p>\n<p>Back in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-objects-and-variables\/\">1.3 -- Introduction to objects and variables<\/a>, we defined an object in C++ as, &#8220;a piece of memory that can be used to store values&#8221;.  An object with a name is called a variable.  Our C++ programs have consisted of sequential lists of instructions to the computer that define data (via objects) and operations performed on that data (via functions containing statements and expressions).<\/p>\n<p>Up to now, we&#8217;ve been doing a type of programming called procedural programming.  In <strong>procedural programming<\/strong>, the focus is on creating &#8220;procedures&#8221; (which in C++ are called functions) that implement our program logic.  We pass data objects to these functions, those functions perform operations on the data, and then potentially return a result to be used by the caller.<\/p>\n<p>In procedural programming, the functions and the data those functions operate on are separate entities.  The programmer is responsible for combining the functions and the data together to produce the desired result.  This leads to code that looks like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">eat(you, apple);<\/code><\/pre>\n<p>Now, take a look around you -- everywhere you look are objects: books and buildings and food and even you.  Such objects have two major components to them: 1) Some number of associated properties (e.g. weight, color, size, solidity, shape, etc&#8230;), and 2) Some number of behaviors that they can exhibit (e.g. being opened, making something else hot, etc&#8230;).  These properties and behaviors are inseparable.<\/p>\n<p>In programming, properties are represented by objects, and behaviors are represented by functions.  And thus, procedural programming represents reality fairly poorly, as it separates properties (objects) and behaviors (functions).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">What is object-oriented programming?<\/p>\n<p>In <strong>object-oriented programming<\/strong> (often abbreviated as OOP), the focus is on creating program-defined data types that contain both properties and a set of well-defined behaviors.  The term &#8220;object&#8221; in OOP refers to the objects that we can instantiate from such types.<\/p>\n<p>This leads to code that looks more like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">you.eat(apple);<\/code><\/pre>\n<p>This makes it clearer who the subject is (<code>you<\/code>), what behavior is being invoked (<code>eat()<\/code>), and what objects are accessories to that behavior (<code>apple<\/code>).<\/p>\n<p>Because the properties and behaviors are no longer separate, objects are easier to modularize, which makes our programs easier to write and understand, and also provides a higher degree of code reusability.  These objects also provide a more intuitive way to work with our data by allowing us to define how we interact with the objects, and how they interact with other objects.<\/p>\n<p>We&#8217;ll discuss how to create such objects in the next lesson.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A procedural vs OOP-like example<\/p>\n<p>Here&#8217;s a short program written in a procedural programming style that prints the name and number of legs of an animal:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nenum AnimalType\r\n{\r\n    cat,\r\n    dog,\r\n    chicken,\r\n};\r\n\r\nconstexpr std::string_view animalName(AnimalType type)\r\n{\r\n    switch (type)\r\n    {\r\n    case cat: return \"cat\";\r\n    case dog: return \"dog\";\r\n    case chicken: return \"chicken\";\r\n    default:  return \"\";\r\n    }\r\n}\r\n\r\nconstexpr int numLegs(AnimalType type)\r\n{\r\n    switch (type)\r\n    {\r\n    case cat: return 4;\r\n    case dog: return 4;\r\n    case chicken: return 2;\r\n    default:  return 0;\r\n    }\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    constexpr AnimalType animal{ cat };\r\n    std::cout &lt;&lt; \"A \" &lt;&lt; animalName(animal) &lt;&lt; \" has \" &lt;&lt; numLegs(animal) &lt;&lt; \" legs\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this program, we have written functions that do allow us to do things like get the number of legs an animal has, and get the name of an animal.<\/p>\n<p>While this works just fine, consider what happens when we want to update this program so that our animal is now a <code>snake<\/code>.  To add a snake to our code, we&#8217;d need to modify <code>AnimalType<\/code>, <code>numLegs()<\/code>, <code>animalName()<\/code>.  If this were a larger codebase, we&#8217;d also need to update any other function that uses <code>AnimalType<\/code> -- if <code>AnimalType<\/code> was used in a lot of places, that could be a lot of code that needs to get touched (and potentially broken).<\/p>\n<p>Now let&#8217;s write that same program (producing the same output) using more of an OOP mindset:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nstruct Cat\r\n{\r\n    std::string_view name{ \"cat\" };\r\n    int numLegs{ 4 };\r\n};\r\n\r\nstruct Dog\r\n{\r\n    std::string_view name{ \"dog\" };\r\n    int numLegs{ 4 };\r\n};\r\n\r\nstruct Chicken\r\n{\r\n    std::string_view name{ \"chicken\" };\r\n    int numLegs{ 2 };\r\n};\r\n\r\nint main()\r\n{\r\n    constexpr Cat animal;\r\n    std::cout &lt;&lt; \"a \" &lt;&lt; animal.name &lt;&lt; \" has \" &lt;&lt; animal.numLegs &lt;&lt; \" legs\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this example, each animal is its own program-defined type, and that type manages everything related to that animal (which in this case, is just keeping track of the name and number of legs).<\/p>\n<p>Now consider the case where we want to update our animal to a snake.  All we have to do is create a <code>Snake<\/code> type and use it instead of <code>Cat<\/code>.  Very little existing code needs to be changed, which means much less risk of breaking something that already works.<\/p>\n<p>As presented, our <code>Cat<\/code>, <code>Dog<\/code>, and <code>Chicken<\/code> example above has a lot of repetition (as each defines the exact same set of members).  In such a case, creating a common <code>Animal<\/code> struct and creating an instance for each animal might be preferable.  But what if we want to add a new member to <code>Chicken<\/code> that&#8217;s not applicable to the other animals (e.g. <code>wormsPerDay<\/code>)?  With a common <code>Animal<\/code> struct, all animals will get that member.  With our OOP model, we can restrict that member to <code>Chicken<\/code> objects.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">OOP brings other benefits to the table<\/p>\n<p>In school, when you submit your programming assignments, your work is essentially done.  Your professor or teacher&#8217;s assistant will run your code to see if it produces the correct result.  It either does or doesn&#8217;t, and you are graded accordingly.  Your code is likely discarded at that point.<\/p>\n<p>On the other hand, when you submit your code into a repository that is used by other developers, or into an application that&#8217;s used by real users, it&#8217;s an entirely different ballgame.  Some new OS or software release will break your code.  Users will find some logic error you made.  A business partner will demand some new capability.  Other developers will need to extend your code without breaking it.  Your code needs to be able to evolve, perhaps significantly, and it needs to be able to do so with minimal time investment, minimal headaches, and minimal breakage.<\/p>\n<p>The best way to address these is by keeping your code as modular (and non-redundant) as possible.  To assist with this, OOP also brings a number of other useful concepts to the table: inheritance, encapsulation, abstraction, and polymorphism.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>Language designers have a philosophy: never use a small word where a big one will do.<\/p>\n<p>Also why is the word abbreviation so long?\n<\/p><\/div>\n<p>We&#8217;ll cover what all of these are in due time, and how they can assist in making your code less redundant, and easier to modify and extend.  Once you&#8217;ve been properly familiarized with OOP and it clicks, you will likely never want to go back to pure procedural programming again.<\/p>\n<p>That said, OOP doesn&#8217;t replace procedural programming -- rather, it gives you additional tools in your programming tool belt to manage complexity when needed.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The term &#8220;object&#8221;<\/p>\n<p>Note that the term &#8220;object&#8221; is overloaded a bit, and this causes some amount of confusion.  In traditional programming, an object is a piece of memory to store values.  And that&#8217;s it.  In object-oriented programming, an &#8220;object&#8221; implies that it is both an object in the traditional programming sense, and that it combines both properties and behaviors.  We will favor the traditional meaning of the term object in these tutorials, and prefer the term &#8220;class object&#8221; when specifically referring to OOP objects.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Update the animal procedural example above and instantiate a snake instead of a cat.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nenum AnimalType\r\n{\r\n    cat,\r\n    dog,\r\n    chicken,\r\n    snake,\r\n};\r\n\r\nconstexpr std::string_view animalName(AnimalType type)\r\n{\r\n    switch (type)\r\n    {\r\n    case cat: return \"cat\";\r\n    case dog: return \"dog\";\r\n    case chicken: return \"chicken\";\r\n    case snake: return \"snake\";\r\n    default:  return \"\";\r\n    }\r\n}\r\n\r\nconstexpr int numLegs(AnimalType type)\r\n{\r\n    switch (type)\r\n    {\r\n    case cat: return 4;\r\n    case dog: return 4;\r\n    case chicken: return 2;\r\n    case snake: return 0;\r\n\r\n    default:  return 0;\r\n    }\r\n}\r\n\r\n\r\nint main()\r\n{\r\n    constexpr AnimalType animal{ snake };\r\n    std::cout &lt;&lt; \"A \" &lt;&lt; animalName(animal) &lt;&lt; \" has \" &lt;&lt; numLegs(animal) &lt;&lt; \" legs\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>Update the animal OOP-like example above and instantiate a snake instead of a cat.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nstruct Cat\r\n{\r\n    std::string_view name{ \"cat\" };\r\n    int numLegs{ 4 };\r\n};\r\n\r\nstruct Dog\r\n{\r\n    std::string_view name{ \"dog\" };\r\n    int numLegs{ 4 };\r\n};\r\n\r\nstruct Chicken\r\n{\r\n    std::string_view name{ \"chicken\" };\r\n    int numLegs{ 2 };\r\n};\r\n\r\nstruct Snake\r\n{\r\n    std::string_view name{ \"snake\" };\r\n    int numLegs{ 0 };\r\n};\r\n\r\nint main()\r\n{\r\n    constexpr Snake animal;\r\n    std::cout &lt;&lt; \"a \" &lt;&lt; animal.name &lt;&lt; \" has \" &lt;&lt; animal.numLegs &lt;&lt; \" legs\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-classes\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.2<\/span>Introduction to classes\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/using-a-language-reference\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.y<\/span>Using a language reference\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Procedural programming Back in lesson , we defined an object in C++ as, &#8220;a piece of memory that can be used to store values&#8221;. An object with a name is called a variable. Our C++ programs have consisted of sequential lists of instructions to the computer that define data (via &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/124"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=124"}],"version-history":[{"count":22,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/124\/revisions"}],"predecessor-version":[{"id":15624,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/124\/revisions\/15624"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=124"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=124"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=124"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}