{"id":127,"date":"2007-09-04T14:21:45","date_gmt":"2007-09-04T22:21:45","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/84-access-functions-and-encapsulation\/"},"modified":"2024-12-29T18:16:07","modified_gmt":"2024-12-30T02:16:07","slug":"access-functions","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/access-functions\/","title":{"rendered":"14.6 &#8212; Access functions"},"content":{"rendered":"<p>In previous lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/public-and-private-members-and-access-specifiers\/\">14.5 -- Public and private members and access specifiers<\/a>, we discussed the public and private access levels.  As a reminder, classes typically make their data members private, and private members can not be directly accessed by the public.<\/p>\n<p>Consider the following <code>Date<\/code> class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Date\r\n{\r\nprivate:\r\n    int m_year{ 2020 };\r\n    int m_month{ 10 };\r\n    int m_day{ 14 };\r\n\r\npublic:\r\n    void print() const\r\n    {\r\n        std::cout &lt;&lt; m_year &lt;&lt; '\/' &lt;&lt; m_month &lt;&lt; '\/' &lt;&lt; m_day &lt;&lt; '\\n';\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Date d{};  \/\/ create a Date object\r\n    d.print(); \/\/ print the date\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>While this class provides a <code>print()<\/code> member function to print the entire date, this may not be sufficient for what the user wants to do.  For example, what if the user of a <code>Date<\/code> object wanted to get the year?  Or to change the year to a different value?  They would be unable to do so, as <code>m_year<\/code> is private (and thus can&#8217;t be directly accessed by the public).<\/p>\n<p>For some classes, it can be appropriate (in the context of what the class does) for us to be able to get or set the value of a private member variable.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Access functions<\/p>\n<p>An <strong>access function<\/strong> is a trivial public member function whose job is to retrieve or change the value of a private member variable.  <\/p>\n<p>Access functions come in two flavors: getters and setters.  <strong>Getters<\/strong> (also sometimes called <strong>accessors<\/strong>) are public member functions that return the value of a private member variable. <strong>Setters<\/strong> (also sometimes called <strong>mutators<\/strong>) are public member functions that set the value of a private member variable.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Nomenclature<\/p>\n<p>The term &#8220;mutator&#8221; is often used interchangably with &#8220;setter&#8221;.  But more broadly, a <strong>mutator<\/strong> is any member function that modifies (mutates) the state of the object.  Under this definition, a setter is a specific kind of mutator.  However, it is also possible to have non-setter functions that qualify as mutators.\n<\/div>\n<p>Getters are usually made const, so they can be called on both const and non-const objects.  Setters should be non-const, so they can modify the data members.<\/p>\n<p>For illustrative purposes, let&#8217;s update our <code>Date<\/code> class to have a full set of getters and setters:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Date\r\n{\r\nprivate:\r\n    int m_year { 2020 };\r\n    int m_month { 10 };\r\n    int m_day { 14 };\r\n\r\npublic:\r\n    void print()\r\n    {\r\n        std::cout &lt;&lt; m_year &lt;&lt; '\/' &lt;&lt; m_month &lt;&lt; '\/' &lt;&lt; m_day &lt;&lt; '\\n';\r\n    }\r\n\r\n    int getYear() const { return m_year; }        \/\/ getter for year\r\n    void setYear(int year) { m_year = year; }     \/\/ setter for year\r\n\r\n    int getMonth() const  { return m_month; }     \/\/ getter for month\r\n    void setMonth(int month) { m_month = month; } \/\/ setter for month\r\n\r\n    int getDay() const { return m_day; }          \/\/ getter for day\r\n    void setDay(int day) { m_day = day; }         \/\/ setter for day\r\n};\r\n\r\nint main()\r\n{\r\n    Date d{};\r\n    d.setYear(2021);\r\n    std::cout &lt;&lt; \"The year is: \" &lt;&lt; d.getYear() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nThe year is: 2021\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Access function naming<\/p>\n<p>There is no common convention for naming access functions.  However, there are a few naming conventions that are more popular than others.<\/p>\n<ul>\n<li>Prefixed with &#8220;get&#8221; and &#8220;set&#8221;:\n<\/li>\n<\/ul>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    int getDay() const { return m_day; }  \/\/ getter\r\n    void setDay(int day) { m_day = day; } \/\/ setter<\/code><\/pre>\n<p>The advantage of using &#8220;get&#8221; and &#8220;set&#8221; prefixes is that it makes it clear that these are access functions (and should be inexpensive to call).<\/p>\n<ul>\n<li>No prefix:\n<\/li>\n<\/ul>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    int day() const { return m_day; }  \/\/ getter\r\n    void day(int day) { m_day = day; } \/\/ setter<\/code><\/pre>\n<p>This style is more concise, and uses the same name for both the getter and setter (relying on function overloading to differentiate the two).  The C++ standard library uses this convention.<\/p>\n<p>The downside of the no-prefix convention is that it is not particularly obvious that this is setting the value of the day member:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">d.day(5); \/\/ does this look like it's setting the day member to 5?<\/code><\/pre>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>One of the best reasons to prefix private data members with &#8220;m_&#8221; is to avoid having data members and getters with the same name (something C++ doesn&#8217;t support, although other languages like Java do).\n<\/p><\/div>\n<ul>\n<li>&#8220;set&#8221; prefix only:\n<\/li>\n<\/ul>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    int day() const { return m_day; }     \/\/ getter\r\n    void setDay(int day) { m_day = day; } \/\/ setter<\/code><\/pre>\n<p>Which of the above you choose is a matter of personal preference.  However, we highly recommend using the &#8220;set&#8221; prefix for setters.  Getters can use either a &#8220;get&#8221; prefix or no prefix.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>Use a &#8220;set&#8221; prefix on your setters to make it more obvious that they are changing the state of the object.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Getters should return by value or by const lvalue reference<\/p>\n<p>Getters should provide &#8220;read-only&#8221; access to data.  Therefore, the best practice is that they should return by either value (if making a copy of the member is inexpensive) or by const lvalue reference (if making a copy of the member is expensive).<\/p>\n<p>Because returning data members by reference is a non-trivial topic, we&#8217;ll cover that topic in more detail in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/member-functions-returning-references-to-data-members\/\">14.7 -- Member functions returning references to data members<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Access functions concerns<\/p>\n<p>There is a fair bit of discussion around cases in which access functions should be used or avoided.  Many developers would argue that use of access functions violates good class design (a topic that could easily fill an entire book).<\/p>\n<p>For now, we&#8217;ll recommend a pragmatic approach.  As you create your classes, consider the following:<\/p>\n<ul>\n<li>If your class has no invariants and requires a lot of access functions, consider using a struct (whose data members are public) and providing direct access to members instead.\n<\/li>\n<li>Prefer implementing behaviors or actions instead of access functions.  For example, instead of a <code>setAlive(bool)<\/code> setter, implement a <code>kill()<\/code> and a <code>revive()<\/code> function.\n<\/li>\n<li>Only provide access functions in cases where the public would reasonably need to get or set the value of an individual member.\n<\/li>\n<\/ul>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Why make data private if we&#8217;re going to provide a public access function to it?<\/p>\n<p>So glad you asked.  We&#8217;ll answer this question in upcoming lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/the-benefits-of-data-hiding-encapsulation\/\">14.8 -- The benefits of data hiding (encapsulation)<\/a>.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/member-functions-returning-references-to-data-members\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.7<\/span>Member functions returning references to data members\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/public-and-private-members-and-access-specifiers\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.5<\/span>Public and private members and access specifiers\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In previous lesson , we discussed the public and private access levels. As a reminder, classes typically make their data members private, and private members can not be directly accessed by the public. Consider the following Date class: #include &lt;iostream&gt; class Date { private: int m_year{ 2020 }; int m_month{ &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/127"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=127"}],"version-history":[{"count":46,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/127\/revisions"}],"predecessor-version":[{"id":2484,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/127\/revisions\/2484"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=127"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=127"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=127"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}