{"id":9391,"date":"2020-01-03T10:41:40","date_gmt":"2020-01-03T18:41:40","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=9391"},"modified":"2024-12-14T16:02:37","modified_gmt":"2024-12-15T00:02:37","slug":"sharing-global-constants-across-multiple-files-using-inline-variables","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/sharing-global-constants-across-multiple-files-using-inline-variables\/","title":{"rendered":"7.10 &#8212; Sharing global constants across multiple files (using inline variables)"},"content":{"rendered":"<p>In some applications, certain symbolic constants may need to be used throughout your code (not just in one location).  These can include physics or mathematical constants that don&#8217;t change (e.g. pi or Avogadro&#8217;s number), or application-specific &#8220;tuning&#8221; values (e.g. friction or gravity coefficients).  Instead of redefining these constants in every file that needs them (a violation of the &#8220;Don&#8217;t Repeat Yourself&#8221; rule), it&#8217;s better to declare them once in a central location and use them wherever needed.  That way, if you ever need to change them, you only need to change them in one place, and those changes can be propagated out.<\/p>\n<p>This lesson discusses the most common ways to do this.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Global constants as internal variables<\/p>\n<p>Prior to C++17, the following is the easiest and most common solution:<\/p>\n<ol start=\"1\">\n<li>Create a header file to hold these constants\n<\/li>\n<li>Inside this header file, define a namespace (discussed in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/user-defined-namespaces-and-the-scope-resolution-operator\/\">7.2 -- User-defined namespaces and the scope resolution operator<\/a>)\n<\/li>\n<li>Add all your constants inside the namespace (make sure they&#8217;re <em>constexpr<\/em>)\n<\/li>\n<li>#include the header file wherever you need it\n<\/li>\n<\/ol>\n<p>For example:<\/p>\n<p>constants.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef CONSTANTS_H\r\n#define CONSTANTS_H\r\n\r\n\/\/ Define your own namespace to hold constants\r\nnamespace constants\r\n{\r\n    \/\/ Global constants have internal linkage by default\r\n    constexpr double pi { 3.14159 };\r\n    constexpr double avogadro { 6.0221413e23 };\r\n    constexpr double myGravity { 9.2 }; \/\/ m\/s^2 -- gravity is light on this planet\r\n    \/\/ ... other related constants\r\n}\r\n#endif<\/code><\/pre>\n<p>Then use the scope resolution operator (::) with the namespace name to the left, and your variable name to the right in order to access your constants in .cpp files:<\/p>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"constants.h\" \/\/ include a copy of each constant in this file\r\n\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter a radius: \";\r\n    double radius{};\r\n    std::cin &gt;&gt; radius;\r\n\r\n    std::cout &lt;&lt; \"The circumference is: \" &lt;&lt; 2 * radius * constants::pi &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When this header gets #included into a .cpp file, each of these variables defined in the header will be copied into that code file at the point of inclusion.  Because these variables live outside of a function, they&#8217;re treated as global variables within the file they are included into, which is why you can use them anywhere in that file.<\/p>\n<p>Because const globals have internal linkage, each .cpp file gets an independent version of the global variable that the linker can&#8217;t see.  In most cases, because these are constexpr, the compiler will simply optimize the variables away.<\/p>\n<p>While this is simple (and fine for smaller programs), every time <em>constants.h<\/em> gets #included into a different code file, each of these variables is copied into the including code file.  Therefore, if constants.h gets included into 20 different code files, each of these variables is duplicated 20 times.  Header guards won&#8217;t stop this from happening, as they only prevent a header from being included more than once into a single including file, not from being included one time into multiple different code files.  This introduces two challenges:<\/p>\n<ol start=\"1\">\n<li>Changing a single constant value would require recompiling every file that includes the constants header, which can lead to lengthy rebuild times for larger projects.\n<\/li>\n<li>If the constants are large in size and can&#8217;t be optimized away, this can use a lot of memory.\n<\/li>\n<\/ol>\n<p>Advantages:<\/p>\n<ul>\n<li>Works prior to C++17.\n<\/li>\n<li>Can be used in constant expressions in any translation unit that includes them.\n<\/li>\n<\/ul>\n<p>Downsides:<\/p>\n<ul>\n<li>Changing anything in the header file requires recompiling files including the header.\n<\/li>\n<li>Each translation unit including the header gets its own copy of the variable.\n<\/li>\n<\/ul>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Global constants as external variables<\/p>\n<p>If you&#8217;re actively changing values or adding new constants, the prior solution might be problematic, at least until things settle.<\/p>\n<p>One way to avoid these problems is by turning these constants into external variables, since we can then have a single variable (initialized once) that is shared across all files.  In this method, we&#8217;ll define the constants in a .cpp file (to ensure the definitions only exist in one place), and put forward declarations in the header (which will be included by other files).<\/p>\n<p>constants.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"constants.h\"\r\n\r\nnamespace constants\r\n{\r\n    \/\/ We use extern to ensure these have external linkage\r\n    extern constexpr double pi { 3.14159 };\r\n    extern constexpr double avogadro { 6.0221413e23 };\r\n    extern constexpr double myGravity { 9.2 }; \/\/ m\/s^2 -- gravity is light on this planet\r\n}<\/code><\/pre>\n<p>constants.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef CONSTANTS_H\r\n#define CONSTANTS_H\r\n\r\nnamespace constants\r\n{\r\n    \/\/ Since the actual variables are inside a namespace, the forward declarations need to be inside a namespace as well\r\n    \/\/ We can't forward declare variables as constexpr, but we can forward declare them as (runtime) const\r\n    extern const double pi;\r\n    extern const double avogadro;\r\n    extern const double myGravity;\r\n}\r\n\r\n#endif<\/code><\/pre>\n<p>Use in the code file stays the same:<\/p>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"constants.h\" \/\/ include all the forward declarations\r\n\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter a radius: \";\r\n    double radius{};\r\n    std::cin &gt;&gt; radius;\r\n\r\n    std::cout &lt;&lt; \"The circumference is: \" &lt;&lt; 2 * radius * constants::pi &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Now the symbolic constants will get instantiated only once (in <em>constants.cpp<\/em>) instead of in each code file where <em>constants.h<\/em> is #included, and all uses of these constants will be linked to the version instantiated in <em>constants.cpp<\/em>.  Any changes made to <em>constants.cpp<\/em> will require recompiling only <em>constants.cpp<\/em>.<\/p>\n<p>However, there are a couple of downsides to this method.  First, because only the variable definitions are constexpr (the forward declarations aren&#8217;t, and can&#8217;t be), these constants are constant expressions only within the file they are actually defined in (<em>constants.cpp<\/em>).  In other files, the compiler will only see the forward declaration, which doesn&#8217;t define a constexpr value (and must be resolved by the linker).  This means outside of the file where they are defined, these variables can&#8217;t be used in a constant expression.  Second, because constant expressions can typically be optimized more than runtime expressions, the compiler may not be able to optimize these as much.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>In order for variables to be usable in compile-time contexts, such as array sizes, the compiler has to see the variable&#8217;s definition (not just a forward declaration).\n<\/p><\/div>\n<p>Because the compiler compiles each source file individually, it can only see variable definitions that appear in the source file being compiled (which includes any included headers). For example, variable definitions in <em>constants.cpp<\/em> are not visible when the compiler compiles <em>main.cpp<\/em>. For this reason, constexpr variables cannot be separated into header and source file, they have to be defined in the header file.<\/p>\n<p>Given the above downsides, prefer defining your constants in a header file (either per the prior section, or per the next section).  If you find that the values for your constants are changing a lot (e.g. because you are tuning the program) and this is leading to long compilation times, you can temporarily move just the offending constants into a .cpp file (using this method) as needed.<\/p>\n<p>Advantages:<\/p>\n<ul>\n<li>Works prior to C++17.\n<\/li>\n<li>Only one copy of each variable is required.\n<\/li>\n<li>Only requires recompilation of one file if the value of a constant changes.\n<\/li>\n<\/ul>\n<p>Disadvantages:<\/p>\n<ul>\n<li>Forward declarations and variable definitions are in separate files, and must be kept in sync.\n<\/li>\n<li>Variables not usable in constant expressions outside of the file in which they are defined.\n<\/li>\n<\/ul>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Global constants as inline variables <span class=\"cpp-section-pill cpp-section-standard\">C++17<\/span><\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/inline-functions-and-variables\/\">7.9 -- Inline functions and variables<\/a>, we covered inline variables, which are variables that can have more than one definition, so long as those definitions are identical.  By making our constexpr variables inline, we can define them in a header file and then #include them into any .cpp file that requires them.  This avoids both ODR violations and the downside of duplicated variables.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">A reminder<\/p>\n<p>Constexpr functions are implicitly inline, but constexpr variables are not implicitly inline.  If you want an inline constexpr variable, you must explicitly mark it as <code>inline<\/code>.\n<\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Inline variables have external linkage by default, so that they are visible to the linker.  This is necessary so the linker can de-duplicate the definitions.<\/p>\n<p>Non-inline constexpr variables have internal linkage.  If included into multiple translation units, each translation unit will get its own copy of the variable.  This is not an ODR violation because they are not exposed to the linker.\n<\/p><\/div>\n<p>constants.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef CONSTANTS_H\r\n#define CONSTANTS_H\r\n\r\n\/\/ define your own namespace to hold constants\r\nnamespace constants\r\n{\r\n    inline constexpr double pi { 3.14159 }; \/\/ note: now inline constexpr\r\n    inline constexpr double avogadro { 6.0221413e23 };\r\n    inline constexpr double myGravity { 9.2 }; \/\/ m\/s^2 -- gravity is light on this planet\r\n    \/\/ ... other related constants\r\n}\r\n#endif<\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"constants.h\"\r\n\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter a radius: \";\r\n    double radius{};\r\n    std::cin &gt;&gt; radius;\r\n\r\n    std::cout &lt;&lt; \"The circumference is: \" &lt;&lt; 2 * radius * constants::pi &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>We can include <code>constants.h<\/code> into as many code files as we want, but these variables will only be instantiated once and shared across all code files.<\/p>\n<p>This method does retain the downside of requiring every file that includes the constants header be recompiled if any constant value is changed.<\/p>\n<p>Advantages:<\/p>\n<ul>\n<li>Can be used in constant expressions in any translation unit that includes them.\n<\/li>\n<li>Only one copy of each variable is required.\n<\/li>\n<\/ul>\n<p>Downsides:<\/p>\n<ul>\n<li>Only works in C++17 onward.\n<\/li>\n<li>Changing anything in the header file requires recompiling files including the header.\n<\/li>\n<\/ul>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>If you need global constants and your compiler is C++17 capable, prefer defining inline constexpr global variables in a header file.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">A reminder<\/p>\n<p>Use <code>std::string_view<\/code> for <code>constexpr<\/code> strings.  We cover this in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdstring_view\/\">5.8 -- Introduction to std::string_view<\/a>.\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We summarize the scope, duration, and linkage of various kinds of variables in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/scope-duration-and-linkage-summary\/\">7.12 -- Scope, duration, and linkage summary<\/a>.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/static-local-variables\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.11<\/span>Static local variables\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/inline-functions-and-variables\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.9<\/span>Inline functions and variables\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In some applications, certain symbolic constants may need to be used throughout your code (not just in one location). These can include physics or mathematical constants that don&#8217;t change (e.g. pi or Avogadro&#8217;s number), or application-specific &#8220;tuning&#8221; values (e.g. friction or gravity coefficients). Instead of redefining these constants in every &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9391"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=9391"}],"version-history":[{"count":37,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9391\/revisions"}],"predecessor-version":[{"id":17986,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9391\/revisions\/17986"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=9391"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=9391"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=9391"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}