{"id":9429,"date":"2020-01-03T13:20:11","date_gmt":"2020-01-03T21:20:11","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=9429"},"modified":"2024-11-04T12:03:58","modified_gmt":"2024-11-04T20:03:58","slug":"chapter-13-summary-and-quiz","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-13-summary-and-quiz\/","title":{"rendered":"13.x &#8212; Chapter 13 summary and quiz"},"content":{"rendered":"<p>Congrats!  You made it through another one.  The knowledge you gained regarding structs will be useful when we get to C++&#8217;s most important topic -- classes!<\/p>\n<p class=\"cpp-section\">Quick review<\/p>\n<p>A <strong>program-defined type<\/strong> (also called a <strong>user-defined type<\/strong>) is a custom type that we can create for use in our own programs.  The enumerated types and class types (including structs, classes and unions) allow for creation of program-defined types.  Program-defined types must be defined before they can be used.  The definition of a program-defined type is called a <strong>type definition<\/strong>.  Type definitions are exempt from the one-definition rule.<\/p>\n<p>An <strong>enumeration<\/strong> (also called an <strong>enumerated type<\/strong> or an <strong>enum<\/strong>) is a compound data type where every possible value is defined as a symbolic constant (called an <strong>enumerator<\/strong>).  Enumerations are <strong>distinct types<\/strong>, meaning the compiler can differentiate them from other types (unlike type aliases).<\/p>\n<p><strong>Unscoped enumerations<\/strong> are named such because they put their enumerator names into the same scope as the enumeration definition itself (as opposed to creating a new scope region like a namespace does).  Unscoped enumerations also provide a named scope region for their enumerators.  Unscoped enumerations will implicitly convert to integral values.<\/p>\n<p><strong>Scoped enumerations<\/strong> work similarly to unscoped enumerations but won&#8217;t implicitly convert to integers, and the enumerators are <em>only<\/em> placed into the scope region of the enumeration (not into the scope region where the enumeration is defined).<\/p>\n<p>A <strong>struct<\/strong> (short for <strong>structure<\/strong>) is a program-defined data type that allows us to bundle multiple variables together into a single type.   The variables that are part of the struct (or class) are called <strong>data members<\/strong> (or <strong>member variables<\/strong>).  To access a specific member variable, we use the <strong>member selection operator<\/strong> (<code>operator.<\/code>) in between the struct variable name and the member name (for normal structs and references to structs), or the <strong>member selection from pointer operator<\/strong> (<code>operator-&gt;<\/code>) (for pointers to structs).<\/p>\n<p>In general programming, an <strong>aggregate data type<\/strong> (also called an <strong>aggregate<\/strong>) is any type that can contain multiple data members.  In C++, arrays and structs with only data members are <strong>aggregates<\/strong>.<\/p>\n<p>Aggregates use a form of initialization called <strong>aggregate initialization<\/strong>, which allows us to directly initialize the members of aggregates. To do this, we provide an <strong>initializer list <\/strong> as an initializer, which is just a list of comma-separated values.  Aggregate initialization does a <strong>memberwise initialization<\/strong>, which means each member in the struct is initialized in the order of declaration.<\/p>\n<p>In C++20, <strong>Designated initializers<\/strong> allow you to explicitly define which initialization values map to which members. The members must be initialized in the order in which they are declared in the struct, otherwise an error will result.<\/p>\n<p>When we define a struct (or class) type, we can provide a default initialization value for each member as part of the type definition. This process is called <strong>non-static member initialization<\/strong>, and the initialization value is called a <strong>default member initializer<\/strong>.<\/p>\n<p>For performance reasons, the compiler will sometimes add gaps into structures (this is called <strong>padding<\/strong>), so the size of a structure may be larger than the sum of the size of its members.<\/p>\n<p>A <strong>class template<\/strong> is a template definition for instantiating class types (structs, classes, or unions).  <strong>Class template argument deduction (CTAD)<\/strong> is a C++17 feature that allows the compiler to deduce the template type arguments from an initializer.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p>Yay!<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>In designing a game, we decide we want to have monsters, because everyone likes fighting monsters.  Declare a struct that represents your monster.  The monster should have a type that can be one of the following: an ogre, a dragon, an orc, a giant spider, or a slime.<\/p>\n<p>Each individual monster should also have a name (use a <code>std::string<\/code>), as well as an amount of health that represents how much damage they can take before they die.  Write a function named printMonster() that prints out all of the struct&#8217;s members.  Instantiate an ogre and a slime, initialize them using an initializer list, and pass them to printMonster().<\/p>\n<p>Your program should produce the following output:<\/p>\n<pre>\nThis Ogre is named Torg and has 145 health.\r\nThis Slime is named Blurp and has 23 health.\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt; \/\/ C++17\r\n\r\n\/\/ Our monster struct represents a single monster\r\n\r\nstruct Monster\r\n{\r\n\t\/\/ Define our different monster types as an enum\r\n\tenum Type\r\n\t{\r\n\t\togre,\r\n\t\tdragon,\r\n\t\torc,\r\n\t\tgiant_spider,\r\n\t\tslime,\r\n\t};\r\n\r\n\tType type{};\r\n\tstd::string name{}; \/\/ the Monster should be an owner of its name\r\n\tint health{};\r\n};\r\n\r\n\/\/ Return the name of the monster's type as a string\r\n\/\/ Since this could be used elsewhere, it's better to make this its own function\r\nconstexpr std::string_view getMonsterTypeString(Monster::Type type)\r\n{\r\n\tswitch (type)\r\n\t{\r\n\tcase Monster::ogre:          return \"Ogre\";\r\n\tcase Monster::dragon:        return \"Dragon\";\r\n\tcase Monster::orc:           return \"Orc\";\r\n\tcase Monster::giant_spider:  return \"Giant Spider\";\r\n\tcase Monster::slime:         return \"Slime\";\r\n\t}\r\n\r\n\treturn \"Unknown\";\r\n}\r\n\r\n\/\/ Print our monster's stats\r\nvoid printMonster(const Monster&amp; monster)\r\n{\r\n\tstd::cout &lt;&lt; \"This \" &lt;&lt; getMonsterTypeString(monster.type) &lt;&lt;\r\n\t\t\" is named \" &lt;&lt; monster.name &lt;&lt;\r\n\t\t\" and has \" &lt;&lt; monster.health &lt;&lt; \" health.\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n\tMonster ogre{ Monster::ogre, \"Torg\", 145 };\r\n\tMonster slime{ Monster::slime, \"Blurp\", 23 };\r\n\r\n\tprintMonster(ogre);\r\n\tprintMonster(slime);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>Specify whether objects of each of the given types should be passed by value, const address, or const reference.  You can assume the function that takes these types as parameters doesn&#8217;t modify them.<\/p>\n<p>a) <code>char<\/code><\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p><code>char<\/code> is a fundamental type, so it should be passed by value.\n<\/div>\n<p>b) <code>std::string<\/code><\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<p><code>std::string<\/code> has to create a copy of the string whenever it is copied.  Pass it by const reference.\n<\/div>\n<p>c) <code>unsigned long<\/code><\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<p><code>unsigned long<\/code> is a fundamental type, so it should be passed by value.\n<\/div>\n<p>d) <code>bool<\/code><\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\n<p><code>bool<\/code> is a fundamental type, so it should be passed by value.\n<\/div>\n<p>e) An enumerated type<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_5'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_5\" style=\"display:none\">\n<p>Enumerated types hold integral values (usually int).  Since integral values are passed by value, enumerated types should be passed by value.\n<\/p><\/div>\n<p>f)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">struct Position\r\n{\r\n  double x{};\r\n  double y{};\r\n  double z{};\r\n};<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_6'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_6\" style=\"display:none\">\n<p><code>Position<\/code> is a struct type and should be passed by const reference.\n<\/div>\n<p>g)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">struct Player\r\n{\r\n  int health{};\r\n  \/\/ The Player struct is still under development.  More members will be added.\r\n};<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_7'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_7\" style=\"display:none\">\n<p>Although <code>Player<\/code> only contains a single <code>int<\/code> in its current state, which would make it fast to pass by value, more members will be added in the future. We don&#8217;t want to update every use of <code>Player<\/code> when that happens, so we pass it by const reference.\n<\/div>\n<p>h) <code>int<\/code> (when null is a valid argument)<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_8'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_8\" style=\"display:none\">\n<p>Normally we&#8217;d pass an <code>int<\/code> by value, but if we want to be able to pass a null value also, then pass by address is a good choice, as we can pass in either the address of the <code>int<\/code>, or <code>nullptr<\/code>.\n<\/div>\n<p>i) <code>std::string_view<\/code><\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_9'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_9\" style=\"display:none\">\n<p><code>std::string_view<\/code> does not create a copy of the string being viewed, and it is cheap to copy.  Pass by value.\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #3<\/p>\n<p>Create a class template named <code>Triad<\/code> that has 3 members of the same template type.  Also create a function template named <code>print<\/code> that can print a Triad.  The following program should compile:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n\tTriad t1{ 1, 2, 3 }; \/\/ note: uses CTAD to deduce template arguments\r\n\tprint(t1);\r\n\r\n\tTriad t2{ 1.2, 3.4, 5.6 }; \/\/ note: uses CTAD to deduce template arguments\r\n\tprint(t2);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>and produce the following result:<\/p>\n<pre>\n[1, 2, 3][1.2, 3.4, 5.6]\r\n<\/pre>\n<p>If you are using C++17, you will need to provide a deduction guide for CTAD to work (see <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-template-argument-deduction-ctad-and-deduction-guides\/\">13.14 -- Class template argument deduction (CTAD) and deduction guides<\/a> for information on that).<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_10'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_10\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nstruct Triad\r\n{\r\n\tT first {};\r\n\tT second {};\r\n\tT third {};\r\n};\r\n\r\n\/\/ If using C++17, we need to provide a deduction guide (not required in C++20)\r\n\/\/ A Triad with three arguments of the same type should deduce to a Triad&lt;T&gt;\r\ntemplate &lt;typename T&gt;\r\nTriad(T, T, T) -&gt; Triad&lt;T&gt;;\r\n\r\ntemplate &lt;typename T&gt;\r\nvoid print(const Triad&lt;T&gt;&amp; t)\r\n{\r\n\tstd::cout &lt;&lt; '[' &lt;&lt; t.first &lt;&lt; \", \" &lt;&lt; t.second &lt;&lt; \", \" &lt;&lt; t.third &lt;&lt; ']';\r\n}\r\n\r\nint main()\r\n{\r\n\tTriad t1{ 1, 2, 3 };\r\n\tprint(t1);\r\n\r\n\tTriad t2{ 1.2, 3.4, 5.6 };\r\n\tprint(t2);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/using-a-language-reference\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.y<\/span>Using a language reference\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/alias-templates\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.15<\/span>Alias templates\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Congrats! You made it through another one. The knowledge you gained regarding structs will be useful when we get to C++&#8217;s most important topic &#8212; classes! A (also called a ) is a custom type that we can create for use in our own programs. The enumerated types and class &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9429"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=9429"}],"version-history":[{"count":43,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9429\/revisions"}],"predecessor-version":[{"id":17828,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9429\/revisions\/17828"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=9429"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=9429"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=9429"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}