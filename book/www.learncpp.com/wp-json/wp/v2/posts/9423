{"id":9423,"date":"2020-01-03T13:12:51","date_gmt":"2020-01-03T21:12:51","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=9423"},"modified":"2024-11-26T16:53:03","modified_gmt":"2024-11-27T00:53:03","slug":"unnamed-and-inline-namespaces","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/unnamed-and-inline-namespaces\/","title":{"rendered":"7.14 &#8212; Unnamed and inline namespaces"},"content":{"rendered":"<p>C++ supports two variants of namespaces that are worth at least knowing about.  We won&#8217;t build on these, so consider this lesson optional for now.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Unnamed (anonymous) namespaces<\/p>\n<p>An <strong>unnamed namespace<\/strong> (also called an <strong>anonymous namespace<\/strong>) is a namespace that is defined without a name, like so:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nnamespace \/\/ unnamed namespace\r\n{\r\n    void doSomething() \/\/ can only be accessed in this file\r\n    {\r\n        std::cout &lt;&lt; \"v1\\n\";\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    doSomething(); \/\/ we can call doSomething() without a namespace prefix\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nv1\r\n<\/pre>\n<p>All content declared in an unnamed namespace is treated as if it is part of the parent namespace.  So even though function <code>doSomething()<\/code> is defined in the unnamed namespace, the function itself is accessible from the parent namespace (which in this case is the global namespace), which is why we can call <code>doSomething()<\/code> from <code>main()<\/code> without any qualifiers.<\/p>\n<p>This might make unnamed namespaces seem useless.  But the other effect of unnamed namespaces is that all identifiers inside an unnamed namespace are treated as if they have internal linkage, which means that the content of an unnamed namespace can&#8217;t be seen outside of the file in which the unnamed namespace is defined.<\/p>\n<p>For functions, this is effectively the same as defining all functions in the unnamed namespace as static functions.  The following program is effectively identical to the one above:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstatic void doSomething() \/\/ can only be accessed in this file\r\n{\r\n    std::cout &lt;&lt; \"v1\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    doSomething(); \/\/ we can call doSomething() without a namespace prefix\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Unnamed namespaces are typically used when you have a lot of content that you want to ensure stays local to a given translation unit, as it&#8217;s easier to cluster such content in a single unnamed namespace than individually mark all declarations as <code>static<\/code>.  Unnamed namespaces will also keep program-defined types (something we&#8217;ll discuss in a later lesson) local to the translation unit, something for which there is no alternative equivalent mechanism to do.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>If you&#8217;re hardcore, you can take the opposite approach -- put all content that isn&#8217;t explicitly meant to be exported\/external in an unnamed namespace.\n<\/p><\/div>\n<p>Unnamed namespaces should generally not be used in header files.  <a href=\"https:\/\/wiki.sei.cmu.edu\/confluence\/display\/cplusplus\/DCL59-CPP.+Do+not+define+an+unnamed+namespace+in+a+header+file\">SEI CERT (rule DCL59-CPP)<\/a> has some good examples as to why.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Prefer unnamed namespaces when you have content you want to keep local to a translation unit.<\/p>\n<p>Avoid unnamed namespaces in header files.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Inline namespaces<\/p>\n<p>Now consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid doSomething()\r\n{\r\n    std::cout &lt;&lt; \"v1\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    doSomething();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nv1\r\n<\/pre>\n<p>Pretty straightforward, right?<\/p>\n<p>But let&#8217;s say you&#8217;re not happy with <code>doSomething()<\/code>, and you want to improve it in some way that changes how it behaves.  But if you do this, you risk breaking existing programs using the older version.  How do you handle this?<\/p>\n<p>One way would be to create a new version of the function with a different name.  But over the course of many changes, you could end up with a whole set of almost-identically named functions (<code>doSomething<\/code>, <code>doSomething_v2<\/code>, <code>doSomething_v3<\/code>, etc&#8230;).<\/p>\n<p>An alternative is to use an inline namespace.  An <strong>inline namespace<\/strong> is a namespace that is typically used to version content.  Much like an unnamed namespace, anything declared inside an inline namespace is considered part of the parent namespace.  However, unlike unnamed namespaces, inline namespaces don&#8217;t affect linkage.<\/p>\n<p>To define an inline namespace, we use the <code>inline<\/code> keyword:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ninline namespace V1 \/\/ declare an inline namespace named V1\r\n{\r\n    void doSomething()\r\n    {\r\n        std::cout &lt;&lt; \"V1\\n\";\r\n    }\r\n}\r\n\r\nnamespace V2 \/\/ declare a normal namespace named V2\r\n{\r\n    void doSomething()\r\n    {\r\n        std::cout &lt;&lt; \"V2\\n\";\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    V1::doSomething(); \/\/ calls the V1 version of doSomething()\r\n    V2::doSomething(); \/\/ calls the V2 version of doSomething()\r\n\r\n    doSomething(); \/\/ calls the inline version of doSomething() (which is V1)\r\n \r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nV1\r\nV2\r\nV1\r\n<\/pre>\n<p>In the above example, callers to <code>doSomething()<\/code> will get the V1 (the inline version) of <code>doSomething()<\/code>.  Callers who want to use the newer version can explicitly call <code>V2::doSomething()<\/code>.  This preserves the function of existing programs while allowing newer programs to take advantage of newer\/better variations.<\/p>\n<p>Alternatively, if you want to push the newer version:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nnamespace V1 \/\/ declare a normal namespace named V1\r\n{\r\n    void doSomething()\r\n    {\r\n        std::cout &lt;&lt; \"V1\\n\";\r\n    }\r\n}\r\n\r\ninline namespace V2 \/\/ declare an inline namespace named V2\r\n{\r\n    void doSomething()\r\n    {\r\n        std::cout &lt;&lt; \"V2\\n\";\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    V1::doSomething(); \/\/ calls the V1 version of doSomething()\r\n    V2::doSomething(); \/\/ calls the V2 version of doSomething()\r\n\r\n    doSomething(); \/\/ calls the inline version of doSomething() (which is V2)\r\n \r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nV1\r\nV2\r\nV2\r\n<\/pre>\n<p>In this example, all callers to <code>doSomething()<\/code> will get the v2 version by default (the newer and better version).  Users who still want the older version of <code>doSomething()<\/code> can explicitly call <code>V1::doSomething()<\/code> to access the old behavior.  This means existing programs who want the V1 version will need to globally replace <code>doSomething<\/code> with <code>V1::doSomething<\/code>, but this typically won&#8217;t be problematic if the functions are well named.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Mixing inline and unnamed namespaces <span class=\"cpp-section-pill cpp-section-optional\">Optional<\/span><\/p>\n<p>A namespace can be both inline and unnamed:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nnamespace V1 \/\/ declare a normal namespace named V1\r\n{\r\n    void doSomething()\r\n    {\r\n        std::cout &lt;&lt; \"V1\\n\";\r\n    }\r\n}\r\n\r\ninline namespace \/\/ declare an inline unnamed namespace\r\n{\r\n    void doSomething() \/\/ has internal linkage\r\n    {\r\n        std::cout &lt;&lt; \"V2\\n\";\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    V1::doSomething(); \/\/ calls the V1 version of doSomething()\r\n    \/\/ there is no V2 in this example, so we can't use V2:: as a namespace prefix\r\n\r\n    doSomething(); \/\/ calls the inline version of doSomething() (which is the anonymous one)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, in such cases, it&#8217;s probably better to nest an anonymous namespace inside an inline namespace.  This has the same effect (all functions inside the anonymous namespace have internal linkage by default) but still gives you an explicit namespace name you can use:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nnamespace V1 \/\/ declare a normal namespace named V1\r\n{\r\n    void doSomething()\r\n    {\r\n        std::cout &lt;&lt; \"V1\\n\";\r\n    }\r\n}\r\n\r\ninline namespace V2 \/\/ declare an inline namespace named V2\r\n{\r\n    namespace \/\/ unnamed namespace\r\n    {\r\n        void doSomething() \/\/ has internal linkage\r\n        {\r\n            std::cout &lt;&lt; \"V2\\n\";\r\n        }\r\n\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    V1::doSomething(); \/\/ calls the V1 version of doSomething()\r\n    V2::doSomething(); \/\/ calls the V2 version of doSomething()\r\n\r\n    doSomething(); \/\/ calls the inline version of doSomething() (which is V2)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-7-summary-and-quiz\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.x<\/span>Chapter 7 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/using-declarations-and-using-directives\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.13<\/span>Using declarations and using directives\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>C++ supports two variants of namespaces that are worth at least knowing about. We won&#8217;t build on these, so consider this lesson optional for now. Unnamed (anonymous) namespaces An (also called an ) is a namespace that is defined without a name, like so: #include &lt;iostream&gt; namespace \/\/ unnamed namespace &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9423"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=9423"}],"version-history":[{"count":20,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9423\/revisions"}],"predecessor-version":[{"id":17911,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9423\/revisions\/17911"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=9423"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=9423"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=9423"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}