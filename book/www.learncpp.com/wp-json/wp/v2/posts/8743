{"id":8743,"date":"2019-08-17T12:06:20","date_gmt":"2019-08-17T20:06:20","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=8743"},"modified":"2025-02-15T16:52:17","modified_gmt":"2025-02-16T00:52:17","slug":"bit-flags-and-bit-manipulation-via-stdbitset","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/bit-flags-and-bit-manipulation-via-stdbitset\/","title":{"rendered":"O.1 &#8212; Bit flags and bit manipulation via std::bitset"},"content":{"rendered":"<p>On modern computer architectures, the smallest addressable unit of memory is a byte.   Since all objects need to have unique memory addresses, this means objects must be at least one byte in size.  For most variable types, this is fine.  However, for Boolean values, this is a bit wasteful (pun intended).  Boolean types only have two states: true (1), or false (0).  This set of states only requires one bit to store.  However, if a variable must be at least a byte, and a byte is 8 bits, that means a Boolean is using 1 bit and leaving the other 7 unused.<\/p>\n<p>In the majority of cases, this is fine -- we&#8217;re usually not so hard-up for memory that we need to care about 7 wasted bits (we&#8217;re better off optimizing for understandability and maintainability).  However, in some storage-intensive cases, it can be useful to &#8220;pack&#8221; 8 individual Boolean values into a single byte for storage efficiency purposes.<\/p>\n<p>Doing these things requires that we can manipulate objects at the bit level.  Fortunately, C++ gives us tools to do precisely this.  Modifying individual bits within an object is called <strong>bit manipulation<\/strong>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>Bit manipulation is used a lot in certain programming contexts (e.g. graphics, encryption, compression, optimization), but not as much in general programming.<\/p>\n<p>Because of that, this entire chapter is optional reading.  Feel free to skip or skim it and come back later.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Bit flags<\/p>\n<p>Up to this point, we&#8217;ve used variables to hold single values:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int foo { 5 }; \/\/ assign foo the value 5 (probably uses 32 bits of storage)\r\nstd::cout &lt;&lt; foo; \/\/ print the value 5<\/code><\/pre>\n<p>However, instead of viewing objects as holding a single value, we can instead treat each bit in the object as an independent Boolean value.  When individual bits of an object are used as Boolean values, the bits are called <strong>bit flags<\/strong>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Nomenclature<\/p>\n<p>A bit holding a <code>0<\/code> value is said to be &#8220;false&#8221;, &#8220;off&#8221;, or &#8220;not set&#8221;.<br \/>\nA bit holding a <code>1<\/code> value is said to be &#8220;true&#8221;, &#8220;on&#8221;, or &#8220;set&#8221;.<br \/>\nWhen a bit is changed from a <code>0<\/code> to a <code>1<\/code> or a <code>1<\/code> to a <code>0<\/code>, we say it has been &#8220;flipped&#8221; or &#8220;inverted&#8221;.\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>In computing, a <strong>flag<\/strong> is a value that signals when some condition exists in a program.  With a bit flag, a value of <code>true<\/code> means the condition exists.<\/p>\n<p>Analogously, in the United States, many mailboxes have small (usually red) physical flags attached to the side.  When outgoing mail is waiting to be picked up by the carrier, the flag is raised to signal that there is outgoing mail.\n<\/p><\/div>\n<p>To define a set of bit flags, we&#8217;ll typically use an unsigned integer of the appropriate size (8 bits, 16 bits, 32 bits, etc&#8230; depending on how many flags we have), or <code>std::bitset<\/code>.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;bitset&gt; \/\/ for std::bitset\r\n\r\nstd::bitset&lt;8&gt; mybitset {}; \/\/ 8 bits in size means room for 8 flags<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Bit manipulation is one of the few times when you should unambiguously use unsigned integers (or <code>std::bitset<\/code>).\n<\/div>\n<p>In this lesson, we&#8217;ll show how to do bit manipulation the easy way, via <code>std::bitset<\/code>.  In the next set of lessons, we&#8217;ll explore how to do it the more difficult but versatile way.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Bit numbering and bit positions<\/p>\n<p>Given a sequence of bits, we typically number the bits from right to left, starting with 0 (not 1).  Each number denotes a <strong>bit position<\/strong>.<\/p>\n<pre>\n76543210  Bit position\r\n00000101  Bit sequence\r\n<\/pre>\n<p>Given the bit sequence 0000 0101, the bits that are in position 0 and 2 have value 1, and the other bits have value 0.  <\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Manipulating bits via <code>std::bitset<\/code><\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/numeral-systems-decimal-binary-hexadecimal-and-octal\/\">5.3 -- Numeral systems (decimal, binary, hexadecimal, and octal)<\/a> we already showed how to use a <code>std::bitset<\/code> to print values in binary.  However, this isn&#8217;t the only useful thing <code>std::bitset<\/code> can do.<\/p>\n<p><code>std::bitset<\/code> provides 4 key member functions that are useful for doing bit manipulation:<\/p>\n<ul>\n<li>test() allows us to query whether a bit is a 0 or 1.\n<\/li>\n<li>set() allows us to turn a bit on (this will do nothing if the bit is already on).\n<\/li>\n<li>reset() allows us to turn a bit off (this will do nothing if the bit is already off).\n<\/li>\n<li>flip() allows us to flip a bit value from a 0 to a 1 or vice versa.\n<\/li>\n<\/ul>\n<p>Each of these functions takes the position of the bit we want to operate on as their only argument.  <\/p>\n<p>Here&#8217;s an example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;bitset&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::bitset&lt;8&gt; bits{ 0b0000'0101 }; \/\/ we need 8 bits, start with bit pattern 0000 0101\r\n    bits.set(3);   \/\/ set bit position 3 to 1 (now we have 0000 1101)\r\n    bits.flip(4);  \/\/ flip bit 4 (now we have 0001 1101)\r\n    bits.reset(4); \/\/ set bit 4 back to 0 (now we have 0000 1101)\r\n\r\n    std::cout &lt;&lt; \"All the bits: \" &lt;&lt; bits&lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"Bit 3 has value: \" &lt;&lt; bits.test(3) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"Bit 4 has value: \" &lt;&lt; bits.test(4) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nAll the bits: 00001101\r\nBit 3 has value: 1\r\nBit 4 has value: 0\r\n<\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">A reminder<\/p>\n<p>We introduced member functions in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdstring\/\">5.7 -- Introduction to std::string<\/a>.  With normal functions, we call <code>function(object)<\/code>. With member functions, we call <code>object.function()<\/code>.<\/p>\n<p>We covered the <code>0b<\/code> binary literal prefix and the <code>'<\/code> digit separator in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/numeral-systems-decimal-binary-hexadecimal-and-octal\/\">5.3 -- Numeral systems (decimal, binary, hexadecimal, and octal)<\/a>.\n<\/div>\n<p>Giving our bits names can help make our code more readable:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;bitset&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    [[maybe_unused]] constexpr int  isHungry   { 0 };\r\n    [[maybe_unused]] constexpr int  isSad      { 1 };\r\n    [[maybe_unused]] constexpr int  isMad      { 2 };\r\n    [[maybe_unused]] constexpr int  isHappy    { 3 };\r\n    [[maybe_unused]] constexpr int  isLaughing { 4 };\r\n    [[maybe_unused]] constexpr int  isAsleep   { 5 };\r\n    [[maybe_unused]] constexpr int  isDead     { 6 };\r\n    [[maybe_unused]] constexpr int  isCrying   { 7 };\r\n\r\n    std::bitset&lt;8&gt; me{ 0b0000'0101 }; \/\/ we need 8 bits, start with bit pattern 0000 0101\r\n    me.set(isHappy);      \/\/ set bit position 3 to 1 (now we have 0000 1101)\r\n    me.flip(isLaughing);  \/\/ flip bit 4 (now we have 0001 1101)\r\n    me.reset(isLaughing); \/\/ set bit 4 back to 0 (now we have 0000 1101)\r\n\r\n    std::cout &lt;&lt; \"All the bits: \" &lt;&lt; me &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"I am happy: \" &lt;&lt; me.test(isHappy) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"I am laughing: \" &lt;&lt; me.test(isLaughing) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover <code>[maybe_unused]<\/code> in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/variable-assignment-and-initialization\/\">1.4 -- Variable assignment and initialization<\/a>.<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/unscoped-enumerations\/\">13.2 -- Unscoped enumerations<\/a>, we show how enumerators make an even better collection of named bits.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">What if we want to get or set multiple bits at once<\/p>\n<p><code>std::bitset<\/code> doesn&#8217;t make this easy.  In order to do this, or if we want to use unsigned integer bit flags instead of <code>std::bitset<\/code>, we need to turn to more traditional methods.  We&#8217;ll cover these in the next couple of lessons.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The size of <code>std::bitset<\/code><\/p>\n<p>One potential surprise is that <code>std::bitset<\/code> is optimized for speed, not memory savings.  The size of a <code>std::bitset<\/code> is typically the number of bytes needed to hold the bits, rounded <em>up<\/em> to the nearest <code>sizeof(size_t)<\/code>, which is 4 bytes on 32-bit machines, and 8-bytes on 64-bit machines.<\/p>\n<p>Thus, a <code>std::bitset&lt;8&gt;<\/code> will typically use either 4 or 8 bytes of memory, even though it technically only needs 1 byte to store 8 bits.  Thus, <code>std::bitset<\/code> is most useful when we desire convenience, not memory savings.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Querying <code>std::bitset<\/code><\/p>\n<p>There are a few other member functions that are often useful:<\/p>\n<ul>\n<li>size() returns the number of bits in the bitset.\n<\/li>\n<li>count() returns the number of bits in the bitset that are set to <code>true<\/code>.\n<\/li>\n<li>all() returns a Boolean indicating whether all bits are set to <code>true<\/code>.\n<\/li>\n<li>any() returns a Boolean indicating whether any bits are set to <code>true<\/code>.\n<\/li>\n<li>none() returns a Boolean indicating whether no bits are set to <code>true<\/code>.\n<\/li>\n<\/ul>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;bitset&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::bitset&lt;8&gt; bits{ 0b0000'1101 };\r\n    std::cout &lt;&lt; bits.size() &lt;&lt; \" bits are in the bitset\\n\";\r\n    std::cout &lt;&lt; bits.count() &lt;&lt; \" bits are set to true\\n\";\r\n\r\n    std::cout &lt;&lt; std::boolalpha;\r\n    std::cout &lt;&lt; \"All bits are true: \" &lt;&lt; bits.all() &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"Some bits are true: \" &lt;&lt; bits.any() &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"No bits are true: \" &lt;&lt; bits.none() &lt;&lt; '\\n';\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n8 bits are in the bitset\r\n3 bits are set to true\r\nAll bits are true: false\r\nSome bits are true: true\r\nNo bits are true: false\r\n<\/pre>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/bitwise-operators\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">O.2<\/span>Bitwise operators\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-6-summary-and-quiz\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">6.x<\/span>Chapter 6 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>On modern computer architectures, the smallest addressable unit of memory is a byte. Since all objects need to have unique memory addresses, this means objects must be at least one byte in size. For most variable types, this is fine. However, for Boolean values, this is a bit wasteful (pun &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/8743"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=8743"}],"version-history":[{"count":21,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/8743\/revisions"}],"predecessor-version":[{"id":18202,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/8743\/revisions\/18202"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=8743"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=8743"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=8743"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}