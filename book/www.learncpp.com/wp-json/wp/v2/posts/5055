{"id":5055,"date":"2016-11-23T14:59:48","date_gmt":"2016-11-23T22:59:48","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=5055"},"modified":"2025-02-19T16:58:35","modified_gmt":"2025-02-20T00:58:35","slug":"chapter-25-summary-and-quiz","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-25-summary-and-quiz\/","title":{"rendered":"25.x &#8212; Chapter 25 summary and quiz"},"content":{"rendered":"<p>And so our journey through C++&#8217;s inheritance and virtual functions comes to an end.  Fret not, dear reader, for there are plenty of other areas of C++ to explore as we move forward.<\/p>\n<p><strong>Chapter summary<\/strong><\/p>\n<p>C++ allows you to set base class pointers and references to a derived object.  This is useful when we want to write a function or array that can work with any type of object derived from a base class.<\/p>\n<p>Without virtual functions, base class pointers and references to a derived class will only have access to base class member variables and versions of functions.<\/p>\n<p>A virtual function is a special type of function that resolves to the most-derived version of the function (called an override) that exists between the base and derived class.  To be considered an override, the derived class function must have the same signature and return type as the virtual base class function.  The one exception is for covariant return types, which allow an override to return a pointer or reference to a derived class if the base class function returns a pointer or reference to the base class.<\/p>\n<p>A function that is intended to be an override should use the override specifier to ensure that it is actually an override.<\/p>\n<p>The final specifier can be used to prevent overrides of a function or inheritance from a class.<\/p>\n<p>If you intend to use inheritance, you should make your destructor virtual, so the proper destructor is called if a pointer to the base class is deleted.<\/p>\n<p>You can ignore virtual resolution by using the scope resolution operator to directly specify which class&#8217;s version of the function you want: e.g. <code>base.Base::getName()<\/code>.<\/p>\n<p>Early binding occurs when the compiler encounters a direct function call.  The compiler or linker can resolve these function calls directly.  Late binding occurs when a function pointer is called.  In these cases, which function will be called can not be resolved until runtime.  Virtual functions use late binding and a virtual table to determine which version of the function to call.<\/p>\n<p>Using virtual functions has a cost: virtual functions take longer to call, and the necessity of the virtual table increases the size of every object containing a virtual function by one pointer.<\/p>\n<p>A virtual function can be made pure virtual\/abstract by adding &#8220;= 0&#8221; to the end of the virtual function prototype.  A class containing a pure virtual function is called an abstract class, and can not be instantiated.  A class that inherits pure virtual functions must concretely define them or it will also be considered abstract.  Pure virtual functions can have a body, but they are still considered abstract.<\/p>\n<p>An interface class is one with no member variables and all pure virtual functions.  These are often named starting with a capital I.<\/p>\n<p>A virtual base class is a base class that is only included once, no matter how many times it is inherited by an object.<\/p>\n<p>When a derived class is assigned to a base class object, the base class only receives a copy of the base portion of the derived class.  This is called object slicing.<\/p>\n<p>Dynamic casting can be used to convert a pointer to a base class object into a pointer to a derived class object.  This is called downcasting.  A failed conversion will return a null pointer.<\/p>\n<p>The easiest way to overload operator&lt;&lt; for inherited classes is to write an overloaded operator&lt;&lt; for the most-base class, and then call a virtual member function to do the printing.<\/p>\n<p><strong>Quiz time<\/strong><\/p>\n<ol start=\"1\">\n<li>Each of the following programs has some kind of defect.  Inspect each program (visually, not by compiling) and determine what is wrong with the program.  The output of each program is supposed to be &#8220;Derived&#8221;.\n<\/li>\n<\/ol>\n<p>1a)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\nprotected:\r\n\tint m_value;\r\n\r\npublic:\r\n\tBase(int value)\r\n\t\t: m_value{ value }\r\n\t{\r\n\t}\r\n\r\n\tconst char* getName() const { return \"Base\"; }\r\n};\r\n\r\nclass Derived : public Base\r\n{\r\npublic:\r\n\tDerived(int value)\r\n\t\t: Base{ value }\r\n\t{\r\n\t}\r\n\r\n\tconst char* getName() const { return \"Derived\"; }\r\n};\r\n\r\nint main()\r\n{\r\n\tDerived d{ 5 };\r\n\tBase&amp; b{ d };\r\n\tstd::cout &lt;&lt; b.getName() &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n Base::getName() wasn&#8217;t made virtual, so b.getName() doesn&#8217;t resolve to Derived::getName().<\/div>\n<p>1b)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\nprotected:\r\n\tint m_value;\r\n\r\npublic:\r\n\tBase(int value)\r\n\t\t: m_value{ value }\r\n\t{\r\n\t}\r\n\r\n\tvirtual const char* getName() { return \"Base\"; }\r\n};\r\n\r\nclass Derived : public Base\r\n{\r\npublic:\r\n\tDerived(int value)\r\n\t\t: Base{ value }\r\n\t{\r\n\t}\r\n\r\n\tvirtual const char* getName() const { return \"Derived\"; }\r\n};\r\n\r\nint main()\r\n{\r\n\tDerived d{ 5 };\r\n\tBase&amp; b{ d };\r\n\tstd::cout &lt;&lt; b.getName() &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\nBase::getName() is non-const and Derived::getName() is const, so Derived::getName() is not considered an override.<\/div>\n<p>1c)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\nprotected:\r\n\tint m_value;\r\n\r\npublic:\r\n\tBase(int value)\r\n\t\t: m_value{ value }\r\n\t{\r\n\t}\r\n\r\n\tvirtual const char* getName() { return \"Base\"; }\r\n};\r\n\r\nclass Derived : public Base\r\n{\r\npublic:\r\n\tDerived(int value)\r\n\t\t: Base{ value }\r\n\t{\r\n\t}\r\n\r\n\tconst char* getName() override { return \"Derived\"; }\r\n};\r\n\r\nint main()\r\n{\r\n\tDerived d{ 5 };\r\n\tBase b{ d };\r\n\tstd::cout &lt;&lt; b.getName() &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\nd was assigned to b by value, causing d to get sliced.<\/div>\n<p>1d)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base final\r\n{\r\nprotected:\r\n\tint m_value;\r\n\r\npublic:\r\n\tBase(int value)\r\n\t\t: m_value{ value }\r\n\t{\r\n\t}\r\n\r\n\tvirtual const char* getName() { return \"Base\"; }\r\n};\r\n\r\nclass Derived : public Base\r\n{\r\npublic:\r\n\tDerived(int value)\r\n\t\t: Base{ value }\r\n\t{\r\n\t}\r\n\r\n\tconst char* getName() override { return \"Derived\"; }\r\n};\r\n\r\nint main()\r\n{\r\n\tDerived d{ 5 };\r\n\tBase&amp; b{ d };\r\n\tstd::cout &lt;&lt; b.getName() &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\nBase was declared as final, so Derived can&#8217;t be derived from it.  This will cause a compile error.<\/div>\n<p>1e)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\nprotected:\r\n\tint m_value;\r\n\r\npublic:\r\n\tBase(int value)\r\n\t\t: m_value{ value }\r\n\t{\r\n\t}\r\n\r\n\tvirtual const char* getName() { return \"Base\"; }\r\n};\r\n\r\nclass Derived : public Base\r\n{\r\npublic:\r\n\tDerived(int value)\r\n\t\t: Base{ value }\r\n\t{\r\n\t}\r\n\r\n\tvirtual const char* getName() = 0;\r\n};\r\n\r\nconst char* Derived::getName()\r\n{\r\n\treturn \"Derived\";\r\n}\r\n\r\nint main()\r\n{\r\n\tDerived d{ 5 };\r\n\tBase&amp; b{ d };\r\n\tstd::cout &lt;&lt; b.getName() &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\nDerived::getName() is a pure virtual function (with a body), and therefore Derived is an abstract class that can&#8217;t be instantiated.<\/div>\n<p>1f)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\nprotected:\r\n\tint m_value;\r\n\r\npublic:\r\n\tBase(int value)\r\n\t\t: m_value{ value }\r\n\t{\r\n\t}\r\n\r\n\tvirtual const char* getName() { return \"Base\"; }\r\n};\r\n\r\nclass Derived : public Base\r\n{\r\npublic:\r\n\tDerived(int value)\r\n\t\t: Base{ value }\r\n\t{\r\n\t}\r\n\r\n\tvirtual const char* getName() { return \"Derived\"; }\r\n};\r\n\r\nint main()\r\n{\r\n\tauto* d{ new Derived(5) };\r\n\tBase* b{ d };\r\n\tstd::cout &lt;&lt; b-&gt;getName() &lt;&lt; '\\n';\r\n\tdelete b;\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_5'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_5\" style=\"display:none\">\nThis program actually produces the right output, but has a different issue.  We&#8217;re deleting b, which is a Base pointer, but we never added a virtual destructor to the Base class.  Consequently, the program only deletes the Base portion of the Derived object, and the Derived portion is left as leaked memory.<\/div>\n<p>2a) Create an abstract class named Shape.  This class should have three functions: a pure virtual print function that takes and returns a std::ostream&#038;, an overloaded operator&lt;&lt; and an empty virtual destructor.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_6'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_6\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Shape\r\n{\r\npublic:\r\n\tvirtual std::ostream&amp; print(std::ostream&amp; out) const = 0;\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Shape&amp; p)\r\n\t{\r\n\t\treturn p.print(out);\r\n\t}\r\n\tvirtual ~Shape() = default;\r\n};<\/code><\/pre>\n<\/div>\n<p>2b) Derive two classes from Shape: a Triangle, and a Circle.  The Triangle should have 3 Points as members.  The Circle should have one center Point, and an integer radius.  Override the print() function so the following program runs:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    Circle c{ Point{ 1, 2 }, 7 };\r\n    std::cout &lt;&lt; c &lt;&lt; '\\n';\r\n\r\n    Triangle t{Point{ 1, 2 }, Point{ 3, 4 }, Point{ 5, 6 }};\r\n    std::cout &lt;&lt; t &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This should print:<\/p>\n<pre>\nCircle(Point(1, 2), radius 7)\r\nTriangle(Point(1, 2), Point(3, 4), Point(5, 6))\r\n<\/pre>\n<p>Here&#8217;s a Point class you can use:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Point\r\n{\r\nprivate:\r\n\tint m_x{};\r\n\tint m_y{};\r\n\r\npublic:\r\n\tPoint(int x, int y)\r\n\t\t: m_x{ x }, m_y{ y }\r\n\t{\r\n\r\n\t}\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Point&amp; p)\r\n\t{\r\n\t\treturn out &lt;&lt; \"Point(\" &lt;&lt; p.m_x &lt;&lt; \", \" &lt;&lt; p.m_y &lt;&lt; ')';\r\n\t}\r\n};<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_7'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_7\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Point\r\n{\r\nprivate:\r\n\tint m_x{};\r\n\tint m_y{};\r\n\r\npublic:\r\n\tPoint(int x, int y)\r\n\t\t: m_x{ x }, m_y{ y }\r\n\t{\r\n\r\n\t}\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Point&amp; p)\r\n\t{\r\n\t\treturn out &lt;&lt; \"Point(\" &lt;&lt; p.m_x &lt;&lt; \", \" &lt;&lt; p.m_y &lt;&lt; ')';\r\n\t}\r\n};\r\n\r\nclass Shape\r\n{\r\npublic:\r\n\tvirtual std::ostream&amp; print(std::ostream&amp; out) const = 0;\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Shape&amp; p)\r\n\t{\r\n\t\treturn p.print(out);\r\n\t}\r\n\tvirtual ~Shape() = default;\r\n};\r\n\r\nclass Triangle : public Shape\r\n{\r\nprivate:\r\n\tPoint m_p1;\r\n\tPoint m_p2;\r\n\tPoint m_p3;\r\n\r\npublic:\r\n\tTriangle(const Point&amp; p1, const Point&amp; p2, const Point&amp; p3)\r\n\t\t: m_p1{ p1 }, m_p2{ p2 }, m_p3{ p3 }\r\n\t{\r\n\t}\r\n\r\n\tstd::ostream&amp; print(std::ostream&amp; out) const override\r\n\t{\r\n\t\treturn out &lt;&lt; \"Triangle(\" &lt;&lt; m_p1 &lt;&lt; \", \" &lt;&lt; m_p2 &lt;&lt; \", \" &lt;&lt; m_p3 &lt;&lt; ')';\r\n\t}\r\n};\r\n\r\nclass Circle : public Shape\r\n{\r\nprivate:\r\n\tPoint m_center;\r\n\tint m_radius;\r\n\r\npublic:\r\n\tCircle(const Point&amp; center, int radius)\r\n\t\t: m_center{ center }, m_radius{ radius }\r\n\t{\r\n\t}\r\n\r\n\tstd::ostream&amp; print(std::ostream&amp; out) const override\r\n\t{\r\n\t\treturn out &lt;&lt; \"Circle(\" &lt;&lt; m_center &lt;&lt; \", radius \" &lt;&lt; m_radius &lt;&lt; ')';\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tCircle c{ Point{ 1, 2 }, 7 };\r\n\tstd::cout &lt;&lt; c &lt;&lt; '\\n';\r\n\r\n\tTriangle t{ Point{ 1, 2 }, Point{ 3, 4 }, Point{ 5, 6 } };\r\n\tstd::cout &lt;&lt; t &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>2c) Given the above classes (Point, Shape, Circle, and Triangle), finish the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;vector&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tstd::vector&lt;Shape*&gt; v{\r\n\t  new Circle{Point{ 1, 2 }, 7},\r\n\t  new Triangle{Point{ 1, 2 }, Point{ 3, 4 }, Point{ 5, 6 }},\r\n\t  new Circle{Point{ 7, 8 }, 3}\r\n\t};\r\n\r\n\t\/\/ print each shape in vector v on its own line here\r\n\r\n\tstd::cout &lt;&lt; \"The largest radius is: \" &lt;&lt; getLargestRadius(v) &lt;&lt; '\\n'; \/\/ write this function\r\n\r\n\t\/\/ delete each element in the vector here\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>The program should print the following:<\/p>\n<pre>\nCircle(Point(1, 2), radius 7)\r\nTriangle(Point(1, 2), Point(3, 4), Point(5, 6))\r\nCircle(Point(7, 8), radius 3)\r\nThe largest radius is: 7\r\n<\/pre>\n<p>Hint: You&#8217;ll need to add a getRadius() function to Circle, and downcast a Shape* into a Circle* to access it.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_8'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_8\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;vector&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt; \/\/ for std::max\r\n\r\nclass Point\r\n{\r\nprivate:\r\n\tint m_x{};\r\n\tint m_y{};\r\n\r\npublic:\r\n\tPoint(int x, int y)\r\n\t\t: m_x{ x }, m_y{ y }\r\n\t{\r\n\r\n\t}\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Point&amp; p)\r\n\t{\r\n\t\treturn out &lt;&lt; \"Point(\" &lt;&lt; p.m_x &lt;&lt; \", \" &lt;&lt; p.m_y &lt;&lt; ')';\r\n\t}\r\n};\r\n\r\nclass Shape\r\n{\r\npublic:\r\n\tvirtual std::ostream&amp; print(std::ostream&amp; out) const = 0;\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Shape&amp; p)\r\n\t{\r\n\t\treturn p.print(out);\r\n\t}\r\n\tvirtual ~Shape() = default;\r\n};\r\n\r\nclass Triangle : public Shape\r\n{\r\nprivate:\r\n\tPoint m_p1;\r\n\tPoint m_p2;\r\n\tPoint m_p3;\r\n\r\npublic:\r\n\tTriangle(const Point&amp; p1, const Point&amp; p2, const Point&amp; p3)\r\n\t\t: m_p1{ p1 }, m_p2{ p2 }, m_p3{ p3 }\r\n\t{\r\n\t}\r\n\r\n\tstd::ostream&amp; print(std::ostream&amp; out) const override\r\n\t{\r\n\t\treturn out &lt;&lt; \"Triangle(\" &lt;&lt; m_p1 &lt;&lt; \", \" &lt;&lt; m_p2 &lt;&lt; \", \" &lt;&lt; m_p3 &lt;&lt; ')';\r\n\t}\r\n};\r\n\r\n\r\nclass Circle : public Shape\r\n{\r\nprivate:\r\n\tPoint m_center;\r\n\tint m_radius{};\r\n\r\npublic:\r\n\tCircle(const Point&amp; center, int radius)\r\n\t\t: m_center{ center }, m_radius{ radius }\r\n\t{\r\n\t}\r\n\r\n\tstd::ostream&amp; print(std::ostream&amp; out) const override\r\n\t{\r\n\t\tout &lt;&lt; \"Circle(\" &lt;&lt; m_center &lt;&lt; \", radius \" &lt;&lt; m_radius &lt;&lt; ')';\r\n\t\treturn out;\r\n\t}\r\n\r\n\tint getRadius() const { return m_radius; }\r\n};\r\n\r\n\/\/ h\/t to reader Olivier for this updated solution\r\n\/\/ assumes radiuses are &gt;= 0\r\nint getLargestRadius(const std::vector&lt;Shape*&gt;&amp; v)\r\n{\r\n\tint largestRadius{ 0 };\r\n\r\n\t\/\/ Loop through all the shapes in the vector\r\n\tfor (const auto* element : v)\r\n\t{\r\n\t\t\/\/ \/\/ Ensure the dynamic cast succeeds by checking for a null pointer result\r\n\t\tif (auto* c { dynamic_cast&lt;const Circle*&gt;(element) })\r\n\t\t{\r\n\t\t\tlargestRadius = std::max(largestRadius, c-&gt;getRadius());\r\n\t\t}\r\n\t}\r\n\r\n\treturn largestRadius;\r\n}\r\nint main()\r\n{\r\n\tstd::vector&lt;Shape*&gt; v{\r\n\t\t  new Circle{Point{ 1, 2 }, 7},\r\n\t\t  new Triangle{Point{ 1, 2 }, Point{ 3, 4 }, Point{ 5, 6 }},\r\n\t\t  new Circle{Point{ 7, 8 }, 3}\r\n\t};\r\n\r\n\tfor (const auto* element : v) \/\/ element will be a Shape*\r\n\t\tstd::cout &lt;&lt; *element &lt;&lt; '\\n';\r\n\r\n\tstd::cout &lt;&lt; \"The largest radius is: \" &lt;&lt; getLargestRadius(v) &lt;&lt; '\\n';\r\n\r\n\tfor (const auto* element : v)\r\n\t\tdelete element;\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>2d) Extra credit: Update the prior solution to use a <code>std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt;<\/code>.  Remember that <code>std::unique_ptr<\/code> is not copyable.<\/p>\n<p>h\/t to reader surrealcereal for this idea.<\/p>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_0'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_0\" style=\"display:none; margin-bottom: 1em\">Hint: You can&#8217;t initialize the vector using a std::initializer_list, since this requires elements to be copied.<\/div>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_1'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_1\" style=\"display:none; margin-bottom: 1em\">Hint: std::unique_ptr::get() returns a pointer to the managed element.<\/div>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_9'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_9\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;vector&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;algorithm&gt; \/\/ for std::max\r\n#include &lt;memory&gt;\r\n\r\nclass Point\r\n{\r\nprivate:\r\n\tint m_x{};\r\n\tint m_y{};\r\n\r\npublic:\r\n\tPoint(int x, int y)\r\n\t\t: m_x{ x }, m_y{ y }\r\n\t{\r\n\r\n\t}\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Point&amp; p)\r\n\t{\r\n\t\treturn out &lt;&lt; \"Point(\" &lt;&lt; p.m_x &lt;&lt; \", \" &lt;&lt; p.m_y &lt;&lt; ')';\r\n\t}\r\n};\r\n\r\nclass Shape\r\n{\r\npublic:\r\n\tvirtual std::ostream&amp; print(std::ostream&amp; out) const = 0;\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Shape&amp; p)\r\n\t{\r\n\t\treturn p.print(out);\r\n\t}\r\n\tvirtual ~Shape() = default;\r\n};\r\n\r\nclass Triangle : public Shape\r\n{\r\nprivate:\r\n\tPoint m_p1;\r\n\tPoint m_p2;\r\n\tPoint m_p3;\r\n\r\npublic:\r\n\tTriangle(const Point&amp; p1, const Point&amp; p2, const Point&amp; p3)\r\n\t\t: m_p1{ p1 }, m_p2{ p2 }, m_p3{ p3 }\r\n\t{\r\n\t}\r\n\r\n\tstd::ostream&amp; print(std::ostream&amp; out) const override\r\n\t{\r\n\t\treturn out &lt;&lt; \"Triangle(\" &lt;&lt; m_p1 &lt;&lt; \", \" &lt;&lt; m_p2 &lt;&lt; \", \" &lt;&lt; m_p3 &lt;&lt; ')';\r\n\t}\r\n};\r\n\r\n\r\nclass Circle : public Shape\r\n{\r\nprivate:\r\n\tPoint m_center;\r\n\tint m_radius{};\r\n\r\npublic:\r\n\tCircle(const Point&amp; center, int radius)\r\n\t\t: m_center{ center }, m_radius{ radius }\r\n\t{\r\n\t}\r\n\r\n\tstd::ostream&amp; print(std::ostream&amp; out) const override\r\n\t{\r\n\t\tout &lt;&lt; \"Circle(\" &lt;&lt; m_center &lt;&lt; \", radius \" &lt;&lt; m_radius &lt;&lt; ')';\r\n\t\treturn out;\r\n\t}\r\n\r\n\tint getRadius() const { return m_radius; }\r\n};\r\n\r\nint getLargestRadius(const std::vector&lt;std::unique_ptr&lt;Shape&gt;&gt;&amp; v)\r\n{\r\n\tint largestRadius{ 0 };\r\n\r\n\t\/\/ Loop through all the shapes in the vector\r\n\tfor (const auto&amp; element : v)\r\n\t{\r\n\t\t\/\/ \/\/ Ensure the dynamic cast succeeds by checking for a null pointer result\r\n\t\tif (auto *c { dynamic_cast&lt;const Circle*&gt;(element.get()) })\r\n\t\t{\r\n\t\t\tlargestRadius = std::max(largestRadius, c-&gt;getRadius());\r\n\t\t}\r\n\t}\r\n\r\n\treturn largestRadius;\r\n}\r\nint main()\r\n{\r\n\tstd::vector&lt;std::unique_ptr&lt;Shape&gt;&gt; v;\r\n\tv.reserve(3);\r\n\tv.push_back(std::make_unique&lt;Circle&gt;(Point{1, 2}, 7));\r\n\tv.push_back(std::make_unique&lt;Triangle&gt;(Point{1, 2}, Point{3, 4}, Point{5, 6}));\r\n\tv.push_back(std::make_unique&lt;Circle&gt;(Point{7, 8}, 3));\r\n\r\n\tfor (const auto&amp; element : v) std::cout &lt;&lt; *element &lt;&lt; '\\n';\r\n    \r\n\tstd::cout &lt;&lt; \"The largest radius is: \" &lt;&lt; getLargestRadius(v) &lt;&lt; '\\n';\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/template-classes\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">26.1<\/span>Template classes\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/printing-inherited-classes-using-operator\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">25.11<\/span>Printing inherited classes using operator&lt;&lt;\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>And so our journey through C++&#8217;s inheritance and virtual functions comes to an end. Fret not, dear reader, for there are plenty of other areas of C++ to explore as we move forward. Chapter summary C++ allows you to set base class pointers and references to a derived object. This &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5055"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=5055"}],"version-history":[{"count":44,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5055\/revisions"}],"predecessor-version":[{"id":18213,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5055\/revisions\/18213"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=5055"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=5055"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=5055"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}