{"id":15426,"date":"2023-09-11T15:50:33","date_gmt":"2023-09-11T22:50:33","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15426"},"modified":"2023-10-14T13:25:09","modified_gmt":"2023-10-14T20:25:09","slug":"arrays-of-references-via-stdreference_wrapper","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/arrays-of-references-via-stdreference_wrapper\/","title":{"rendered":"17.5 &#8212; Arrays of references via std::reference_wrapper"},"content":{"rendered":"<p>In the prior lesson, we mentioned that arrays can have elements of any object type.  This includes objects with fundamental types (e.g. int) and objects with compound types (e.g. pointer to int).<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    int x { 1 };\r\n    int y { 2 };\r\n\r\n    [[maybe_unused]] std::array valarr { x, y };   \/\/ an array of int values\r\n    [[maybe_unused]] std::vector ptrarr { &amp;x, &amp;y }; \/\/ a vector of int pointers\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, because references are not objects, you cannot make an array of references.  The elements of an array must also be assignable, and references can&#8217;t be reseated.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 1 };\r\n    int y { 2 };\r\n\r\n    [[maybe_unused]] std::array&lt;int&amp;, 2&gt; refarr { x, y }; \/\/ compile error: cannot define array of references\r\n\r\n    int&amp; ref1 { x };\r\n    int&amp; ref2 { y };\r\n    [[maybe_unused]] std::array valarr { ref1, ref2 }; \/\/ ok: this is actually a std::array&lt;int, 2&gt;, not an array of references\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this lesson, we&#8217;ll use <code>std::array<\/code> in the examples, but this is equally applicable to all array types.<\/p>\n<p>However, if you want an array of references, there is a workaround.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">std::reference_wrapper<\/p>\n<p><code>std::reference_wrapper<\/code> is a standard library class template that lives in the &lt;functional&gt; header.  It takes a type template argument T, and then behaves like a modifiable lvalue reference to T.<\/p>\n<p>There are a few things worth noting about <code>std::reference_wrapper<\/code>:<\/p>\n<ul>\n<li><code>Operator=<\/code> will reseat a <code>std::reference_wrapper<\/code> (change which object is being referenced).\n<\/li>\n<li><code>std::reference_wrapper&lt;T&gt;<\/code> will implicitly convert to <code>T&amp;<\/code>.\n<\/li>\n<li>The <code>get()<\/code> member function can be used to get a <code>T&amp;<\/code>.  This is useful when we want to update the value of the object being referenced.\n<\/li>\n<\/ul>\n<p>Here&#8217;s a simple example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;functional&gt; \/\/ for std::reference_wrapper\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 1 };\r\n    int y { 2 };\r\n    int z { 3 };\r\n\r\n    std::array&lt;std::reference_wrapper&lt;int&gt;, 3&gt; arr { x, y, z };\r\n    \r\n    arr[1].get() = 5; \/\/ modify the object in array element 1\r\n\r\n    std::cout &lt;&lt; arr[1] &lt;&lt; y &lt;&lt; '\\n'; \/\/ show that we modified arr[1] and y, prints 55\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>This example prints the following:<\/p>\n<pre>\n55\r\n<\/pre>\n<p>Note that we must use <code>arr[1].get() = 5<\/code> and not <code>arr[1] = 5<\/code>.  The latter is ambiguous, as the compiler can&#8217;t tell if we intend to reseat the <code>std::reference_wrapper&lt;int&gt;<\/code> to value 5 (something that is illegal anyway) or change the value being referenced.  Using <code>get()<\/code> disambiguates this.<\/p>\n<p>When printing <code>arr[1]<\/code>, the compiler will realize it can&#8217;t print a <code>std::reference_wrapper&lt;int&gt;<\/code>, so it will implicitly convert it to an <code>int&amp;<\/code>, which it can print.  So we don&#8217;t need to use <code>get()<\/code> here.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><code>std::ref<\/code> and <code>std::cref<\/code><\/p>\n<p>Prior to C++17, CTAD (class template argument deduction) didn&#8217;t exist, so all template arguments for a class type needed to be listed explicitly.  Thus, to create a <code>std::reference_wrapper&lt;int&gt;<\/code>, you could do either of these:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    int x { 5 };\r\n\r\n    std::reference_wrapper&lt;int&gt; ref1 { x };        \/\/ C++11\r\n    auto ref2 { std::reference_wrapper&lt;int&gt;{ x }}; \/\/ C++11<\/code><\/pre>\n<p>Between the long name and having to explicitly list the template arguments, creating many such reference wrappers could be a pain.<\/p>\n<p>To make things easier, the <code>std::ref()<\/code> and <code>std::cref()<\/code> functions were provided as shortcuts to create <code>std::reference_wrapper<\/code> and <code>const std::reference_wrapper<\/code> wrapped objects.  Note that these functions can be used with <code>auto<\/code> to avoid having to explicitly specify the template argument.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    int x { 5 };\r\n    auto ref { std::ref(x) };   \/\/ C++11, deduces to std::reference_wrapper&lt;int&gt;\r\n    auto cref { std::cref(x) }; \/\/ C++11, deduces to std::reference_wrapper&lt;const int&gt;<\/code><\/pre>\n<p>Of course, now that we have CTAD in C++17, we can also do this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    std::reference_wrapper ref1 { x };        \/\/ C++17\r\n    auto ref2 { std::reference_wrapper{ x }}; \/\/ C++17<\/code><\/pre>\n<p>But since <code>std::ref()<\/code> and <code>std::cref()<\/code> are shorter to type, they are still widely used to create <code>std::reference_wrapper<\/code> objects.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdarray-and-enumerations\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.6<\/span>std::array and enumerations\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdarray-of-class-types-and-brace-elision\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.4<\/span>std::array of class types, and brace elision\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the prior lesson, we mentioned that arrays can have elements of any object type. This includes objects with fundamental types (e.g. int) and objects with compound types (e.g. pointer to int). #include &lt;array&gt; #include &lt;iostream&gt; #include &lt;vector&gt; int main() { int x { 1 }; int y { 2 &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15426"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15426"}],"version-history":[{"count":6,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15426\/revisions"}],"predecessor-version":[{"id":15929,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15426\/revisions\/15929"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15426"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15426"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15426"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}