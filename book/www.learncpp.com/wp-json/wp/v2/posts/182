{"id":182,"date":"2008-02-07T15:46:43","date_gmt":"2008-02-07T23:46:43","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/124-early-binding-and-late-binding\/"},"modified":"2024-10-20T15:18:11","modified_gmt":"2024-10-20T22:18:11","slug":"early-binding-and-late-binding","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/early-binding-and-late-binding\/","title":{"rendered":"25.5 &#8212; Early binding and late binding"},"content":{"rendered":"<p>In this lesson and the next, we are going to take a closer look at how virtual functions are implemented.  While this information is not strictly necessary to effectively use virtual functions, it is interesting.  Nevertheless, you can consider both sections optional reading.<\/p>\n<p>When a C++ program is executed, it executes sequentially, beginning at the top of <code>main()<\/code>.  When a function call is encountered, the point of execution jumps to the beginning of the function being called.  How does the CPU know to do this?<\/p>\n<p>When a program is compiled, the compiler converts each statement in your C++ program into one or more lines of machine language.  Each line of machine language is given its own unique sequential address.  This is no different for functions -- when a function is encountered, it is converted into machine language and given the next available address.  Thus, each function ends up with a unique address.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Binding and dispatching<\/p>\n<p>Our programs contain many names (identifiers, keywords, etc&#8230;).  Each name has a set of associated properties: for example, if the name represents a variable, that variable has a type, a value, a memory address, etc&#8230;  <\/p>\n<p>For example, when we say <code>int x<\/code>, we&#8217;re telling the compiler to associate the name <code>x<\/code> with the type <code>int<\/code>.  Later if we say <code>x = 5<\/code>, the compiler can use this association to type check the assignment to ensure it is valid.<\/p>\n<p>In general programming, <strong>binding<\/strong> is the process of associating names with such properties.  <strong>Function binding<\/strong> (or <strong>method binding<\/strong>) is the process that determines what function definition is associated with a function call.  The process of actually invoking a bound function is called <strong>dispatching<\/strong>.<\/p>\n<p>In C++, the term binding is used more casually (and dispatching is usually considered part of binding).  We&#8217;ll explore the C++ use of the terms below.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Nomenclature<\/p>\n<p>Binding is an overloaded term.  In other contexts, binding may refer to:<\/p>\n<ul>\n<li>The binding of a reference to an object\n<\/li>\n<li><code>std::bind<\/code>\n<\/li>\n<li>Language binding\n<\/li>\n<\/ul>\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Early binding<\/p>\n<p>Most of the function calls the compiler encounters will be direct function calls.  A direct function call is a statement that directly calls a function.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Foo\r\n{\r\n    void printValue(int value)\r\n    {\r\n        std::cout &lt;&lt; value;\r\n    }\r\n};\r\n\r\nvoid printValue(int value)\r\n{\r\n    std::cout &lt;&lt; value;\r\n}\r\n\r\nint main()\r\n{\r\n    printValue(5);   \/\/ direct function call to printValue(int)\r\n\r\n    Foo f{};\r\n    f.printValue(5); \/\/ direct function call to Foo::printValue(int)\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In C++, when a direct call is made to a non-member function or a non-virtual member function, the compiler can determine which function definition should be matched to the call.  This is sometimes called <strong>early binding<\/strong> (or <strong>static binding<\/strong>), as it can be performed at compile-time.  The compiler (or linker) can then generate machine language instructions that tells the CPU to jump directly to the address of the function.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>If we look at the assembly code generated for the call to <code>printValue(5)<\/code> (using clang x86-64), we see something like this:<\/p>\n<pre>\n        mov     edi, 5           ; copy argument 5 into edi register in preparation for function call\r\n        call    printValue(int)  ; directly call printValue(int)\r\n<\/pre>\n<p>You can clearly see that this is a direct function call to printValue(int).\n<\/p><\/div>\n<p>Calls to overloaded functions and function templates can also be resolved at compile-time:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nvoid printValue(T value)\r\n{\r\n    std::cout &lt;&lt; value &lt;&lt; '\\n';\r\n}\r\n\r\nvoid printValue(double value)\r\n{\r\n    std::cout &lt;&lt; value &lt;&lt; '\\n';\r\n}\r\n\r\nvoid printValue(int value)\r\n{\r\n    std::cout &lt;&lt; value &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    printValue(5);   \/\/ direct function call to printValue(int)\r\n    printValue&lt;&gt;(5); \/\/ direct function call to printValue&lt;int&gt;(int)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Let&#8217;s take a look at a simple calculator program that uses early binding:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y)\r\n{\r\n    return x + y;\r\n}\r\n\r\nint subtract(int x, int y)\r\n{\r\n    return x - y;\r\n}\r\n\r\nint multiply(int x, int y)\r\n{\r\n    return x * y;\r\n}\r\n\r\nint main()\r\n{\r\n    int x{};\r\n    std::cout &lt;&lt; \"Enter a number: \";\r\n    std::cin &gt;&gt; x;\r\n\r\n    int y{};\r\n    std::cout &lt;&lt; \"Enter another number: \";\r\n    std::cin &gt;&gt; y;\r\n\r\n    int op{};\r\n    std::cout &lt;&lt; \"Enter an operation (0=add, 1=subtract, 2=multiply): \";\r\n    std::cin &gt;&gt; op;\r\n\r\n    int result {};\r\n    switch (op)\r\n    {\r\n        \/\/ call the target function directly using early binding\r\n        case 0: result = add(x, y); break;\r\n        case 1: result = subtract(x, y); break;\r\n        case 2: result = multiply(x, y); break;\r\n        default:\r\n            std::cout &lt;&lt; \"Invalid operator\\n\";\r\n            return 1;\r\n    }\r\n\r\n    std::cout &lt;&lt; \"The answer is: \" &lt;&lt; result &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because <code>add()<\/code>, <code>subtract()<\/code>, and <code>multiply()<\/code> are all direct function calls to non-member functions, the compiler will match these function calls to their respective function definitions at compile-time.<\/p>\n<p>Note that because of the switch statement, which function is actually called is not determined until runtime.  However, that is a path of execution issue, not a binding issue.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Late binding<\/p>\n<p>In some cases, a function call can&#8217;t be resolved until runtime.  In C++, this is sometimes known as <strong>late binding<\/strong> (or in the case of virtual function resolution, <strong>dynamic dispatch<\/strong>).<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>In general programming terminology, the term &#8220;late binding&#8221; usually means that the function being called can&#8217;t be determined based on static type information alone, but must be resolved using dynamic type information.<\/p>\n<p>In C++, the term tends to be used more loosely to mean any function call where the actual function being called is not known by the compiler or linker at the point where the function call is actually being made.\n<\/p><\/div>\n<p>In C++, one way to get late binding is to use function pointers.  To review function pointers briefly, a function pointer is a type of pointer that points to a function instead of a variable.  The function that a function pointer points to can be called by using the function call operator <code>()<\/code> on the pointer.<\/p>\n<p>For example, the following code calls the <code>printValue()<\/code> function through a function pointer:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printValue(int value)\r\n{\r\n    std::cout &lt;&lt; value &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    auto fcn { printValue }; \/\/ create a function pointer and make it point to function printValue\r\n    fcn(5);                  \/\/ invoke printValue indirectly through the function pointer\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Calling a function via a function pointer is also known as an indirect function call.  At the point where <code>fcn(5)<\/code> is actually called, the compiler does not know at compile-time what function is being called.  Instead, at runtime, an indirect function call is made to whatever function exists at the address held by the function pointer.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>If we look at the assembly code generated for the call to <code>fcn(5)<\/code> (using clang x86-64), we see something like this:<\/p>\n<pre>\n        lea     rax, [rip + printValue(int)] ; determine address of printValue and place into rax register\r\n        mov     qword ptr [rbp - 8], rax     ; move value in rax register into memory associated with variable fcn\r\n\r\n        mov     edi, 5                       ; copy argument 5 into edi register in preparation for function call\r\n        call    qword ptr [rbp - 8]          ; invoke the function at the address held by variable fcn\r\n<\/pre>\n<p>You can clearly see that this is a indirect function call to printValue(int) via its address.\n<\/p><\/div>\n<p>The following calculator program is functionally identical to the calculator example above, except it uses a function pointer instead of a direct function call:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y)\r\n{\r\n    return x + y;\r\n}\r\n\r\nint subtract(int x, int y)\r\n{\r\n    return x - y;\r\n}\r\n\r\nint multiply(int x, int y)\r\n{\r\n    return x * y;\r\n}\r\n\r\nint main()\r\n{\r\n    int x{};\r\n    std::cout &lt;&lt; \"Enter a number: \";\r\n    std::cin &gt;&gt; x;\r\n\r\n    int y{};\r\n    std::cout &lt;&lt; \"Enter another number: \";\r\n    std::cin &gt;&gt; y;\r\n\r\n    int op{};\r\n    std::cout &lt;&lt; \"Enter an operation (0=add, 1=subtract, 2=multiply): \";\r\n    std::cin &gt;&gt; op;\r\n\r\n    using FcnPtr = int (*)(int, int); \/\/ alias ugly function pointer type\r\n    FcnPtr fcn { nullptr }; \/\/ create a function pointer object, set to nullptr initially\r\n\r\n    \/\/ Set fcn to point to the function the user chose\r\n    switch (op)\r\n    {\r\n        case 0: fcn = add; break;\r\n        case 1: fcn = subtract; break;\r\n        case 2: fcn = multiply; break;\r\n        default:\r\n            std::cout &lt;&lt; \"Invalid operator\\n\";\r\n            return 1;\r\n    }\r\n\r\n    \/\/ Call the function that fcn is pointing to with x and y as parameters\r\n    std::cout &lt;&lt; \"The answer is: \" &lt;&lt; fcn(x, y) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this example, instead of calling the <code>add()<\/code>, <code>subtract()<\/code>, or <code>multiply()<\/code> function directly, we&#8217;ve instead set <code>fcn<\/code> to point at the function we wish to call.  Then we call the function through the pointer.<\/p>\n<p>The compiler is unable to use early binding to resolve the function call <code>fcn(x, y)<\/code> because it can not tell which function <code>fcn<\/code> will be pointing to at compile time!<\/p>\n<p>Late binding is slightly less efficient since it involves an extra level of indirection.  With early binding, the CPU can jump directly to the function&#8217;s address.  With late binding, the program has to read the address held in the pointer and then jump to that address.  This involves one extra step, making it slightly slower.  However, the advantage of late binding is that it is more flexible than early binding, because decisions about what function to call do not need to be made until runtime.<\/p>\n<p>In the next lesson, we&#8217;ll take a look at how late binding is used to implement virtual functions.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/the-virtual-table\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">25.6<\/span>The virtual table\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/virtual-destructors-virtual-assignment-and-overriding-virtualization\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">25.4<\/span>Virtual destructors, virtual assignment, and overriding virtualization\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In this lesson and the next, we are going to take a closer look at how virtual functions are implemented. While this information is not strictly necessary to effectively use virtual functions, it is interesting. Nevertheless, you can consider both sections optional reading. When a C++ program is executed, it &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/182"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=182"}],"version-history":[{"count":20,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/182\/revisions"}],"predecessor-version":[{"id":5024,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/182\/revisions\/5024"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=182"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=182"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=182"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}