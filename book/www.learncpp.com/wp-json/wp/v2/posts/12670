{"id":12670,"date":"2022-02-18T13:56:24","date_gmt":"2022-02-18T21:56:24","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=12670"},"modified":"2024-08-26T00:10:30","modified_gmt":"2024-08-26T07:10:30","slug":"introduction-to-random-number-generation","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-random-number-generation\/","title":{"rendered":"8.13 &#8212; Introduction to random number generation"},"content":{"rendered":"<p>The ability to generate random numbers can be useful in certain kinds of programs, particularly in games, statistical modelling programs, and cryptographic applications that need to encrypt and decrypt things.  Take games for example -- without random events, monsters would always attack you the same way, you&#8217;d always find the same treasure, the dungeon layout would never change, etc&#8230; and that would not make for a very good game.<\/p>\n<p>In real life, we often produce randomization by doing things like flipping a coin, rolling a dice, or shuffling a deck of cards.  These events aren&#8217;t actually random, but involve so many physical variables (e.g. gravity, friction, air resistance, momentum, etc&#8230;) that they become almost impossible to predict or control, and (unless you&#8217;re a magician) produce results that are for all intents and purposes random.<\/p>\n<p>However, computers aren&#8217;t designed to take advantage of physical variables -- your computer can&#8217;t toss a coin, throw a dice, or shuffle real cards.  Modern computers live in a controlled electrical world where everything is binary (0 or 1) and there is no in-between.  By their very nature, computers are designed to produce results that are as predictable as possible.  When you tell the computer to calculate 2 + 2, you <em>always<\/em> want the answer to be 4.  Not 3 or 5 on occasion.<\/p>\n<p>Consequently, computers are generally incapable of generating truly random numbers (at least through software).  Instead, modern programs typically <em>simulate<\/em> randomness using an algorithm.<\/p>\n<p>In this lesson, we&#8217;ll cover a lot of the theory behind how random numbers are generated in programs, and introduce some terminology we&#8217;ll use in future lessons.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Algorithms and state<\/p>\n<p>First, let&#8217;s take a detour through the concepts of algorithms and states.<\/p>\n<p>An <strong>algorithm<\/strong> is a finite sequence of instructions that can be followed to solve some problem or produce some useful result.<\/p>\n<p>For example, let&#8217;s say your boss gives you a small text file containing a bunch of unsorted names (one per line), and asks you to sort the list.  Since the list is small, and you don&#8217;t expect to do this often, you decide to sort it by hand.  There are multiple ways to sort a list, but you might do something like this:<\/p>\n<ul>\n<li>Create a new empty list to hold the sorted results\n<\/li>\n<li>Scan the list of unsorted names to find the name that comes first alphabetically\n<\/li>\n<li>Cut that name out of the unsorted list and paste it at the bottom of the sorted list\n<\/li>\n<li>Repeat the previous two steps until there are no more names on the unsorted list\n<\/li>\n<\/ul>\n<p>The above set of steps describes a sorting algorithm (using natural language).  By nature, algorithms are reusable -- if your boss asks you to sort another list tomorrow, you can just apply the same algorithm to the new list.<\/p>\n<p>Because computers can execute instructions and manipulate data much more quickly than we can, algorithms are often written using programming languages, allowing us to automate tasks.  In C++, algorithms are typically implemented as reusable functions.<\/p>\n<p>Here&#8217;s a simple algorithm for generating a sequence of numbers where each successive number is incremented by 1:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint plusOne()\r\n{\r\n    static int s_state { 3 }; \/\/ only initialized the first time this function is called\r\n\r\n    \/\/ Generate the next number\r\n\r\n    ++s_state;      \/\/ first we modify the state\r\n    return s_state; \/\/ then we use the new state to generate the next number in the sequence\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; plusOne() &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; plusOne() &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; plusOne() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n4\r\n5\r\n6\r\n<\/pre>\n<p>This algorithm is pretty simple.  The first time we call <code>plusOne()<\/code>, <code>s_state<\/code> is initialized to value <code>3<\/code>.  Then the next number in the output sequence is generated and returned.<\/p>\n<p>An algorithm is considered to be <strong>stateful<\/strong> if it retains some information across calls.  Conversely, a <strong>stateless<\/strong> algorithm does not store any information (and must be given all the information it needs to work with whenever it is called).  Our <code>plusOne()<\/code> function is stateful, in that it uses the static variable <code>s_state<\/code> to store the last number that was generated.  When applied to algorithms, the term <strong>state<\/strong> refers to the current values held in stateful variables (those retained across calls).<\/p>\n<p>To generate the next number in the sequence, our algorithm uses a two step process:<\/p>\n<ul>\n<li>First, the current state (initialized from the start value, or preserved from the prior call) is modified to produce a new state.\n<\/li>\n<li>Then, the next number in the sequence is generated from the new state.\n<\/li>\n<\/ul>\n<p>Our algorithm is considered <strong>deterministic<\/strong>, meaning that for a given input (the value provided for <code>start<\/code>), it will always produce the same output sequence.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Pseudo-random number generators (PRNGs)<\/p>\n<p>To simulate randomness, programs typically use a pseudo-random number generator.  A <strong>pseudo-random number generator (PRNG)<\/strong> is an algorithm that generates a sequence of numbers whose properties simulate a sequence of random numbers.<\/p>\n<p>It&#8217;s easy to write a basic PRNG algorithm.  Here&#8217;s a short PRNG example that generates 100 16-bit pseudo-random numbers:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ For illustrative purposes only, don't use this\r\nunsigned int LCG16() \/\/ our PRNG\r\n{\r\n    static unsigned int s_state{ 0 }; \/\/ only initialized the first time this function is called\r\n\r\n    \/\/ Generate the next number\r\n\r\n    \/\/ We modify the state using large constants and intentional overflow to make it hard\r\n    \/\/ for someone to casually determine what the next number in the sequence will be.\r\n\r\n    s_state = 8253729 * s_state + 2396403; \/\/ first we modify the state\r\n    return s_state % 32768; \/\/ then we use the new state to generate the next number in the sequence\r\n}\r\n\r\nint main()\r\n{\r\n    \/\/ Print 100 random numbers\r\n    for (int count{ 1 }; count &lt;= 100; ++count)\r\n    {\r\n        std::cout &lt;&lt; LCG16() &lt;&lt; '\\t';\r\n\r\n        \/\/ If we've printed 10 numbers, start a new row\r\n        if (count % 10 == 0)\r\n            std::cout &lt;&lt; '\\n';\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The result of this program is:<\/p>\n<pre>\n4339\t838\t25337\t15372\t6783\t2642\t6021\t19992\t14859\t26462\t\r\n25105\t13860\t28567\t6762\t17053\t29744\t15139\t9078\t14633\t2108\t\r\n7343\t642\t17845\t29256\t5179\t14222\t26689\t12884\t8647\t17050\t\r\n8397\t18528\t17747\t9126\t28505\t13420\t32479\t23218\t21477\t30328\t\r\n20075\t26558\t20081\t3716\t13303\t19146\t24317\t31888\t12163\t982\t\r\n1417\t16540\t16655\t4834\t16917\t23208\t26779\t30702\t5281\t19124\t\r\n9767\t13050\t32045\t4288\t31155\t17414\t31673\t11468\t25407\t11026\t\r\n4165\t7896\t25291\t26654\t15057\t26340\t30807\t31530\t31581\t1264\t\r\n9187\t25654\t20969\t30972\t25967\t9026\t15989\t17160\t15611\t14414\t\r\n16641\t25364\t10887\t9050\t22925\t22816\t11795\t25702\t2073\t9516\t\r\n<\/pre>\n<p>Each number appears to be pretty random with respect to the previous one.<\/p>\n<p>Notice how similar <code>LCG16()<\/code> is to our <code>plusOne()<\/code> example above!  The state is initially set to value <code>0<\/code>.  Then to produce the next number in the output sequence, the current state is modified (by applying some mathematical operations) to produce a new state, and the next number in the sequence is generated from that new state.<\/p>\n<p>As it turns out, this particular algorithm isn&#8217;t very good as a random number generator (note how each result alternates between even and odd -- that&#8217;s not very random!).  But most PRNGs work similarly to <code>LCG16()<\/code> -- they just typically use more state variables and more complex mathematical operations in order to generate better quality results.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Seeding a PRNG<\/p>\n<p>The sequence of &#8220;random numbers&#8221; generated by a PRNG is not random at all.  Just like our <code>plusOne()<\/code> function, <code>LCG16()<\/code> is also deterministic.  Given some initial state value (such as <code>0<\/code>), a PRNG will generate the same sequence of numbers each time.  If you run the above program 3 times, you&#8217;ll see it generates the same sequence of values each time.<\/p>\n<p>In order to generate different output sequences, the initial state of a PRNG needs to be varied.  The value (or set of values) used to set the initial state of a PRNG is called a <strong>random seed<\/strong> (or <strong>seed<\/strong> for short).  When the initial state of a PRNG has been set using a seed, we say it has been <strong>seeded<\/strong>.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Because the initial state of the PRNG is set from the seed value(s), all of the values that a PRNG will produce are deterministically calculated from the seed value(s).\n<\/p><\/div>\n<p>The seed value is typically provided by the program using the PRNG.  Here&#8217;s a sample program that requests a seed value from the user and then generates 10 random numbers using that seed value (using our <code>LCG16()<\/code> function).<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nunsigned int g_state{ 0 };\r\n\r\nvoid seedPRNG(unsigned int seed)\r\n{\r\n    g_state = seed;\r\n}\r\n\r\n\/\/ For illustrative purposes only, don't use this\r\nunsigned int LCG16() \/\/ our PRNG\r\n{\r\n    \/\/ We modify the state using large constants and intentional overflow to make it hard\r\n    \/\/ for someone to casually determine what the next number in the sequence will be.\r\n\r\n    g_state = 8253729 * g_state + 2396403; \/\/ first we modify the state\r\n    return g_state % 32768; \/\/ then we use the new state to generate the next number in the sequence\r\n}\r\n\r\nvoid print10()\r\n{\r\n    \/\/ Print 10 random numbers\r\n    for (int count{ 1 }; count &lt;= 10; ++count)\r\n    {\r\n        std::cout &lt;&lt; LCG16() &lt;&lt; '\\t';\r\n    }   \r\n\r\n    std::cout &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    unsigned int x {};\r\n    std::cout &lt;&lt; \"Enter a seed value: \";\r\n    std::cin &gt;&gt; x;\r\n\r\n    seedPRNG(x); \/\/ seed our PRNG\r\n    print10();   \/\/ generate 10 random values\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Here are 3 sample runs from this:<\/p>\n<pre>\nEnter a seed value: 7\r\n10458\t3853\t16032\t17299\t10726\t32153\t19116\t7455\t242\t549\t\r\n<\/pre>\n<pre>\nEnter a seed value: 7\r\n10458\t3853\t16032\t17299\t10726\t32153\t19116\t7455\t242\t549\t\r\n<\/pre>\n<pre>\nEnter a seed value: 9876\r\n24071\t18138\t27917\t23712\t8595\t18406\t23449\t26796\t31519\t7922\t\r\n<\/pre>\n<p>Notice that when we provide the same seed value, we get the same output sequence.  If we provide a different seed value, we get a different output sequence.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Seed quality and underseeding<\/p>\n<p>If we want the program to produce different randomized numbers each time it is run, then we need some way to vary the seed each time the program is run.  Asking the user to provide a seed value isn&#8217;t great, since they can just enter the same value each time.  The program really needs some way to generate a randomized seed value each time it is run.  Unfortunately, we can&#8217;t use a PRNG to generate a random seed, because we need a randomized seed to generate random numbers.  Instead, we&#8217;ll typically use a seed generation algorithm that is designed to produce seed values.  We&#8217;ll discuss (and implement) such algorithms in the next lesson.<\/p>\n<p>The theoretical maximum number of unique sequences that a PRNG can generate is determined by the number of bits in the PRNG&#8217;s state.  For example, a PRNG with 128 bits of state can theoretically generate up to 2^128 (340,282,366,920,938,463,463,374,607,431,768,211,456) unique output sequences.  That&#8217;s a lot!<\/p>\n<p>However, which output sequence is <em>actually<\/em> generated depends on the initial state of the PRNG, which is determined by the seed.  Therefore, practically speaking, the number of unique output sequences a PRNG can <em>actually<\/em> generate is limited by the number of unique seed values the program using the PRNG can provide.  For example, if a particular seed generation algorithm can only generate 4 different seed values, then the PRNG will only be able to generate at most 4 different output sequences.<\/p>\n<p>If a PRNG is not provided with enough bits of quality seed data, we say that it is <strong>underseeded<\/strong>.  An underseeded PRNG may begin to produce randomized results whose quality is compromised in some way -- and the more severe the underseeding, the more the quality of the results will suffer.<\/p>\n<p>For example, an underseeded PRNG may exhibit any of the following issues:<\/p>\n<ul>\n<li>The random sequences generated by consecutive runs may have a high correlation to each other.\n<\/li>\n<li>On the generation of the Nth random number, some values will never be able to be generated.  For example, a Mersenne Twister that is underseeded in a particular way will never generate the values 7 or 13 as its first output.\n<\/li>\n<li>Someone may be able to guess the seed based on the initial random value produced (or the first few random values).  That would allow them to then generate all future random numbers that are going to be produced by the generator.  This may allow them to cheat or game the system.\n<\/li>\n<\/ul>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>An ideal seed should have the following characteristics:<\/p>\n<ul>\n<li>The seed should contain at least as many bits as the state of the PRNG, so that every bit in the state of the PRNG can be initialized by an independent bit in the seed.\n<\/li>\n<li>Each bit in the seed should be independently randomized.\n<\/li>\n<li>The seed should contain a good mix of 0 and 1s distributed across all of the bits.\n<\/li>\n<li>There should be no bits in the seed that are always 0 or always 1.  These &#8220;stuck bits&#8221; do not provide any value.\n<\/li>\n<li>The seed should have a low correlation with previously generated seeds.\n<\/li>\n<\/ul>\n<p>In practice, we may compromise on some of these characteristics.  Some PRNGs have huge states (e.g. the state of a Mersenne Twister has 19937 bits), and generating quality seeds that large can be difficult.  As a result, PRNGs with large states are often designed to be resilient to being seeded with fewer bits.  Stuck bits are also common.  For example, if we use the system clock as part of our seed, we&#8217;ll end up with some number of stuck bits, as the bits that represent larger time units (e.g. years) are effectively stuck.\n<\/p><\/div>\n<p>Developers who aren&#8217;t familiar with proper seeding practices will often try to initialize a PRNG using a single 32-bit or 64-bit value (unfortunately, the design of C++&#8217;s standard Random library inadvertently encourages this).  This will generally result in a significantly underseeded PRNG.<\/p>\n<p>Seeding a PRNG with 64 bytes of quality seed data (less if the PRNGs state is smaller) is typically good enough to facilitate the generation of 8-byte random values for non-sensitive uses (e.g. not statistical simulations or cryptography).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">What makes a good PRNG? (optional reading)<\/p>\n<p>In order to be a good PRNG, the PRNG needs to exhibit a number of properties:<\/p>\n<ul>\n<li>The PRNG should generate each number with approximately the same probability.\n<\/li>\n<\/ul>\n<p>This is called distribution uniformity.  If some numbers are generated more often than others, the result of the program that uses the PRNG will be biased!  To check distribution uniformity, we can use a histogram.  A histogram is a graph that tracks how many times each number has been generated.  Since our histograms are text-based, we&#8217;ll use a &#42; symbol to represent each time a given number was generated.<\/p>\n<p>Consider a PRNG that generates numbers between 1 and 6.   If we generate 36 numbers, a PRNG with distribution uniformity should generate a histogram that looks something like this:<\/p>\n<pre>\n1|******\r\n2|******\r\n3|******\r\n4|******\r\n5|******\r\n6|******\r\n<\/pre>\n<p>A PRNG that is biased in some way will generate a histogram that is uneven, like this:<\/p>\n<pre>\n1|***\r\n2|******\r\n3|******\r\n4|******\r\n5|******\r\n6|*********\r\n<\/pre>\n<p>or this:<\/p>\n<pre>\n1|****\r\n2|********\r\n3|******\r\n4|********\r\n5|******\r\n6|****\r\n<\/pre>\n<p>or maybe even this:<\/p>\n<pre>\n1|*******\r\n2|********\r\n3|*******\r\n4|********\r\n5|\r\n6|******\r\n<\/pre>\n<p>Let&#8217;s say you&#8217;re trying to write a random item generator for a game.  When a monster is killed, your code generates a random number between 1 and 6, and if the result is a 6, the monster will drop a rare item instead of a common one.  You would expect a 1 in 6 chance of this happening.  But if the underlying PRNG is not uniform, and generates a lot more 6s than it should (like the second histogram above), your players will end up getting more rare items than you&#8217;d intended, possibly trivializing the difficulty of your game, or messing up your in-game economy.<\/p>\n<p>Finding PRNG algorithms that produce uniform results is difficult.<\/p>\n<ul>\n<li>The method by which the next number in the sequence is generated shouldn&#8217;t be predictable.\n<\/li>\n<\/ul>\n<p>For example, consider the following PRNG algorithm: <code>return ++num<\/code>.  This PRNG is perfectly uniform, but it is also completely predictable -- and not very useful as a sequence of random numbers!<\/p>\n<p>Even sequences of numbers that seem random to the eye (such as the output of <code>LCG16()<\/code> above) may be trivially predictable by someone who is motivated.  By examining just a few numbers generated from the <code>LCG16()<\/code> function above, it is possible to determine which constants are used (<code>8253729<\/code> and <code>2396403<\/code>) to modify the state.  Once that is known, it becomes trivial to calculate all of the future numbers that will be generated from this PRNG.<\/p>\n<p>Now, imagine you&#8217;re running a betting website where users can bet $100.  Your website then generates a random number between 0 and 32767.  If the number is greater than 20000, the customer wins and you return double the bet.  Otherwise, they lose and you keep the bet.  Since the customer wins only 12767\/32767 (39%) of the time, your website should make tons of money, right?  However, if customers are able to determine which numbers will be generated next, then they can strategically place bets so they always (or usually) win.  Congrats, now you get to file for bankruptcy!<\/p>\n<ul>\n<li>The PRNG should have a good dimensional distribution of numbers.\n<\/li>\n<\/ul>\n<p>This means the PRNG should return numbers across the entire range of possible results at random.  For example, the PRNG should generate low numbers, middle numbers, high numbers, even numbers, and odd numbers seemingly at random.<\/p>\n<p>A PRNG that returned all low numbers, then all high numbers may be uniform and non-predictable, but it&#8217;s still going to lead to biased results, particularly if the number of random numbers you actually use is small.<\/p>\n<ul>\n<li>The PRNG should have a high period for all seeds\n<\/li>\n<\/ul>\n<p>All PRNGs are periodic, which means that at some point the sequence of numbers generated will begin to repeat itself.  The length of the sequence before a PRNG begins to repeat itself is known as the <strong>period<\/strong>.<\/p>\n<p>For example, here are the first 100 numbers generated from a PRNG with poor periodicity:<\/p>\n<pre>\n112\t9\t130\t97\t64\t31\t152\t119\t86\t53\t\r\n20\t141\t108\t75\t42\t9\t130\t97\t64\t31\t\r\n152\t119\t86\t53\t20\t141\t108\t75\t42\t9\t\r\n130\t97\t64\t31\t152\t119\t86\t53\t20\t141\t\r\n108\t75\t42\t9\t130\t97\t64\t31\t152\t119\t\r\n86\t53\t20\t141\t108\t75\t42\t9\t130\t97\t\r\n64\t31\t152\t119\t86\t53\t20\t141\t108\t75\t\r\n42\t9\t130\t97\t64\t31\t152\t119\t86\t53\t\r\n20\t141\t108\t75\t42\t9\t130\t97\t64\t31\t\r\n152\t119\t86\t53\t20\t141\t108\t75\t42\t9\r\n<\/pre>\n<p>You will note that it generated 9 as the 2nd number, again as the 16th number, and then every 14 numbers after that.  This PRNG is stuck generating the following sequence repeatedly:  9-130-97-64-31-152-119-86-53-20-141-108-75-42-(repeat).<\/p>\n<p>This happens because PRNGs are deterministic.  Once the state of a PRNG is identical to a prior state, the PRNG will start producing the same sequence of outputs it has produced before -- resulting in a loop.<\/p>\n<p>A good PRNG should have a long period for <em>all<\/em> seed numbers.  Designing an algorithm that meets this property can be extremely difficult -- many PRNGs have long periods only for some seeds and not others.  If the user happens to pick a seed that results in a state with a short period, then the PRNG won&#8217;t do a good job if many random numbers are needed.<\/p>\n<ul>\n<li>The PRNG should be efficient\n<\/li>\n<\/ul>\n<p>Most PRNGs have a state size of less than 4096 bytes, so total memory usage typically isn&#8217;t a concern.  However, the larger the internal state, the more likely the PRNG is to be underseeded, and the slower the initial seeding will be (since there&#8217;s more state to initialize).<\/p>\n<p>Second, to generate the next number in sequence, a PRNG has to mix up its internal state by applying various mathematical operations.  How much time this takes can vary significantly by PRNG and also by architecture (some PRNGs perform better on certain architectures than others).  This doesn&#8217;t matter if you only generate random numbers periodically, but can have a huge impact if you need lots of randomness.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">There are many different kinds of PRNG algorithms<\/p>\n<p>Over the years, many different kinds of PRNG algorithms have been developed (Wikipedia has a good list <a href=\"https:\/\/en.wikipedia.org\/wiki\/List_of_random_number_generators\">here<\/a>).  Every PRNG algorithm has strengths and weaknesses that might make it more or less suitable for a particular application, so selecting the right algorithm for your application is important.<\/p>\n<p>Many PRNGs are now considered relatively poor by modern standards -- and there&#8217;s no reason to use a PRNG that doesn&#8217;t perform well when it&#8217;s just as easy to use one that does.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><a name=\"random\"><\/a>Randomization in C++ <a href=\"#random\"><i class=\"fa fa-link\" style=\"font-size: 0.8em;\"><\/i><\/a><\/p>\n<p>The randomization capabilities in C++ are accessible via the <code>&lt;random&gt;<\/code> header of the standard library.  Within the random library, there are 6 PRNG families available for use (as of C++20):<\/p>\n<div class=\"cpp-table-wrapper\">\n<table class=\"cpp-table\">\n<tr>\n<th> Type name                    <\/th>\n<th> Family                                <\/th>\n<th> Period <\/th>\n<th> State size* <\/th>\n<th> Performance <\/th>\n<th> Quality <\/th>\n<th> Should I use this? <\/th>\n<\/tr>\n<tr>\n<td> minstd_rand<br \/>minstd_rand0 <\/td>\n<td> Linear congruential generator          <\/td>\n<td> 2^31 <\/td>\n<td> 4 bytes <\/td>\n<td> Bad <\/td>\n<td> Awful <\/td>\n<td> No <\/td>\n<\/tr>\n<tr>\n<td> mt19937<br \/>mt19937_64       <\/td>\n<td> Mersenne twister                       <\/td>\n<td> 2^19937 <\/td>\n<td> 2500 bytes <\/td>\n<td> Decent <\/td>\n<td> Decent <\/td>\n<td> Probably (see next section) <\/td>\n<\/tr>\n<tr>\n<td> ranlux24<br \/>ranlux48        <\/td>\n<td> Subtract and carry <\/td>\n<td> 10^171 <\/td>\n<td> 96 bytes <\/td>\n<td> Awful <\/td>\n<td> Good <\/td>\n<td> No <\/td>\n<\/tr>\n<tr>\n<td> knuth_b                      <\/td>\n<td> Shuffled linear congruential generator <\/td>\n<td> 2^31 <\/td>\n<td> 1028 bytes <\/td>\n<td> Awful <\/td>\n<td> Bad <\/td>\n<td> No <\/td>\n<\/tr>\n<tr>\n<td> default_random_engine        <\/td>\n<td> Any of above (implementation defined)  <\/td>\n<td> Varies <\/td>\n<td> Varies <\/td>\n<td> ? <\/td>\n<td> ? <\/td>\n<td> No<sup>2<\/sup> <\/td>\n<\/tr>\n<tr>\n<td> rand()                       <\/td>\n<td> Linear congruential generator          <\/td>\n<td> 2^31 <\/td>\n<td> 4 bytes <\/td>\n<td>  Bad <\/td>\n<td> Awful <\/td>\n<td> No<sup>no<\/sup> <\/td>\n<\/tr>\n<\/table>\n<\/div>\n<p>There is zero reason to use <code>knuth_b<\/code>, <code>default_random_engine<\/code>, or <code>rand()<\/code> (which is a random number generator provided for compatibility with C).<\/p>\n<p>As of C++20, the Mersenne Twister algorithm is the only PRNG that ships with C++ that has both decent performance and quality.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>A test called <a href=\"http:\/\/pracrand.sourceforge.net\/\">PracRand<\/a> is often used to assess the performance and quality of PRNGs (to determine whether they have different kinds of biases).  You may also see references to SmallCrush, Crush or BigCrush -- these are other tests that are sometimes used for the same purpose.<\/p>\n<p>If you want to see what the output of Pracrand looks like, <a href=\"https:\/\/arvid.io\/2018\/06\/30\/on-cxx-random-number-generator-quality\/\">this website<\/a> has output for all of the PRNGs that C++ supports as of C++20.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">So we should use Mersenne Twister, right?<\/p>\n<p>Probably.  For most applications, Mersenne Twister is fine, both in terms of performance and quality.<\/p>\n<p>However, it&#8217;s worth noting that by modern PRNG standards, Mersenne Twister is <a href=\"https:\/\/en.wikipedia.org\/wiki\/Mersenne_Twister#Characteristics\">a bit outdated<\/a>.  The biggest issue with Mersenne Twister is that its results can be predicted after seeing 624 generated numbers, making it non-suitable for any application that requires non-predictability.<\/p>\n<p>If you are developing an application that requires the highest quality random results (e.g. a statistical simulation), the fastest results, or one where non-predictability is important (e.g. cryptography), you&#8217;ll need to use a 3rd party library.<\/p>\n<p>Popular choices as of the time of writing:<\/p>\n<ul>\n<li>The <a href=\"https:\/\/prng.di.unimi.it\/\">Xoshiro family<\/a> and <a href=\"https:\/\/github.com\/wangyi-fudan\/wyhash\">Wyrand<\/a> for non-cryptographic PRNGs.\n<\/li>\n<li>The <a href=\"https:\/\/cr.yp.to\/chacha.html\">Chacha family<\/a> for cryptographic (non-predictable) PRNGs.\n<\/li>\n<\/ul>\n<p>Okay, now that your eyes are probably bleeding, that&#8217;s enough theory.  Let&#8217;s discuss how to actually generate random numbers with Mersenne Twister in C++.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/generating-random-numbers-using-mersenne-twister\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">8.14<\/span>Generating random numbers using Mersenne Twister\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/halts-exiting-your-program-early\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">8.12<\/span>Halts (exiting your program early)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>The ability to generate random numbers can be useful in certain kinds of programs, particularly in games, statistical modelling programs, and cryptographic applications that need to encrypt and decrypt things. Take games for example &#8212; without random events, monsters would always attack you the same way, you&#8217;d always find the &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12670"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=12670"}],"version-history":[{"count":24,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12670\/revisions"}],"predecessor-version":[{"id":17524,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12670\/revisions\/17524"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=12670"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=12670"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=12670"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}