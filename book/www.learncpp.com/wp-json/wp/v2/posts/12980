{"id":12980,"date":"2022-04-21T13:48:18","date_gmt":"2022-04-21T20:48:18","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=12980"},"modified":"2024-12-30T20:09:52","modified_gmt":"2024-12-31T04:09:52","slug":"class-templates","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/class-templates\/","title":{"rendered":"13.13 &#8212; Class templates"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-templates\/\">11.6 -- Function templates<\/a>, we introduced the challenge of having to create a separate (overloaded) function for each different set of types we want to work with:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ function to calculate the greater of two int values\r\nint max(int x, int y)\r\n{\r\n    return (x &lt; y) ? y : x;\r\n}\r\n\r\n\/\/ almost identical function to calculate the greater of two double values\r\n\/\/ the only difference is the type information\r\ndouble max(double x, double y)\r\n{\r\n    return (x &lt; y) ? y : x;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; max(5, 6);     \/\/ calls max(int, int)\r\n    std::cout &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; max(1.2, 3.4); \/\/ calls max(double, double)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The solution to this was to create a function template that the compiler can use to instantiate normal functions for whichever set of types we need:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ a single function template for max\r\ntemplate &lt;typename T&gt;\r\nT max(T x, T y)\r\n{\r\n    return (x &lt; y) ? y : x;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; max(5, 6);     \/\/ instantiates and calls max&lt;int&gt;(int, int)\r\n    std::cout &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; max(1.2, 3.4); \/\/ instantiates and calls max&lt;double&gt;(double, double)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover how function template instantiation works in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-template-instantiation\/\">11.7 -- Function template instantiation<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Aggregate types have similar challenges<\/p>\n<p>We run into similar challenges with aggregate types (both structs\/classes\/unions and arrays).<\/p>\n<p>For example, let&#8217;s say we&#8217;re writing a program where we need to work with pairs of <code>int<\/code> values, and need to determine which of the two numbers is larger.  We might write a program like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Pair\r\n{\r\n    int first{};\r\n    int second{};\r\n};\r\n\r\nconstexpr int max(Pair p) \/\/ pass by value because Pair is small\r\n{\r\n    return (p.first &lt; p.second ? p.second : p.first);\r\n}\r\n\r\nint main()\r\n{\r\n    Pair p1{ 5, 6 };\r\n    std::cout &lt;&lt; max(p1) &lt;&lt; \" is larger\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Later, we discover that we also need pairs of <code>double<\/code> values.  So we update our program to the following:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Pair\r\n{\r\n    int first{};\r\n    int second{};\r\n};\r\n\r\nstruct Pair \/\/ compile error: erroneous redefinition of Pair\r\n{\r\n    double first{};\r\n    double second{};\r\n};\r\n\r\nconstexpr int max(Pair p)\r\n{\r\n    return (p.first &lt; p.second ? p.second : p.first);\r\n}\r\n\r\nconstexpr double max(Pair p) \/\/ compile error: overloaded function differs only by return type\r\n{\r\n    return (p.first &lt; p.second ? p.second : p.first);\r\n}\r\n\r\nint main()\r\n{\r\n    Pair p1{ 5, 6 };\r\n    std::cout &lt;&lt; max(p1) &lt;&lt; \" is larger\\n\";\r\n\r\n    Pair p2{ 1.2, 3.4 };\r\n    std::cout &lt;&lt; max(p2) &lt;&lt; \" is larger\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Unfortunately, this program won&#8217;t compile, and has a number of problems that need to be addressed.<\/p>\n<p>First, unlike functions, type definitions can&#8217;t be overloaded.  The compiler will treat double second definition of <code>Pair<\/code> as an erroneous redeclaration of the first definition of <code>Pair<\/code>.  Second, although functions can be overloaded, our <code>max(Pair)<\/code> functions only differ by return type, and overloaded functions can&#8217;t be differentiated solely by return type.  Third, there is a lot of redundancy here.  Each <code>Pair<\/code> struct is identical (except for the data type) and same with our <code>max(Pair)<\/code> functions (except for the return type).<\/p>\n<p>We could solve the first two issues by giving our <code>Pair<\/code> structs different names (e.g. <code>PairInt<\/code> and <code>PairDouble<\/code>).  But then we both have to remember our naming scheme, and essentially clone a bunch of code for each additional pair type we want, which doesn&#8217;t solve the redundancy problem.<\/p>\n<p>Fortunately, we can do better.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>Before proceeding, please review lessons <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-templates\/\">11.6 -- Function templates<\/a> and <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-template-instantiation\/\">11.7 -- Function template instantiation<\/a> if you&#8217;re hazy on how function templates, template types, or function template instantiation works.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Class templates<\/p>\n<p>Much like a function template is a template definition for instantiating functions, a <strong>class template<\/strong> is a template definition for instantiating class types.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">A reminder<\/p>\n<p>A &#8220;class type&#8221; is a struct, class, or union type.  Although we&#8217;ll be demonstrating &#8220;class templates&#8221; on structs for simplicity, everything here applies equally well to classes.\n<\/p><\/div>\n<p>As a reminder, here&#8217;s our <code>int<\/code> pair struct definition:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">struct Pair\r\n{\r\n    int first{};\r\n    int second{};\r\n};<\/code><\/pre>\n<p>Let&#8217;s rewrite our pair class as a class template:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nstruct Pair\r\n{\r\n    T first{};\r\n    T second{};\r\n};\r\n\r\nint main()\r\n{\r\n    Pair&lt;int&gt; p1{ 5, 6 };        \/\/ instantiates Pair&lt;int&gt; and creates object p1\r\n    std::cout &lt;&lt; p1.first &lt;&lt; ' ' &lt;&lt; p1.second &lt;&lt; '\\n';\r\n\r\n    Pair&lt;double&gt; p2{ 1.2, 3.4 }; \/\/ instantiates Pair&lt;double&gt; and creates object p2\r\n    std::cout &lt;&lt; p2.first &lt;&lt; ' ' &lt;&lt; p2.second &lt;&lt; '\\n';\r\n\r\n    Pair&lt;double&gt; p3{ 7.8, 9.0 }; \/\/ creates object p3 using prior definition for Pair&lt;double&gt;\r\n    std::cout &lt;&lt; p3.first &lt;&lt; ' ' &lt;&lt; p3.second &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Just like with function templates, we start a class template definition with a template parameter declaration.  We begin with the <code>template<\/code> keyword.  Next, we specify all of the template types that our class template will use inside angled brackets (&lt;&gt;). For each template type that we need, we use the keyword <code>typename<\/code> (preferred) or <code>class<\/code> (not preferred), followed by the name of the template type (e.g. <code>T<\/code>).  In this case, since both of our members will be the same type, we only need one template type.<\/p>\n<p>Next, we define our struct like usual, except we can use our template type (<code>T<\/code>) wherever we want a templated type that will be replaced with a real type later.  That&#8217;s it!  We&#8217;re done with the class template definition.<\/p>\n<p>Inside main, we can instantiate <code>Pair<\/code> objects using whatever types we desire.  First, we instantiate an object of type <code>Pair&lt;int&gt;<\/code>.  Because a type definition for <code>Pair&lt;int&gt;<\/code> doesn&#8217;t exist yet, the compiler uses the class template to instantiate a struct type definition named <code>Pair&lt;int&gt;<\/code>, where all occurrences of template type <code>T<\/code> are replaced by type <code>int<\/code>.<\/p>\n<p>Next, we instantiate an object of type <code>Pair&lt;double&gt;<\/code>, which instantiates a struct type definition named <code>Pair&lt;double&gt;<\/code> where <code>T<\/code> is replaced by <code>double<\/code>.  For <code>p3<\/code>, <code>Pair&lt;double&gt;<\/code> has already been instantiated, so the compiler will use the prior type definition.<\/p>\n<p>Here&#8217;s the same example as above, showing what the compiler actually compiles after all template instantiations are done:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ A declaration for our Pair class template\r\n\/\/ (we don't need the definition any more since it's not used)\r\ntemplate &lt;typename T&gt;\r\nstruct Pair;\r\n\r\n\/\/ Explicitly define what Pair&lt;int&gt; looks like\r\ntemplate &lt;&gt; \/\/ tells the compiler this is a template type with no template parameters\r\nstruct Pair&lt;int&gt;\r\n{\r\n    int first{};\r\n    int second{};\r\n};\r\n\r\n\/\/ Explicitly define what Pair&lt;double&gt; looks like\r\ntemplate &lt;&gt; \/\/ tells the compiler this is a template type with no template parameters\r\nstruct Pair&lt;double&gt;\r\n{\r\n    double first{};\r\n    double second{};\r\n};\r\n\r\nint main()\r\n{\r\n    Pair&lt;int&gt; p1{ 5, 6 };        \/\/ instantiates Pair&lt;int&gt; and creates object p1\r\n    std::cout &lt;&lt; p1.first &lt;&lt; ' ' &lt;&lt; p1.second &lt;&lt; '\\n';\r\n\r\n    Pair&lt;double&gt; p2{ 1.2, 3.4 }; \/\/ instantiates Pair&lt;double&gt; and creates object p2\r\n    std::cout &lt;&lt; p2.first &lt;&lt; ' ' &lt;&lt; p2.second &lt;&lt; '\\n';\r\n\r\n    Pair&lt;double&gt; p3{ 7.8, 9.0 }; \/\/ creates object p3 using prior definition for Pair&lt;double&gt;\r\n    std::cout &lt;&lt; p3.first &lt;&lt; ' ' &lt;&lt; p3.second &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>You can compile this example directly and see that it works as expected!<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>The above example makes use of a feature called class template specialization (covered in future lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-template-specialization\/\">26.4 -- Class template specialization<\/a>).  Knowledge of how this feature works is not required at this point.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using our class template in a function<\/p>\n<p>Now let&#8217;s return to the challenge of making our <code>max()<\/code> function work with different types.  Because the compiler treats <code>Pair&lt;int&gt;<\/code> and <code>Pair&lt;double&gt;<\/code> as separate types, we could use overloaded functions that are differentiated by parameter type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">constexpr int max(Pair&lt;int&gt; p)\r\n{\r\n    return (p.first &lt; p.second ? p.second : p.first);\r\n}\r\n\r\nconstexpr double max(Pair&lt;double&gt; p) \/\/ okay: overloaded function differentiated by parameter type\r\n{\r\n    return (p.first &lt; p.second ? p.second : p.first);\r\n}<\/code><\/pre>\n<p>While this compiles, it doesn&#8217;t solve the redundancy problem.  What we really want is a function that can take a pair of any type.  In other words, we want a function that takes a parameter of type <code>Pair&lt;T&gt;<\/code>, where T is a template type parameter.  And that means we need a function template for this job!<\/p>\n<p>Here&#8217;s a full example, with <code>max()<\/code> being implemented as a function template:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nstruct Pair\r\n{\r\n    T first{};\r\n    T second{};\r\n};\r\n\r\ntemplate &lt;typename T&gt;\r\nconstexpr T max(Pair&lt;T&gt; p)\r\n{\r\n    return (p.first &lt; p.second ? p.second : p.first);\r\n}\r\n\r\nint main()\r\n{\r\n    Pair&lt;int&gt; p1{ 5, 6 };\r\n    std::cout &lt;&lt; max&lt;int&gt;(p1) &lt;&lt; \" is larger\\n\"; \/\/ explicit call to max&lt;int&gt;\r\n\r\n    Pair&lt;double&gt; p2{ 1.2, 3.4 };\r\n    std::cout &lt;&lt; max(p2) &lt;&lt; \" is larger\\n\"; \/\/ call to max&lt;double&gt; using template argument deduction (prefer this)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The <code>max()<\/code> function template is pretty straightforward.  Because we want to pass in a <code>Pair&lt;T&gt;<\/code>, we need the compiler to understand what <code>T<\/code> is.  Therefore, we need to start our function with a template parameter declaration that defines template type T.  We can then use <code>T<\/code> as both our return type, and as the template type for <code>Pair&lt;T&gt;<\/code>.<\/p>\n<p>When the <code>max()<\/code> function is called with a <code>Pair&lt;int&gt;<\/code> argument, the compiler will instantiate the function <code>int max&lt;int&gt;(Pair&lt;int&gt;)<\/code> from the function template, where template type <code>T<\/code> is replaced with <code>int<\/code>.  The following snippet shows what the compiler actually instantiates in such a case:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;&gt;\r\nconstexpr int max(Pair&lt;int&gt; p)\r\n{\r\n    return (p.first &lt; p.second ? p.second : p.first);\r\n}<\/code><\/pre>\n<p>As with all calls to a function template, we can either be explicit about the template type argument (e.g. <code>max&lt;int&gt;(p1)<\/code>) or we can be implicit (e.g. <code>max(p2)<\/code>) and let the compiler use template argument deduction to determine what the template type argument should be.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Class templates with template type and non-template type members<\/p>\n<p>Class templates can have some members using a template type and other members using a normal (non-template) type.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;typename T&gt;\r\nstruct Foo\r\n{\r\n    T first{};    \/\/ first will have whatever type T is replaced with\r\n    int second{}; \/\/ second will always have type int, regardless of what type T is\r\n};<\/code><\/pre>\n<p>This works exactly like you&#8217;d expect: <code>first<\/code> will be whatever the template type <code>T<\/code> is, and <code>second<\/code> will always be an <code>int<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Class templates with multiple template types<\/p>\n<p>Class templates can also have multiple template types.  For example, if we wanted the two members of our <code>Pair<\/code> class to be able to have different types, we can define our <code>Pair<\/code> class template with two template types:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T, typename U&gt;\r\nstruct Pair\r\n{\r\n    T first{};\r\n    U second{};\r\n};\r\n\r\ntemplate &lt;typename T, typename U&gt;\r\nvoid print(Pair&lt;T, U&gt; p)\r\n{\r\n    std::cout &lt;&lt; '[' &lt;&lt; p.first &lt;&lt; \", \" &lt;&lt; p.second &lt;&lt; ']';\r\n}\r\n\r\nint main()\r\n{\r\n    Pair&lt;int, double&gt; p1{ 1, 2.3 }; \/\/ a pair holding an int and a double\r\n    Pair&lt;double, int&gt; p2{ 4.5, 6 }; \/\/ a pair holding a double and an int\r\n    Pair&lt;int, int&gt; p3{ 7, 8 };      \/\/ a pair holding two ints\r\n\r\n    print(p2);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>To define multiple template types, in our template parameter declaration, we separate each of our desired template types with a comma.  In the above example we define two different template types, one named <code>T<\/code>, and one named <code>U<\/code>.  The actual template type arguments for <code>T<\/code> and <code>U<\/code> can be different (as in the case of <code>p1<\/code> and <code>p2<\/code> above) or the same (as in the case of <code>p3<\/code>).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Making a function template work with more than one class type<\/p>\n<p>Consider the <code>print()<\/code> function template from the above example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;typename T, typename U&gt;\r\nvoid print(Pair&lt;T, U&gt; p)\r\n{\r\n    std::cout &lt;&lt; '[' &lt;&lt; p.first &lt;&lt; \", \" &lt;&lt; p.second &lt;&lt; ']';\r\n}<\/code><\/pre>\n<p>Because we&#8217;ve explicitly defined the function parameter as a <code>Pair&lt;T, U&gt;<\/code>, only arguments of type <code>Pair&lt;T, U&gt;<\/code> (or those that can be converted to a <code>Pair&lt;T, U&gt;<\/code>) will match.  This is ideal if we only want to be able to call our function with a <code>Pair&lt;T, U&gt;<\/code> argument.<\/p>\n<p>In some cases, we may write function templates that we want to use with any type that will successfully compile.  To do that, we simply use a type template parameter as the function parameter instead.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T, typename U&gt;\r\nstruct Pair\r\n{\r\n    T first{};\r\n    U second{};\r\n};\r\n\r\nstruct Point\r\n{\r\n    int first{};\r\n    int second{};\r\n};\r\n\r\ntemplate &lt;typename T&gt;\r\nvoid print(T p) \/\/ type template parameter will match anything\r\n{\r\n    std::cout &lt;&lt; '[' &lt;&lt; p.first &lt;&lt; \", \" &lt;&lt; p.second &lt;&lt; ']'; \/\/ will only compile if type has first and second members\r\n}\r\n\r\nint main()\r\n{\r\n    Pair&lt;double, int&gt; p1{ 4.5, 6 };\r\n    print(p1); \/\/ matches print(Pair&lt;double, int&gt;)\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    Point p2 { 7, 8 };\r\n    print(p2); \/\/ matches print(Point)\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, we&#8217;ve rewritten <code>print()<\/code> so that it has only a single type template parameter (<code>T<\/code>), which will match any type.  The body of the function will compile successfully for any class type that has a <code>first<\/code> and <code>second<\/code> member.  We demonstrate this by calling <code>print()<\/code> with an object of type <code>Pair&lt;double, int&gt;<\/code>, and then again with an object of type <code>Point<\/code>.<\/p>\n<p>There is one case that can be misleading.  Consider the following version of <code>print()<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;typename T, typename U&gt;\r\nstruct Pair \/\/ defines a class type named Pair\r\n{\r\n    T first{};\r\n    U second{};\r\n};\r\n\r\ntemplate &lt;typename Pair&gt; \/\/ defines a type template parameter named Pair (shadows Pair class type)\r\nvoid print(Pair p)       \/\/ this refers to template parameter Pair, not class type Pair\r\n{\r\n    std::cout &lt;&lt; '[' &lt;&lt; p.first &lt;&lt; \", \" &lt;&lt; p.second &lt;&lt; ']';\r\n}<\/code><\/pre>\n<p>You might expect that this function will only match when called with a <code>Pair<\/code> class type argument.  But this version of <code>print()<\/code> is functionally identically to the prior version where the template parameter was named <code>T<\/code>, and will match with <em>any<\/em> type.  The issue here is that when we define <code>Pair<\/code> as a type template parameter, it shadows other uses of the name <code>Pair<\/code> within the global scope.  So within the function template, <code>Pair <\/code> refers to the template parameter <code>Pair<\/code>, not the class type <code>Pair<\/code>.  And since a type template parameter will match to any type, this <code>Pair<\/code> matches to any argument type, not just those of class type <code>Pair<\/code>!<\/p>\n<p>This is a good reason to stick to simple template parameter names, such a <code>T<\/code>, <code>U<\/code>, <code>N<\/code>, as they are less likely to shadow a class type name.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">std::pair<\/p>\n<p>Because working with pairs of data is common, the C++ standard library contains a class template named <code>std::pair<\/code> (in the <code>&lt;utility&gt;<\/code> header) that is defined identically to the <code>Pair<\/code> class template with multiple template types in the preceding section.  In fact, we can swap out the <code>pair<\/code> struct we developed for <code>std::pair<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;utility&gt;\r\n\r\ntemplate &lt;typename T, typename U&gt;\r\nvoid print(std::pair&lt;T, U&gt; p)\r\n{\r\n    \/\/ the members of std::pair have predefined names `first` and `second`\r\n    std::cout &lt;&lt; '[' &lt;&lt; p.first &lt;&lt; \", \" &lt;&lt; p.second &lt;&lt; ']';\r\n}\r\n\r\nint main()\r\n{\r\n    std::pair&lt;int, double&gt; p1{ 1, 2.3 }; \/\/ a pair holding an int and a double\r\n    std::pair&lt;double, int&gt; p2{ 4.5, 6 }; \/\/ a pair holding a double and an int\r\n    std::pair&lt;int, int&gt; p3{ 7, 8 };      \/\/ a pair holding two ints\r\n\r\n    print(p2);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>We developed our own <code>Pair<\/code> class in this lesson to show how things work, but in real code, you should favor <code>std::pair<\/code> over writing your own.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using class templates in multiple files<\/p>\n<p>Just like function templates, class templates are typically defined in header files so they can be included into any code file that needs them.  Both template definitions and type definitions are exempt from the one-definition rule, so this won&#8217;t cause problems:<\/p>\n<p>pair.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef PAIR_H\r\n#define PAIR_H\r\n\r\ntemplate &lt;typename T&gt;\r\nstruct Pair\r\n{\r\n    T first{};\r\n    T second{};\r\n};\r\n\r\ntemplate &lt;typename T&gt;\r\nconstexpr T max(Pair&lt;T&gt; p)\r\n{\r\n    return (p.first &lt; p.second ? p.second : p.first);\r\n}\r\n\r\n#endif<\/code><\/pre>\n<p>foo.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"pair.h\"\r\n#include &lt;iostream&gt;\r\n\r\nvoid foo()\r\n{\r\n    Pair&lt;int&gt; p1{ 1, 2 };\r\n    std::cout &lt;&lt; max(p1) &lt;&lt; \" is larger\\n\";\r\n}<\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"pair.h\"\r\n#include &lt;iostream&gt;\r\n\r\nvoid foo(); \/\/ forward declaration for function foo()\r\n\r\nint main()\r\n{\r\n    Pair&lt;double&gt; p2 { 3.4, 5.6 };\r\n    std::cout &lt;&lt; max(p2) &lt;&lt; \" is larger\\n\";\r\n\r\n    foo();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-template-argument-deduction-ctad-and-deduction-guides\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.14<\/span>Class template argument deduction (CTAD) and deduction guides\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/member-selection-with-pointers-and-references\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.12<\/span>Member selection with pointers and references\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we introduced the challenge of having to create a separate (overloaded) function for each different set of types we want to work with: #include &lt;iostream&gt; \/\/ function to calculate the greater of two int values int max(int x, int y) { return (x &lt; y) ? y &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12980"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=12980"}],"version-history":[{"count":21,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12980\/revisions"}],"predecessor-version":[{"id":18056,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12980\/revisions\/18056"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=12980"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=12980"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=12980"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}