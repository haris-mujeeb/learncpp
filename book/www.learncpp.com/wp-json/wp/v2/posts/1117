{"id":1117,"date":"2015-02-08T17:06:18","date_gmt":"2015-02-09T01:06:18","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=1117"},"modified":"2025-01-01T22:21:21","modified_gmt":"2025-01-02T06:21:21","slug":"introduction-to-local-scope","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-local-scope\/","title":{"rendered":"2.5 &#8212; Introduction to local scope"},"content":{"rendered":"<p class=\"cpp-section\">Local variables<\/p>\n<p>Variables defined inside the body of a function are called <strong>local variables<\/strong> (as opposed to <em>global variables<\/em>, which we&#8217;ll discuss in a future chapter):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int add(int x, int y)\r\n{\r\n    int z{ x + y }; \/\/ z is a local variable\r\n\r\n    return z;\r\n}<\/code><\/pre>\n<p>Function parameters are also generally considered to be local variables, and we will include them as such:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int add(int x, int y) \/\/ function parameters x and y are local variables\r\n{\r\n    int z{ x + y };\r\n\r\n    return z;\r\n}<\/code><\/pre>\n<p>In this lesson, we&#8217;ll take a look at some properties of local variables in more detail.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Local variable lifetime<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-objects-and-variables\/\">1.3 -- Introduction to objects and variables<\/a>, we discussed how a variable definition such as <code>int x;<\/code> causes the variable to be instantiated when this statement is executed.  Function parameters are created and initialized when the function is entered, and variables within the function body are created and initialized at the point of definition.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int add(int x, int y) \/\/ x and y created and initialized here\r\n{ \r\n    int z{ x + y };   \/\/ z created and initialized here\r\n\r\n    return z;\r\n}<\/code><\/pre>\n<p>The natural follow-up question is, \u201cso when is an instantiated variable destroyed?\u201d.  Local variables are destroyed in the opposite order of creation at the end of the set of curly braces in which it is defined (or for a function parameter, at the end of the function).<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int add(int x, int y)\r\n{ \r\n    int z{ x + y };\r\n\r\n    return z;\r\n} \/\/ z, y, and x destroyed here<\/code><\/pre>\n<p>Much like a person&#8217;s lifetime is defined to be the time between their birth and death, an object&#8217;s <strong>lifetime<\/strong> is defined to be the time between its creation and destruction.  Note that variable creation and destruction happen when the program is running (called runtime), not at compile time.  Therefore, lifetime is a runtime property.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>The above rules around creation, initialization, and destruction are guarantees.  That is, objects must be created and initialized no later than the point of definition, and destroyed no earlier than the end of the set of the curly braces in which they are defined (or, for function parameters, at the end of the function).<\/p>\n<p>In actuality, the C++ specification gives compilers a lot of flexibility to determine when local variables are created and destroyed.  Objects may be created earlier, or destroyed later for optimization purposes.  Most often, local variables are created when the function is entered, and destroyed in the opposite order of creation when the function is exited.  We&#8217;ll discuss this in more detail in a future lesson, when we talk about the call stack.\n<\/p><\/div>\n<p>Here&#8217;s a slightly more complex program demonstrating the lifetime of a variable named <code>x<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid doSomething()\r\n{\r\n    std::cout &lt;&lt; \"Hello!\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    int x{ 0 };    \/\/ x's lifetime begins here\r\n\r\n    doSomething(); \/\/ x is still alive during this function call\r\n\r\n    return 0;\r\n} \/\/ x's lifetime ends here<\/code><\/pre>\n<p>In the above program, the lifetime of <code>x<\/code> runs from the point of definition to the end of function <code>main<\/code>.  This includes the time spent during the execution of function <code>doSomething<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">What happens when an object is destroyed?<\/p>\n<p>In most cases, nothing.  The destroyed object simply becomes invalid.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>If the object is a class type object, prior to destruction, a special function called a destructor is invoked.  In many cases, the destructor does nothing, in which case no cost is incurred.  We introduce destructors in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-destructors\/\">15.4 -- Introduction to destructors<\/a>.\n<\/p><\/div>\n<p>Any use of an object after it has been destroyed will result in undefined behavior.<\/p>\n<p>At some point after destruction, the memory used by the object will be <strong>deallocated<\/strong> (freed up for reuse).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Local scope (block scope)<\/p>\n<p>An identifier&#8217;s <strong>scope<\/strong> determines where the identifier can be seen and used within the source code.  When an identifier can be seen and used, we say it is <strong>in scope<\/strong>.  When an identifier can not be seen, we can not use it, and we say it is <strong>out of scope<\/strong>.  Scope is a compile-time property, and trying to use an identifier when it is not in scope will result in a compile error.<\/p>\n<p>The identifier of a local variable has local scope.  An identifier with <strong>local scope<\/strong> (technically called <strong>block scope<\/strong>) is usable from the point of definition to the end of the innermost pair of curly braces containing the identifier (or for function parameters, at the end of the function).  This ensures local variables cannot be used before the point of definition (even if the compiler opts to create them before then) or after they are destroyed.  Local variables defined in one function are also not in scope in other functions that are called.<\/p>\n<p>Here&#8217;s a program demonstrating the scope of a variable named <code>x<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ x is not in scope anywhere in this function\r\nvoid doSomething()\r\n{\r\n    std::cout &lt;&lt; \"Hello!\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    \/\/ x can not be used here because it's not in scope yet\r\n\r\n    int x{ 0 }; \/\/ x enters scope here and can now be used within this function\r\n\r\n    doSomething();\r\n\r\n    return 0;\r\n} \/\/ x goes out of scope here and can no longer be used<\/code><\/pre>\n<p>In the above program, variable <code>x<\/code> enters scope at the point of definition.  <code>x<\/code> goes out of scope at the end of the innermost pair of curly braces containing the identifier, which is the closing curly brace of function <code>main()<\/code>.  Note that variable <code>x<\/code> is not in scope anywhere inside of function <code>doSomething<\/code>.  The fact that function <code>main<\/code> calls function <code>doSomething<\/code> is irrelevant in this context.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">&#8220;Out of scope&#8221; vs &#8220;going out of scope&#8221;<\/p>\n<p>The terms &#8220;out of scope&#8221; and &#8220;going out of scope&#8221; can be confusing to new programmers.<\/p>\n<p>An identifier is out of scope anywhere it cannot be accessed within the code.  In the example above, the identifier <code>x<\/code> is in scope from its point of definition to the end of the <code>main<\/code> function.  The identifier <code>x<\/code> is out of scope outside of that code region.<\/p>\n<p>The term &#8220;going out of scope&#8221; is typically applied to objects rather than identifiers.  We say an object goes out of scope at the end of the scope (the end curly brace) in which the object was instantiated.  In the example above, the object named <code>x<\/code> goes out of scope at the end of the function <code>main<\/code>.<\/p>\n<p>A local variable&#8217;s lifetime ends at the point where it goes out of scope, so local variables are destroyed at this point.<\/p>\n<p>Note that not all types of variables are destroyed when they go out of scope.  We&#8217;ll see examples of these in future lessons.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Another example<\/p>\n<p>Here&#8217;s a slightly more complex example.  Remember, lifetime is a runtime property, and scope is a compile-time property, so although we are talking about both in the same program, they are enforced at different points.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y) \/\/ x and y are created and enter scope here\r\n{\r\n    \/\/ x and y are usable only within add()\r\n    return x + y;\r\n} \/\/ y and x go out of scope and are destroyed here\r\n\r\nint main()\r\n{\r\n    int a{ 5 }; \/\/ a is created, initialized, and enters scope here\r\n    int b{ 6 }; \/\/ b is created, initialized, and enters scope here\r\n\r\n    \/\/ a and b are usable only within main()\r\n\r\n    std::cout &lt;&lt; add(a, b) &lt;&lt; '\\n'; \/\/ calls add(5, 6), where x=5 and y=6\r\n\r\n    return 0;\r\n} \/\/ b and a go out of scope and are destroyed here<\/code><\/pre>\n<p>Parameters <code>x<\/code> and <code>y<\/code> are created when the <code>add<\/code> function is called, can only be seen\/used within function <code>add<\/code>, and are destroyed at the end of <code>add<\/code>. Variables <code>a<\/code> and <code>b<\/code> are created within function <code>main<\/code>, can only be seen\/used within function <code>main<\/code>, and are destroyed at the end of <code>main<\/code>.<\/p>\n<p>To enhance your understanding of how all this fits together, let&#8217;s trace through this program in a little more detail.  The following happens, in order:<\/p>\n<ul>\n<li>Execution starts at the top of <code>main<\/code>.\n<\/li>\n<li><code>main<\/code> variable <code>a<\/code> is created and given value <code>5<\/code>.\n<\/li>\n<li><code>main<\/code> variable <code>b<\/code> is created and given value <code>6<\/code>.\n<\/li>\n<li>Function <code>add<\/code> is called with argument values <code>5<\/code> and <code>6<\/code>.\n<\/li>\n<li><code>add<\/code> parameters <code>x<\/code> and <code>y<\/code> are created and initialized with values <code>5<\/code> and <code>6<\/code> respectively.\n<\/li>\n<li>The expression <code>x + y<\/code> is evaluated to produce the value <code>11<\/code>.\n<\/li>\n<li><code>add<\/code> copies the value <code>11<\/code> back to caller <code>main<\/code>.\n<\/li>\n<li><code>add<\/code> parameters <code>y<\/code> and <code>x<\/code> are destroyed.\n<\/li>\n<li><code>main<\/code> prints <code>11<\/code> to the console.\n<\/li>\n<li><code>main<\/code> returns <code>0<\/code> to the operating system.\n<\/li>\n<li><code>main<\/code> variables <code>b<\/code> and <code>a<\/code> are destroyed.\n<\/li>\n<\/ul>\n<p>And we&#8217;re done.<\/p>\n<p>Note that if function <code>add<\/code> were to be called twice, parameters <code>x<\/code> and <code>y<\/code> would be created and destroyed twice -- once for each call.  In a program with lots of functions and function calls, variables are created and destroyed often.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Functional separation<\/p>\n<p>In the above example, it&#8217;s easy to see that variables <code>a<\/code> and <code>b<\/code> are different variables from <code>x<\/code> and <code>y<\/code>.<\/p>\n<p>Now consider the following similar program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y) \/\/ add's x and y are created and enter scope here\r\n{\r\n    \/\/ add's x and y are visible\/usable within this function only\r\n    return x + y;\r\n} \/\/ add's y and x go out of scope and are destroyed here\r\n\r\nint main()\r\n{\r\n    int x{ 5 }; \/\/ main's x is created, initialized, and enters scope here\r\n    int y{ 6 }; \/\/ main's y is created, initialized, and enters scope here\r\n\r\n    \/\/ main's x and y are usable within this function only\r\n    std::cout &lt;&lt; add(x, y) &lt;&lt; '\\n'; \/\/ calls function add() with x=5 and y=6\r\n\r\n    return 0;\r\n} \/\/ main's y and x go out of scope and are destroyed here<\/code><\/pre>\n<p>In this example, all we&#8217;ve done is change the names of variables <code>a<\/code> and <code>b<\/code> inside of function <code>main<\/code> to <code>x<\/code> and <code>y<\/code>.  This program compiles and runs identically, even though functions <code>main<\/code> and <code>add<\/code> both have variables named <code>x<\/code> and <code>y<\/code>.  Why does this work?<\/p>\n<p>First, we need to recognize that even though functions <code>main<\/code> and <code>add<\/code> both have variables named <code>x<\/code> and <code>y<\/code>, these variables are distinct.  The <code>x<\/code> and <code>y<\/code> in function <code>main<\/code> have nothing to do with the <code>x<\/code> and <code>y<\/code> in function <code>add<\/code> -- they just happen to share the same names.<\/p>\n<p>Second, when inside of function <code>main<\/code>, the names <code>x<\/code> and <code>y<\/code> refer to main&#8217;s locally scoped variables <code>x<\/code> and <code>y<\/code>.  Those variables can only be seen (and used) inside of <code>main<\/code>.  Similarly, when inside function <code>add<\/code>, the names <code>x<\/code> and <code>y<\/code> refer to function parameters <code>x<\/code> and <code>y<\/code>, which can only be seen (and used) inside of <code>add<\/code>.<\/p>\n<p>In short, neither <code>add<\/code> nor <code>main<\/code> know that the other function has variables with the same names.  Because the scopes don&#8217;t overlap, it&#8217;s always clear to the compiler which <code>x<\/code> and <code>y<\/code> are being referred to at any time.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Names used for function parameters or variables declared in a function body are only visible within the function that declares them.  This means local variables within a function can be named without regard for the names of variables in other functions.  This helps keep functions independent.\n<\/p><\/div>\n<p>We&#8217;ll talk more about local scope, and other kinds of scope, in a future chapter.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Where to define local variables<\/p>\n<p>In modern C++, the best practice is that local variables inside the function body should be defined as close to their first use as reasonable:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; \"Enter an integer: \";\r\n\tint x{};       \/\/ x defined here\r\n\tstd::cin &gt;&gt; x; \/\/ and used here\r\n\r\n\tstd::cout &lt;&lt; \"Enter another integer: \";\r\n\tint y{};       \/\/ y defined here\r\n\tstd::cin &gt;&gt; y; \/\/ and used here\r\n\r\n\tint sum{ x + y }; \/\/ sum can be initialized with intended value\r\n\tstd::cout &lt;&lt; \"The sum is: \" &lt;&lt; sum &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In the above example, each variable is defined just before it is first used.  There&#8217;s no need to be strict about this -- if you prefer to swap lines 5 and 6, that&#8217;s fine.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Define your local variables as close to their first use as reasonable.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>Due to the limitations of older, more primitive compilers, the C language used to require all local variables be defined at the top of the function.  The equivalent C++ program using that style would look like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tint x{}, y{}, sum{}; \/\/ how are these used?\r\n\r\n\tstd::cout &lt;&lt; \"Enter an integer: \";\r\n\tstd::cin &gt;&gt; x;\r\n\r\n\tstd::cout &lt;&lt; \"Enter another integer: \";\r\n\tstd::cin &gt;&gt; y;\r\n\r\n\tsum = x + y;\r\n\tstd::cout &lt;&lt; \"The sum is: \" &lt;&lt; sum &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This style is suboptimal for several reasons:<\/p>\n<ul>\n<li>The intended use of these variables isn&#8217;t apparent at the point of definition.  You have to scan through the entire function to determine where and how each variable is used.\n<\/li>\n<li>The intended initialization value may not be available at the top of the function (e.g. we can&#8217;t initialize <code>sum<\/code> to its intended value because we don&#8217;t know the value of <code>x<\/code> and <code>y<\/code> yet).\n<\/li>\n<li>There may be many lines between a variable&#8217;s initializer and its first use.  If we don&#8217;t remember what value it was initialized with, we will have to scroll back to the top of the function, which is distracting.\n<\/li>\n<\/ul>\n<p>This restriction was lifted in the C99 language standard.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">When to use function parameters vs Local variables<\/p>\n<p>Because function parameters and local variable can both be used within the body of a function, new programmers sometimes struggle to understand when each should be used.  A function parameter should be used when the caller will pass in the initialization value as an argument.  A local variable should be used otherwise.<\/p>\n<p>Using a function parameter when you should use a local variable leads to code looking like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint getValueFromUser(int val) \/\/ val is a function parameter\r\n{\r\n    std::cout &lt;&lt; \"Enter a value: \";\r\n    std::cin &gt;&gt; val;\r\n    return val;\r\n}\r\n\r\nint main()\r\n{\r\n    int x {};\r\n    int num { getValueFromUser(x) }; \/\/ main must pass x as an argument\r\n\r\n    std::cout &lt;&lt; \"You entered \" &lt;&lt; num &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, <code>getValueFromUser()<\/code> has defined <code>val<\/code> as a function parameter.  Because of this, <code>main()<\/code> must define <code>x<\/code> so that it has something to pass as an argument.  However, the actual value of <code>x<\/code> is never used, and the value that <code>val<\/code> is initialized with is never used.  Making the caller define and pass a variable that is never used adds needless complexity.<\/p>\n<p>The correct way to write this would be as follows:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint getValueFromUser()\r\n{\r\n    int val {}; \/\/ val is a local variable\r\n    std::cout &lt;&lt; \"Enter a value: \";\r\n    std::cin &gt;&gt; val;\r\n    return val;\r\n}\r\n\r\nint main()\r\n{\r\n    int num { getValueFromUser() }; \/\/ main does not need to pass anything\r\n\r\n    std::cout &lt;&lt; \"You entered \" &lt;&lt; num &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this example, <code>val<\/code> is now a local variable.  <code>main()<\/code> is now simpler because it does not need to define or pass a variable to call <code>getValueFromUser()<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>When a variable is needed within a function:<\/p>\n<ul>\n<li>Use a function parameter when the caller will pass in the initialization value for the variable as an argument.\n<\/li>\n<li>Use a local variable otherwise.\n<\/li>\n<\/ul>\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><a name=\"temporaries\"><\/a>Introduction to temporary objects <a href=\"#temporaries\"><i class=\"fa fa-link\" style=\"font-size: 0.8em;\"><\/i><\/a><\/p>\n<p>A <strong>temporary object<\/strong> (also sometimes called an <strong>anonymous object<\/strong>) is an unnamed object that is used to hold a value that is only needed for a short period of time.  Temporary objects are generated by the compiler when they are needed.<\/p>\n<p>There are many different ways that temporary values can be created, but here&#8217;s a common one: <\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint getValueFromUser()\r\n{\r\n \tstd::cout &lt;&lt; \"Enter an integer: \";\r\n\tint input{};\r\n\tstd::cin &gt;&gt; input;\r\n\r\n\treturn input; \/\/ return the value of input back to the caller\r\n}\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; getValueFromUser() &lt;&lt; '\\n'; \/\/ where does the returned value get stored?\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In the above program, the function <code>getValueFromUser()<\/code> returns the value stored in local variable <code>input<\/code> back to the caller.  Because <code>input<\/code> will be destroyed at the end of the function, the caller receives a copy of the value so that it has a value it can use even after <code>input<\/code> is destroyed.<\/p>\n<p>But where is the value that is copied back to the caller stored?  We haven&#8217;t defined any variables in <code>main()<\/code>.  The answer is that the return value is stored in a temporary object.  This temporary object is then passed to <code>std::cout<\/code> to be printed.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Return by value returns a temporary object (that holds a copy of the return value) to the caller.\n<\/p><\/div>\n<p>Temporary objects have no scope at all (this makes sense, since scope is a property of an identifier, and temporary objects have no identifier).<\/p>\n<p>Temporary objects are destroyed at the end of the full expression in which they are created.  This means temporary objects are always destroyed before the next statement executes.<\/p>\n<p>In our example above, the temporary object created to hold the return value of <code>getValueFromUser()<\/code> is destroyed after <code>std::cout &lt;&lt; getValueFromUser() &lt;&lt; '\\n'<\/code> executes.<\/p>\n<p>In the case where a temporary object is used to initialize a variable, the initialization happens before the destruction of the temporary.<\/p>\n<p>In modern C++ (especially since C++17), the compiler has many tricks to avoid generating temporaries where previously it would have needed to.  For example, when we use a return value to initialize a variable, this would normally result in the creation of a temporary holding the return value, and then using the temporary to initialize the variable.  However, in modern C++, the compiler will often skip creating the temporary and just initialize the variable directly with the return value.<\/p>\n<p>Similarly, in the above example, since the return value of <code>getValueFromUser()<\/code> is immediately output, the compiler can skip creation and destruction of the temporary in <code>main()<\/code>, and use the return value of <code>getValueFromUser()<\/code> to directly initialize the parameter of <code>operator&lt;&lt;<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #1<\/p>\n<p>What does the following program print?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid doIt(int x)\r\n{\r\n    int y{ 4 };\r\n    std::cout &lt;&lt; \"doIt: x = \" &lt;&lt; x &lt;&lt; \" y = \" &lt;&lt; y &lt;&lt; '\\n';\r\n\r\n    x = 3;\r\n    std::cout &lt;&lt; \"doIt: x = \" &lt;&lt; x &lt;&lt; \" y = \" &lt;&lt; y &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    int x{ 1 };\r\n    int y{ 2 };\r\n\r\n    std::cout &lt;&lt; \"main: x = \" &lt;&lt; x &lt;&lt; \" y = \" &lt;&lt; y &lt;&lt; '\\n';\r\n\r\n    doIt(x);\r\n\r\n    std::cout &lt;&lt; \"main: x = \" &lt;&lt; x &lt;&lt; \" y = \" &lt;&lt; y &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre>\r\nmain: x = 1 y = 2\r\ndoIt: x = 1 y = 4\r\ndoIt: x = 3 y = 4\r\nmain: x = 1 y = 2\r\n<\/pre>\n<p>Here&#8217;s what happens in this program:<\/p>\n<ul>\n<li>execution starts at the top of <code>main<\/code><\/li>\n<li><code>main<\/code>&#8216;s variable <code>x<\/code> is created and initialized with value <code>1<\/code><\/li>\n<li><code>main<\/code>&#8216;s variable <code>y<\/code> is created and initialized with value <code>2<\/code><\/li>\n<li><code>std::cout<\/code> prints <code>main: x = 1 y = 2<\/code><\/li>\n<li><code>doIt<\/code> is called with argument <code>1<\/code><\/li>\n<li><code>doIt<\/code>&#8216;s parameter <code>x<\/code> is created and initialized with value <code>1<\/code><\/li>\n<li><code>doIt<\/code>\u2019s variable <code>y<\/code> is created and initialized with value <code>4<\/code><\/li>\n<li><code>doIt<\/code> prints <code>doIt: x = 1 y = 4<\/code><\/li>\n<li><code>doIt<\/code>&#8216;s variable <code>x<\/code> is assigned the new value <code>3<\/code><\/li>\n<li><code>std::cout<\/code> prints <code>doIt: x = 3 y = 4<\/code><\/li>\n<li><code>doIt<\/code>&#8216;s <code>y<\/code> and <code>x<\/code> are destroyed<\/li>\n<li><code>std::cout<\/code> prints <code>main: x = 1 y = 2<\/code><\/li>\n<li><code>main<\/code> returns <code>0<\/code> to the operating system<\/li>\n<li><code>main<\/code>&#8216;s <code>y<\/code> and <code>x<\/code> are destroyed<\/li>\n<\/ul>\n<p>Note that even though <code>doIt<\/code>&#8216;s variables <code>x<\/code> and <code>y<\/code> had their values initialized or assigned to something different than <code>main<\/code>&#8216;s, <code>main<\/code>&#8216;s <code>x<\/code> and <code>y<\/code> were unaffected because they are different variables.\n<\/div>\n<\/p>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/why-functions-are-useful-and-how-to-use-them-effectively\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">2.6<\/span>Why functions are useful, and how to use them effectively\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-function-parameters-and-arguments\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">2.4<\/span>Introduction to function parameters and arguments\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Local variables Variables defined inside the body of a function are called local variables (as opposed to global variables, which we&#8217;ll discuss in a future chapter): int add(int x, int y) { int z{ x + y }; \/\/ z is a local variable return z; } Function parameters are &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1117"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=1117"}],"version-history":[{"count":76,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1117\/revisions"}],"predecessor-version":[{"id":18065,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1117\/revisions\/18065"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=1117"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=1117"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=1117"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}