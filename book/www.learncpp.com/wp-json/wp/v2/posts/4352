{"id":4352,"date":"2016-08-09T14:44:04","date_gmt":"2016-08-09T22:44:04","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=4352"},"modified":"2024-12-28T19:11:02","modified_gmt":"2024-12-29T03:11:02","slug":"chapter-21-summary-and-quiz","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-21-summary-and-quiz\/","title":{"rendered":"21.x &#8212; Chapter 21 summary and quiz"},"content":{"rendered":"<p>In this chapter, we explored topics related to operator overloading, as well as overloaded typecasts, and topics related to the copy constructor.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Summary<\/p>\n<p>Operator overloading is a variant of function overloading that lets you overload operators for your classes.  When operators are overloaded, the intent of the operators should be kept as close to the original intent of the operators as possible.  If the meaning of an operator when applied to a custom class is not clear and intuitive, use a named function instead.<\/p>\n<p>Operators can be overloaded as a normal function, a friend function, or a member function. The following rules of thumb can help you determine which form is best for a given situation:<\/p>\n<ul>\n<li>If you\u2019re overloading assignment (=), subscript ([]), function call (()), or member selection (->), do so as a member function.\n<\/li>\n<li>If you\u2019re overloading a unary operator, do so as a member function.\n<\/li>\n<li>If you\u2019re overloading a binary operator that modifies its left operand (e.g. operator+=), do so as a member function if you can.\n<\/li>\n<li>If you\u2019re overloading a binary operator that does not modify its left operand (e.g. operator+), do so as a normal function or friend function.\n<\/li>\n<\/ul>\n<p>Typecasts can be overloaded to provide conversion functions, which can be used to explicitly or implicitly convert your class into another type.<\/p>\n<p>A copy constructor is a special type of constructor used to initialize an object from another object of the same type.  Copy constructors are used for direct\/uniform initialization from an object of the same type, copy initialization (Fraction f = Fraction(5,3)), and when passing or returning a parameter by value.<\/p>\n<p>If you do not supply a copy constructor, the compiler will create one for you.  Compiler-provided copy constructors will use memberwise initialization, meaning each member of the copy is initialized from the original member.  The copy constructor may be elided for optimization purposes, even if it has side-effects, so do not rely on your copy constructor actually executing.<\/p>\n<p>Constructors are considered converting constructors by default, meaning that the compiler will use them to implicitly convert objects of other types into objects of your class.  You can avoid this by using the explicit keyword in front of your constructor.  You can also delete functions within your class, including the copy constructor and overloaded assignment operator if desired.  This will cause a compiler error if a deleted function would be called.<\/p>\n<p>The assignment operator can be overloaded to allow assignment to your class.  If you do not provide an overloaded assignment operator, the compiler will create one for you.  Overloaded assignment operators should always include a self-assignment check (unless it&#8217;s handled naturally, or you&#8217;re using the copy and swap idiom).<\/p>\n<p>New programmers often mix up when the assignment operator vs copy constructor are used, but it&#8217;s fairly straightforward:<\/p>\n<ul>\n<li>If a new object has to be created before the copying can occur, the copy constructor is used (note: this includes passing or returning objects by value).\n<\/li>\n<li>If a new object does not have to be created before the copying can occur, the assignment operator is used.\n<\/li>\n<\/ul>\n<p>By default, the copy constructor and assignment operators provided by the compiler do a memberwise initialization or assignment, which is a shallow copy.  If your class dynamically allocates memory, this will likely lead to problems, as multiple objects will end up pointing to the same allocated memory.  In this case, you&#8217;ll need to explicitly define these in order to do a deep copy.  Even better, avoid doing your own memory management if you can and use classes from the standard library.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<ol start=\"1\">\n<li>Assuming <code>Point<\/code> is a class and <code>point<\/code> is an instance of that class, should you use a normal\/friend or member function overload for the following operators?\n<\/li>\n<\/ol>\n<p>a) <code>point + point<\/code><\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\nbinary <code>operator+<\/code> is best implemented as a normal\/friend function.<\/div>\n<p>b) <code>-point<\/code><\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\nunary <code>operator-<\/code> is best implemented as a member function.<\/div>\n<p>c) <code>std::cout &lt;&lt; point<\/code><\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<code>operator&lt;&lt;<\/code> must be implemented as a normal\/friend function.<\/div>\n<p>d) <code>point = 5;<\/code><\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<code>operator=<\/code> must be implemented as a member function.<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>Write a class named Average that will keep track of the average of all integers passed to it.  Use two members: The first one should be type <code>std::int32_t<\/code>, and used to keep track of the sum of all the numbers you&#8217;ve seen so far.  The second should keep track of how many numbers you&#8217;ve seen so far.  You can divide them to find your average.<\/p>\n<p>a) Write all of the functions necessary for the following program to run:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n\tAverage avg{};\r\n\tstd::cout &lt;&lt; avg &lt;&lt; '\\n';\r\n\t\r\n\tavg += 4;\r\n\tstd::cout &lt;&lt; avg &lt;&lt; '\\n'; \/\/ 4 \/ 1 = 4\r\n\t\r\n\tavg += 8;\r\n\tstd::cout &lt;&lt; avg &lt;&lt; '\\n'; \/\/ (4 + 8) \/ 2 = 6\r\n\r\n\tavg += 24;\r\n\tstd::cout &lt;&lt; avg &lt;&lt; '\\n'; \/\/ (4 + 8 + 24) \/ 3 = 12\r\n\r\n\tavg += -10;\r\n\tstd::cout &lt;&lt; avg &lt;&lt; '\\n'; \/\/ (4 + 8 + 24 - 10) \/ 4 = 6.5\r\n\r\n\t(avg += 6) += 10; \/\/ 2 calls chained together\r\n\tstd::cout &lt;&lt; avg &lt;&lt; '\\n'; \/\/ (4 + 8 + 24 - 10 + 6 + 10) \/ 6 = 7\r\n\r\n\tAverage copy{ avg };\r\n\tstd::cout &lt;&lt; copy &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>and produce the result:<\/p>\n<pre>\n0\r\n4\r\n6\r\n12\r\n6.5\r\n7\r\n7\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;cstdint&gt; \/\/ for fixed width integers\r\n\r\nclass Average\r\n{\r\nprivate:\r\n\tstd::int32_t m_total{ 0 }; \/\/ the sum of all numbers we've seen so far\r\n\tint m_numbers{ 0 }; \/\/ the count of numbers we've seen so far\r\n\r\npublic:\r\n\tAverage()\r\n\t{\r\n\t}\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Average&amp; average)\r\n\t{\r\n        \/\/ Handle case where we haven't seen any numbers yet\r\n\t\tif (average.m_numbers == 0)\r\n\t\t{\r\n\t\t\tout &lt;&lt; 0;\r\n\t\t\treturn out;\r\n\t\t}\r\n\r\n\t\t\/\/ Our average is the sum of the numbers we've seen divided by the count of the numbers we've seen\r\n\t\t\/\/ We need to remember to do a floating point division here, not an integer division\r\n\t\tout &lt;&lt; static_cast&lt;double&gt;(average.m_total) \/ average.m_numbers;\r\n\r\n\t\treturn out;\r\n\t}\r\n\r\n\t\/\/ Because operator+= modifies its left operand, we'll write it as a member\r\n\tAverage&amp; operator+=(std::int32_t num)\r\n\t{\r\n\t\t\/\/ Increment our total by the new number\r\n\t\tm_total += num;\r\n\t\t\/\/ And increase the count by 1\r\n\t\t++m_numbers;\r\n\r\n\t\t\/\/ return *this in case someone wants to chain +='s together\r\n\t\treturn *this;\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tAverage avg{};\r\n\tstd::cout &lt;&lt; avg &lt;&lt; '\\n';\r\n\r\n\tavg += 4;\r\n\tstd::cout &lt;&lt; avg &lt;&lt; '\\n';\r\n\t\r\n\tavg += 8;\r\n\tstd::cout &lt;&lt; avg &lt;&lt; '\\n';\r\n\r\n\tavg += 24;\r\n\tstd::cout &lt;&lt; avg &lt;&lt; '\\n';\r\n\r\n\tavg += -10;\r\n\tstd::cout &lt;&lt; avg &lt;&lt; '\\n';\r\n\r\n\t(avg += 6) += 10; \/\/ 2 calls chained together\r\n\tstd::cout &lt;&lt; avg &lt;&lt; '\\n';\r\n\r\n\tAverage copy{ avg };\r\n\tstd::cout &lt;&lt; copy &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>b) Should you provide a user-defined copy constructor or assignment operator for this class?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_5'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_5\" style=\"display:none\">\n<p>No.  Because using memberwise initialization\/copy is fine here, using the compiler provided defaults is acceptable.\n<\/p><\/div>\n<p>c) Why use <code>std::int32_t<\/code> instead of <code>int<\/code>?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_6'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_6\" style=\"display:none\">\n<p><code>int<\/code> may be 16-bits on some platforms, which would mean our <code>Average<\/code> object could only have a maximum numerator value of 32,767.  Using <code>std::int32_t<\/code> guarantees a 32-bit integral value, which gives us much more range to work with.\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #3<\/p>\n<p>Write your own integer array class named <code>IntArray<\/code> from scratch (do not use std::array or std::vector).  Users should pass in the size of the array when it is created, and the array should be dynamically allocated.  Use assert statements to guard against bad data.  Create any constructors or overloaded operators needed to make the following program operate correctly:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nIntArray fillArray()\r\n{\r\n\tIntArray a(5);\r\n\r\n\ta[0] = 5;\r\n\ta[1] = 8;\r\n\ta[2] = 2;\r\n\ta[3] = 3;\r\n\ta[4] = 6;\r\n\r\n\treturn a;\r\n}\r\n\r\nint main()\r\n{\r\n\tIntArray a{ fillArray() };\r\n\r\n\tstd::cout &lt;&lt; a &lt;&lt; '\\n';\r\n\r\n\tauto&amp; ref{ a }; \/\/ we're using this reference to avoid compiler self-assignment errors\r\n\ta = ref;\r\n\r\n\tIntArray b(1);\r\n\tb = a;\r\n\r\n\ta[4] = 7;\r\n\r\n\tstd::cout &lt;&lt; b &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This program should print:<\/p>\n<pre>\n5 8 2 3 6\r\n5 8 2 3 6\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_7'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_7\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;cassert&gt; \/\/ for assert\r\n\r\nclass IntArray\r\n{\r\nprivate:\r\n\tint m_length{ 0 };\r\n\tint* m_array{ nullptr };\r\n\r\npublic:\r\n\texplicit IntArray(int length)\r\n\t\t: m_length{ length }\r\n\t{\r\n\t\tassert(length &gt; 0 &amp;&amp; \"IntArray length should be a positive integer\");\r\n\r\n\t\tm_array = new int[static_cast&lt;std::size_t&gt;(m_length)] {};\r\n\t}\r\n\r\n\t\/\/ Copy constructor that does a deep copy\r\n\tIntArray(const IntArray&amp; array)\r\n\t\t: m_length{ array.m_length }\r\n\t{\r\n\t\t\/\/ Allocate a new array\r\n\t\tm_array = new int[static_cast&lt;std::size_t&gt;(m_length)] {};\r\n\r\n\t\t\/\/ Copy elements from original array to new array\r\n\t\tfor (int count{ 0 }; count &lt; array.m_length; ++count)\r\n\t\t\tm_array[count] = array.m_array[count];\r\n\t}\r\n\r\n\t~IntArray()\r\n\t{\r\n\t\tdelete[] m_array;\r\n\t}\r\n\r\n\t\/\/ If you're getting crazy values here you probably forgot to do a deep copy in your copy constructor\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const IntArray&amp; array)\r\n\t{\r\n\t\tfor (int count{ 0 }; count &lt; array.m_length; ++count)\r\n\t\t{\r\n\t\t\tout &lt;&lt; array.m_array[count] &lt;&lt; ' ';\r\n\t\t}\r\n\t\treturn out;\r\n\t}\r\n\r\n\tint&amp; operator[] (const int index)\r\n\t{\r\n\t\tassert(index &gt;= 0);\r\n\t\tassert(index &lt; m_length);\r\n\t\treturn m_array[index];\r\n\t}\r\n\r\n\t\/\/ Assignment operator that does a deep copy\r\n\tIntArray&amp; operator= (const IntArray&amp; array)\r\n\t{\r\n\t\t\/\/ self-assignment guard\r\n\t\tif (this == &amp;array)\r\n\t\t\treturn *this;\r\n\r\n\t\t\/\/ If this array already exists, delete it so we don't leak memory\r\n\t\tdelete[] m_array;\r\n\r\n\t\tm_length = array.m_length;\r\n\r\n\t\t\/\/ Allocate a new array\r\n\t\tm_array = new int[static_cast&lt;std::size_t&gt;(m_length)] {};\r\n\r\n\t\t\/\/ Copy elements from original array to new array\r\n\t\tfor (int count{ 0 }; count &lt; array.m_length; ++count)\r\n\t\t\tm_array[count] = array.m_array[count];\r\n\r\n\t\treturn *this;\r\n\t}\r\n\r\n};\r\n\r\nIntArray fillArray()\r\n{\r\n\tIntArray a(5);\r\n\ta[0] = 5;\r\n\ta[1] = 8;\r\n\ta[2] = 2;\r\n\ta[3] = 3;\r\n\ta[4] = 6;\r\n\r\n\treturn a;\r\n}\r\n\r\nint main()\r\n{\r\n\tIntArray a{ fillArray() };\r\n\r\n\t\/\/ If you're getting crazy values here you probably forgot to do a deep copy in your copy constructor\r\n\tstd::cout &lt;&lt; a &lt;&lt; '\\n';\r\n\r\n\tauto&amp; ref{ a }; \/\/ we're using this reference to avoid compiler self-assignment errors\r\n\ta = ref;\r\n\r\n\tIntArray b(1);\r\n\tb = a;\r\n\r\n\ta[4] = 7; \/\/ change value in a, b should not change\r\n\r\n\t\/\/ If you're getting crazy values here you probably forgot to do self-assignment check\r\n\t\/\/ If b ends in 7, you probably forgot to do a deep copy in your copy assignment\r\n\tstd::cout &lt;&lt; b &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #4<\/p>\n<p>Extra credit: This one is a little more tricky.<\/p>\n<p>A floating point number is a number with a decimal where the number of digits after the decimal can be variable.  A fixed point number is a number with a fractional component where the number of digits in the fractional portion is fixed.<\/p>\n<p>In this quiz, we&#8217;re going to write a class to implement a fixed point number with two fractional digits (e.g. 12.34, 3.00, or 1278.99).  Assume that the range of the class should be -32768.99 to 32767.99, that the fractional component should hold any two digits, that we don&#8217;t want precision errors, and that we want to conserve space.<\/p>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #1<\/p>\n<p>What type of member variable(s) do you think we should use to implement our fixed point number with 2 digits after the decimal?  (Make sure you read the answer before proceeding with the next questions)<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_8'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_8\" style=\"display:none\">\n<p>There are many different ways to implement a fixed point number.  Because a fixed point number is essentially a subcase of a floating point number (where the number of digits after the decimal is fixed instead of variable), using a floating point number might seem like an obvious choice.  But floating point numbers have precision issues.  With a fixed number of decimal digits, we can reasonably enumerate all the possible fractional values (in our case, .00 to .99), so using a data type that has precision issues isn&#8217;t the best choice.<\/p>\n<p>A better solution would be to use a 16-bit signed integer to hold the non-fractional part of the number, and an 8-bit signed integer to hold the fractional component.\n<\/p><\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #2<\/p>\n<p>Write a class named <code>FixedPoint2<\/code> that implements the recommended solution from the previous question.  If either (or both) of the non-fractional and fractional part of the number are negative, the number should be treated as negative.  Provide the overloaded operators and constructors required for the following program to run.  For now, don&#8217;t worry about the fractional portion being out of bounds (&gt;99 or &lt;-99).<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tFixedPoint2 a{ 34, 56 };\r\n\tstd::cout &lt;&lt; a &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; static_cast&lt;double&gt;(a) &lt;&lt; '\\n';\r\n\tassert(static_cast&lt;double&gt;(a) == 34.56);\r\n\r\n\tFixedPoint2 b{ -2, 8 };\r\n\tassert(static_cast&lt;double&gt;(b) == -2.08);\r\n\r\n\tFixedPoint2 c{ 2, -8 };\r\n\tassert(static_cast&lt;double&gt;(c) == -2.08);\r\n\r\n\tFixedPoint2 d{ -2, -8 };\r\n\tassert(static_cast&lt;double&gt;(d) == -2.08);\r\n\r\n\tFixedPoint2 e{ 0, -5 };\r\n\tassert(static_cast&lt;double&gt;(e) == -0.05);\r\n\r\n\tFixedPoint2 f{ 0, 10 };\r\n\tassert(static_cast&lt;double&gt;(f) == 0.1);\r\n    \r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This program should produce the result:<\/p>\n<pre>\n34.56\r\n34.56\r\n<\/pre>\n<p>Hint: To output your number, static_cast it to a double.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_9'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_9\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;cstdint&gt; \/\/ for fixed width integers\r\n#include &lt;iostream&gt;\r\n\r\nclass FixedPoint2\r\n{\r\nprivate:\r\n\tstd::int16_t m_base{}; \/\/ here's our non-fractional part\r\n\tstd::int8_t m_decimal{}; \/\/ here's our factional part\r\n\r\npublic:\r\n\tFixedPoint2(std::int16_t base = 0, std::int8_t decimal = 0)\r\n\t\t: m_base{ base }, m_decimal{ decimal }\r\n\t{\r\n\t\t\/\/ If either (or both) of the non-fractional and fractional part of the number are negative, the number should be treated as negative\r\n\t\tif (m_base &lt; 0 || m_decimal &lt; 0)\r\n\t\t{\r\n\t\t\t\/\/ Make sure base is negative\r\n\t\t\tif (m_base &gt; 0)\r\n\t\t\t\tm_base = -m_base;\r\n\t\t\t\/\/ Make sure decimal is negative\r\n\t\t\tif (m_decimal &gt; 0)\r\n\t\t\t\tm_decimal = -m_decimal;\r\n\t\t}\r\n\t}\r\n\r\n\texplicit operator double() const\r\n\t{\r\n\t\treturn m_base + (static_cast&lt;double&gt;(m_decimal) \/ 100);\r\n\t}\r\n};\r\n\r\n\/\/ This doesn't require access to the internals of the class, so it can be defined outside the class\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const FixedPoint2&amp; fp)\r\n{\r\n\tout &lt;&lt; static_cast&lt;double&gt;(fp);\r\n\treturn out;\r\n}\r\n\r\nint main()\r\n{\r\n\tFixedPoint2 a{ 34, 56 };\r\n\tstd::cout &lt;&lt; a &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; static_cast&lt;double&gt;(a) &lt;&lt; '\\n';\r\n\tassert(static_cast&lt;double&gt;(a) == 34.56);\r\n\r\n\tFixedPoint2 b{ -2, 8 };\r\n\tassert(static_cast&lt;double&gt;(b) == -2.08);\r\n\r\n\tFixedPoint2 c{ 2, -8 };\r\n\tassert(static_cast&lt;double&gt;(c) == -2.08);\r\n\r\n\tFixedPoint2 d{ -2, -8 };\r\n\tassert(static_cast&lt;double&gt;(d) == -2.08);\r\n\r\n\tFixedPoint2 e{ 0, -5 };\r\n\tassert(static_cast&lt;double&gt;(e) == -0.05);\r\n\r\n\tFixedPoint2 f{ 0, 10 };\r\n\tassert(static_cast&lt;double&gt;(f) == 0.1);\r\n    \r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #3<\/p>\n<p>Now let&#8217;s handle the case where the fractional portion is out of bounds.  We have two reasonable strategies here:<\/p>\n<ul>\n<li>Clamp the fraction portion (if &gt;99, set to 99).\n<\/li>\n<li>Treat overflow as relevant (if &gt;99, reduce by 100 and add 1 to base).\n<\/li>\n<\/ul>\n<p>In this exercise, we&#8217;ll treat decimal overflow as relevant, as this will be useful in the next step.<\/p>\n<p>The following should run:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n\r\n\/\/ You will need to make testDecimal a friend of FixedPoint2\r\n\/\/ so the function can access the private members of FixedPoint2\r\nbool testDecimal(const FixedPoint2 &amp;fp)\r\n{\r\n    if (fp.m_base &gt;= 0)\r\n        return fp.m_decimal &gt;= 0 &amp;&amp; fp.m_decimal &lt; 100;\r\n    else\r\n        return fp.m_decimal &lt;= 0 &amp;&amp; fp.m_decimal &gt; -100;\r\n}\r\n\r\nint main()\r\n{\r\n\tFixedPoint2 a{ 1, 104 };\r\n\tstd::cout &lt;&lt; a &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; static_cast&lt;double&gt;(a) &lt;&lt; '\\n';\r\n\tassert(static_cast&lt;double&gt;(a) == 2.04);\r\n\tassert(testDecimal(a));\r\n\r\n\tFixedPoint2 b{ 1, -104 };\r\n\tassert(static_cast&lt;double&gt;(b) == -2.04);\r\n\tassert(testDecimal(b));\r\n\r\n\tFixedPoint2 c{ -1, 104 };\r\n\tassert(static_cast&lt;double&gt;(c) == -2.04);\r\n\tassert(testDecimal(c));\r\n\r\n\tFixedPoint2 d{ -1, -104 };\r\n\tassert(static_cast&lt;double&gt;(d) == -2.04);\r\n\tassert(testDecimal(d));\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>And produce the output:<\/p>\n<pre>\n2.04\r\n2.04\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_10'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_10\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;cstdint&gt; \/\/ for fixed width integers\r\n#include &lt;iostream&gt;\r\n\r\nclass FixedPoint2\r\n{\r\nprivate:\r\n\tstd::int16_t m_base{}; \/\/ here's our non-fractional part\r\n\tstd::int8_t m_decimal{}; \/\/ here's our factional part\r\n\r\npublic:\r\n\tFixedPoint2(std::int16_t base = 0, std::int8_t decimal = 0)\r\n\t\t: m_base{ base }, m_decimal{ decimal }\r\n\t{\r\n\t\t\/\/ If either (or both) of the non-fractional and fractional part of the number are negative, the number should be treated as negative\r\n\t\tif (m_base &lt; 0 || m_decimal &lt; 0)\r\n\t\t{\r\n\t\t\t\/\/ Make sure base is negative\r\n\t\t\tif (m_base &gt; 0)\r\n\t\t\t\tm_base = -m_base;\r\n\t\t\t\/\/ Make sure decimal is negative\r\n\t\t\tif (m_decimal &gt; 0)\r\n\t\t\t\tm_decimal = -m_decimal;\r\n\t\t}\r\n\r\n\t\t\/\/ If decimal is out of bounds (in either direction),\r\n\t\t\/\/ adjust the decimal so it's in bounds,\r\n\t\t\/\/ and adjust base to account for the number of units removed from the decimal\r\n\t\t\/\/ h\/t to reader David Pinheiro for simplifying this\r\n\t\tm_base += m_decimal \/ 100;    \/\/ integer division\r\n\t\tm_decimal = m_decimal % 100;  \/\/ integer remainder\r\n\t}\r\n\r\n\texplicit operator double() const\r\n\t{\r\n\t\treturn m_base + (static_cast&lt;double&gt;(m_decimal) \/ 100);\r\n\t}\r\n\r\n\tfriend bool testDecimal(const FixedPoint2 &amp;fp);\r\n};\r\n\r\n\/\/ This doesn't require access to the internals of the class, so it can be defined outside the class\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const FixedPoint2&amp; fp)\r\n{\r\n\tout &lt;&lt; static_cast&lt;double&gt;(fp);\r\n\treturn out;\r\n}\r\n\r\n\/\/ You will need to make testDecimal a friend of FixedPoint2\r\n\/\/ so the function can access the private members of FixedPoint2\r\nbool testDecimal(const FixedPoint2 &amp;fp)\r\n{\r\n\tif (fp.m_base &gt;= 0)\r\n\t\treturn fp.m_decimal &gt;= 0 &amp;&amp; fp.m_decimal &lt; 100;\r\n\telse\r\n\t\treturn fp.m_decimal &lt;= 0 &amp;&amp; fp.m_decimal &gt; -100;\r\n}\r\n\r\nint main()\r\n{\r\n\tFixedPoint2 a{ 1, 104 };\r\n\tstd::cout &lt;&lt; a &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; static_cast&lt;double&gt;(a) &lt;&lt; '\\n';\r\n\tassert(static_cast&lt;double&gt;(a) == 2.04);\r\n\tassert(testDecimal(a));\r\n\r\n\tFixedPoint2 b{ 1, -104 };\r\n\tassert(static_cast&lt;double&gt;(b) == -2.04);\r\n\tassert(testDecimal(b));\r\n\r\n\tFixedPoint2 c{ -1, 104 };\r\n\tassert(static_cast&lt;double&gt;(c) == -2.04);\r\n\tassert(testDecimal(c));\r\n\r\n\tFixedPoint2 d{ -1, -104 };\r\n\tassert(static_cast&lt;double&gt;(d) == -2.04);\r\n\tassert(testDecimal(d));\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #4<\/p>\n<p>Now add a constructor that takes a double.  The follow program should run:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tFixedPoint2 a{ 0.01 };\r\n\tassert(static_cast&lt;double&gt;(a) == 0.01);\r\n\r\n\tFixedPoint2 b{ -0.01 };\r\n\tassert(static_cast&lt;double&gt;(b) == -0.01);\r\n\r\n\tFixedPoint2 c{ 1.9 }; \/\/ make sure we handle single digit decimal\r\n\tassert(static_cast&lt;double&gt;(c) == 1.9);\r\n    \r\n\tFixedPoint2 d{ 5.01 }; \/\/ stored as 5.0099999... so we'll need to round this\r\n\tassert(static_cast&lt;double&gt;(d) == 5.01);\r\n\r\n\tFixedPoint2 e{ -5.01 }; \/\/ stored as -5.0099999... so we'll need to round this\r\n\tassert(static_cast&lt;double&gt;(e) == -5.01);\r\n\r\n\t\/\/ Handle case where the argument's decimal rounds to 100 (need to increase base by 1)\r\n\tFixedPoint2 f { 106.9978 }; \/\/ should be stored with base 107 and decimal 0\r\n\tassert(static_cast&lt;double&gt;(f) == 107.0);\r\n\r\n\t\/\/ Handle case where the argument's decimal rounds to -100 (need to decrease base by 1)\r\n\tFixedPoint2 g { -106.9978 }; \/\/ should be stored with base -107 and decimal 0\r\n\tassert(static_cast&lt;double&gt;(g) == -107.0);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Recommendation: This one will be a bit tricky.  Do this one in three steps.  First, solve for the cases where the double parameter is representable directly (variables <code>a<\/code> through <code>c<\/code> above).  Then, update your code to handle the cases where the double parameter has a rounding error (variables <code>d<\/code> &#038; <code>e<\/code>).  Variables <code>f<\/code> and <code>g<\/code> should be handled by the overflow handling we added in the prior step.<\/p>\n<p>For all cases: <a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_0'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_0\" style=\"display:none; margin-bottom: 1em\">Hint: You can move a digit from the right of the decimal to the left of the decimal by multiplying by 10.  Multiply by 100 to move two places.<\/div>\n<p>For variables <code>a<\/code> through <code>c<\/code>: <a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_1'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_1\" style=\"display:none; margin-bottom: 1em\">Hint: You can get the non-fractional part of a double by static casting the double to an integer.  To get the fractional part, you can subtract out the base part.<\/div>\n<p>For variables <code>d<\/code> &#038; <code>e<\/code>: <a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_2'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_2\" style=\"display:none; margin-bottom: 1em\">Hint: You can round a number (on the left of the decimal) by using the <code>std::round()<\/code> function (included in header <code>&lt;cmath&gt;<\/code>), and take the floor of the number (towards zero) using <code>std::trunc()<\/code>.<\/div>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_11'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_11\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;cmath&gt;\r\n#include &lt;cstdint&gt; \/\/ for fixed width integers\r\n#include &lt;iostream&gt;\r\n\r\nclass FixedPoint2\r\n{\r\nprivate:\r\n\tstd::int16_t m_base{}; \/\/ here's our non-fractional part\r\n\tstd::int8_t m_decimal{}; \/\/ here's our factional part\r\n\r\npublic:\r\n\tFixedPoint2(std::int16_t base = 0, std::int8_t decimal = 0)\r\n\t\t: m_base{ base }, m_decimal{ decimal }\r\n\t{\r\n\t\t\/\/ If either (or both) of the non-fractional and fractional part of the number are negative, the number should be treated as negative\r\n\t\tif (m_base &lt; 0 || m_decimal &lt; 0)\r\n\t\t{\r\n\t\t\t\/\/ Make sure base is negative\r\n\t\t\tif (m_base &gt; 0)\r\n\t\t\t\tm_base = -m_base;\r\n\t\t\t\/\/ Make sure decimal is negative\r\n\t\t\tif (m_decimal &gt; 0)\r\n\t\t\t\tm_decimal = -m_decimal;\r\n\t\t}\r\n\r\n\t\t\/\/ If decimal is out of bounds (in either direction),\r\n\t\t\/\/ adjust the decimal so it's in bounds,\r\n\t\t\/\/ and adjust base to account for the number of units removed from the decimal\r\n\t\t\/\/ h\/t to reader David Pinheiro for simplifying this\r\n\t\tm_base += m_decimal \/ 100;    \/\/ integer division\r\n\t\tm_decimal = m_decimal % 100;  \/\/ integer remainder\r\n\t}\r\n\r\n\t\/\/ We'll delegate to the prior constructor so we don't have to duplicate the negative number and overflow handling logic\r\n\tFixedPoint2(double d) :\r\n\t\tFixedPoint2(\r\n\t\t\tstatic_cast&lt;std::int16_t&gt;(std::trunc(d)),\r\n\t\t\tstatic_cast&lt;std::int8_t&gt;(std::round(d * 100) - std::trunc(d) * 100)\r\n\t\t)\r\n\t{\r\n\t}\r\n\r\n\texplicit operator double() const\r\n\t{\r\n\t\treturn m_base + (static_cast&lt;double&gt;(m_decimal) \/ 100);\r\n\t}\r\n};\r\n\r\n\/\/ This doesn't require access to the internals of the class, so it can be defined outside the class\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const FixedPoint2&amp; fp)\r\n{\r\n\tout &lt;&lt; static_cast&lt;double&gt;(fp);\r\n\treturn out;\r\n}\r\n\r\nint main()\r\n{\r\n\tFixedPoint2 a{ 0.01 };\r\n\tstd::cout &lt;&lt; a &lt;&lt; '\\n';\r\n\tassert(static_cast&lt;double&gt;(a) == 0.01);\r\n\r\n\tFixedPoint2 b{ -0.01 };\r\n\tassert(static_cast&lt;double&gt;(b) == -0.01);\r\n\r\n\tFixedPoint2 c{ 1.9 }; \/\/ make sure we handle single digit decimal\r\n\tassert(static_cast&lt;double&gt;(c) == 1.9);\r\n    \r\n\tFixedPoint2 d{ 5.01 }; \/\/ stored as 5.0099999... so we'll need to round this\r\n\tassert(static_cast&lt;double&gt;(d) == 5.01);\r\n\r\n\tFixedPoint2 e{ -5.01 }; \/\/ stored as -5.0099999... so we'll need to round this\r\n\tassert(static_cast&lt;double&gt;(e) == -5.01);\r\n\r\n\t\/\/ Handle case where the argument's decimal rounds to 100 (need to increase base by 1)\r\n\tFixedPoint2 f { 106.9978 }; \/\/ should be stored with base 107 and decimal 0\r\n\tassert(static_cast&lt;double&gt;(f) == 107.0);\r\n\r\n\t\/\/ Handle case where the argument's decimal rounds to -100 (need to decrease base by 1)\r\n\tFixedPoint2 g { -106.9978 }; \/\/ should be stored with base -107 and decimal 0\r\n\tassert(static_cast&lt;double&gt;(g) == -107.0);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #5<\/p>\n<p>Overload <code>operator==<\/code>, <code>operator&gt;&gt;<\/code>, <code>operator-<\/code> (unary), and <code>operator+<\/code> (binary).<\/p>\n<p>The following program should run:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tassert(FixedPoint2{ 0.75 } == FixedPoint2{ 0.75 });    \/\/ Test equality true\r\n\tassert(!(FixedPoint2{ 0.75 } == FixedPoint2{ 0.76 })); \/\/ Test equality false\r\n    \r\n\t\/\/ Test additional cases -- h\/t to reader Sharjeel Safdar for these test cases\r\n\tassert(FixedPoint2{ 0.75 } + FixedPoint2{ 1.23 } == FixedPoint2{ 1.98 });    \/\/ both positive, no decimal overflow\r\n\tassert(FixedPoint2{ 0.75 } + FixedPoint2{ 1.50 } == FixedPoint2{ 2.25 });    \/\/ both positive, with decimal overflow\r\n\tassert(FixedPoint2{ -0.75 } + FixedPoint2{ -1.23 } == FixedPoint2{ -1.98 }); \/\/ both negative, no decimal overflow\r\n\tassert(FixedPoint2{ -0.75 } + FixedPoint2{ -1.50 } == FixedPoint2{ -2.25 }); \/\/ both negative, with decimal overflow\r\n\tassert(FixedPoint2{ 0.75 } + FixedPoint2{ -1.23 } == FixedPoint2{ -0.48 });  \/\/ second negative, no decimal overflow\r\n\tassert(FixedPoint2{ 0.75 } + FixedPoint2{ -1.50 } == FixedPoint2{ -0.75 });  \/\/ second negative, possible decimal overflow\r\n\tassert(FixedPoint2{ -0.75 } + FixedPoint2{ 1.23 } == FixedPoint2{ 0.48 });   \/\/ first negative, no decimal overflow\r\n\tassert(FixedPoint2{ -0.75 } + FixedPoint2{ 1.50 } == FixedPoint2{ 0.75 });   \/\/ first negative, possible decimal overflow\r\n    \r\n\tFixedPoint2 a{ -0.48 };\r\n\tassert(static_cast&lt;double&gt;(a) == -0.48);\r\n\tassert(static_cast&lt;double&gt;(-a) == 0.48);\r\n\r\n\tstd::cout &lt;&lt; \"Enter a number: \"; \/\/ enter 5.678\r\n\tstd::cin &gt;&gt; a;\r\n\tstd::cout &lt;&lt; \"You entered: \" &lt;&lt; a &lt;&lt; '\\n';\r\n\tassert(static_cast&lt;double&gt;(a) == 5.68);\r\n\t\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_3'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_3\" style=\"display:none; margin-bottom: 1em\">Hint: Add your two <code>FixedPoint2<\/code> together by leveraging the double cast, adding the results, and converting back to a <code>FixedPoint2<\/code>.  This elegantly handles overflowing decimals.<\/div>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_4'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_4\" style=\"display:none; margin-bottom: 1em\">Hint: For <code>operator&gt;&gt;<\/code>, use your double constructor to create an anonymous object of type <code>FixedPoint2<\/code>, and assign it to your <code>FixedPoint2<\/code> function parameter.<\/div>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_12'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_12\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;cmath&gt;\r\n#include &lt;cstdint&gt; \/\/ for fixed width integers\r\n#include &lt;iostream&gt;\r\n\r\nclass FixedPoint2\r\n{\r\nprivate:\r\n\tstd::int16_t m_base{}; \/\/ here's our non-fractional part\r\n\tstd::int8_t m_decimal{}; \/\/ here's our factional part\r\n\r\npublic:\r\n\tFixedPoint2(std::int16_t base = 0, std::int8_t decimal = 0)\r\n\t\t: m_base{ base }, m_decimal{ decimal }\r\n\t{\r\n\t\t\/\/ If either (or both) of the non-fractional and fractional part of the number are negative, the number should be treated as negative\r\n\t\tif (m_base &lt; 0 || m_decimal &lt; 0)\r\n\t\t{\r\n\t\t\t\/\/ Make sure base is negative\r\n\t\t\tif (m_base &gt; 0)\r\n\t\t\t\tm_base = -m_base;\r\n\t\t\t\/\/ Make sure decimal is negative\r\n\t\t\tif (m_decimal &gt; 0)\r\n\t\t\t\tm_decimal = -m_decimal;\r\n\t\t}\r\n\r\n\t\t\/\/ If decimal is out of bounds (in either direction),\r\n\t\t\/\/ adjust the decimal so it's in bounds,\r\n\t\t\/\/ and adjust base to account for the number of units removed from the decimal\r\n\t\t\/\/ h\/t to reader David Pinheiro for simplifying this\r\n\t\tm_base += m_decimal \/ 100;    \/\/ integer division\r\n\t\tm_decimal = m_decimal % 100;  \/\/ integer remainder\r\n\t}\r\n\r\n\tFixedPoint2(double d) :\r\n\t\tFixedPoint2(\r\n\t\t\tstatic_cast&lt;std::int16_t&gt;(std::trunc(d)),\r\n\t\t\tstatic_cast&lt;std::int8_t&gt;(std::round(d * 100) - std::trunc(d) * 100)\r\n\t\t)\r\n\t{\r\n\t}\r\n\r\n\texplicit operator double() const\r\n\t{\r\n\t\treturn m_base + (static_cast&lt;double&gt;(m_decimal) \/ 100);\r\n\t}\r\n\r\n\tfriend bool operator==(const FixedPoint2&amp; fp1, const FixedPoint2&amp; fp2)\r\n\t{\r\n\t\treturn fp1.m_base == fp2.m_base &amp;&amp; fp1.m_decimal == fp2.m_decimal;\r\n\t}\r\n\r\n\tFixedPoint2 operator-() const\r\n\t{\r\n\t\t\/\/ Cast to double, make the double negative, then convert back to FixedPoint2\r\n\t\t\/\/ h\/t to reader EmtyC for this version\r\n\t\treturn FixedPoint2{ -static_cast&lt;double&gt;(*this) };\r\n\t}\r\n};\r\n\r\n\/\/ This doesn't require access to the internals of the class, so it can be defined outside the class\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const FixedPoint2&amp; fp)\r\n{\r\n\tout &lt;&lt; static_cast&lt;double&gt;(fp);\r\n\treturn out;\r\n}\r\n\r\nstd::istream&amp; operator&gt;&gt;(std::istream&amp; in, FixedPoint2&amp; fp)\r\n{\r\n\tdouble d{};\r\n\tin &gt;&gt; d;\r\n\tfp = FixedPoint2{ d };\r\n\r\n\treturn in;\r\n}\r\n\r\nFixedPoint2 operator+(const FixedPoint2&amp; fp1, const FixedPoint2&amp; fp2)\r\n{\r\n\treturn FixedPoint2{ static_cast&lt;double&gt;(fp1) + static_cast&lt;double&gt;(fp2) };\r\n}\r\n\r\nint main()\r\n{\r\n\tassert(FixedPoint2{ 0.75 } == FixedPoint2{ 0.75 });    \/\/ Test equality true\r\n\tassert(!(FixedPoint2{ 0.75 } == FixedPoint2{ 0.76 })); \/\/ Test equality false\r\n    \r\n\t\/\/ Test additional cases -- h\/t to reader Sharjeel Safdar for these test cases\r\n\tassert(FixedPoint2{ 0.75 } + FixedPoint2{ 1.23 } == FixedPoint2{ 1.98 });    \/\/ both positive, no decimal overflow\r\n\tassert(FixedPoint2{ 0.75 } + FixedPoint2{ 1.50 } == FixedPoint2{ 2.25 });    \/\/ both positive, with decimal overflow\r\n\tassert(FixedPoint2{ -0.75 } + FixedPoint2{ -1.23 } == FixedPoint2{ -1.98 }); \/\/ both negative, no decimal overflow\r\n\tassert(FixedPoint2{ -0.75 } + FixedPoint2{ -1.50 } == FixedPoint2{ -2.25 }); \/\/ both negative, with decimal overflow\r\n\tassert(FixedPoint2{ 0.75 } + FixedPoint2{ -1.23 } == FixedPoint2{ -0.48 });  \/\/ second negative, no decimal overflow\r\n\tassert(FixedPoint2{ 0.75 } + FixedPoint2{ -1.50 } == FixedPoint2{ -0.75 });  \/\/ second negative, possible decimal overflow\r\n\tassert(FixedPoint2{ -0.75 } + FixedPoint2{ 1.23 } == FixedPoint2{ 0.48 });   \/\/ first negative, no decimal overflow\r\n\tassert(FixedPoint2{ -0.75 } + FixedPoint2{ 1.50 } == FixedPoint2{ 0.75 });   \/\/ first negative, possible decimal overflow\r\n    \r\n\tFixedPoint2 a{ -0.48 };\r\n\tassert(static_cast&lt;double&gt;(a) == -0.48);\r\n\tassert(static_cast&lt;double&gt;(-a) == 0.48);\r\n\r\n\tstd::cout &lt;&lt; \"Enter a number: \"; \/\/ enter 5.678\r\n\tstd::cin &gt;&gt; a;\r\n\tstd::cout &lt;&lt; \"You entered: \" &lt;&lt; a &lt;&lt; '\\n';\r\n\tassert(static_cast&lt;double&gt;(a) == 5.68);\r\n\t\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-21-project\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.y<\/span>Chapter 21 project\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-operators-and-function-templates\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.14<\/span>Overloading operators and function templates\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In this chapter, we explored topics related to operator overloading, as well as overloaded typecasts, and topics related to the copy constructor. Summary Operator overloading is a variant of function overloading that lets you overload operators for your classes. When operators are overloaded, the intent of the operators should be &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4352"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=4352"}],"version-history":[{"count":78,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4352\/revisions"}],"predecessor-version":[{"id":18026,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4352\/revisions\/18026"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=4352"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=4352"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=4352"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}