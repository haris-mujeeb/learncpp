{"id":5465,"date":"2017-02-20T14:49:19","date_gmt":"2017-02-20T22:49:19","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=5465"},"modified":"2024-05-15T14:32:09","modified_gmt":"2024-05-15T21:32:09","slug":"rvalue-references","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/rvalue-references\/","title":{"rendered":"22.2 &#8212; R-value references"},"content":{"rendered":"<p>In chapter 12, we introduced the concept of value categories (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/value-categories-lvalues-and-rvalues\/\">12.2 -- Value categories (lvalues and rvalues)<\/a>), which is a property of expressions that helps determine whether an expression resolves to a value, function, or object.  We also introduced l-values and r-values so that we could discuss l-value references.<\/p>\n<p>If you&#8217;re hazy on l-values and r-values, now would be a good time to refresh on that topic since we&#8217;ll be talking a lot about them in this chapter.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">L-value references recap<\/p>\n<p>Prior to C++11, only one type of reference existed in C++, and so it was just called a &#8220;reference&#8221;.  However, in C++11, it&#8217;s called an l-value reference.  L-value references can only be initialized with modifiable l-values.<\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<th>L-value reference<\/th>\n<th>Can be initialized with<\/th>\n<th>Can modify<\/th>\n<\/tr>\n<tr>\n<td>Modifiable l-values<\/td>\n<td>Yes<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Non-modifiable l-values<\/td>\n<td>No<\/td>\n<td>No<\/td>\n<\/tr>\n<tr>\n<td>R-values<\/td>\n<td>No<\/td>\n<td>No<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>L-value references to const objects can be initialized with modifiable and non-modifiable l-values and r-values alike.  However, those values can&#8217;t be modified.<\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<th>L-value reference to const<\/th>\n<th>Can be initialized with<\/th>\n<th>Can modify<\/th>\n<\/tr>\n<tr>\n<td>Modifiable l-values<\/td>\n<td>Yes<\/td>\n<td>No<\/td>\n<\/tr>\n<tr>\n<td>Non-modifiable l-values<\/td>\n<td>Yes<\/td>\n<td>No<\/td>\n<\/tr>\n<tr>\n<td>R-values<\/td>\n<td>Yes<\/td>\n<td>No<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>L-value references to const objects are particularly useful because they allow us to pass any type of argument (l-value or r-value) into a function without making a copy of the argument.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">R-value references<\/p>\n<p>C++11 adds a new type of reference called an r-value reference.  An r-value reference is a reference that is designed to be initialized with an r-value (only).  While an l-value reference is created using a single ampersand, an r-value reference is created using a double ampersand:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int x{ 5 };\r\nint&amp; lref{ x }; \/\/ l-value reference initialized with l-value x\r\nint&amp;&amp; rref{ 5 }; \/\/ r-value reference initialized with r-value 5<\/code><\/pre>\n<p>R-values references cannot be initialized with l-values.<\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<th>R-value reference<\/th>\n<th>Can be initialized with<\/th>\n<th>Can modify<\/th>\n<\/tr>\n<tr>\n<td>Modifiable l-values<\/td>\n<td>No<\/td>\n<td>No<\/td>\n<\/tr>\n<tr>\n<td>Non-modifiable l-values<\/td>\n<td>No<\/td>\n<td>No<\/td>\n<\/tr>\n<tr>\n<td>R-values<\/td>\n<td>Yes<\/td>\n<td>Yes<\/td>\n<\/tr>\n<p><\/table><\/div>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<th>R-value reference to const<\/th>\n<th>Can be initialized with<\/th>\n<th>Can modify<\/th>\n<\/tr>\n<tr>\n<td>Modifiable l-values<\/td>\n<td>No<\/td>\n<td>No<\/td>\n<\/tr>\n<tr>\n<td>Non-modifiable l-values<\/td>\n<td>No<\/td>\n<td>No<\/td>\n<\/tr>\n<tr>\n<td>R-values<\/td>\n<td>Yes<\/td>\n<td>No<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>R-value references have two properties that are useful.  First, r-value references extend the lifespan of the object they are initialized with to the lifespan of the r-value reference (l-value references to const objects can do this too).  Second, non-const r-value references allow you to modify the r-value!<\/p>\n<p>Let&#8217;s take a look at some examples:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n \r\nclass Fraction\r\n{\r\nprivate:\r\n\tint m_numerator { 0 };\r\n\tint m_denominator { 1 };\r\n \r\npublic:\r\n\tFraction(int numerator = 0, int denominator = 1) :\r\n\t\tm_numerator{ numerator }, m_denominator{ denominator }\r\n\t{\r\n\t}\r\n \r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)\r\n\t{\r\n\t\tout &lt;&lt; f1.m_numerator &lt;&lt; '\/' &lt;&lt; f1.m_denominator;\r\n\t\treturn out;\r\n\t}\r\n};\r\n \r\nint main()\r\n{\r\n\tauto&amp;&amp; rref{ Fraction{ 3, 5 } }; \/\/ r-value reference to temporary Fraction\r\n\t\r\n\t\/\/ f1 of operator&lt;&lt; binds to the temporary, no copies are created.\r\n\tstd::cout &lt;&lt; rref &lt;&lt; '\\n';\r\n \r\n\treturn 0;\r\n} \/\/ rref (and the temporary Fraction) goes out of scope here<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\r\n3\/5\r\n<\/pre>\n<p>As an anonymous object, Fraction(3, 5) would normally go out of scope at the end of the expression in which it is defined.  However, since we&#8217;re initializing an r-value reference with it, its duration is extended until the end of the block.  We can then use that r-value reference to print the Fraction&#8217;s value.<\/p>\n<p>Now let&#8217;s take a look at a less intuitive example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int&amp;&amp; rref{ 5 }; \/\/ because we're initializing an r-value reference with a literal, a temporary with value 5 is created here\r\n    rref = 10;\r\n    std::cout &lt;&lt; rref &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\r\n10\r\n<\/pre>\n<p>While it may seem weird to initialize an r-value reference with a literal value and then be able to change that value, when initializing an r-value reference with a literal, a temporary object is constructed from the literal so that the reference is referencing a temporary object, not a literal value.<\/p>\n<p>R-value references are not very often used in either of the manners illustrated above.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">R-value references as function parameters<\/p>\n<p>R-value references are more often used as function parameters.  This is most useful for function overloads when you want to have different behavior for l-value and r-value arguments.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid fun(const int&amp; lref) \/\/ l-value arguments will select this function\r\n{\r\n\tstd::cout &lt;&lt; \"l-value reference to const: \" &lt;&lt; lref &lt;&lt; '\\n';\r\n}\r\n\r\nvoid fun(int&amp;&amp; rref) \/\/ r-value arguments will select this function\r\n{\r\n\tstd::cout &lt;&lt; \"r-value reference: \" &lt;&lt; rref &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n\tint x{ 5 };\r\n\tfun(x); \/\/ l-value argument calls l-value version of function\r\n\tfun(5); \/\/ r-value argument calls r-value version of function\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\nl-value reference to const: 5\r\nr-value reference: 5\r\n<\/pre>\n<p>As you can see, when passed an l-value, the overloaded function resolved to the version with the l-value reference.  When passed an r-value, the overloaded function resolved to the version with the r-value reference (this is considered a better match than an l-value reference to const).<\/p>\n<p>Why would you ever want to do this?  We&#8217;ll discuss this in more detail in the next lesson.  Needless to say, it&#8217;s an important part of move semantics.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Rvalue reference variables are lvalues<\/p>\n<p>Consider the following snippet:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\tint&amp;&amp; ref{ 5 };\r\n\tfun(ref);<\/code><\/pre>\n<p>Which version of <code>fun<\/code> would you expect the above to call: <code>fun(const int&amp;)<\/code> or <code>fun(int&amp;&amp;)<\/code>?<\/p>\n<p>The answer might surprise you.  This calls <code>fun(const int&amp;)<\/code>.<\/p>\n<p>Although variable <code>ref<\/code> has type <code>int&amp;&amp;<\/code>, when used in an expression it is an lvalue (as are all named variables).  The type of an object and its value category are independent.<\/p>\n<p>You already know that literal <code>5<\/code> is an rvalue of type <code>int<\/code>, and <code>int x<\/code> is an lvalue of type <code>int<\/code>.  Similarly, <code>int&amp;&amp; ref<\/code> is an lvalue of type <code>int&amp;&amp;<\/code>.<\/p>\n<p>So not only does <code>fun(ref)<\/code> call <code>fun(const int&amp;)<\/code>, it does not even match <code>fun(int&amp;&amp;)<\/code>, as rvalue references can&#8217;t bind to lvalues.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Returning an r-value reference<\/p>\n<p>You should almost never return an r-value reference, for the same reason you should almost never return an l-value reference.  In most cases, you&#8217;ll end up returning a hanging reference when the referenced object goes out of scope at the end of the function.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>State which of the following lettered statements will not compile:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n\tint x{};\r\n\r\n\t\/\/ l-value references\r\n\tint&amp; ref1{ x }; \/\/ A\r\n\tint&amp; ref2{ 5 }; \/\/ B\r\n\r\n\tconst int&amp; ref3{ x }; \/\/ C\r\n\tconst int&amp; ref4{ 5 }; \/\/ D\r\n\r\n\t\/\/ r-value references\r\n\tint&amp;&amp; ref5{ x }; \/\/ E\r\n\tint&amp;&amp; ref6{ 5 }; \/\/ F\r\n\r\n\tconst int&amp;&amp; ref7{ x }; \/\/ G\r\n\tconst int&amp;&amp; ref8{ 5 }; \/\/ H\r\n\t\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>B, E, and G won&#8217;t compile.<\/p>\n<p>Recapping the binding combinations:<\/p>\n<ul>\n<li>Non-const l-value references can only bind to non-const l-values.\n<\/li>\n<li>Const l-value references can bind to non-const l-values, const l-values, and r-values.\n<\/li>\n<li>R-value references can only bind to r-values.\n<\/li>\n<\/ul>\n<p><code>x<\/code> is a non-const l-value, so we can bind a non-const l-value reference (A) and a const l-value reference (C) to it.  We cannot bind a non-const l-value reference to an r-value (B).<br \/>\n<code>5<\/code> is an rvalue, so we can bind a const l-value reference (D) and r-value reference (F &#038; H) to it.  We cannot bind an rvalue reference to an l-value (E &#038; G).<\/p>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/move-constructors-and-move-assignment\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">22.3<\/span>Move constructors and move assignment\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-smart-pointers-move-semantics\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">22.1<\/span>Introduction to smart pointers and move semantics\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In chapter 12, we introduced the concept of value categories (), which is a property of expressions that helps determine whether an expression resolves to a value, function, or object. We also introduced l-values and r-values so that we could discuss l-value references. If you&#8217;re hazy on l-values and r-values, &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5465"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=5465"}],"version-history":[{"count":45,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5465\/revisions"}],"predecessor-version":[{"id":17051,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5465\/revisions\/17051"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=5465"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=5465"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=5465"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}