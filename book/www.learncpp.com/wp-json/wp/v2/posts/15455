{"id":15455,"date":"2023-09-11T16:18:14","date_gmt":"2023-09-11T23:18:14","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15455"},"modified":"2024-06-26T14:23:50","modified_gmt":"2024-06-26T21:23:50","slug":"multidimensional-stdarray","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/multidimensional-stdarray\/","title":{"rendered":"17.13 &#8212; Multidimensional std::array"},"content":{"rendered":"<p>In the prior lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/multidimensional-c-style-arrays\/\">17.12 -- Multidimensional C-style Arrays<\/a>), we discussed C-style multidimensional arrays.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    \/\/ C-style 2d array\r\n    int arr[3][4] { \r\n        { 1, 2, 3, 4 },\r\n        { 5, 6, 7, 8 },\r\n        { 9, 10, 11, 12 }};<\/code><\/pre>\n<p>But as you&#8217;re aware, we generally want to avoid C-style arrays (unless they are being used to store global data).<\/p>\n<p>In this lesson, we&#8217;ll take a look at how multidimensional arrays work with <code>std::array<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">There is no standard library multidimensional array class<\/p>\n<p>Note that <code>std::array<\/code> is implemented as a single-dimensional array.  So the first question you should ask is, &#8220;is there a standard library class for multidimensional arrays?&#8221;  And the answer is&#8230; no.  Too bad.  Womp womp.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A two-dimensional <code>std::array<\/code><\/p>\n<p>The canonical way to create a two-dimensional array of <code>std::array<\/code> is to create a <code>std::array<\/code> where the template type argument is another <code>std::array<\/code>.  That leads to something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    std::array&lt;std::array&lt;int, 4&gt;, 3&gt; arr {{  \/\/ note double braces\r\n        { 1, 2, 3, 4 },\r\n        { 5, 6, 7, 8 },\r\n        { 9, 10, 11, 12 }}};<\/code><\/pre>\n<p>There are a number of &#8220;interesting&#8221; things to note about this:<\/p>\n<ul>\n<li>When initializing a multidimensional <code>std::array<\/code>, we need to use double-braces (we discuss why in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdarray-of-class-types-and-brace-elision\/\">17.4 -- std::array of class types, and brace elision<\/a>).\n<\/li>\n<li>The syntax is verbose and hard to read.\n<\/li>\n<li>Because of the way templates get nested, the array dimensions are switched.  We want an array with 3 rows of 4 elements, so <code>arr[3][4]<\/code> is natural.  <code>std::array&lt;std::array&lt;int, 4&gt;, 3&gt;<\/code> is backwards.\n<\/li>\n<\/ul>\n<p>Indexing a two-dimensional <code>std::array<\/code> element works just like indexing a two-dimensional C-style array:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    std::cout &lt;&lt; arr[1][2]; \/\/ print the element in row 1, column 2<\/code><\/pre>\n<p>We can also pass a two-dimensional <code>std::array<\/code> to a function just like a one-dimensional <code>std::array<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T, std::size_t Row, std::size_t Col&gt;\r\nvoid printArray(const std::array&lt;std::array&lt;T, Col&gt;, Row&gt; &amp;arr)\r\n{\r\n    for (const auto&amp; arow: arr)   \/\/ get each array row\r\n    {\r\n        for (const auto&amp; e: arow) \/\/ get each element of the row\r\n            std::cout &lt;&lt; e &lt;&lt; ' ';\r\n\r\n        std::cout &lt;&lt; '\\n';\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    std::array&lt;std::array&lt;int, 4&gt;, 3&gt;  arr {{\r\n        { 1, 2, 3, 4 },\r\n        { 5, 6, 7, 8 },\r\n        { 9, 10, 11, 12 }}};\r\n\r\n    printArray(arr);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Yuck.  And this is for a two-dimensional <code>std::array<\/code>.  A three-dimensional or higher <code>std::array<\/code> is even more verbose!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Making two-dimensional <code>std::array<\/code> easier using an alias templates<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/typedefs-and-type-aliases\/\">10.7 -- Typedefs and type aliases<\/a>, we introduced type aliases, and noted that one of the uses of type aliases is to make complex types simpler to use.  However, with a normal type alias, we must explicitly specify all template arguments.  e.g.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">using Array2dint34 = std::array&lt;std::array&lt;int, 4&gt;, 3&gt;;<\/code><\/pre>\n<p>This allows us to use <code>Array2dint34<\/code> wherever we want a 3&#215;4 two-dimensional std::array of <code>int<\/code>.  But note we&#8217;d need one such alias for every combination of element type and dimensions we want to use!<\/p>\n<p>This is a perfect place to use an alias template, which will lets us specify the element type, row length, and column length for a type alias as template arguments!<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ An alias template for a two-dimensional std::array\r\ntemplate &lt;typename T, std::size_t Row, std::size_t Col&gt;\r\nusing Array2d = std::array&lt;std::array&lt;T, Col&gt;, Row&gt;;<\/code><\/pre>\n<p>We can then use <code>Array2d&lt;int, 3, 4&gt;<\/code> anywhere we want a 3&#215;4 two-dimensional std::array of <code>int<\/code>.  That&#8217;s much better!<\/p>\n<p>Here&#8217;s a full example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\n\/\/ An alias template for a two-dimensional std::array\r\ntemplate &lt;typename T, std::size_t Row, std::size_t Col&gt;\r\nusing Array2d = std::array&lt;std::array&lt;T, Col&gt;, Row&gt;;\r\n\r\n\/\/ When using Array2d as a function parameter, we need to respecify the template parameters\r\ntemplate &lt;typename T, std::size_t Row, std::size_t Col&gt;\r\nvoid printArray(const Array2d&lt;T, Row, Col&gt; &amp;arr)\r\n{\r\n    for (const auto&amp; arow: arr)   \/\/ get each array row\r\n    {\r\n        for (const auto&amp; e: arow) \/\/ get each element of the row\r\n            std::cout &lt;&lt; e &lt;&lt; ' ';\r\n\r\n        std::cout &lt;&lt; '\\n';\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    \/\/ Define a two-dimensional array of int with 3 rows and 4 columns\r\n    Array2d&lt;int, 3, 4&gt; arr {{\r\n        { 1, 2, 3, 4 },\r\n        { 5, 6, 7, 8 },\r\n        { 9, 10, 11, 12 }}};\r\n\r\n    printArray(arr);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Note how much more concise and easy to use this is!<\/p>\n<p>One neat thing about our alias template is that we can define our template parameters in whatever order we like.  Since a <code>std::array<\/code> specifies element type first and then dimension, we stick with that convention.  But we have the flexibility to define either <code>Row<\/code> or <code>Col<\/code> first.  Since C-style array definitions are defined row-first, we define our alias template with <code>Row<\/code> before <code>Col<\/code>.<\/p>\n<p>This method also scales up nicely to higher-dimensional <code>std::array<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ An alias template for a three-dimensional std::array\r\ntemplate &lt;typename T, std::size_t Row, std::size_t Col, std::size_t Depth&gt;\r\nusing Array3d = std::array&lt;std::array&lt;std::array&lt;T, Depth&gt;, Col&gt;, Row&gt;;<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Getting the dimensional lengths of a two-dimensional array<\/p>\n<p>With a one-dimensional <code>std::array<\/code>, we can use the <code>size()<\/code> member function (or <code>std::size()<\/code>) to get the length of the array.  But what do we do when we have a two-dimensional <code>std::array<\/code>?  In this case, <code>size()<\/code> will only return the length of the first dimension.<\/p>\n<p>One seemingly appealing (but potentially dangerous) option is to get an element of the desired dimension, and then call <code>size()<\/code> on that element:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\n\/\/ An alias template for a two-dimensional std::array\r\ntemplate &lt;typename T, std::size_t Row, std::size_t Col&gt;\r\nusing Array2d = std::array&lt;std::array&lt;T, Col&gt;, Row&gt;;\r\n\r\nint main()\r\n{\r\n    \/\/ Define a two-dimensional array of int with 3 rows and 4 columns\r\n    Array2d&lt;int, 3, 4&gt; arr {{\r\n        { 1, 2, 3, 4 },\r\n        { 5, 6, 7, 8 },\r\n        { 9, 10, 11, 12 }}};\r\n\r\n    std::cout &lt;&lt; \"Rows: \" &lt;&lt; arr.size() &lt;&lt; '\\n';    \/\/ get length of first dimension (rows)\r\n    std::cout &lt;&lt; \"Cols: \" &lt;&lt; arr[0].size() &lt;&lt; '\\n'; \/\/ get length of second dimension (cols), undefined behavior if length of first dimension is zero!\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In order to get the length of the first dimension, we call <code>size()<\/code> on the array.  To get the length of the second dimension, we first call <code>arr[0]<\/code> to get the first element, and then call <code>size()<\/code> on that.  To get the length of the third dimension of a 3-dimensional array, we would call <code>arr[0][0].size()<\/code>.<\/p>\n<p>However, the above code is flawed, as it will produce undefined behavior if any dimension other than the last has a length of 0!<\/p>\n<p>A better option is to use a function template to return the length of the dimension directly from the associated non-type template parameter:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\n\/\/ An alias template for a two-dimensional std::array\r\ntemplate &lt;typename T, std::size_t Row, std::size_t Col&gt;\r\nusing Array2d = std::array&lt;std::array&lt;T, Col&gt;, Row&gt;;\r\n\r\n\/\/ Fetch the number of rows from the Row non-type template parameter\r\ntemplate &lt;typename T, std::size_t Row, std::size_t Col&gt;\r\nconstexpr int rowLength(const Array2d&lt;T, Row, Col&gt;&amp;) \/\/ you can return std::size_t if you prefer\r\n{\r\n    return Row;\r\n}\r\n\r\n\/\/ Fetch the number of cols from the Col non-type template parameter\r\ntemplate &lt;typename T, std::size_t Row, std::size_t Col&gt;\r\nconstexpr int colLength(const Array2d&lt;T, Row, Col&gt;&amp;) \/\/ you can return std::size_t if you prefer\r\n{\r\n    return Col;\r\n}\r\n\r\nint main()\r\n{\r\n    \/\/ Define a two-dimensional array of int with 3 rows and 4 columns\r\n    Array2d&lt;int, 3, 4&gt; arr {{\r\n        { 1, 2, 3, 4 },\r\n        { 5, 6, 7, 8 },\r\n        { 9, 10, 11, 12 }}};\r\n\r\n    std::cout &lt;&lt; \"Rows: \" &lt;&lt; rowLength(arr) &lt;&lt; '\\n'; \/\/ get length of first dimension (rows)\r\n    std::cout &lt;&lt; \"Cols: \" &lt;&lt; colLength(arr) &lt;&lt; '\\n'; \/\/ get length of second dimension (cols)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This avoids any undefined behavior if the length of any dimension is zero, as it only uses the type information of the array, rather than the actual data of the array.  This also allows us to easily return the length as an <code>int<\/code> if we desire (no static_cast is required, as converting from a <code>constexpr std::size_t<\/code> to <code>constexpr int<\/code> is non-narrowing, so an implicit conversion is fine).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Flatting a two-dimensional array<\/p>\n<p>Arrays with two or more dimensions have some challenges:<\/p>\n<ul>\n<li>They are more verbose to define and work with.\n<\/li>\n<li>It is awkward to get the length of dimensions greater than the first.\n<\/li>\n<li>They are increasingly hard to iterate over (requiring one more loop for each dimension).\n<\/li>\n<\/ul>\n<p>One approach to make multidimensional arrays easier to work with is to flatten them.  <strong>Flattening<\/strong> an array is a process of reducing the dimensionality of an array (often down to a single dimension).<\/p>\n<p>For example, instead of creating a two-dimensional array with <code>Row<\/code> rows and <code>Col<\/code> columns, we can create a one-dimensional array with <code>Row * Col<\/code> elements.  This gives us the same amount of storage using a single dimension.<\/p>\n<p>However, because our one-dimensional array only has a single dimension, we cannot work with it as a multidimensional array.  To address this, we can provide an interface that mimics a multidimensional array.  This interface will accept two-dimensional coordinates, and then map them to a unique position in the one-dimensional array.<\/p>\n<p>Here&#8217;s an example of that approach that works in C++11 or newer:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;functional&gt;\r\n\r\n\/\/ An alias template to allow us to define a one-dimensional std::array using two dimensions\r\ntemplate &lt;typename T, std::size_t Row, std::size_t Col&gt;\r\nusing ArrayFlat2d = std::array&lt;T, Row * Col&gt;;\r\n\r\n\/\/ A modifiable view that allows us to work with an ArrayFlat2d using two dimensions\r\n\/\/ This is a view, so the ArrayFlat2d being viewed must stay in scope\r\ntemplate &lt;typename T, std::size_t Row, std::size_t Col&gt;\r\nclass ArrayView2d\r\n{\r\nprivate:\r\n    \/\/ You might be tempted to make m_arr a reference to an ArrayFlat2d,\r\n    \/\/ but this makes the view non-copy-assignable since references can't be reseated.\r\n    \/\/ Using std::reference_wrapper gives us reference semantics and copy assignability.\r\n    std::reference_wrapper&lt;ArrayFlat2d&lt;T, Row, Col&gt;&gt; m_arr {};\r\n\r\npublic:\r\n    ArrayView2d(ArrayFlat2d&lt;T, Row, Col&gt; &amp;arr)\r\n        : m_arr { arr }\r\n    {}\r\n\r\n    \/\/ Get element via single subscript (using operator[])\r\n    T&amp; operator[](int i) { return m_arr.get()[static_cast&lt;std::size_t&gt;(i)]; }\r\n    const T&amp; operator[](int i) const { return m_arr.get()[static_cast&lt;std::size_t&gt;(i)]; }\r\n\r\n    \/\/ Get element via 2d subscript (using operator(), since operator[] doesn't support multiple dimensions prior to C++23)\r\n    T&amp; operator()(int row, int col) { return m_arr.get()[static_cast&lt;std::size_t&gt;(row * cols() + col)]; }\r\n    const T&amp; operator()(int row, int col) const { return m_arr.get()[static_cast&lt;std::size_t&gt;(row * cols() + col)]; }\r\n\r\n    \/\/ in C++23, you can uncomment these since multidimensional operator[] is supported\r\n\/\/    T&amp; operator[](int row, int col) { return m_arr.get()[static_cast&lt;std::size_t&gt;(row * cols() + col)]; }\r\n\/\/    const T&amp; operator[](int row, int col) const { return m_arr.get()[static_cast&lt;std::size_t&gt;(row * cols() + col)]; }\r\n\r\n    int rows() const { return static_cast&lt;int&gt;(Row); }\r\n    int cols() const { return static_cast&lt;int&gt;(Col); }\r\n    int length() const { return static_cast&lt;int&gt;(Row * Col); }\r\n};\r\n\r\nint main()\r\n{\r\n    \/\/ Define a one-dimensional std::array of int (with 3 rows and 4 columns)\r\n    ArrayFlat2d&lt;int, 3, 4&gt; arr {\r\n        1, 2, 3, 4,\r\n        5, 6, 7, 8,\r\n        9, 10, 11, 12 };\r\n\r\n    \/\/ Define a two-dimensional view into our one-dimensional array\r\n    ArrayView2d&lt;int, 3, 4&gt; arrView { arr };\r\n\r\n    \/\/ print array dimensions\r\n    std::cout &lt;&lt; \"Rows: \" &lt;&lt; arrView.rows() &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"Cols: \" &lt;&lt; arrView.cols() &lt;&lt; '\\n';\r\n\r\n    \/\/ print array using a single dimension\r\n    for (int i=0; i &lt; arrView.length(); ++i)\r\n        std::cout &lt;&lt; arrView[i] &lt;&lt; ' ';\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    \/\/ print array using two dimensions\r\n    for (int row=0; row &lt; arrView.rows(); ++row)\r\n    {\r\n        for (int col=0; col &lt; arrView.cols(); ++col)\r\n            std::cout &lt;&lt; arrView(row, col) &lt;&lt; ' ';\r\n        std::cout &lt;&lt; '\\n';\r\n    }\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nRows: 3\r\nCols: 4\r\n1 2 3 4 5 6 7 8 9 10 11 12\r\n1 2 3 4\r\n5 6 7 8\r\n9 10 11 12\r\n<\/pre>\n<p>Because <code>operator[]<\/code> can only accept a single subscript prior to C++23, there are two alternate approaches:<\/p>\n<ul>\n<li>Use <code>operator()<\/code> instead, which can accept multiple subscripts.  This lets you use <code>[]<\/code> for single index indexing and <code>()<\/code> for multiple-dimension indexing.  We&#8217;ve opted for this approach above.\n<\/li>\n<li>Have <code>operator[]<\/code> return a subview that also overloads <code>operator[]<\/code> so that you can chain <code>operator[]<\/code>.  This is more complex and doesn&#8217;t scale well to higher dimensions.\n<\/li>\n<\/ul>\n<p>In C++23, <code>operator[]<\/code> was extended to accept multiple subscripts, so you can overload it to handle both single and multiple subscripts (instead of using <code>operator()<\/code> for multiple subscripts).<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover <code>std::reference_wrapper<\/code> in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/arrays-of-references-via-stdreference_wrapper\/\">17.5 -- Arrays of references via std::reference_wrapper<\/a>.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">std::mdspan <span class=\"cpp-section-pill cpp-section-standard\">C++23<\/span><\/p>\n<p>Introduced in C++23, <code>std::mdspan<\/code> is a modifiable view that provides a multidimensional array interface for a contiguous sequence of elements.  By modifiable view, we mean that a <code>std::mdspan<\/code> is not just a read-only view (like <code>std::string_view<\/code>) -- if the underlying sequence of elements is non-const, those elements can be modified.<\/p>\n<p>The following example prints the same output as the prior example, but uses <code>std::mdspan<\/code> instead of our own custom view:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;mdspan&gt;\r\n\r\n\/\/ An alias template to allow us to define a one-dimensional std::array using two dimensions\r\ntemplate &lt;typename T, std::size_t Row, std::size_t Col&gt;\r\nusing ArrayFlat2d = std::array&lt;T, Row * Col&gt;;\r\n\r\nint main()\r\n{\r\n    \/\/ Define a one-dimensional std::array of int (with 3 rows and 4 columns)\r\n    ArrayFlat2d&lt;int, 3, 4&gt; arr {\r\n        1, 2, 3, 4,\r\n        5, 6, 7, 8,\r\n        9, 10, 11, 12 };\r\n\r\n    \/\/ Define a two-dimensional span into our one-dimensional array\r\n    \/\/ We must pass std::mdspan a pointer to the sequence of elements\r\n    \/\/ which we can do via the data() member function of std::array or std::vector\r\n    std::mdspan mdView { arr.data(), 3, 4 };\r\n\r\n    \/\/ print array dimensions\r\n    \/\/ std::mdspan calls these extents\r\n    std::size_t rows { mdView.extents().extent(0) };\r\n    std::size_t cols { mdView.extents().extent(1) };\r\n    std::cout &lt;&lt; \"Rows: \" &lt;&lt; rows &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"Cols: \" &lt;&lt; cols &lt;&lt; '\\n';\r\n\r\n    \/\/ print array in 1d\r\n    \/\/ The data_handle() member gives us a pointer to the sequence of elements\r\n    \/\/ which we can then index\r\n    for (std::size_t i=0; i &lt; mdView.size(); ++i)\r\n        std::cout &lt;&lt; mdView.data_handle()[i] &lt;&lt; ' ';\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    \/\/ print array in 2d\r\n    \/\/ We use multidimensional [] to access elements\r\n    for (std::size_t row=0; row &lt; rows; ++row)\r\n    {\r\n        for (std::size_t col=0; col &lt; cols; ++col)\r\n            std::cout &lt;&lt; mdView[row, col] &lt;&lt; ' ';\r\n        std::cout &lt;&lt; '\\n';\r\n    }\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This should be fairly straightforward, but there are a few things worth noting:<\/p>\n<ul>\n<li><code>std::mdspan<\/code> let us define a view with as many dimensions as we want.\n<\/li>\n<li>The first parameter to the constructor of <code>std::mdspan<\/code> should be a pointer to the array data.  This can be a decayed C-style array, or we can use the <code>data()<\/code> member function of <code>std::array<\/code> or <code>std::vector<\/code> to get this data.\n<\/li>\n<li>To index a <code>std::mdspan<\/code> in one-dimension, we must fetch the pointer to the array data, which we can do using the <code>data_handle()<\/code> member function.  We can then subscript that.\n<\/li>\n<li>In C++23, <code>operator[]<\/code> accepts multiple indices, so we use <code>[row, col]<\/code> as our index instead of <code>[row][col]<\/code>.\n<\/li>\n<\/ul>\n<p>C++26 will include <code>std::mdarray<\/code>, which essentially combines <code>std::array<\/code> and <code>std::mdspan<\/code> into an owning multidimensional array!<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-17-summary-and-quiz\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.x<\/span>Chapter 17 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/multidimensional-c-style-arrays\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.12<\/span>Multidimensional C-style Arrays\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the prior lesson (), we discussed C-style multidimensional arrays. \/\/ C-style 2d array int arr[3][4] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 }}; But as you&#8217;re aware, we generally want to avoid C-style arrays (unless they are being &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15455"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15455"}],"version-history":[{"count":14,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15455\/revisions"}],"predecessor-version":[{"id":15458,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15455\/revisions\/15458"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15455"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15455"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15455"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}