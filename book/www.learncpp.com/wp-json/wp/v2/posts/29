{"id":29,"date":"2007-06-01T23:15:48","date_gmt":"2007-06-02T07:15:48","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=29"},"modified":"2007-06-01T23:15:48","modified_gmt":"2007-06-02T07:15:48","slug":"6-ways-to-write-better-code","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-programming\/6-ways-to-write-better-code\/","title":{"rendered":"6 ways to write better code"},"content":{"rendered":"<p>There was an article linked from Digg posted up a couple days ago entitled &#8220;6 ways to write better code&#8221;.   It&#8217;s pretty good advice (for the most part), so I thought I&#8217;d link it here.<\/p>\n<p><a href=\"http:\/\/www.ibm.com\/developerworks\/linux\/library\/l-clear-code\/index.html?ca=drs-\">http:\/\/www.ibm.com\/developerworks\/linux\/library\/l-clear-code\/index.html?ca=drs-<\/a><\/p>\n<p>Here are the recommendations of the author, along with my own comments:<br \/>\n<em>1) Comment like a smart person.<\/em><\/p>\n<p>I can&#8217;t emphasize this enough.  Code that seems beyond obvious has a funny way of reading like a foreign language after a couple of months.  Comment everything -- and don&#8217;t just state the obvious.  Try to write the comment as if you were writing it for someone else who has no prior knowledge of what you are doing.  Because in three or six months, that person will be you.<\/p>\n<p><em>2) Use #define a lot. No, a LOT.<\/em><\/p>\n<p>Right sentiment, wrong implementation.  As the article says, it&#8217;s a very bad idea to hard-code numbers into your program.  Inevitably, you&#8217;ll want to change something in the future, and it&#8217;s really difficult if everything there are numbers scattered everywhere.  Using #define helps document what you are doing, and makes it easy to change those numbers in the future.<\/p>\n<p>But #define is so&#8230; C.  There are a few problems with using #defines.  First, because #define is a preprocessor command, the preprocessor goes through and replaces all your defined names with their corresponding values.  This means those names are not available when you are debugging, which makes debugging more difficult.  Assume you have a function call that passes in a #defined value called EXP_PER_KILL.  Even though the code you are debugging may says AddExp(EXP_PER_KILL), you won&#8217;t have any idea what EXP_PER_KILL evaluates to unless you can locate it&#8217;s definition.  <\/p>\n<p>Second, #defined variables are always declared in the global scope regardless of where they are defined.<\/p>\n<p>In the world of C++, we can do better.  One better choice is to use a const variable.  Const variables are actual objects, so you can easily get their values in the debugger, and they follow normal scoping rules.  The other better choice is to use an enum, which has the same benefits.<\/p>\n<p><em>3) Don&#8217;t use variable names that will mock you.<\/em><\/p>\n<p>Not much to say about this -- naming your variables things that makes their purpose clear is an important aspect of documenting your code.<\/p>\n<p><em>4) Do error checking. You make errors. Yes, you.<\/em><\/p>\n<p>This one is both easier and harder than it looks.  Inevitably you will misuse a function you wrote by passing it an invalid parameter, or something will go wrong and a pointer will end up NULL when you were expecting it to have a value or vice-versa.  Checking for these things is good and can and will keep your program from crashing.  However, if you do detect an error and then do not do anything intelligent with that information, your program might as well just crash and get it over with.<\/p>\n<p>Just as big a problem as detecting an error is doing something intelligent about it.  If you&#8217;re writing a reusable function, the intelligent thing generally involves informing your caller that something went wrong and leaving it up to the caller to handle the problem.  If you&#8217;re the caller, or you&#8217;re writing a function that&#8217;s integral to your program, figuring out how to handle errors can be a tricky proposition.  Do you pop up a message box warning?  Do you ask the user for new input?  Do you save the user&#8217;s data and then terminate the program?  It really depends, and there&#8217;s no easy solution.<\/p>\n<p>But before you can do any of these things, you have to detect than an error occurred, and that&#8217;s why I agree with the author that this is important.<\/p>\n<p><em>5) &#8220;Premature optimization is the root of all evil.&#8221; - Donald Knuth<\/em><\/p>\n<p>One of the biggest problems new or overzealous programmers run into is trying to write code that is as fast as possible at the expense of things like code readability.  This is almost always a bad idea.  It IS a good idea to pick an algorithm that&#8217;s right for the problem you&#8217;re trying to solve -- for example, if you&#8217;re doing lots of element insertions and deletions, a linked list is probably going to be a better choice than an array.  But that doesn&#8217;t mean you have to design an algorithm that squeezes out every last bit of performance out of the linked list.  Efficiency generally comes at the expense of legibility, and honestly, with a few exceptions, legibility is more important, because at some point, you&#8217;re going to have to fix a bug, or expand your code, and code that&#8217;s tricked-out to be as efficient as possible isn&#8217;t going to be conducive to either of those things.<\/p>\n<p>Once your code is written, you can always profile it to find out where the ACTUAL bottlenecks are, rather than prematurely act on where you perceive the bottlenecks may be.  With properly implemented code that utilizes concepts such as encapsulation, swapping out one algorithm for a better one when needed is often no problem.<\/p>\n<p><em>6) Don&#8217;t be too clever by half.<\/em><\/p>\n<p>This is sort of along the same lines as #5.  It&#8217;s almost always a better idea to write code that is clean, straightforward, and legible than code that is as efficient as possible.  As I wrote in the section on comments, if you need a comment to explain <em>what<\/em> your line of code is doing, it probably needs to be rewritten, not commented.<\/p>\n<p>Many of you have heard of the KISS acronym -- Keep It Simple, Stupid.  It applies to code too.<\/p>\n","protected":false},"excerpt":{"rendered":"<p>There was an article linked from Digg posted up a couple days ago entitled &#8220;6 ways to write better code&#8221;. It&#8217;s pretty good advice (for the most part), so I thought I&#8217;d link it here. http:\/\/www.ibm.com\/developerworks\/linux\/library\/l-clear-code\/index.html?ca=drs- Here are the recommendations of the author, along with my own comments: 1) Comment &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[4],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/29"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=29"}],"version-history":[{"count":1,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/29\/revisions"}],"predecessor-version":[{"id":13152,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/29\/revisions\/13152"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=29"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=29"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=29"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}