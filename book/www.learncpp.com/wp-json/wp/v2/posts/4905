{"id":4905,"date":"2016-11-06T20:34:13","date_gmt":"2016-11-07T04:34:13","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=4905"},"modified":"2024-12-29T17:51:22","modified_gmt":"2024-12-30T01:51:22","slug":"the-override-and-final-specifiers-and-covariant-return-types","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/the-override-and-final-specifiers-and-covariant-return-types\/","title":{"rendered":"25.3 &#8212; The override and final specifiers, and covariant return types"},"content":{"rendered":"<p>To address some common challenges with inheritance, C++ has two inheritance-related identifiers: <code>override<\/code> and <code>final<\/code>.  Note that these identifiers are not keywords -- they are normal words that have special meaning only when used in certain contexts.  The C++ standard calls them &#8220;identifiers with special meaning&#8221;, but they are often referred to as &#8220;specifiers&#8221;.<\/p>\n<p>Although final isn&#8217;t used very much, override is a fantastic addition that you should use regularly.  In this lesson, we&#8217;ll take a look at both, as well as one exception to the rule that virtual function override return types must match.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The override specifier<\/p>\n<p>As we mentioned in the previous lesson, a derived class virtual function is only considered an override if its signature and return types match exactly.  That can lead to inadvertent issues, where a function that was intended to be an override actually isn&#8217;t.<\/p>\n<p>Consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass A\r\n{\r\npublic:\r\n\tvirtual std::string_view getName1(int x) { return \"A\"; }\r\n\tvirtual std::string_view getName2(int x) { return \"A\"; }\r\n};\r\n\r\nclass B : public A\r\n{\r\npublic:\r\n\tvirtual std::string_view getName1(short x) { return \"B\"; } \/\/ note: parameter is a short\r\n\tvirtual std::string_view getName2(int x) const { return \"B\"; } \/\/ note: function is const\r\n};\r\n\r\nint main()\r\n{\r\n\tB b{};\r\n\tA&amp; rBase{ b };\r\n\tstd::cout &lt;&lt; rBase.getName1(1) &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; rBase.getName2(2) &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Because rBase is an A reference to a B object, the intention here is to use virtual functions to access B::getName1() and B::getName2().  However, because B::getName1() takes a different parameter (a short instead of an int), it&#8217;s not considered an override of A::getName1().  More insidiously, because B::getName2() is const and A::getName2() isn&#8217;t, B::getName2() isn&#8217;t considered an override of A::getName2().<\/p>\n<p>Consequently, this program prints:<\/p>\n<pre>\r\nA\r\nA\r\n<\/pre>\n<p>In this particular case, because A and B just print their names, it&#8217;s fairly easy to see that we messed up our overrides, and that the wrong virtual function is being called.  However, in a more complicated program, where the functions have behaviors or return values that aren&#8217;t printed, such issues can be very difficult to debug.<\/p>\n<p>To help address the issue of functions that are meant to be overrides but aren&#8217;t, the <code>override<\/code> specifier can be applied to any virtual function to tell the compiler to enforce that the function is an override.  The <code>override<\/code> specifier is placed at the end of a member function declaration (in the same place where a function-level <code>const<\/code> goes).  If a member function is <code>const<\/code> and an override, the <code>const<\/code> must come before <code>override<\/code>.<\/p>\n<p>If a function marked as <code>override<\/code> does not override a base class function (or is applied to a non-virtual function), the compiler will flag the function as an error.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string_view&gt;\r\n\r\nclass A\r\n{\r\npublic:\r\n\tvirtual std::string_view getName1(int x) { return \"A\"; }\r\n\tvirtual std::string_view getName2(int x) { return \"A\"; }\r\n\tvirtual std::string_view getName3(int x) { return \"A\"; }\r\n};\r\n\r\nclass B : public A\r\n{\r\npublic:\r\n\tstd::string_view getName1(short int x) override { return \"B\"; } \/\/ compile error, function is not an override\r\n\tstd::string_view getName2(int x) const override { return \"B\"; } \/\/ compile error, function is not an override\r\n\tstd::string_view getName3(int x) override { return \"B\"; } \/\/ okay, function is an override of A::getName3(int)\r\n\r\n};\r\n\r\nint main()\r\n{\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>The above program produces two compile errors: one for B::getName1(), and one for B::getName2(), because neither override a prior function.  B::getName3() does override A::getName3(), so no error is produced for that line.<\/p>\n<p>Because there is no performance penalty for using the override specifier and it helps ensure you&#8217;ve actually overridden the function you think you have, all virtual override functions should be tagged using the override specifier.  Additionally, because the override specifier implies virtual, there&#8217;s no need to tag functions using the override specifier with the virtual keyword.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Use the virtual keyword on virtual functions in a base class.<\/p>\n<p>Use the override specifier (but not the virtual keyword) on override functions in derived classes.  This includes virtual destructors.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightpurplebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Rule<\/p>\n<p>If a member function is both <code>const<\/code> and an <code>override<\/code>, the <code>const<\/code> must be listed first.  <code>const override<\/code> is correct, <code>override const<\/code> is not.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The final specifier<\/p>\n<p>There may be cases where you don&#8217;t want someone to be able to override a virtual function, or inherit from a class.  The final specifier can be used to tell the compiler to enforce this.  If the user tries to override a function or inherit from a class that has been specified as final, the compiler will give a compile error.<\/p>\n<p>In the case where we want to restrict the user from overriding a function, the <strong>final specifier<\/strong> is used in the same place the override specifier is, like so:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string_view&gt;\r\n\r\nclass A\r\n{\r\npublic:\r\n\tvirtual std::string_view getName() const { return \"A\"; }\r\n};\r\n\r\nclass B : public A\r\n{\r\npublic:\r\n\t\/\/ note use of final specifier on following line -- that makes this function not able to be overridden in derived classes\r\n\tstd::string_view getName() const override final { return \"B\"; } \/\/ okay, overrides A::getName()\r\n};\r\n\r\nclass C : public B\r\n{\r\npublic:\r\n\tstd::string_view getName() const override { return \"C\"; } \/\/ compile error: overrides B::getName(), which is final\r\n};<\/code><\/pre>\n<p>In the above code, B::getName() overrides A::getName(), which is fine.  But B::getName() has the final specifier, which means that any further overrides of that function should be considered an error.  And indeed, C::getName() tries to override B::getName() (the override specifier here isn&#8217;t relevant, it&#8217;s just there for good practice), so the compiler will give a compile error.<\/p>\n<p>In the case where we want to prevent inheriting from a class, the final specifier is applied after the class name:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string_view&gt;\r\n\r\nclass A\r\n{\r\npublic:\r\n\tvirtual std::string_view getName() const { return \"A\"; }\r\n};\r\n\r\nclass B final : public A \/\/ note use of final specifier here\r\n{\r\npublic:\r\n\tstd::string_view getName() const override { return \"B\"; }\r\n};\r\n\r\nclass C : public B \/\/ compile error: cannot inherit from final class\r\n{\r\npublic:\r\n\tstd::string_view getName() const override { return \"C\"; }\r\n};<\/code><\/pre>\n<p>In the above example, class B is declared final.  Thus, when C tries to inherit from B, the compiler will give a compile error.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Covariant return types<\/p>\n<p>There is one special case in which a derived class virtual function override can have a different return type than the base class and still be considered a matching override.  If the return type of a virtual function is a pointer or a reference to some class, override functions can return a pointer or a reference to a derived class.  These are called <strong>covariant return types<\/strong>.  Here is an example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n\t\/\/ This version of getThis() returns a pointer to a Base class\r\n\tvirtual Base* getThis() { std::cout &lt;&lt; \"called Base::getThis()\\n\"; return this; }\r\n\tvoid printType() { std::cout &lt;&lt; \"returned a Base\\n\"; }\r\n};\r\n\r\nclass Derived : public Base\r\n{\r\npublic:\r\n\t\/\/ Normally override functions have to return objects of the same type as the base function\r\n\t\/\/ However, because Derived is derived from Base, it's okay to return Derived* instead of Base*\r\n\tDerived* getThis() override { std::cout &lt;&lt; \"called Derived::getThis()\\n\";  return this; }\r\n\tvoid printType() { std::cout &lt;&lt; \"returned a Derived\\n\"; }\r\n};\r\n\r\nint main()\r\n{\r\n\tDerived d{};\r\n\tBase* b{ &amp;d };\r\n\td.getThis()-&gt;printType(); \/\/ calls Derived::getThis(), returns a Derived*, calls Derived::printType\r\n\tb-&gt;getThis()-&gt;printType(); \/\/ calls Derived::getThis(), returns a Base*, calls Base::printType\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\ncalled Derived::getThis()\r\nreturned a Derived\r\ncalled Derived::getThis()\r\nreturned a Base\r\n<\/pre>\n<p>One interesting note about covariant return types: C++ can&#8217;t dynamically select types, so you&#8217;ll always get the type that matches the actual version of the function being called.<\/p>\n<p>In the above example, we first call d.getThis().  Since d is a Derived, this calls Derived::getThis(), which returns a <code>Derived*<\/code>.  This <code>Derived*<\/code> is then used to call non-virtual function Derived::printType().<\/p>\n<p>Now the interesting case.  We then call b->getThis().  Variable b is a Base pointer to a Derived object.  Base::getThis() is a virtual function, so this calls Derived::getThis().  Although Derived::getThis() returns a <code>Derived*<\/code>, because Base version of the function returns a <code>Base*<\/code>, the returned Derived* is upcast to a <code>Base*<\/code>.  Because Base::printType() is non-virtual, Base::printType() is called.<\/p>\n<p>In other words, in the above example, you only get a <code>Derived*<\/code> if you call getThis() with an object that is typed as a Derived object in the first place.<\/p>\n<p>Note that if printType() were virtual instead of non-virtual, the result of b->getThis() (an object of type <code>Base*<\/code>) would have undergone virtual function resolution, and Derived::printType() would have been called.<\/p>\n<p>Covariant return types are often used in cases where a virtual member function returns a pointer or reference to the class containing the member function (e.g. Base::getThis() returns a <code>Base*<\/code>, and Derived::getThis() returns a <code>Derived*<\/code>).  However, this isn&#8217;t strictly necessary.  Covariant return types can be used in any case where the return type of the override member function is derived from the return type of the base virtual member function.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>What does the following program output?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass A\r\n{\r\npublic:\r\n    void print()\r\n    {\r\n        std::cout &lt;&lt; \"A\";\r\n    }\r\n    virtual void vprint()\r\n    {\r\n        std::cout &lt;&lt; \"A\";\r\n    }\r\n};\r\nclass B : public A\r\n{\r\npublic:\r\n    void print()\r\n    {\r\n        std::cout &lt;&lt; \"B\";\r\n    }\r\n    void vprint() override\r\n    {\r\n        std::cout &lt;&lt; \"B\";\r\n    }\r\n};\r\n\r\n\r\nclass C\r\n{\r\nprivate:\r\n    A m_a{};\r\n\r\npublic:\r\n    virtual A&amp; get()\r\n    {\r\n        return m_a;\r\n    }\r\n};\r\n\r\nclass D : public C\r\n{\r\nprivate:\r\n    B m_b{};\r\n\r\npublic:\r\n    B&amp; get() override \/\/ covariant return type\r\n    {\r\n        return m_b;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    \/\/ case 1\r\n    D d {};\r\n    d.get().print();\r\n    d.get().vprint();\r\n    std::cout &lt;&lt; '\\n';\r\n \r\n    \/\/ case 2\r\n    C c {};\r\n    c.get().print();\r\n    c.get().vprint();\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    \/\/ case 3\r\n    C&amp; ref{ d };\r\n    ref.get().print();\r\n    ref.get().vprint();\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre>\nBB\r\nAA\r\nAB\r\n<\/pre>\n<p>In all cases, because <code>get()<\/code> has a covariant return type, the return type of <code>get()<\/code> will be the return type of the <code>get()<\/code> member function of the implicit object.<\/p>\n<p>Case 1 is straightforward.  In both statements, <code>d.get()<\/code> calls <code>D::get()<\/code>, which returns <code>m_b<\/code>.  Because <code>get()<\/code> is being called on <code>d<\/code>, which is of type <code>D<\/code>, the return type of <code>D::get()<\/code> is used, which is type <code>B&amp;<\/code>.  The calls to <code>print()<\/code> and <code>vprint()<\/code> resolve to <code>B::print()<\/code> and <code>B::vprint()<\/code> respectively.<\/p>\n<p>Case 2 is also straightforward.  In both statements, <code>c.get()<\/code> calls <code>C::get()<\/code>, which returns <code>m_a<\/code>.  Because <code>get()<\/code> is being called on <code>c<\/code>, which is of type <code>C<\/code>, the return type of <code>C::get()<\/code> is used, which is type <code>A&amp;<\/code>.  The calls to <code>print()<\/code> and <code>vprint()<\/code> resolve to <code>A::print()<\/code> and <code>A::vprint()<\/code> respectively.<\/p>\n<p>Case 3 is the interesting one.  <code>ref<\/code> is a <code>C&amp;<\/code> referencing a <code>D<\/code>.  <code>ref.get()<\/code> is a virtual function, so <code>ref.get()<\/code> virtually resolves to <code>D::get()<\/code>, which returns <code>m_b<\/code>.  However, <code>get()<\/code> has a covariant return type, so the return type of <code>get()<\/code> is determined by the type of the implicit object that <code>get()<\/code> is called on.  Since <code>ref<\/code> is a <code>C&amp;<\/code>, the return type of <code>C::get()<\/code> is used, which means the return type of <code>ref.get()<\/code> is <code>A&amp;<\/code> (referencing object <code>m_b<\/code>, which is a <code>B<\/code>).<\/p>\n<p>Because the return type of <code>ref.get()<\/code> is an <code>A&amp;<\/code>, non-virtual function call <code>ref.get().print()<\/code> resolves to <code>A::print()<\/code>.<\/p>\n<p>When virtual function <code>ref.get().vprint()<\/code> is called, virtual function resolution is used.  Although the return type of <code>ref.get()<\/code> is an <code>A&amp;<\/code>, the object being reference is actually a <code>B<\/code>.  Therefore, <code>B::vprint()<\/code> is called.\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>When would we use function overloading vs function overriding?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p>Function overloading is used when we need a member or non-member function to behave differently when passed parameters of different types.<\/p>\n<p>Function overriding is used when we need a member function to behave differently when the implicit object is a derived class.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/virtual-destructors-virtual-assignment-and-overriding-virtualization\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">25.4<\/span>Virtual destructors, virtual assignment, and overriding virtualization\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/virtual-functions\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">25.2<\/span>Virtual functions and polymorphism\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>To address some common challenges with inheritance, C++ has two inheritance-related identifiers: override and final. Note that these identifiers are not keywords &#8212; they are normal words that have special meaning only when used in certain contexts. The C++ standard calls them &#8220;identifiers with special meaning&#8221;, but they are often &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4905"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=4905"}],"version-history":[{"count":40,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4905\/revisions"}],"predecessor-version":[{"id":18040,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4905\/revisions\/18040"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=4905"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=4905"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=4905"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}