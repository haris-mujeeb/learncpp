{"id":184,"date":"2008-02-13T16:09:36","date_gmt":"2008-02-14T00:09:36","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/126-pure-virtual-functions-abstract-base-classes-and-interface-classes\/"},"modified":"2024-10-01T15:43:20","modified_gmt":"2024-10-01T22:43:20","slug":"pure-virtual-functions-abstract-base-classes-and-interface-classes","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/pure-virtual-functions-abstract-base-classes-and-interface-classes\/","title":{"rendered":"25.7 &#8212; Pure virtual functions, abstract base classes, and interface classes"},"content":{"rendered":"<p><strong>Pure virtual (abstract) functions and abstract base classes<\/strong><\/p>\n<p>So far, all of the virtual functions we have written have a body (a definition).  However, C++ allows you to create a special kind of virtual function called a <strong>pure virtual function<\/strong> (or <strong>abstract function<\/strong>) that has no body at all!  A pure virtual function simply acts as a placeholder that is meant to be redefined by derived classes.<\/p>\n<p>To create a pure virtual function, rather than define a body for the function, we simply assign the function the value 0.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string_view&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n    std::string_view sayHi() const { return \"Hi\"; } \/\/ a normal non-virtual function    \r\n\r\n    virtual std::string_view getName() const { return \"Base\"; } \/\/ a normal virtual function\r\n\r\n    virtual int getValue() const = 0; \/\/ a pure virtual function\r\n\r\n    int doSomething() = 0; \/\/ Compile error: can not set non-virtual functions to 0\r\n};<\/code><\/pre>\n<p>When we add a pure virtual function to our class, we are effectively saying, &#8220;it is up to the derived classes to implement this function&#8221;.<\/p>\n<p>Using a pure virtual function has two main consequences: First, any class with one or more pure virtual functions becomes an <strong>abstract base class<\/strong>, which means that it can not be instantiated!  Consider what would happen if we could create an instance of Base:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    Base base {}; \/\/ We can't instantiate an abstract base class, but for the sake of example, pretend this was allowed\r\n    base.getValue(); \/\/ what would this do?\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because there&#8217;s no definition for getValue(), what would base.getValue() resolve to?<\/p>\n<p>Second, any derived class must define a body for this function, or that derived class will be considered an abstract base class as well.<\/p>\n<p><strong>A pure virtual function example<\/strong><\/p>\n<p>Let&#8217;s take a look at an example of a pure virtual function in action.  In a previous lesson, we wrote a simple Animal base class and derived a Cat and a Dog class from it.  Here&#8217;s the code as we left it:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Animal\r\n{\r\nprotected:\r\n    std::string m_name {};\r\n\r\n    \/\/ We're making this constructor protected because\r\n    \/\/ we don't want people creating Animal objects directly,\r\n    \/\/ but we still want derived classes to be able to use it.\r\n    Animal(std::string_view name)\r\n        : m_name{ name }\r\n    {\r\n    }\r\n\r\npublic:\r\n    const std::string&amp; getName() const { return m_name; }\r\n    virtual std::string_view speak() const { return \"???\"; }\r\n    \r\n    virtual ~Animal() = default;\r\n};\r\n\r\nclass Cat: public Animal\r\n{\r\npublic:\r\n    Cat(std::string_view name)\r\n        : Animal{ name }\r\n    {\r\n    }\r\n\r\n    std::string_view speak() const override { return \"Meow\"; }\r\n};\r\n\r\nclass Dog: public Animal\r\n{\r\npublic:\r\n    Dog(std::string_view name)\r\n        : Animal{ name }\r\n    {\r\n    }\r\n\r\n    std::string_view speak() const override { return \"Woof\"; }\r\n};<\/code><\/pre>\n<p>We&#8217;ve prevented people from allocating objects of type Animal by making the constructor protected.  However, it is still possible to create derived classes that do not redefine function speak().<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Animal\r\n{\r\nprotected:\r\n    std::string m_name {};\r\n\r\n    \/\/ We're making this constructor protected because\r\n    \/\/ we don't want people creating Animal objects directly,\r\n    \/\/ but we still want derived classes to be able to use it.\r\n    Animal(std::string_view name)\r\n        : m_name{ name }\r\n    {\r\n    }\r\n\r\npublic:\r\n    const std::string&amp; getName() const { return m_name; }\r\n    virtual std::string_view speak() const { return \"???\"; }\r\n    \r\n    virtual ~Animal() = default;\r\n};\r\n\r\nclass Cow : public Animal\r\n{\r\npublic:\r\n    Cow(std::string_view name)\r\n        : Animal{ name }\r\n    {\r\n    }\r\n\r\n    \/\/ We forgot to redefine speak\r\n};\r\n\r\nint main()\r\n{\r\n    Cow cow{\"Betsy\"};\r\n    std::cout &lt;&lt; cow.getName() &lt;&lt; \" says \" &lt;&lt; cow.speak() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This will print:<\/p>\n<pre>\r\nBetsy says ???\r\n<\/pre>\n<p>What happened?  We forgot to redefine function speak(), so cow.Speak() resolved to Animal.speak(), which isn&#8217;t what we wanted.<\/p>\n<p>A better solution to this problem is to use a pure virtual function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Animal \/\/ This Animal is an abstract base class\r\n{\r\nprotected:\r\n    std::string m_name {};\r\n\r\npublic:\r\n    Animal(std::string_view name)\r\n        : m_name{ name }\r\n    {\r\n    }\r\n\r\n    const std::string&amp; getName() const { return m_name; }\r\n    virtual std::string_view speak() const = 0; \/\/ note that speak is now a pure virtual function\r\n    \r\n    virtual ~Animal() = default;\r\n};<\/code><\/pre>\n<p>There are a couple of things to note here.  First, speak() is now a pure virtual function.  This means Animal is now an abstract base class, and can not be instantiated.  Consequently, we do not need to make the constructor protected any longer (though it doesn&#8217;t hurt).  Second, because our Cow class was derived from Animal, but we did not define Cow::speak(), Cow is also an abstract base class.  Now when we try to compile this code:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Animal \/\/ This Animal is an abstract base class\r\n{\r\nprotected:\r\n    std::string m_name {};\r\n\r\npublic:\r\n    Animal(std::string_view name)\r\n        : m_name{ name }\r\n    {\r\n    }\r\n\r\n    const std::string&amp; getName() const { return m_name; }\r\n    virtual std::string_view speak() const = 0; \/\/ note that speak is now a pure virtual function\r\n    \r\n    virtual ~Animal() = default;\r\n};\r\n\r\nclass Cow: public Animal\r\n{\r\npublic:\r\n    Cow(std::string_view name)\r\n        : Animal{ name }\r\n    {\r\n    }\r\n\r\n    \/\/ We forgot to redefine speak\r\n};\r\n\r\nint main()\r\n{\r\n    Cow cow{ \"Betsy\" };\r\n    std::cout &lt;&lt; cow.getName() &lt;&lt; \" says \" &lt;&lt; cow.speak() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The compiler will give us an error because Cow is an abstract base class and we can not create instances of abstract base classes:<\/p>\n<pre>\r\nprog.cc:35:9: error: variable type 'Cow' is an abstract class\r\n   35 |     Cow cow{ \"Betsy\" };\r\n      |         ^\r\nprog.cc:17:30: note: unimplemented pure virtual method 'speak' in 'Cow'\r\n   17 |     virtual std::string_view speak() const = 0; \/\/ note that speak is now a pure virtual function\r\n      |                              ^\r\n<\/pre>\n<p>This tells us that we will only be able to instantiate Cow if Cow provides a body for speak().<\/p>\n<p>Let&#8217;s go ahead and do that:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Animal \/\/ This Animal is an abstract base class\r\n{\r\nprotected:\r\n    std::string m_name {};\r\n\r\npublic:\r\n    Animal(std::string_view name)\r\n        : m_name{ name }\r\n    {\r\n    }\r\n\r\n    const std::string&amp; getName() const { return m_name; }\r\n    virtual std::string_view speak() const = 0; \/\/ note that speak is now a pure virtual function\r\n    \r\n    virtual ~Animal() = default;\r\n};\r\n\r\nclass Cow: public Animal\r\n{\r\npublic:\r\n    Cow(std::string_view name)\r\n        : Animal(name)\r\n    {\r\n    }\r\n\r\n    std::string_view speak() const override { return \"Moo\"; }\r\n};\r\n\r\nint main()\r\n{\r\n    Cow cow{ \"Betsy\" };\r\n    std::cout &lt;&lt; cow.getName() &lt;&lt; \" says \" &lt;&lt; cow.speak() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Now this program will compile and print:<\/p>\n<pre>\r\nBetsy says Moo\r\n<\/pre>\n<p>A pure virtual function is useful when we have a function that we want to put in the base class, but only the derived classes know what it should return.  A pure virtual function makes it so the base class can not be instantiated, and the derived classes are forced to define these functions before they can be instantiated.  This helps ensure the derived classes do not forget to redefine functions that the base class was expecting them to.<\/p>\n<p>Just like with normal virtual functions, pure virtual functions can be called using a reference (or pointer) to a base class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    Cow cow{ \"Betsy\" };\r\n    Animal&amp; a{ cow };\r\n\r\n    std::cout &lt;&lt; a.speak(); \/\/ resolves to Cow::speak(), prints \"Moo\"\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, <code>a.speak()<\/code> resolves to <code>Cow::speak()<\/code> via virtual function resolution.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">A reminder<\/p>\n<p>Any class with pure virtual functions should also have a virtual destructor.\n<\/p><\/div>\n<p><strong>Pure virtual functions with definitions<\/strong><\/p>\n<p>It turns out that we can create pure virtual functions that have definitions:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Animal \/\/ This Animal is an abstract base class\r\n{\r\nprotected:\r\n    std::string m_name {};\r\n\r\npublic:\r\n    Animal(std::string_view name)\r\n        : m_name{ name }\r\n    {\r\n    }\r\n\r\n    const std::string&amp; getName() { return m_name; }\r\n    virtual std::string_view speak() const = 0; \/\/ The = 0 means this function is pure virtual\r\n    \r\n    virtual ~Animal() = default;\r\n};\r\n\r\nstd::string_view Animal::speak() const  \/\/ even though it has a definition\r\n{\r\n    return \"buzz\";\r\n}<\/code><\/pre>\n<p>In this case, speak() is still considered a pure virtual function because of the &#8220;= 0&#8221; (even though it has been given a definition) and Animal is still considered an abstract base class (and thus can&#8217;t be instantiated).  Any class that inherits from Animal needs to provide its own definition for speak() or it will also be considered an abstract base class.<\/p>\n<p>When providing a definition for a pure virtual function, the definition must be provided separately (not inline).<\/p>\n<div class=\"cpp-note cpp-lightyellowbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For Visual Studio users<\/p>\n<p>Visual Studio allows pure virtual function declarations to be definitions, for example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">virtual std::string_view speak() const = 0\r\n{\r\n  return \"buzz\";\r\n}<\/code><\/pre>\n<p>This is non-conforming with the C++ standard, and cannot be disabled.\n<\/p><\/div>\n<p>This paradigm can be useful when you want your base class to provide a default implementation for a function, but still force any derived classes to provide their own implementation.  However, if the derived class is happy with the default implementation provided by the base class, it can simply call the base class implementation directly.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Animal \/\/ This Animal is an abstract base class\r\n{\r\nprotected:\r\n    std::string m_name {};\r\n\r\npublic:\r\n    Animal(std::string_view name)\r\n        : m_name(name)\r\n    {\r\n    }\r\n\r\n    const std::string&amp; getName() const { return m_name; }\r\n    virtual std::string_view speak() const = 0; \/\/ note that speak is a pure virtual function\r\n    \r\n    virtual ~Animal() = default;\r\n};\r\n\r\nstd::string_view Animal::speak() const\r\n{\r\n    return \"buzz\"; \/\/ some default implementation\r\n}\r\n\r\nclass Dragonfly: public Animal\r\n{\r\n\r\npublic:\r\n    Dragonfly(std::string_view name)\r\n        : Animal{name}\r\n    {\r\n    }\r\n\r\n    std::string_view speak() const override\/\/ this class is no longer abstract because we defined this function\r\n    {\r\n        return Animal::speak(); \/\/ use Animal's default implementation\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Dragonfly dfly{\"Sally\"};\r\n    std::cout &lt;&lt; dfly.getName() &lt;&lt; \" says \" &lt;&lt; dfly.speak() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The above code prints:<\/p>\n<pre>\r\nSally says buzz\r\n<\/pre>\n<p>This capability isn&#8217;t used very commonly.<\/p>\n<p>A destructor can be made pure virtual, but must be given a definition so that it can be called when a derived object is destructed.<\/p>\n<p><strong>Interface classes<\/strong><\/p>\n<p>An <strong>interface class<\/strong> is a class that has no member variables, and where <em>all<\/em> of the functions are pure virtual!  Interfaces are useful when you want to define the functionality that derived classes must implement, but leave the details of how the derived class implements that functionality entirely up to the derived class.<\/p>\n<p>Interface classes are often named beginning with an I.  Here&#8217;s a sample interface class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string_view&gt;\r\n\r\nclass IErrorLog\r\n{\r\npublic:\r\n    virtual bool openLog(std::string_view filename) = 0;\r\n    virtual bool closeLog() = 0;\r\n\r\n    virtual bool writeError(std::string_view errorMessage) = 0;\r\n\r\n    virtual ~IErrorLog() {} \/\/ make a virtual destructor in case we delete an IErrorLog pointer, so the proper derived destructor is called\r\n};<\/code><\/pre>\n<p>Any class inheriting from IErrorLog must provide implementations for all three functions in order to be instantiated.  You could derive a class named FileErrorLog, where openLog() opens a file on disk, closeLog() closes the file, and writeError() writes the message to the file.  You could derive another class called ScreenErrorLog, where openLog() and closeLog() do nothing, and writeError() prints the message in a pop-up message box on the screen.<\/p>\n<p>Now, let&#8217;s say you need to write some code that uses an error log.  If you write your code so it includes FileErrorLog or ScreenErrorLog directly, then you&#8217;re effectively stuck using that kind of error log (at least without recoding your program).  For example, the following function effectively forces callers of mySqrt() to use a FileErrorLog, which may or may not be what they want.  <\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cmath&gt; \/\/ for sqrt()\r\n\r\ndouble mySqrt(double value, FileErrorLog&amp; log)\r\n{\r\n    if (value &lt; 0.0)\r\n    {\r\n        log.writeError(\"Tried to take square root of value less than 0\");\r\n        return 0.0;\r\n    }\r\n\r\n    return std::sqrt(value);\r\n}<\/code><\/pre>\n<p>A much better way to implement this function is to use IErrorLog instead:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cmath&gt; \/\/ for sqrt()\r\ndouble mySqrt(double value, IErrorLog&amp; log)\r\n{\r\n    if (value &lt; 0.0)\r\n    {\r\n        log.writeError(\"Tried to take square root of value less than 0\");\r\n        return 0.0;\r\n    }\r\n\r\n    return std::sqrt(value);\r\n}<\/code><\/pre>\n<p>Now the caller can pass in <em>any<\/em> class that conforms to the IErrorLog interface.  If they want the error to go to a file, they can pass in an instance of FileErrorLog.  If they want it to go to the screen, they can pass in an instance of ScreenErrorLog.  Or if they want to do something you haven&#8217;t even thought of, such as sending an email to someone when there&#8217;s an error, they can derive a new class from IErrorLog (e.g. EmailErrorLog) and use an instance of that!  By using IErrorLog, your function becomes more independent and flexible.<\/p>\n<p>Don&#8217;t forget to include a virtual destructor for your interface classes, so that the proper derived destructor will be called if a pointer to the interface is deleted.<\/p>\n<p>Interface classes have become extremely popular because they are easy to use, easy to extend, and easy to maintain.  In fact, some modern languages, such as Java and C#, have added an &#8220;interface&#8221; keyword that allows programmers to directly define an interface class without having to explicitly mark all of the member functions as abstract.  Furthermore, although Java and C# will not let you use multiple inheritance on normal classes, they will let you multiple inherit as many interfaces as you like.  Because interfaces have no data and no function bodies, they avoid a lot of the traditional problems with multiple inheritance while still providing much of the flexibility.<\/p>\n<p><strong>Pure virtual functions and the virtual table<\/strong><\/p>\n<p>For consistency, abstract classes still have virtual tables.  A constructor or destructor of an abstract class can call a virtual function, and it needs to resolve to the proper function (in the same class, since the derived classes either haven&#8217;t been constructed yet or have already been destroyed).<\/p>\n<p>The virtual table entry for a class with a pure virtual function will generally either contain a null pointer, or point to a generic function that prints an error (sometimes this function is named __purecall).<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/virtual-base-classes\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">25.8<\/span>Virtual base classes\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/the-virtual-table\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">25.6<\/span>The virtual table\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Pure virtual (abstract) functions and abstract base classes So far, all of the virtual functions we have written have a body (a definition). However, C++ allows you to create a special kind of virtual function called a pure virtual function (or abstract function) that has no body at all! A &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/184"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=184"}],"version-history":[{"count":48,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/184\/revisions"}],"predecessor-version":[{"id":17699,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/184\/revisions\/17699"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=184"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=184"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=184"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}