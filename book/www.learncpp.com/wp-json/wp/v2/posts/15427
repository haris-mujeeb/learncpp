{"id":15427,"date":"2023-09-11T15:52:11","date_gmt":"2023-09-11T22:52:11","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15427"},"modified":"2025-02-01T15:01:56","modified_gmt":"2025-02-01T23:01:56","slug":"stdarray-and-enumerations","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/stdarray-and-enumerations\/","title":{"rendered":"17.6 &#8212; std::array and enumerations"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/array-indexing-and-length-using-enumerators\/\">16.9 -- Array indexing and length using enumerators<\/a>, we discussed arrays and enumerations.<\/p>\n<p>Now that we have <code>constexpr std::array<\/code> in our toolkit, we&#8217;re going to continue that discussion and show a few additional tricks.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using static assert to ensure the proper number of array initializers<\/p>\n<p>When initializing a <code>constexpr std::array<\/code> using CTAD, the compiler will deduce how long the array should be from the number of initializers.  If less initializers are provided than there should be, the array will be shorter than expected, and indexing it can lead to undefined behavior.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nenum StudentNames\r\n{\r\n    kenny, \/\/ 0\r\n    kyle, \/\/ 1\r\n    stan, \/\/ 2\r\n    butters, \/\/ 3\r\n    cartman, \/\/ 4\r\n    max_students \/\/ 5\r\n};\r\n\r\nint main()\r\n{\r\n    constexpr std::array testScores { 78, 94, 66, 77 }; \/\/ oops, only 4 values\r\n\r\n    std::cout &lt;&lt; \"Cartman got a score of \" &lt;&lt; testScores[StudentNames::cartman] &lt;&lt; '\\n'; \/\/ undefined behavior due to invalid index\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Whenever the number of initializers in a <code>constexpr std::array<\/code> can be reasonably sanity checked, you can do so using a static assert:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nenum StudentNames\r\n{\r\n    kenny, \/\/ 0\r\n    kyle, \/\/ 1\r\n    stan, \/\/ 2\r\n    butters, \/\/ 3\r\n    cartman, \/\/ 4\r\n    max_students \/\/ 5\r\n};\r\n\r\nint main()\r\n{\r\n    constexpr std::array testScores { 78, 94, 66, 77 };\r\n\r\n    \/\/ Ensure the number of test scores is the same as the number of students\r\n    static_assert(std::size(testScores) == max_students); \/\/ compile error: static_assert condition failed\r\n\r\n    std::cout &lt;&lt; \"Cartman got a score of \" &lt;&lt; testScores[StudentNames::cartman] &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>That way, if you add a new enumerator later but forget to add a corresponding initializer to <code>testScores<\/code>, the program will fail to compile.<\/p>\n<p>You can also use a static assert to ensure two different <code>constexpr std::array<\/code> have the same length.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using constexpr arrays for better enumeration input and output<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-overloading-the-i-o-operators\/\">13.5 -- Introduction to overloading the I\/O operators<\/a>, we covered a few ways to input and output the names of enumerators.  To assist in this task, we had helper functions that converted an enumerator to a string and vice-versa.  These functions each had their own (duplicate) set of string literals, and we had to specifically code logic to check each:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">constexpr std::string_view getPetName(Pet pet)\r\n{\r\n    switch (pet)\r\n    {\r\n    case cat:   return \"cat\";\r\n    case dog:   return \"dog\";\r\n    case pig:   return \"pig\";\r\n    case whale: return \"whale\";\r\n    default:    return \"???\";\r\n    }\r\n}\r\n\r\nconstexpr std::optional&lt;Pet&gt; getPetFromString(std::string_view sv)\r\n{\r\n    if (sv == \"cat\")   return cat;\r\n    if (sv == \"dog\")   return dog;\r\n    if (sv == \"pig\")   return pig;\r\n    if (sv == \"whale\") return whale;\r\n\r\n    return {};\r\n}<\/code><\/pre>\n<p>This means that if we were to add a new enumerator, we&#8217;d have to remember to update these functions.<\/p>\n<p>Let&#8217;s improve these functions a bit.  In cases where the value of our enumerators start at 0 and proceed sequentially (which is true for most enumerations), we can use an array to hold the name of each enumerator.  <\/p>\n<p>This allows us to do two things:<\/p>\n<ol start=\"1\">\n<li>Index the array using the enumerator&#8217;s value to get the name of that enumerator.\n<\/li>\n<li>Use a loop to iterate through all of the names, and be able to correlate a name back to the enumerator based on index.\n<\/li>\n<\/ol>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nnamespace Color\r\n{\r\n    enum Type\r\n    {\r\n        black,\r\n        red,\r\n        blue,\r\n        max_colors\r\n    };\r\n\r\n    \/\/ use sv suffix so std::array will infer type as std::string_view\r\n    using namespace std::string_view_literals; \/\/ for sv suffix\r\n    constexpr std::array colorName { \"black\"sv, \"red\"sv, \"blue\"sv };\r\n\r\n    \/\/ Make sure we've defined strings for all our colors\r\n    static_assert(std::size(colorName) == max_colors);\r\n};\r\n\r\nconstexpr std::string_view getColorName(Color::Type color)\r\n{\r\n    \/\/ We can index the array using the enumerator to get the name of the enumerator\r\n    return Color::colorName[static_cast&lt;std::size_t&gt;(color)];\r\n}\r\n\r\n\/\/ Teach operator&lt;&lt; how to print a Color\r\n\/\/ std::ostream is the type of std::cout\r\n\/\/ The return type and parameter type are references (to prevent copies from being made)!\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, Color::Type color)\r\n{\r\n    return out &lt;&lt; getColorName(color);\r\n}\r\n\r\n\/\/ Teach operator&gt;&gt; how to input a Color by name\r\n\/\/ We pass color by non-const reference so we can have the function modify its value\r\nstd::istream&amp; operator&gt;&gt; (std::istream&amp; in, Color::Type&amp; color)\r\n{\r\n    std::string input {};\r\n    std::getline(in &gt;&gt; std::ws, input);\r\n\r\n    \/\/ Iterate through the list of names to see if we can find a matching name\r\n    for (std::size_t index=0; index &lt; Color::colorName.size(); ++index)\r\n    {\r\n        if (input == Color::colorName[index])\r\n        {\r\n            \/\/ If we found a matching name, we can get the enumerator value based on its index\r\n            color = static_cast&lt;Color::Type&gt;(index);\r\n            return in;\r\n        }\r\n    }\r\n\r\n    \/\/ We didn't find a match, so input must have been invalid\r\n    \/\/ so we will set input stream to fail state\r\n    in.setstate(std::ios_base::failbit);\r\n\r\n    \/\/ On an extraction failure, operator&gt;&gt; zero-initializes fundamental types\r\n    \/\/ Uncomment the following line to make this operator do the same thing\r\n    \/\/ color = {};\r\n    return in;\r\n}\r\n\r\nint main()\r\n{\r\n    auto shirt{ Color::blue };\r\n    std::cout &lt;&lt; \"Your shirt is \" &lt;&lt; shirt &lt;&lt; '\\n';\r\n\r\n    std::cout &lt;&lt; \"Enter a new color: \";\r\n    std::cin &gt;&gt; shirt;\r\n    if (!std::cin)\r\n        std::cout &lt;&lt; \"Invalid\\n\";\r\n    else\r\n        std::cout &lt;&lt; \"Your shirt is now \" &lt;&lt; shirt &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nYour shirt is blue\r\nEnter a new color: red\r\nYour shirt is now red\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><a name=\"rangedEnumeration\"><\/a>Range-based for-loops and enumerations <a href=\"#rangedEnumeration\"><i class=\"fa fa-link\" style=\"font-size: 0.8em;\"><\/i><\/a><\/p>\n<p>Occasionally we run across situations where it would be useful to iterate through the enumerators of an enumeration.  While we can do this using a for-loop with an integer index, this is likely to require a lot of static casting of the integer index to our enumeration type.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nnamespace Color\r\n{\r\n    enum Type\r\n    {\r\n        black,\r\n        red,\r\n        blue,\r\n        max_colors\r\n    };\r\n\r\n    \/\/ use sv suffix so std::array will infer type as std::string_view\r\n    using namespace std::string_view_literals; \/\/ for sv suffix\r\n    constexpr std::array colorName { \"black\"sv, \"red\"sv, \"blue\"sv };\r\n\r\n    \/\/ Make sure we've defined strings for all our colors\r\n    static_assert(std::size(colorName) == max_colors);\r\n};\r\n\r\nconstexpr std::string_view getColorName(Color::Type color)\r\n{\r\n    return Color::colorName[color];\r\n}\r\n\r\n\/\/ Teach operator&lt;&lt; how to print a Color\r\n\/\/ std::ostream is the type of std::cout\r\n\/\/ The return type and parameter type are references (to prevent copies from being made)!\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, Color::Type color)\r\n{\r\n    return out &lt;&lt; getColorName(color);\r\n}\r\n\r\nint main()\r\n{\r\n    \/\/ Use a for loop to iterate through all our colors\r\n    for (int i=0; i &lt; Color::max_colors; ++i )\r\n        std::cout &lt;&lt; static_cast&lt;Color::Type&gt;(i) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Unfortunately, range-based for-loops won&#8217;t allow you to iterate over the enumerators of an enumeration:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nnamespace Color\r\n{\r\n    enum Type\r\n    {\r\n        black,\r\n        red,\r\n        blue,\r\n        max_colors\r\n    };\r\n\r\n    \/\/ use sv suffix so std::array will infer type as std::string_view\r\n    using namespace std::string_view_literals; \/\/ for sv suffix\r\n    constexpr std::array colorName { \"black\"sv, \"red\"sv, \"blue\"sv };\r\n\r\n    \/\/ Make sure we've defined strings for all our colors\r\n    static_assert(std::size(colorName) == max_colors);\r\n};\r\n\r\nconstexpr std::string_view getColorName(Color::Type color)\r\n{\r\n    return Color::colorName[color];\r\n}\r\n\r\n\/\/ Teach operator&lt;&lt; how to print a Color\r\n\/\/ std::ostream is the type of std::cout\r\n\/\/ The return type and parameter type are references (to prevent copies from being made)!\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, Color::Type color)\r\n{\r\n    return out &lt;&lt; getColorName(color);\r\n}\r\n\r\nint main()\r\n{\r\n    for (auto c: Color::Type) \/\/ compile error: can't traverse enumeration\r\n        std::cout &lt;&lt; c &lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>There are many creative solutions for this.  Since we can use a range-based for-loop on an array, one of the most straightforward solutions is to create a <code>constexpr std::array<\/code> containing each of our enumerators, and then iterate over that.  This method only works if the enumerators have unique values.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nnamespace Color\r\n{\r\n    enum Type\r\n    {\r\n        black,     \/\/ 0\r\n        red,       \/\/ 1\r\n        blue,      \/\/ 2\r\n        max_colors \/\/ 3\r\n    };\r\n\r\n    using namespace std::string_view_literals; \/\/ for sv suffix\r\n    constexpr std::array colorName { \"black\"sv, \"red\"sv, \"blue\"sv };\r\n    static_assert(std::size(colorName) == max_colors);\r\n\r\n    constexpr std::array types { black, red, blue }; \/\/ A std::array containing all our enumerators\r\n    static_assert(std::size(types) == max_colors);\r\n};\r\n\r\nconstexpr std::string_view getColorName(Color::Type color)\r\n{\r\n    return Color::colorName[color];\r\n}\r\n\r\n\/\/ Teach operator&lt;&lt; how to print a Color\r\n\/\/ std::ostream is the type of std::cout\r\n\/\/ The return type and parameter type are references (to prevent copies from being made)!\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, Color::Type color)\r\n{\r\n    return out &lt;&lt; getColorName(color);\r\n}\r\n\r\nint main()\r\n{\r\n    for (auto c: Color::types) \/\/ ok: we can do a range-based for on a std::array\r\n        std::cout &lt;&lt; c &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, since the element type of <code>Color::types<\/code> is <code>Color::Type<\/code>, variable <code>c<\/code> will be deduced as a <code>Color::Type<\/code>, which is exactly what we want!<\/p>\n<p>This prints:<\/p>\n<pre>\nblack\r\nred\r\nblue\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p>Define a namespace named <code>Animal<\/code>.  Inside it, define an enum containing the following animals: chicken, dog, cat, elephant, duck, and snake.  Also create a struct named <code>Data<\/code> to store each animal&#8217;s name, number of legs, and the sound it makes.  Create a <code>std::array<\/code> of Data and fill out a Data element for each animal.<\/p>\n<p>Ask the user to enter the name of an animal.  If the name does not match the name of one of our animals, tell them so.  Otherwise, print the data for that animal.  Then print the data for all of the other animals that didn&#8217;t match their input.<\/p>\n<p>For example:<\/p>\n<pre>\nEnter an animal: dog\r\nA dog has 4 legs and says woof.\r\n\r\nHere is the data for the rest of the animals:\r\nA chicken has 2 legs and says cluck.\r\nA cat has 4 legs and says meow.\r\nA elephant has 4 legs and says pawoo.\r\nA duck has 2 legs and says quack.\r\nA snake has 0 legs and says hissss.\r\n<\/pre>\n<pre>\nEnter an animal: frog\r\nThat animal couldn't be found.\r\n\r\nHere is the data for the rest of the animals:\r\nA chicken has 2 legs and says cluck.\r\nA dog has 4 legs and says woof.\r\nA cat has 4 legs and says meow.\r\nA elephant has 4 legs and says pawoo.\r\nA duck has 2 legs and says quack.\r\nA snake has 0 legs and says hissss.\r\n<\/pre>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nnamespace Animal\r\n{\r\n    enum Type\r\n    {\r\n        chicken,\r\n        dog,\r\n        cat,\r\n        elephant,\r\n        duck,\r\n        snake,\r\n        max_animals\r\n    };\r\n\r\n    struct Data\r\n    {\r\n        std::string_view name{};\r\n        int legs{};\r\n        std::string_view sound{};\r\n    };\r\n\r\n    constexpr std::array types { chicken, dog, cat, elephant, duck, snake };\r\n    constexpr std::array data {\r\n        Data{ \"chicken\",    2, \"cluck\" },\r\n        Data{ \"dog\",        4, \"woof\" },\r\n        Data{ \"cat\",        4, \"meow\" },\r\n        Data{ \"elephant\",   4, \"pawoo\" },\r\n        Data{ \"duck\",       2, \"quack\" },\r\n        Data{ \"snake\",      0, \"hissss\" },\r\n    };\r\n\r\n    static_assert(std::size(types) == max_animals);\r\n    static_assert(std::size(data) == max_animals);\r\n}\r\n\r\n\/\/ Teach operator&gt;&gt; how to input an Animal by name\r\n\/\/ We pass animal by non-const reference so we can have the function modify its value\r\nstd::istream&amp; operator&gt;&gt; (std::istream&amp; in, Animal::Type&amp; animal)\r\n{\r\n    std::string input {};\r\n    std::getline(in &gt;&gt; std::ws, input);\r\n\r\n    \/\/ See if we can find a match\r\n    for (std::size_t index=0; index &lt; Animal::data.size(); ++index)\r\n    {\r\n        if (input == Animal::data[index].name)\r\n        {\r\n            animal = static_cast&lt;Animal::Type&gt;(index);\r\n            return in;\r\n        }\r\n    }\r\n\r\n    \/\/ We didn't find a match, so input must have been invalid\r\n    \/\/ so we will set input stream to fail state\r\n    in.setstate(std::ios_base::failbit);\r\n    return in;\r\n}\r\n\r\nvoid printAnimalData(Animal::Type type)\r\n{\r\n    const Animal::Data&amp; animal { Animal::data[type] };\r\n    std::cout &lt;&lt; \"A \" &lt;&lt; animal.name &lt;&lt; \" has \" &lt;&lt; animal.legs &lt;&lt; \" legs and says \" &lt;&lt; animal.sound &lt;&lt; \".\\n\";    \r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter an animal: \";\r\n    Animal::Type type{};\r\n    std::cin &gt;&gt; type;\r\n\r\n    \/\/ If users input didn't match\r\n    if (!std::cin)\r\n    {\r\n        std::cin.clear();\r\n        std::cout &lt;&lt; \"That animal couldn't be found.\\n\";\r\n        type = Animal::max_animals; \/\/ set to invalid option so we don't match below\r\n    }\r\n    else\r\n        printAnimalData(type);\r\n\r\n\r\n    std::cout &lt;&lt; \"\\nHere is the data for the rest of the animals:\\n\";\r\n    for (auto a : Animal::types)\r\n    {\r\n        if (a != type)\r\n            printAnimalData(a);\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-c-style-arrays\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.7<\/span>Introduction to C-style arrays\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/arrays-of-references-via-stdreference_wrapper\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.5<\/span>Arrays of references via std::reference_wrapper\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we discussed arrays and enumerations. Now that we have constexpr std::array in our toolkit, we&#8217;re going to continue that discussion and show a few additional tricks. Using static assert to ensure the proper number of array initializers When initializing a constexpr std::array using CTAD, the compiler will &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15427"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15427"}],"version-history":[{"count":13,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15427\/revisions"}],"predecessor-version":[{"id":18154,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15427\/revisions\/18154"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15427"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15427"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15427"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}