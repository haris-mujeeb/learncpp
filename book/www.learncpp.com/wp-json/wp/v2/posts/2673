{"id":2673,"date":"2015-09-28T16:34:41","date_gmt":"2015-09-29T00:34:41","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=2673"},"modified":"2024-12-26T17:39:52","modified_gmt":"2024-12-27T01:39:52","slug":"introduction-to-stdvector-and-list-constructors","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdvector-and-list-constructors\/","title":{"rendered":"16.2 &#8212; Introduction to std::vector and list constructors"},"content":{"rendered":"<p>In the previous lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-containers-and-arrays\/\">16.1 -- Introduction to containers and arrays<\/a>, we introduced both containers and arrays.  In this lesson, we&#8217;ll introduce the array type that we&#8217;ll be focused on for the rest of the chapter: <code>std::vector<\/code>.  We&#8217;ll also solve one part of the scalability challenge we introduced last lesson.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Introduction to <code>std::vector<\/code><\/p>\n<p><code>std::vector<\/code> is one of the container classes in the C++ standard containers library that implements an array.  <code>std::vector<\/code> is defined in the &lt;vector&gt; header as a class template, with a template type parameter that defines the type of the elements.  Thus, <code>std::vector&lt;int&gt;<\/code> declares a <code>std::vector<\/code> whose elements are of type <code>int<\/code>.<\/p>\n<p>Instantiating a <code>std::vector<\/code> object is straightforward:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n\t\/\/ Value initialization (uses default constructor)\r\n\tstd::vector&lt;int&gt; empty{}; \/\/ vector containing 0 int elements\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Variable <code>empty<\/code> is defined as a <code>std::vector<\/code> whose elements have type <code>int<\/code>.  Because we&#8217;ve used value initialization here, our vector will start empty (that is, with no elements).<\/p>\n<p>A vector with no elements may not seem useful now, but we&#8217;ll encounter this again in future lessons (particularly <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdvector-and-stack-behavior\/\">16.11 -- std::vector and stack behavior<\/a>).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Initializing a <code>std::vector<\/code> with a list of values<\/p>\n<p>Since the goal of a container is to manage a set of related values, most often we will want to initialize our container with those values.  We can do this by using list initialization with the specific initialization values we want.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n\t\/\/ List construction (uses list constructor)\r\n\tstd::vector&lt;int&gt; primes{ 2, 3, 5, 7 };          \/\/ vector containing 4 int elements with values 2, 3, 5, and 7\r\n\tstd::vector vowels { 'a', 'e', 'i', 'o', 'u' }; \/\/ vector containing 5 char elements with values 'a', 'e', 'i', 'o', and 'u'.  Uses CTAD (C++17) to deduce element type char (preferred).\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>With <code>primes<\/code>, we&#8217;re explicitly specifying that we want a <code>std::vector<\/code> whose elements have type <code>int<\/code>.  Because we&#8217;ve supplied 4 initialization values, <code>primes<\/code> will contain 4 elements whose values are <code>2<\/code>, <code>3<\/code>, <code>5<\/code>, and <code>7<\/code>.<\/p>\n<p>With <code>vowels<\/code>, we haven&#8217;t explicitly specified an element type.  Instead, we&#8217;re using C++17&#8217;s CTAD (class template argument deduction) to have the compiler deduce the element type from the initializers.  Because we&#8217;ve supplied 5 initialization values, <code>vowels<\/code> will contain 5 elements whose values are <code>'a'<\/code>, <code>'e'<\/code>, <code>'i'<\/code>, <code>'o'<\/code>, and <code>'u'<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">List constructors and initializer lists<\/p>\n<p>Let&#8217;s talk about how the above works in a little more detail.<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/struct-aggregate-initialization\/\">13.8 -- Struct aggregate initialization<\/a>, we defined an initializer list as a braced list of comma-separated values (e.g. <code>{ 1, 2, 3 }<\/code>).<\/p>\n<p>Containers typically have a special constructor called a <strong>list constructor<\/strong> that allows us to construct an instance of the container using an initializer list.  The list constructor does three things:<\/p>\n<ul>\n<li>Ensures the container has enough storage to hold all the initialization values (if needed).\n<\/li>\n<li>Sets the length of the container to the number of elements in the initializer list (if needed).\n<\/li>\n<li>Initializes the elements to the values in the initializer list (in sequential order).\n<\/li>\n<\/ul>\n<p>Thus, when we provide a container with an initializer list of values, the list constructor is called, and the container is constructed using that list of values!<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Use list initialization with an initializer list of values to construct a container with those element values.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We discuss adding list constructors to your own program-defined classes in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdinitializer_list\/\">23.7 -- std::initializer_list<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Accessing array elements using the subscript operator (operator[])<\/p>\n<p>So now that we&#8217;ve created an array of elements&#8230; how do we access them?<\/p>\n<p>Let&#8217;s use an analogy for a moment.  Consider a set of identical mailboxes, side by side.  To make it easier to identify the mailboxes, each mailbox has a number painted on the front.  The first mailbox has number 0, the second has number 1, etc&#8230;  So if you were told to put something in mailbox number 0, you&#8217;d know that meant the first mailbox.<\/p>\n<p>In C++, the most common way to access array elements is by using the name of the array along with the subscript operator (<code>operator[]<\/code>).  To select a specific element, inside the square brackets of the subscript operator, we provide an integral value that identifies which element we want to select.  This integral value is called a <strong>subscript<\/strong> (or informally, an <strong>index<\/strong>).  Much like our mailboxes, the first element is accessed using index 0, the second is accessed using index 1, etc&#8230;<\/p>\n<p>For example, <code>primes[0]<\/code> will return the element with index <code>0<\/code> (the first element) from the <code>prime<\/code> array.  The subscript operator returns a reference to the actual element, not a copy.  Once we&#8217;ve accessed an array element, we can use it just like a normal object (e.g. assign a value to it, output it, etc&#8230;)<\/p>\n<p>Because the indexing starts with 0 rather than 1, we say arrays in C++ are <strong>zero-based<\/strong>.  This can be confusing because we&#8217;re used to counting objects starting from 1.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Indexes are actually a distance (offset) from the first element of the array.<\/p>\n<p>If you start at the first element of the array and travel 0 elements, you&#8217;re still on the first element.   Thus index 0 is the first element.<\/p>\n<p>If you start at the first element of the array and travel 1 element, you&#8217;re now on the second element.  Thus index 1 is the second element.<\/p>\n<p>We discuss how indexes are relative distances (not absolute positions) in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pointer-arithmetic-and-subscripting\/\">17.9 -- Pointer arithmetic and subscripting<\/a>\n<\/p><\/div>\n<p>This also can cause some linguistic ambiguity, because when we talk about array element 1, it may not be clear whether we&#8217;re talking about the first array element (with index 0) or the second array element (with index 1).  Generally, we&#8217;ll talk about array elements in terms of position rather than index (so the &#8220;first element&#8221; is the one with index 0).<\/p>\n<p>Here&#8217;s an example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::vector primes { 2, 3, 5, 7, 11 }; \/\/ hold the first 5 prime numbers (as int)\r\n\r\n    std::cout &lt;&lt; \"The first prime number is: \" &lt;&lt; primes[0] &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"The second prime number is: \" &lt;&lt; primes[1] &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"The sum of the first 5 primes is: \" &lt;&lt; primes[0] + primes[1] + primes[2] + primes[3] + primes[4] &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nThe first prime number is: 2\r\nThe second prime number is: 3\r\nThe sum of the first 5 primes is: 28\r\n<\/pre>\n<p>By using arrays, we no longer have to define 5 differently-named variables to hold our 5 prime values.  Instead, we can define a single array (<code>primes<\/code>) with 5 elements, and just change the value of the index to access different elements!<\/p>\n<p>We&#8217;ll talk more about <code>operator[]<\/code> and some other methods for accessing array elements in the next lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdvector-and-the-unsigned-length-and-subscript-problem\/\">16.3 -- std::vector and the unsigned length and subscript problem<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Subscript out of bounds<\/p>\n<p>When indexing an array, the index provided must select a valid element of the array.  That is, for an array of length N, the subscript must be a value between 0 and N-1 (inclusive).<\/p>\n<p><code>operator[]<\/code> does not do any kind of <strong>bounds checking<\/strong>, meaning it does not check to see whether the index is within the bounds of 0 to N-1 (inclusive).  Passing an invalid index to <code>operator[]<\/code> will return in undefined behavior.<\/p>\n<p>It is fairly easy to remember not to use negative subscripts.  It is less easy to remember that there is no element with index N!  The last element of the array has index N-1, so using index N will cause the compiler to try to access an element that is one-past the end of the array.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>In an array with N elements, the first element has index 0, the second has index 1, and the last element has index N-1.  There is no element with index N!<\/p>\n<p>Using N as a subscript will cause undefined behavior (as this is actually attempting to access the N+1th element, which isn&#8217;t part of the array).\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>Some compilers (like Visual Studio) provide a runtime assert that the index is valid.  In such cases, if an invalid index is provided in debug mode, the program will assert out.  In release mode, the assert is compiled out so there is no performance penalty.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Arrays are contiguous in memory<\/p>\n<p>One of the defining characteristics of arrays is that the elements are always allocated contiguously in memory, meaning the elements are all adjacent in memory (with no gaps between them).<\/p>\n<p>As an illustration of this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::vector primes { 2, 3, 5, 7, 11 }; \/\/ hold the first 5 prime numbers (as int)\r\n\r\n    std::cout &lt;&lt; \"An int is \" &lt;&lt; sizeof(int) &lt;&lt; \" bytes\\n\";\r\n    std::cout &lt;&lt; &amp;(primes[0]) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; &amp;(primes[1]) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; &amp;(primes[2]) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>On the author&#8217;s machine, one run of the above program produced the following result:<\/p>\n<pre>\nAn int is 4 bytes\r\n00DBF720\r\n00DBF724\r\n00DBF728\r\n<\/pre>\n<p>You&#8217;ll note that the memory addresses for these int elements are 4 bytes apart, the same as the size of an <code>int<\/code> on the author&#8217;s machine.<\/p>\n<p>This means arrays do not have any per-element overhead.  It also allows the compiler to quickly calculate the address of any element in the array.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We&#8217;ll talk about the math behind subscripting in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pointer-arithmetic-and-subscripting\/\">17.9 -- Pointer arithmetic and subscripting<\/a>.\n<\/p><\/div>\n<p>Arrays are one of the few container types that allow for <strong>random access<\/strong>, meaning any element in the container can be accessed directly (as opposed to sequential access, where elements must be accessed in a particular order).  Random access to array elements is typically efficient, and makes arrays very easy to use.  This is a primary reason why arrays are often preferred over other containers.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constructing a <code>std::vector<\/code> of a specific length<\/p>\n<p>Consider the case where we want the user to input 10 values that we&#8217;ll store in a <code>std::vector<\/code>.  In this case, we need a <code>std::vector<\/code> of length 10 before we have any values to put in the <code>std::vector<\/code>.  How do we address this?<\/p>\n<p>We could create a <code>std::vector<\/code> and initialize it with an initializer list with 10 placeholder values:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\tstd::vector&lt;int&gt; data { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; \/\/ vector containing 10 int values<\/code><\/pre>\n<p>But that&#8217;s bad for a lot of reasons.  It requires a lot of typing.  It&#8217;s not easy to see how many initializers there are.  And it&#8217;s not easy to update if we decide we want a different number of values later.<\/p>\n<p>Fortunately, <code>std::vector<\/code> has an explicit constructor (<code>explicit std::vector&lt;T&gt;(std::size_t)<\/code>) that takes a single <code>std::size_t<\/code> value defining the length of the <code>std::vector<\/code> to construct:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\tstd::vector&lt;int&gt; data( 10 ); \/\/ vector containing 10 int elements, value-initialized to 0<\/code><\/pre>\n<p>Each of the created elements are value-initialized, which for <code>int<\/code> does zero-initialization (and for class types calls the default constructor).<\/p>\n<p>However, there is one non-obvious thing about using this constructor: it must be called using direct initialization.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Non-empty initializer lists prefer list constructors<\/p>\n<p>To understand why the previous constructor must be called using direct initialization, consider this definition:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\tstd::vector&lt;int&gt; data{ 10 }; \/\/ what does this do?<\/code><\/pre>\n<p>There are two different constructors that match this initialization:<\/p>\n<ul>\n<li><code>{ 10 }<\/code> can be interpreted as an initializer list, and matched with the list constructor to construct a vector of length 1 with value 10.\n<\/li>\n<li><code>{ 10 }<\/code> can be interpreted as a single braced initialization value, and matched with the <code>std::vector&lt;T&gt;(std::size_t)<\/code> constructor to construct a vector of length 10 with elements value-initialized to 0.\n<\/li>\n<\/ul>\n<p>Normally when a class type definition matches more than one constructor, the match is considered ambiguous and a compilation error results.  However, C++ has a special rule for this case: When an initializer list is non-empty, a matching list constructor will be selected over other matching constructors.  Without this rule, a list constructor would result in an ambiguous match with any constructor that took arguments of a single type.<\/p>\n<p>Since <code>{ 10 }<\/code> can be interpreted as an initializer list and <code>std::vector<\/code> has a list constructor, the list constructor takes precedence in this case.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>When constructing a class type object using a initializer list:<\/p>\n<ul>\n<li>If the initializer list is empty, the default constructor is preferred over the list constructor.\n<\/li>\n<li>If the initializer list is non-empty, a matching list constructor is preferred over other matching constructors.\n<\/li>\n<\/ul>\n<\/div>\n<p>To help clarify what happens in various initialization cases further, let&#8217;s look at similar cases using copy, direct, and list initialization:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\t\/\/ Copy init\r\n\tstd::vector&lt;int&gt; v1 = 10;     \/\/ 10 not an initializer list, copy init won't match explicit constructor: compilation error\r\n\r\n\t\/\/ Direct init\r\n\tstd::vector&lt;int&gt; v2(10);      \/\/ 10 not an initializer list, matches explicit single-argument constructor\r\n\r\n\t\/\/ List init\r\n\tstd::vector&lt;int&gt; v3{ 10 };    \/\/ { 10 } interpreted as initializer list, matches list constructor\r\n\r\n\t\/\/ Copy list init\r\n\tstd::vector&lt;int&gt; v4 = { 10 }; \/\/ { 10 } interpreted as initializer list, matches list constructor\r\n\tstd::vector&lt;int&gt; v5({ 10 });  \/\/ { 10 } interpreted as initializer list, matches list constructor\r\n\r\n        \/\/ Default init\r\n        std::vector&lt;int&gt; v6 {};       \/\/ {} is empty initializer list, matches default constructor\r\n        std::vector&lt;int&gt; v7 = {};     \/\/ {} is empty initializer list, matches default constructor<\/code><\/pre>\n<p>In case <code>v1<\/code>, the initialization value of <code>10<\/code> is not an initializer list, so the list constructor isn&#8217;t a match.  The single-argument constructor <code>explicit std::vector&lt;T&gt;(std::size_t)<\/code> won&#8217;t match either because copy initialization won&#8217;t match explicit constructors.  Since no constructors match, this is a compilation error.<\/p>\n<p>In case <code>v2<\/code>, the initialization value of <code>10<\/code> is not an initializer list, so the list constructor isn&#8217;t a match.  The single-argument constructor <code>explicit std::vector&lt;T&gt;(std::size_t)<\/code> is a match, so the single-argument constructor is selected.<\/p>\n<p>In case <code>v3<\/code> (list initialization), <code>{ 10 }<\/code> can be matched with the list constructor or <code>explicit std::vector&lt;T&gt;(std::size_t)<\/code>.  The list constructor takes precedence over other matching constructors and is selected.<\/p>\n<p>In case <code>v4<\/code> (copy list initialization), <code>{ 10 }<\/code> can be matched with the list constructor (which is a non-explicit constructor, so can be used with copy initialization).  The list constructor is selected.<\/p>\n<p>Case <code>v5<\/code> surprisingly is an alternate syntax for copy list initialization (not direct initialization), and is the same as <code>v4<\/code>.<\/p>\n<p>This is one of the warts of C++ initialization: <code>{ 10 }<\/code> will match a list constructor if one exists, or a single-argument constructor if a list constructor doesn&#8217;t exist.  This means which behavior you get depends on whether a list constructor exists!  You can generally assume containers have list constructors.<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>If a class does not have a list constructor but then one is added later, this will change which constructor is called for all objects initialized using a non-empty initializer list.\n<\/p><\/div>\n<p><code>v6<\/code> and <code>v7<\/code> are both initialized using empty initializer lists.  In this case, the default constructor takes precedence.<\/p>\n<p>To summarize, list initializers are generally designed to allow us to initialize a container with a list of element values, and should be used for that purpose.  That is what we want the majority of the time anyway.  Therefore, <code>{ 10 }<\/code> is appropriate if <code>10<\/code> is meant to be an element value.  If <code>10<\/code> is meant to be an argument to a non-list constructor of a container, use direct initialization.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>When constructing a container (or any type that has a list constructor) with initializers that are not element values, use direct initialization.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>When a <code>std::vector<\/code> is a member of a class type, it is not obvious how to provide a default initializer that sets the length of a <code>std::vector<\/code> to some initial value:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;vector&gt;\r\n\r\nstruct Foo\r\n{\r\n    std::vector&lt;int&gt; v1(8); \/\/ compile error: direct initialization not allowed for member default initializers\r\n};<\/code><\/pre>\n<p>This doesn&#8217;t work because direct (parenthesis) initialization is disallowed for member default initializers.<\/p>\n<p>When providing a default initializer for a member of a class type:<\/p>\n<ul>\n<li>We must use either copy initialization or list initialization (direct or copy).\n<\/li>\n<li>CTAD is not allowed (so we must explicitly specify the element type).\n<\/li>\n<\/ul>\n<p>The answer is as follows:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">struct Foo\r\n{\r\n    std::vector&lt;int&gt; v{ std::vector&lt;int&gt;(8) }; \/\/ ok \r\n};<\/code><\/pre>\n<p>This creates a <code>std::vector<\/code> with a capacity of 8, and then uses that as the initializer for <code>v<\/code>.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Const and constexpr <code>std::vector<\/code><\/p>\n<p>Objects of type <code>std::vector<\/code> can be made <code>const<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    const std::vector&lt;int&gt; prime { 2, 3, 5, 7, 11 }; \/\/ prime and its elements cannot be modified\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>A <code>const std::vector<\/code> must be initialized, and then cannot be modified.  The elements of such a vector are treated as if they were const.<\/p>\n<p>The element type of a <code>std::vector<\/code> must not be defined as const (e.g. <code>std::vector&lt;const int&gt;<\/code> is disallowed).<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Per <a href=\"https:\/\/stackoverflow.com\/questions\/6954906\/does-c11-allow-vectorconst-t#comment8294604_6955332\">Howard Hinnant&#8217;s comment here<\/a>, the standard library containers were not designed to have const elements.<\/p>\n<p>A containers const-ness comes from const-ing the container itself, not the elements.\n<\/p><\/div>\n<p>One of the biggest downsides of <code>std::vector<\/code> is that it cannot be made <code>constexpr<\/code>.  If you need a <code>constexpr<\/code> array, use <code>std::array<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover <code>std::array<\/code> in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdarray\/\">17.1 -- Introduction to std::array<\/a>.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Why is it called a vector?<\/p>\n<p>When people use the term &#8220;vector&#8221; in conversation, they typically mean a geometric vector, which is an object with a magnitude and direction.  So how did <code>std::vector<\/code> get its name when it&#8217;s not a geometric vector?<\/p>\n<p>In the book &#8220;From Mathematics to Generic Programming&#8221;, Alexander Stepanov wrote, &#8220;The name vector in STL was taken from the earlier programming languages Scheme and Common Lisp.  Unfortunately, this was inconsistent with the much older meaning of the term in mathematics&#8230; this data structure should have been called array.  Sadly, if you make a mistake and violate these principles, the result might stay around for a long time.&#8221;<\/p>\n<p>So, basically, <code>std::vector<\/code> is misnamed, but it&#8217;s too late to change it now.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Define a <code>std::vector<\/code> using CTAD and initialize it with the first 5 positive square numbers (1, 4, 9, 16, and 25).<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::vector squares{ 1, 4, 9, 16, 25 };<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>What&#8217;s the behavioral difference between these two definitions?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::vector&lt;int&gt; v1 { 5 };\r\nstd::vector&lt;int&gt; v2 ( 5 );<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p><code>v1<\/code> invokes the list constructor to define a 1 element vector containing value <code>5<\/code>.<br \/>\n<code>v2<\/code> invokes a non-list constructor that defines a 5 element vector whose elements are value-initialized.\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #3<\/p>\n<p>Define a <code>std::vector<\/code> (using an explicit template type argument) to hold the high temperature (to the nearest tenth of a degree) for each day of a year (assume 365 days in a year).<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::vector&lt;double&gt; temperature (365); \/\/ create a vector to hold 365 double values<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #4<\/p>\n<p>Using a <code>std::vector<\/code>, write a program that asks the user to enter 3 integral values.  Print the sum and product of those values.<\/p>\n<p>The output should match the following:<\/p>\n<pre>\nEnter 3 integers: 3 4 5\r\nThe sum is: 12\r\nThe product is: 60\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n\tstd::vector&lt;int&gt; arr(3); \/\/ create a vector of length 3\r\n\t\r\n\tstd::cout &lt;&lt; \"Enter 3 integers: \";\r\n\tstd::cin &gt;&gt; arr[0] &gt;&gt; arr[1] &gt;&gt; arr[2];\r\n\r\n\tstd::cout &lt;&lt; \"The sum is: \" &lt;&lt; arr[0] + arr[1] + arr[2] &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; \"The product is: \" &lt;&lt; arr[0] * arr[1] * arr[2] &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdvector-and-the-unsigned-length-and-subscript-problem\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">16.3<\/span>std::vector and the unsigned length and subscript problem\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-containers-and-arrays\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">16.1<\/span>Introduction to containers and arrays\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the previous lesson , we introduced both containers and arrays. In this lesson, we&#8217;ll introduce the array type that we&#8217;ll be focused on for the rest of the chapter: std::vector. We&#8217;ll also solve one part of the scalability challenge we introduced last lesson. Introduction to std::vector std::vector is one &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/2673"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=2673"}],"version-history":[{"count":59,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/2673\/revisions"}],"predecessor-version":[{"id":18018,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/2673\/revisions\/18018"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=2673"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=2673"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=2673"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}