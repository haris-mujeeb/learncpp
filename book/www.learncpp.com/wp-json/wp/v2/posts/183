{"id":183,"date":"2008-02-08T15:29:37","date_gmt":"2008-02-08T23:29:37","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/125-the-virtual-table\/"},"modified":"2024-12-07T03:18:51","modified_gmt":"2024-12-07T11:18:51","slug":"the-virtual-table","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/the-virtual-table\/","title":{"rendered":"25.6 &#8212; The virtual table"},"content":{"rendered":"<p>Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n    std::string_view getName() const { return \"Base\"; }                \/\/ not virtual\r\n    virtual std::string_view getNameVirtual() const { return \"Base\"; } \/\/ virtual\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\npublic:\r\n    std::string_view getName() const { return \"Derived\"; }\r\n    virtual std::string_view getNameVirtual() const override { return \"Derived\"; }\r\n};\r\n\r\nint main()\r\n{\r\n    Derived derived {};\r\n    Base&amp; base { derived };\r\n\r\n    std::cout &lt;&lt; \"base has static type \" &lt;&lt; base.getName() &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"base has dynamic type \" &lt;&lt; base.getNameVirtual() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>First, let&#8217;s look at the call to <code>base.getName()<\/code>.  Because this is a non-virtual function, the compiler can use the actual type of <code>base<\/code> (<code>Base<\/code>) to determine (at compile-time) that this should resolve to <code>Base::getName()<\/code>.<\/p>\n<p>Although it looks almost identical, the call to <code>base.getNameVirtual()<\/code> must be resolved differently.  Because this is a virtual function call, the compiler must use the dynamic type of <code>base<\/code> to resolve the call, and the dynamic type of <code>base<\/code> is not knowable until runtime.  Therefore, only at runtime will it be determined that this particular call to <code>base.getNameVirtual()<\/code> resolves to <code>Derived::getNameVirtual()<\/code>, not <code>Base::getNameVirtual()<\/code>.<\/p>\n<p>So how do virtual functions actually work?<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The virtual table<\/p>\n<p>The C++ standard does not specify how virtual functions should be implemented (this detail is left up to the implementation).<\/p>\n<p>However, C++ implementations typically implement virtual functions using a form of late binding known as the virtual table.<\/p>\n<p>The <strong>virtual table<\/strong> is a lookup table of functions used to resolve function calls in a dynamic\/late binding manner.  The virtual table sometimes goes by other names, such as &#8220;vtable&#8221;, &#8220;virtual function table&#8221;, &#8220;virtual method table&#8221;, or &#8220;dispatch table&#8221;.  In C++, virtual function resolution is sometimes called <strong>dynamic dispatch<\/strong>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Nomenclature<\/p>\n<p>Here&#8217;s an easier way of thinking about it in C++:<br \/>\nEarly binding\/static dispatch = direct function call overload resolution<br \/>\nLate binding = indirect function call resolution<br \/>\nDynamic dispatch = virtual function override resolution\n<\/p><\/div>\n<p>Because knowing how the virtual table works is not necessary to use virtual functions, this section can be considered optional reading.<\/p>\n<p>The virtual table is actually quite simple, though it&#8217;s a little complex to describe in words.  First, every class that uses virtual functions (or is derived from a class that uses virtual functions) has a corresponding virtual table.  This table is simply a static array that the compiler sets up at compile time.  A virtual table contains one entry for each virtual function that can be called by objects of the class.  Each entry in this table is simply a function pointer that points to the most-derived function accessible by that class.<\/p>\n<p>Second, the compiler also adds a hidden pointer that is a member of the base class, which we will call <code>*__vptr<\/code>.  <code>*__vptr<\/code> is set (automatically) when a class object is created so that it points to the virtual table for that class.  Unlike the <code>this<\/code> pointer, which is actually a function parameter used by the compiler to resolve self-references, <code>*__vptr<\/code> is a real pointer member.  Consequently, it makes each class object allocated bigger by the size of one pointer.  It also means that <code>*__vptr<\/code> is inherited by derived classes, which is important.<\/p>\n<p>By now, you&#8217;re probably confused as to how these things all fit together, so let&#8217;s take a look at a simple example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Base\r\n{\r\npublic:\r\n    virtual void function1() {};\r\n    virtual void function2() {};\r\n};\r\n\r\nclass D1: public Base\r\n{\r\npublic:\r\n    void function1() override {};\r\n};\r\n\r\nclass D2: public Base\r\n{\r\npublic:\r\n    void function2() override {};\r\n};<\/code><\/pre>\n<p>Because there are 3 classes here, the compiler will set up 3 virtual tables: one for Base, one for D1, and one for D2.<\/p>\n<p>The compiler also adds a hidden pointer member to the most base class that uses virtual functions.  Although the compiler does this automatically, we&#8217;ll put it in the next example just to show where it&#8217;s added:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Base\r\n{\r\npublic:\r\n    VirtualTable* __vptr;\r\n    virtual void function1() {};\r\n    virtual void function2() {};\r\n};\r\n\r\nclass D1: public Base\r\n{\r\npublic:\r\n    void function1() override {};\r\n};\r\n\r\nclass D2: public Base\r\n{\r\npublic:\r\n    void function2() override {};\r\n};<\/code><\/pre>\n<p>When a class object is created, <code>*__vptr<\/code> is set to point to the virtual table for that class.  For example, when an object of type Base is created, <code>*__vptr<\/code> is set to point to the virtual table for Base.  When objects of type D1 or D2 are constructed, <code>*__vptr<\/code> is set to point to the virtual table for D1 or D2 respectively.<\/p>\n<p>Now, let&#8217;s talk about how these virtual tables are filled out.  Because there are only two virtual functions here, each virtual table will have two entries (one for function1() and one for function2()).  Remember that when these virtual tables are filled out, each entry is filled out with the most-derived function an object of that class type can call.<\/p>\n<p>The virtual table for Base objects is simple.  An object of type Base can only access the members of Base.  Base has no access to D1 or D2 functions.  Consequently, the entry for function1 points to Base::function1() and the entry for function2 points to Base::function2().<\/p>\n<p>The virtual table for D1 is slightly more complex.  An object of type D1 can access members of both D1 and Base.  However, D1 has overridden function1(), making D1::function1() more derived than Base::function1().  Consequently, the entry for function1 points to D1::function1().  D1 hasn&#8217;t overridden function2(), so the entry for function2 will point to Base::function2().<\/p>\n<p>The virtual table for D2 is similar to D1, except the entry for function1 points to Base::function1(), and the entry for function2 points to D2::function2().<\/p>\n<p>Here&#8217;s a picture of this graphically:<\/p>\n<p><img src=\"http:\/\/www.learncpp.com\/images\/CppTutorial\/Section12\/VTable.gif\"><\/p>\n<p>Although this diagram is kind of crazy looking, it&#8217;s really quite simple: the <code>*__vptr<\/code> in each class points to the virtual table for that class.  The entries in the virtual table point to the most-derived version of the function that objects of that class are allowed to call.<\/p>\n<p>So consider what happens when we create an object of type D1:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    D1 d1 {};\r\n}<\/code><\/pre>\n<p>Because d1 is a D1 object, d1 has its *__vptr set to the D1 virtual table.<\/p>\n<p>Now, let&#8217;s set a base pointer to D1:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    D1 d1 {};\r\n    Base* dPtr = &amp;d1;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Note that because dPtr is a base pointer, it only points to the Base portion of d1.  However, also note that <code>*__vptr<\/code> is in the Base portion of the class, so dPtr has access to this pointer.  Finally, note that <code>dPtr-&gt;__vptr<\/code> points to the D1 virtual table!  Consequently, even though dPtr is of type <code>Base*<\/code>, it still has access to D1&#8217;s virtual table (through <code>__vptr<\/code>).<\/p>\n<p>So what happens when we try to call dPtr->function1()?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    D1 d1 {};\r\n    Base* dPtr = &amp;d1;\r\n    dPtr-&gt;function1();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>First, the program recognizes that function1() is a virtual function.  Second, the program uses <code>dPtr-&gt;__vptr<\/code> to get to D1&#8217;s virtual table.  Third, it looks up which version of function1() to call in D1&#8217;s virtual table.  This has been set to D1::function1().  Therefore, <code>dPtr-&gt;function1()<\/code> resolves to D1::function1()!<\/p>\n<p>Now, you might be saying, &#8220;But what if dPtr really pointed to a Base object instead of a D1 object.  Would it still call D1::function1()?&#8221;.  The answer is no.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    Base b {};\r\n    Base* bPtr = &amp;b;\r\n    bPtr-&gt;function1();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this case, when b is created, b.__vptr points to Base&#8217;s virtual table, not D1&#8217;s virtual table.  Since bPtr is pointing to b, <code>bPtr-&gt;__vptr<\/code> points to Base&#8217;s virtual table as well.  Base&#8217;s virtual table entry for function1() points to Base::function1().  Thus, <code>bPtr-&gt;function1()<\/code> resolves to Base::function1(), which is the most-derived version of function1() that a Base object should be able to call.<\/p>\n<p>By using these tables, the compiler and program are able to ensure function calls resolve to the appropriate virtual function, even if you&#8217;re only using a pointer or reference to a base class!<\/p>\n<p>Calling a virtual function is slower than calling a non-virtual function for a couple of reasons: First, we have to use the <code>*__vptr<\/code> to get to the appropriate virtual table.  Second, we have to index the virtual table to find the correct function to call.  Only then can we call the function.  As a result, we have to do 3 operations to find the function to call, as opposed to 2 operations for a normal indirect function call, or one operation for a direct function call.  However, with modern computers, this added time is usually fairly insignificant.<\/p>\n<p>Also as a reminder, any class that uses virtual functions has a <code>*__vptr<\/code>, and thus each object of that class will be bigger by one pointer.  Virtual functions are powerful, but they do have a performance cost.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pure-virtual-functions-abstract-base-classes-and-interface-classes\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">25.7<\/span>Pure virtual functions, abstract base classes, and interface classes\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/early-binding-and-late-binding\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">25.5<\/span>Early binding and late binding\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Consider the following program: #include &lt;iostream&gt; #include &lt;string_view&gt; class Base { public: std::string_view getName() const { return &#8220;Base&#8221;; } \/\/ not virtual virtual std::string_view getNameVirtual() const { return &#8220;Base&#8221;; } \/\/ virtual }; class Derived: public Base { public: std::string_view getName() const { return &#8220;Derived&#8221;; } virtual std::string_view getNameVirtual() const &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/183"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=183"}],"version-history":[{"count":27,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/183\/revisions"}],"predecessor-version":[{"id":5029,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/183\/revisions\/5029"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=183"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=183"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=183"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}