{"id":16842,"date":"2024-03-25T14:51:17","date_gmt":"2024-03-25T21:51:17","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=16842"},"modified":"2024-10-28T14:09:20","modified_gmt":"2024-10-28T21:09:20","slug":"introduction-to-overloading-the-i-o-operators","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-overloading-the-i-o-operators\/","title":{"rendered":"13.5 &#8212; Introduction to overloading the I\/O operators"},"content":{"rendered":"<p>In the prior lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/converting-an-enumeration-to-and-from-a-string\/\">13.4 -- Converting an enumeration to and from a string<\/a>), we showed this example, where we used a function to convert an enumeration into an equivalent string:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nenum Color\r\n{\r\n    black,\r\n    red,\r\n    blue,\r\n};\r\n\r\nconstexpr std::string_view getColorName(Color color)\r\n{\r\n    switch (color)\r\n    {\r\n    case black: return \"black\";\r\n    case red:   return \"red\";\r\n    case blue:  return \"blue\";\r\n    default:    return \"???\";\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    constexpr Color shirt{ blue };\r\n\r\n    std::cout &lt;&lt; \"Your shirt is \" &lt;&lt; getColorName(shirt) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Although the above example works just fine, there are two downsides:<\/p>\n<ol start=\"1\">\n<li>We have to remember the name of the function we created to get the enumerator name.\n<\/li>\n<li>Having to call such a function adds clutter to our output statement.\n<\/li>\n<\/ol>\n<p>Ideally, it would be nice if we could somehow teach <code>operator&lt;&lt;<\/code> to output an enumeration, so we could do something like this: <code>std::cout &lt;&lt; shirt<\/code> and have it do what we expect.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Introduction to operator overloading<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-function-overloading\/\">11.1 -- Introduction to function overloading<\/a>, we introduced function overloading, which allows us to create multiple functions with the same name so long as each function has a unique function prototype.  Using function overloading, we can create variations of a function that work with different data types, without having to think up a unique name for each variant.<\/p>\n<p>Similarly, C++ also supports <strong>operator overloading<\/strong>, which lets us define overloads of existing operators, so that we can make those operators work with our program-defined data types.<\/p>\n<p>Basic operator overloading is fairly straightforward:<\/p>\n<ul>\n<li>Define a function using the name of the operator as the function&#8217;s name.\n<\/li>\n<li>Add a parameter of the appropriate type for each operand (in left-to-right order).  One of these parameters must be a user-defined type (a class type or an enumerated type), otherwise the compiler will error.\n<\/li>\n<li>Set the return type to whatever type makes sense.\n<\/li>\n<li>Use a return statement to return the result of the operation.\n<\/li>\n<\/ul>\n<p>When the compiler encounters the use of an operator in an expression and one or more of the operands is a user-defined type, the compiler will check to see if there is an overloaded operator function that it can use to resolve that call.  For example, given some expression <code>x + y<\/code>, the compiler will use function overload resolution to see if there is an <code>operator+(x, y)<\/code> function call that it can use to evaluate the operation.  If a non-ambiguous <code>operator+<\/code> function can be found, it will be called, and the result of the operation returned as the return value.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover operator overloading in much more detail in chapter <a href=\"https:\/\/www.learncpp.com#Chapter21\">chapter 21<\/a>.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Operators can also be overloaded as member functions of the left-most operand.  We discuss this in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-operators-using-member-functions\/\">21.5 -- Overloading operators using member functions<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><a name=\"insertion\"><\/a>Overloading <code>operator&lt;&lt;<\/code> to print an enumerator <a href=\"#insertion\"><i class=\"fa fa-link\" style=\"font-size: 0.8em;\"><\/i><\/a><\/p>\n<p>Before we proceed, let&#8217;s quickly recap how <code>operator&lt;&lt;<\/code> works when used for output.<\/p>\n<p>Consider a simple expression like <code>std::cout &lt;&lt; 5<\/code>.  <code>std::cout<\/code> has type <code>std::ostream<\/code> (which is a user-defined type in the standard library), and <code>5<\/code> is a literal of type <code>int<\/code>.<\/p>\n<p>When this expression is evaluated, the compiler will look for an overloaded <code>operator&lt;&lt;<\/code> function that can handle arguments of type <code>std::ostream<\/code> and <code>int<\/code>.  It will find such a function (also defined as part of the standard I\/O library) and call it.  Inside that function, <code>std::cout<\/code> is used to output <code>x<\/code> to the console (exactly how is implementation-defined).  Finally, the <code>operator&lt;&lt;<\/code> function returns its left-operand (which in this case is <code>std::cout<\/code>), so that subsequent calls to <code>operator&lt;&lt;<\/code> can be chained.<\/p>\n<p>With the above in mind, let&#8217;s implement an overload of <code>operator&lt;&lt;<\/code> to print a <code>Color<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nenum Color\r\n{\r\n\tblack,\r\n\tred,\r\n\tblue,\r\n};\r\n\r\nconstexpr std::string_view getColorName(Color color)\r\n{\r\n    switch (color)\r\n    {\r\n    case black: return \"black\";\r\n    case red:   return \"red\";\r\n    case blue:  return \"blue\";\r\n    default:    return \"???\";\r\n    }\r\n}\r\n\r\n\/\/ Teach operator&lt;&lt; how to print a Color\r\n\/\/ std::ostream is the type of std::cout, std::cerr, etc...\r\n\/\/ The return type and parameter type are references (to prevent copies from being made)\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, Color color)\r\n{\r\n    out &lt;&lt; getColorName(color); \/\/ print our color's name to whatever output stream out \r\n    return out;                 \/\/ operator&lt;&lt; conventionally returns its left operand\r\n\r\n    \/\/ The above can be condensed to the following single line:\r\n    \/\/ return out &lt;&lt; getColorName(color)\r\n}\r\n\r\nint main()\r\n{\r\n\tColor shirt{ blue };\r\n\tstd::cout &lt;&lt; \"Your shirt is \" &lt;&lt; shirt &lt;&lt; '\\n'; \/\/ it works!\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nYour shirt is blue\r\n<\/pre>\n<p>Let&#8217;s unpack our overloaded operator function a bit.  First, the name of the function is <code>operator&lt;&lt;<\/code>, since that is the name of the operator we&#8217;re overloading.  <code>operator&lt;&lt;<\/code> has two parameters. The left parameter (which will be matched with the left operand) is our output stream, which has type <code>std::ostream<\/code>.  We use pass by non-const reference here because we don&#8217;t want to make a copy of a <code>std::ostream<\/code> object when the function is called, but the <code>std::ostream<\/code> object needs to be modified in order to do output.  The right parameter (which will be matched with the right operand) is our <code>Color<\/code> object.  Since <code>operator&lt;&lt;<\/code> conventionally returns its left operand, the return type matches the type of the left-operand, which is <code>std::ostream&amp;<\/code>.<\/p>\n<p>Now let&#8217;s look at the implementation.  A <code>std::ostream<\/code> object already knows how to print a <code>std::string_view<\/code> using <code>operator&lt;&lt;<\/code> (this comes as part of the standard library).  So <code>out &lt;&lt; getColorName(color)<\/code> simply fetches our color&#8217;s name as a <code>std::string_view<\/code> and then prints it to the output stream.<\/p>\n<p>Note that our implementation uses parameter <code>out<\/code> instead of <code>std::cout<\/code> because we want to allow the caller to determine which output stream they will output to (e.g. <code>std::cerr &lt;&lt; color<\/code> should output to <code>std::cerr<\/code>, not <code>std::cout<\/code>).<\/p>\n<p>Returning the left operand is also easy.  The left operand is parameter <code>out<\/code>, so we just return <code>out<\/code>.<\/p>\n<p>Putting it all together: when we call <code>std::cout &lt;&lt; shirt<\/code>, the compiler will see that we&#8217;ve overloaded <code>operator&lt;&lt;<\/code> to work with objects of type <code>Color<\/code>.  Our overloaded <code>operator&lt;&lt;<\/code> function is then called with <code>std::cout<\/code> as the <code>out<\/code> parameter, and our <code>shirt<\/code> variable (which has value <code>blue<\/code>) as parameter <code>color<\/code>.  Since <code>out<\/code> is a reference to <code>std::cout<\/code>, and <code>color<\/code> is a copy of enumerator <code>blue<\/code>, the expression <code>out &lt;&lt; getColorName(color)<\/code> prints <code>\"blue\"<\/code> to the console.  Finally <code>out<\/code> is returned back to the caller in case we want to chain additional output.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><a name=\"extraction\"><\/a>Overloading <code>operator&gt;&gt;<\/code> to input an enumerator <a href=\"#extraction\"><i class=\"fa fa-link\" style=\"font-size: 0.8em;\"><\/i><\/a><\/p>\n<p>Similar to how we were able to teach <code>operator&lt;&lt;<\/code> to output an enumeration above, we can also teach <code>operator&gt;&gt;<\/code> how to input an enumeration:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;limits&gt;\r\n#include &lt;optional&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nenum Pet\r\n{\r\n    cat,   \/\/ 0\r\n    dog,   \/\/ 1\r\n    pig,   \/\/ 2\r\n    whale, \/\/ 3\r\n};\r\n\r\nconstexpr std::string_view getPetName(Pet pet)\r\n{\r\n    switch (pet)\r\n    {\r\n    case cat:   return \"cat\";\r\n    case dog:   return \"dog\";\r\n    case pig:   return \"pig\";\r\n    case whale: return \"whale\";\r\n    default:    return \"???\";\r\n    }\r\n}\r\n\r\nconstexpr std::optional&lt;Pet&gt; getPetFromString(std::string_view sv)\r\n{\r\n    if (sv == \"cat\")   return cat;\r\n    if (sv == \"dog\")   return dog;\r\n    if (sv == \"pig\")   return pig;\r\n    if (sv == \"whale\") return whale;\r\n\r\n    return {};\r\n}\r\n\r\n\/\/ pet is an in\/out parameter\r\nstd::istream&amp; operator&gt;&gt;(std::istream&amp; in, Pet&amp; pet)\r\n{\r\n    std::string s{};\r\n    in &gt;&gt; s; \/\/ get input string from user\r\n\r\n    std::optional&lt;Pet&gt; match { getPetFromString(s) };\r\n    if (match) \/\/ if we found a match\r\n    {\r\n        pet = *match; \/\/ dereference std::optional to get matching enumerator\r\n        return in;\r\n    }\r\n\r\n    \/\/ We didn't find a match, so input must have been invalid\r\n    \/\/ so we will set input stream to fail state\r\n    in.setstate(std::ios_base::failbit);\r\n    \r\n    \/\/ On an extraction failure, operator&gt;&gt; zero-initializes fundamental types\r\n    \/\/ Uncomment the following line to make this operator do the same thing\r\n    \/\/ pet = {};\r\n\r\n    return in;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter a pet: cat, dog, pig, or whale: \";\r\n    Pet pet{};\r\n    std::cin &gt;&gt; pet;\r\n        \r\n    if (std::cin) \/\/ if we found a match\r\n        std::cout &lt;&lt; \"You chose: \" &lt;&lt; getPetName(pet) &lt;&lt; '\\n';\r\n    else\r\n    {\r\n        std::cin.clear(); \/\/ reset the input stream to good\r\n        std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\r\n        std::cout &lt;&lt; \"Your pet was not valid\\n\";\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>There are a few differences from the output case worth noting here.  First, <code>std::cin<\/code> has type <code>std::istream<\/code>, so we use <code>std::istream&amp;<\/code> as the type of our left parameter and return value instead of <code>std::ostream&amp;<\/code>.  Second, the <code>pet<\/code> parameter is a non-const reference.  This allows our <code>operator&gt;&gt;<\/code> to modify the value of the right operand that is passed in if our extraction results in a match.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Our right operand (<code>pet<\/code>) is an out parameter.  We cover out parameters in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/in-and-out-parameters\/\">12.13 -- In and out parameters<\/a>.<\/p>\n<p>If <code>pet<\/code> was a value parameter rather than a reference parameter, then our <code>operator&gt;&gt;<\/code> function would end up assigning a new value to a copy of the right operand rather than the actual right operand.  We want our right operand to be modified in this case.\n<\/div>\n<p>Inside the function, we use <code>operator&gt;&gt;<\/code> to input a <code>std::string<\/code> (something it already knows how to do).  If the value the user enters matches one of our pets, then we can assign <code>pet<\/code> the appropriate enumerator and return the left operand (<code>in<\/code>).<\/p>\n<p>If the user did not enter a valid pet, then we handle that case by putting <code>std::cin<\/code> into &#8220;failure mode&#8221;.  This is the state that <code>std::cin<\/code> typically goes into when an extraction fails.  The caller can then check <code>std::cin<\/code> to see if the extraction succeeded or failed.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdarray-and-enumerations\/\">17.6 -- std::array and enumerations<\/a>, we show how we can use <code>std::array<\/code> to make our input and output operators less redundant, and avoid having to modify them when a new enumerator is added.\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/scoped-enumerations-enum-classes\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.6<\/span>Scoped enumerations (enum classes)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/converting-an-enumeration-to-and-from-a-string\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.4<\/span>Converting an enumeration to and from a string\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the prior lesson (), we showed this example, where we used a function to convert an enumeration into an equivalent string: #include &lt;iostream&gt; #include &lt;string_view&gt; enum Color { black, red, blue, }; constexpr std::string_view getColorName(Color color) { switch (color) { case black: return &#8220;black&#8221;; case red: return &#8220;red&#8221;; case &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/16842"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=16842"}],"version-history":[{"count":10,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/16842\/revisions"}],"predecessor-version":[{"id":17808,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/16842\/revisions\/17808"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=16842"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=16842"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=16842"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}