{"id":14313,"date":"2023-05-05T18:10:14","date_gmt":"2023-05-06T01:10:14","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=14313"},"modified":"2024-02-16T09:39:22","modified_gmt":"2024-02-16T17:39:22","slug":"narrowing-conversions-list-initialization-and-constexpr-initializers","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/narrowing-conversions-list-initialization-and-constexpr-initializers\/","title":{"rendered":"10.4 &#8212; Narrowing conversions, list initialization, and constexpr initializers"},"content":{"rendered":"<p>In the previous lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/numeric-conversions\/\">10.3 -- Numeric conversions<\/a>), we covered numeric conversions, which cover a wide range of different type conversions between fundamental types.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Narrowing conversions<\/p>\n<p>In C++, a <strong>narrowing conversion<\/strong> is a potentially unsafe numeric conversion where the destination type may not be able to hold all the values of the source type.<\/p>\n<p>The following conversions are defined to be narrowing:<\/p>\n<ul>\n<li>From a floating point type to an integral type.\n<\/li>\n<li>From a floating point type to a narrower or lesser ranked floating point type, unless the value being converted is constexpr and is in range of the destination type (even if the destination type doesn&#8217;t have the precision to store all the significant digits of the number).\n<\/li>\n<li>From an integral to a floating point type, unless the value being converted is constexpr and whose value can be stored exactly in the destination type.\n<\/li>\n<li>From an integral type to another integral type that cannot represent all values of the original type, unless the value being converted is constexpr and whose value can be stored exactly in the destination type.  This covers both wider to narrower integral conversions, as well as integral sign conversions (signed to unsigned, or vice-versa).\n<\/li>\n<\/ul>\n<p>In most cases, implicit narrowing conversions will result in compiler warnings, with the exception of signed\/unsigned conversions (which may or may not produce warnings, depending on how your compiler is configured).<\/p>\n<p>Narrowing conversions should be avoided as much as possible, because they are potentially unsafe, and thus a source of potential errors.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Because they can be unsafe and are a source of errors, avoid narrowing conversions whenever possible.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Make intentional narrowing conversions explicit<\/p>\n<p>Narrowing conversions are not always avoidable -- this is particularly true for function calls, where the function parameter and argument may have mismatched types and require a narrowing conversion.<\/p>\n<p>In such cases, it is a good idea to convert an implicit narrowing conversion into an explicit narrowing conversion using <code>static_cast<\/code>.  Doing so helps document that the narrowing conversion is intentional, and will suppress any compiler warnings or errors that would otherwise result.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void someFcn(int i)\r\n{\r\n}\r\n\r\nint main()\r\n{\r\n    double d{ 5.0 };\r\n    \r\n    someFcn(d); \/\/ bad: implicit narrowing conversion will generate compiler warning\r\n\r\n    \/\/ good: we're explicitly telling the compiler this narrowing conversion is intentional\r\n    someFcn(static_cast&lt;int&gt;(d)); \/\/ no warning generated\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>If you need to perform a narrowing conversion, use <code>static_cast<\/code> to convert it into an explicit conversion.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Brace initialization disallows narrowing conversions<\/p>\n<p>Narrowing conversions are disallowed when using brace initialization (which is one of the primary reasons this initialization form is preferred), and attempting to do so will produce a compile error.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int i { 3.5 }; \/\/ won't compile\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Visual Studio produces the following error:<\/p>\n<pre>\nerror C2397: conversion from 'double' to 'int' requires a narrowing conversion\r\n<\/pre>\n<p>If you actually want to do a narrowing conversion inside a brace initialization, use <code>static_cast<\/code> to convert the narrowing conversion into an explicit conversion:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    double d { 3.5 };\r\n\r\n    \/\/ static_cast&lt;int&gt; converts double to int, initializes i with int result\r\n    int i { static_cast&lt;int&gt;(d) }; \r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Some constexpr conversions aren&#8217;t considered narrowing<\/p>\n<p>When the source value of a narrowing conversion isn&#8217;t known until runtime, the result of the conversion also can&#8217;t be determined until runtime.  In such cases, whether the narrowing conversion preserves the value or not also can&#8217;t be determined until runtime.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid print(unsigned int u) \/\/ note: unsigned\r\n{\r\n    std::cout &lt;&lt; u &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter an integral value: \";\r\n    int n{};\r\n    std::cin &gt;&gt; n; \/\/ enter 5 or -5\r\n    print(n);      \/\/ conversion to unsigned may or may not preserve value\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above program, the compiler has no idea what value will be entered for <code>n<\/code>.  When <code>print(n)<\/code> is called, the conversion from <code>int<\/code> to <code>unsigned int<\/code> will be performed at that time, and the results may be value-preserving or not depending on what value for <code>n<\/code> was entered.  Thus, a compiler that has signed\/unsigned warnings enabled will issue a warning for this case.<\/p>\n<p>However, you may have noticed that most of the narrowing conversions definitions have an exception clause that begins with &#8220;unless the value being converted is constexpr and &#8230;&#8221;.  For example, a conversion is narrowing when it is &#8220;From an integral type to another integral type that cannot represent all values of the original type, unless the value being converted is constexpr and whose value can be stored exactly in the destination type.&#8221;<\/p>\n<p>When the source value of a narrowing conversion is constexpr, the specific value to be converted must be known to the compiler.  In such cases, the compiler can perform the conversion itself, and then check whether the value was preserved.  If the value was not preserved, the compiler can halt compilation with an error.  If the value is preserved, the conversion is not considered to be narrowing (and the compiler can replace the entire conversion with the converted result, knowing that doing so is safe).<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    constexpr int n1{ 5 };   \/\/ note: constexpr\r\n    unsigned int u1 { n1 };  \/\/ okay: conversion is not narrowing due to exclusion clause\r\n\r\n    constexpr int n2 { -5 }; \/\/ note: constexpr\r\n    unsigned int u2 { n2 };  \/\/ compile error: conversion is narrowing due to value change\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Let&#8217;s apply the rule &#8220;From an integral type to another integral type that cannot represent all values of the original type, unless the value being converted is constexpr and whose value can be stored exactly in the destination type&#8221; to both of the conversions above.<\/p>\n<p>In the case of <code>n1<\/code> and <code>u1<\/code>, <code>n1<\/code> is an <code>int<\/code> and <code>u1<\/code> is an <code>unsigned int<\/code>, so this is a conversion from an integral type to another integral type that cannot represent all values of the original type.  However, <code>n1<\/code> is constexpr, and its value <code>5<\/code> can be represented exactly in the destination type (as unsigned value <code>5<\/code>).  Therefore, this is not considered to be a narrowing conversion, and we are allowed to list initialize  <code>u1<\/code> using <code>n1<\/code>.<\/p>\n<p>In the case of <code>n2<\/code> and <code>u2<\/code>, things are similar.  Although <code>n2<\/code> is constexpr, its value <code>-5<\/code> cannot be represented exactly in the destination type, so this is considered to be a narrowing conversion, and because we are doing list initialization, the compiler will error and halt the compilation.<\/p>\n<p>Strangely, conversions from a floating point type to an integral type do not have a constexpr exclusion clause, so these are always considered narrowing conversions even when the value to be converted is constexpr and fits in the range of the destination type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int n { 5.0 }; \/\/ compile error: narrowing conversion<\/code><\/pre>\n<p>Even more strangely, conversions from a constexpr floating point type to a narrower floating point type are not considered narrowing even when there is a loss of precision!<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">constexpr double d { 0.1 };\r\nfloat f { d }; \/\/ not narrowing, even though loss of precision results<\/code><\/pre>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Conversion from a constexpr floating point type to a narrower floating point type is not considered narrowing even when a loss of precision results.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">List initialization with constexpr initializers<\/p>\n<p>These constexpr exception clauses are incredibly useful when list initializing non-int\/non-double objects, as we can use an int or double literal (or a constexpr object) initialization value.<\/p>\n<p>This allows us to avoid:<\/p>\n<ul>\n<li>Having to use literal suffixes in most cases\n<\/li>\n<li>Having to clutter our initializations with a static_cast\n<\/li>\n<\/ul>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    \/\/ We can avoid literals with suffixes\r\n    unsigned int u { 5 }; \/\/ okay (we don't need to use `5u`)\r\n    float f { 1.5 };      \/\/ okay (we don't need to use `1.5f`)\r\n\r\n    \/\/ We can avoid static_casts\r\n    constexpr int n{ 5 };\r\n    double d { n };       \/\/ okay (we don't need a static_cast here)\r\n    short s { 5 };        \/\/ okay (there is no suffix for short, we don't need a static_cast here)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This also works with copy and direct initialization.<\/p>\n<p>One caveat worth mentioning: initializing a narrower or lesser ranked floating point type with a constexpr value is allowed as long as the value is in range of the destination type, even if the destination type doesn&#8217;t have enough precision to precisely store the value!<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Floating point types are ranked in this order (greater to lesser):<\/p>\n<ul>\n<li>Long double\n<\/li>\n<li>Double\n<\/li>\n<li>Float\n<\/li>\n<\/ul>\n<\/div>\n<p>Therefore, something like this is legal and will not emit an error:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    float f { 1.23456789 }; \/\/ not a narrowing conversion, even though precision lost!\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, your compiler may still issue a warning in this case (GCC and Clang do if you use the -Wconversion compile flag).<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/arithmetic-conversions\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">10.5<\/span>Arithmetic conversions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/numeric-conversions\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">10.3<\/span>Numeric conversions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the previous lesson (), we covered numeric conversions, which cover a wide range of different type conversions between fundamental types. Narrowing conversions In C++, a is a potentially unsafe numeric conversion where the destination type may not be able to hold all the values of the source type. The &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/14313"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=14313"}],"version-history":[{"count":18,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/14313\/revisions"}],"predecessor-version":[{"id":16677,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/14313\/revisions\/16677"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=14313"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=14313"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=14313"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}