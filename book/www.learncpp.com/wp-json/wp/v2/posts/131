{"id":131,"date":"2007-09-07T09:22:16","date_gmt":"2007-09-07T17:22:16","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/88-constructors-part-ii\/"},"modified":"2025-01-21T20:19:17","modified_gmt":"2025-01-22T04:19:17","slug":"delegating-constructors","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/delegating-constructors\/","title":{"rendered":"14.12 &#8212; Delegating constructors"},"content":{"rendered":"<p>Whenever possible, we want to reduce redundant code (following the DRY principle -- Don&#8217;t Repeat Yourself).<\/p>\n<p>Consider the following functions:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void A()\r\n{\r\n    \/\/ statements that do task A\r\n}\r\n\r\nvoid B()\r\n{\r\n    \/\/ statements that do task A\r\n    \/\/ statements that do task B\r\n}<\/code><\/pre>\n<p>Both functions have a set of statements that do exactly the same thing (task A).  In such a case, we can refactor like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void A()\r\n{\r\n    \/\/ statements that do task A\r\n}\r\n\r\nvoid B()\r\n{\r\n    A();\r\n    \/\/ statements that do task B\r\n}<\/code><\/pre>\n<p>In that way, we&#8217;ve removed redundant code that existed in functions <code>A()<\/code> and <code>B()<\/code>.  This makes our code easier to maintain, as changes only need to be made in one place.<\/p>\n<p>When a class contains multiple constructors, it&#8217;s extremely common for the code in each constructor to be similar if not identical, with lots of repetition.  We&#8217;d similarly like to remove constructor redundancy where possible.<\/p>\n<p>Consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Employee\r\n{\r\nprivate:\r\n    std::string m_name { \"???\" };\r\n    int m_id { 0 };\r\n    bool m_isManager { false };\r\n\r\npublic:\r\n    Employee(std::string_view name, int id) \/\/ Employees must have a name and an id\r\n        : m_name{ name }, m_id { id }\r\n    {\r\n        std::cout &lt;&lt; \"Employee \" &lt;&lt; m_name &lt;&lt; \" created\\n\";\r\n    }\r\n\r\n    Employee(std::string_view name, int id, bool isManager) \/\/ They can optionally be a manager\r\n        : m_name{ name }, m_id{ id }, m_isManager { isManager }\r\n    {\r\n        std::cout &lt;&lt; \"Employee \" &lt;&lt; m_name &lt;&lt; \" created\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Employee e1{ \"James\", 7 };\r\n    Employee e2{ \"Dave\", 42, true };\r\n}<\/code><\/pre>\n<p>The body of each constructor has the exact same print statement.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>It&#8217;s generally not a good idea to have a constructor print something (except for debugging purposes), as this means you can&#8217;t create an object using that constructor in cases where you do not want to print something.  We&#8217;re doing it in this example to help illustrate what&#8217;s happening.\n<\/p><\/div>\n<p>Constructors are allowed to call other functions, including other member functions of the class.  So we could refactor like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Employee\r\n{\r\nprivate:\r\n    std::string m_name { \"???\" };\r\n    int m_id{ 0 };\r\n    bool m_isManager { false };\r\n\r\n    void printCreated() const \/\/ our new helper function\r\n    {\r\n        std::cout &lt;&lt; \"Employee \" &lt;&lt; m_name &lt;&lt; \" created\\n\";\r\n    }\r\n\r\npublic:\r\n    Employee(std::string_view name, int id)\r\n        : m_name{ name }, m_id { id }\r\n    {\r\n        printCreated(); \/\/ we call it here\r\n    }\r\n\r\n    Employee(std::string_view name, int id, bool isManager)\r\n        : m_name{ name }, m_id{ id }, m_isManager { isManager }\r\n    {\r\n        printCreated(); \/\/ and here\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Employee e1{ \"James\", 7 };\r\n    Employee e2{ \"Dave\", 42, true };\r\n}<\/code><\/pre>\n<p>While this is better than the prior version (as the redundant statement has been replaced by a redundant function call), it requires introduction of a new function.  And our two constructors are also both initializing <code>m_name<\/code> and <code>m_id<\/code>.  Ideally we&#8217;d remove this redundancy too.<\/p>\n<p>Can we do better?  We can.  But this is where many new programmers run into trouble.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Calling a constructor in the body of a function creates a temporary object<\/p>\n<p>Analogous to how we had function <code>B()<\/code> call function <code>A()<\/code> in the example above, the obvious solution seems like it would be to call the <code>Employee(std::string_view, int)<\/code> constructor from the body of <code>Employee(std::string_view, int, bool)<\/code> in order to initialize <code>m_name<\/code>, <code>m_id<\/code>, and print the statement.  Here&#8217;s what that looks like:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Employee\r\n{\r\nprivate:\r\n    std::string m_name { \"???\" };\r\n    int m_id { 0 };\r\n    bool m_isManager { false };\r\n\r\npublic:\r\n    Employee(std::string_view name, int id)\r\n        : m_name{ name }, m_id { id } \/\/ this constructor initializes name and id\r\n    {\r\n        std::cout &lt;&lt; \"Employee \" &lt;&lt; m_name &lt;&lt; \" created\\n\"; \/\/ our print statement is back here\r\n    }\r\n\r\n    Employee(std::string_view name, int id, bool isManager)\r\n        : m_isManager { isManager } \/\/ this constructor initializes m_isManager\r\n    {\r\n        \/\/ Call Employee(std::string_view, int) to initialize m_name and m_id\r\n        Employee(name, id); \/\/ this doesn't work as expected!\r\n    }\r\n\r\n    const std::string&amp; getName() const { return m_name; }\r\n};\r\n\r\nint main()\r\n{\r\n    Employee e2{ \"Dave\", 42, true };\r\n    std::cout &lt;&lt; \"e2 has name: \" &lt;&lt; e2.getName() &lt;&lt; \"\\n\"; \/\/ print e2.m_name\r\n}<\/code><\/pre>\n<p>But this doesn&#8217;t work correctly, as the program outputs the following:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">Employee Dave created\r\ne2 has name: ???<\/code><\/pre>\n<p>Even though <code>Employee Dave created<\/code> printed, after <code>e2<\/code> finished construction, <code>e2.m_name<\/code> still appears to be set to its initial value of <code>\"???\"<\/code>.  How is that possible?<\/p>\n<p>We were expecting <code>Employee(name, id)<\/code> to call the constructor in order to continue initialization of the current implicit object (<code>e2<\/code>).  But initialization of a class object is finished once the member initializer list has finished executing.  By the time we begin executing the constructor&#8217;s body, it&#8217;s too late to do more initialization.<\/p>\n<p>When called from the body of a function, what looks like a function call to a constructor usually creates and direct-initializes a temporary object (in one other case, you&#8217;ll get a compile error instead).  In our example above, <code>Employee(name, id);<\/code> creates a temporary (unnamed) Employee object.  This temporary object is the one whose <code>m_name<\/code> is set to <code>Dave<\/code>, and is the one that prints <code>Employee Dave created<\/code>.  Then the temporary is destroyed.  <code>e2<\/code> never has its <code>m_name<\/code> or <code>m_id<\/code> changed from the default values.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Constructors should not be called directly from the body of another function.  Doing so will either result in a compilation error, or will direct-initialize a temporary object.<br \/>\nIf you do want a temporary object, prefer list-initialization (which makes it clear you are intending to create an object).\n<\/p><\/div>\n<p>So if we can&#8217;t call a constructor from the body of another constructor, then how do we solve this issue?<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Delegating constructors<\/p>\n<p>Constructors are allowed to delegate (transfer responsibility for) initialization to another constructor from the same class type.  This process is sometimes called <strong>constructor chaining<\/strong> and such constructors are called <strong>delegating constructors<\/strong>.<\/p>\n<p>To make one constructor delegate initialization to another constructor, simply call the constructor in the member initializer list:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Employee\r\n{\r\nprivate:\r\n    std::string m_name { \"???\" };\r\n    int m_id { 0 };\r\n\r\npublic:\r\n    Employee(std::string_view name)\r\n        : Employee{ name, 0 } \/\/ delegate initialization to Employee(std::string_view, int) constructor\r\n    {\r\n    }\r\n\r\n    Employee(std::string_view name, int id)\r\n        : m_name{ name }, m_id { id } \/\/ actually initializes the members\r\n    {\r\n        std::cout &lt;&lt; \"Employee \" &lt;&lt; m_name &lt;&lt; \" created\\n\";\r\n    }\r\n\r\n};\r\n\r\nint main()\r\n{\r\n    Employee e1{ \"James\" };\r\n    Employee e2{ \"Dave\", 42 };\r\n}<\/code><\/pre>\n<p>When <code>e1 { \"James\" }<\/code> is initialized, matching constructor <code>Employee(std::string_view)<\/code> is called with parameter <code>name<\/code> set to <code>\"James\"<\/code>.  The member initializer list of this constructor delegates initialization to other constructor, so <code>Employee(std::string_view, int)<\/code> is then called.  The value of <code>name<\/code> (<code>\"James\"<\/code>) is passed as the first argument, and literal <code>0<\/code> is passed as the second argument.  The member initializer list of the delegated constructor then initializes the members.  The body of the delegated constructor then runs.  Then control returns to the initial constructor, whose (empty) body runs.  Finally, control returns to the caller.<\/p>\n<p>The downside of this method is that it sometimes requires duplication of initialization values.  In the delegation to the <code>Employee(std::string_view, int)<\/code> constructor, we need an initialization value for the <code>int<\/code> parameter.  We had to hardcode literal <code>0<\/code>, as there is no way to reference the default member initializer.<\/p>\n<p>A few additional notes about delegating constructors.  First, a constructor that delegates to another constructor is not allowed to do any member initialization itself.  So your constructors can delegate or initialize, but not both.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>Note that we had <code>Employee(std::string_view)<\/code> (the constructor with less parameters) delegate to <code>Employee(std::string_view name, int id)<\/code> (the constructor with more parameters).  It is common to have the constructor with fewer parameters delegate to the constructor with more parameters.<\/p>\n<p>If we had instead chosen to have <code>Employee(std::string_view name, int id)<\/code> delegate to <code>Employee(std::string_view)<\/code>, then that would have left us unable to initialize <code>m_id<\/code> using <code>id<\/code>, as a constructor can only delegate or initialize, not both.\n<\/div>\n<p>Second, it&#8217;s possible for one constructor to delegate to another constructor, which delegates back to the first constructor.  This forms an infinite loop, and will cause your program to run out of stack space and crash.  You can avoid this by ensuring all of your constructors resolve to a non-delegating constructor.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>If you have multiple constructors, consider whether you can use delegating constructors to reduce duplicate code.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Reducing constructors using default arguments<\/p>\n<p>Default values can also sometimes be used to reduce multiple constructors into fewer constructors.  For example, by putting a default value on our <code>id<\/code> parameter, we can create a single <code>Employee<\/code> constructor that requires a name argument but will optionally accept an id argument:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Employee\r\n{\r\nprivate:\r\n    std::string m_name{};\r\n    int m_id{ 0 }; \/\/ default member initializer\r\n\r\npublic:\r\n\r\n    Employee(std::string_view name, int id = 0) \/\/ default argument for id\r\n        : m_name{ name }, m_id{ id }\r\n    {\r\n        std::cout &lt;&lt; \"Employee \" &lt;&lt; m_name &lt;&lt; \" created\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Employee e1{ \"James\" };\r\n    Employee e2{ \"Dave\", 42 };\r\n}<\/code><\/pre>\n<p>Since default values must be attached to the rightmost parameters in a function call, a good practice when defining classes is to define members for which a user <em>must<\/em> provide initialization values for first (and then make those the leftmost parameters of the constructor).  Members for which the user can optionally provide (because the default values are acceptable) should be defined second (and then make those the rightmost parameters of the constructor). <\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Members for which the user must provide initialization values should be defined first (and as the leftmost parameters of the constructor).  Members for which the user can optionally provide initialization values (because the default values are acceptable) should be defined second (and as the rightmost parameters of the constructor).\n<\/p><\/div>\n<p>Note that this method also requires duplication of the default initialization value for <code>m_id<\/code> (&#8216;0&#8217;): once as a default member initializer, and once as a default argument.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A conundrum: Redundant constructors vs redundant default values<\/p>\n<p>In the above examples, we used delegating constructors and then default arguments to reduce constructor redundancy.  But both of these methods required us to duplicate initialization values for our members in various places.  Unfortunately, there is currently no way to specify that a delegating constructor or default argument should use the default member initializer value.<\/p>\n<p>There are various opinions about whether it is better to have fewer constructors (with duplication of initialization values) or more constructors (with no duplication of initialization values).  Our opinion is that it&#8217;s usually more straightforward to have fewer constructors, even if it results in duplication of initialization values.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>When we have an initialization value that is used in multiple places (e.g. as a default member initializer and a default argument for a constructor parameter), we can define a named constant and use that wherever our initialization value is needed.  This allows the initialization value to be defined in one place.<\/p>\n<p>Although you could use a constexpr global variable for this, a better option is to use a <code>static constexpr<\/code> member inside the class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Employee\r\n{\r\nprivate:\r\n    static constexpr int default_id { 0 }; \/\/ define a named constant with our desired initialization value\r\n    \r\n    std::string m_name {};\r\n    int m_id { default_id }; \/\/ we can use it here\r\n\r\npublic:\r\n\r\n    Employee(std::string_view name, int id = default_id) \/\/ and we can use it here\r\n        : m_name { name }, m_id { id }\r\n    {\r\n        std::cout &lt;&lt; \"Employee \" &lt;&lt; m_name &lt;&lt; \" created\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Employee e1 { \"James\" };\r\n    Employee e2 { \"Dave\", 42 };\r\n}<\/code><\/pre>\n<p>Use of the <code>static<\/code> keyword in this context allows us to have a single <code>default_id<\/code> member that is shared by all <code>Employee<\/code> objects.  Without the <code>static<\/code>, each <code>Employee<\/code> object would have its own independent <code>default_id<\/code> member (which would work, but be a waste of memory).<\/p>\n<p>The downside of this approach is that each additional named constant adds another name that must be understood, making your class a little more cluttered and complex.  Whether this is worth it depends on how many of such constants are required, and in how many places the initialization values are needed.<\/p>\n<p>We cover static data members in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/static-member-variables\/\">15.6 -- Static member variables<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Write a class named Ball.  Ball should have two private member variables, one to hold a color (default value: <code>black<\/code>), and one to hold a radius (default value: <code>10.0<\/code>).  Add 4 constructors, one to handle each case below:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    Ball def{};\r\n    Ball blue{ \"blue\" };\r\n    Ball twenty{ 20.0 };\r\n    Ball blueTwenty{ \"blue\", 20.0 };\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The program should produce the following result:<\/p>\n<pre>\nBall(black, 10)\r\nBall(blue, 10)\r\nBall(black, 20)\r\nBall(blue, 20)\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Ball\r\n{\r\nprivate:\r\n\tstd::string m_color{ \"black\" };\r\n\tdouble m_radius{ 10.0 };\r\n\r\npublic:\r\n\t\/\/ Default constructor (color and radius will use default value)\r\n\tBall()\r\n\t{\r\n            print();\r\n\t}\r\n\r\n\t\/\/ Constructor with only radius parameter (color will use default value)\r\n\tBall(double radius)\r\n\t\t: m_radius{ radius }\r\n\t{\r\n            print();\r\n\t}\r\n\r\n\t\/\/ Constructor with only color parameter (radius will use default value)\r\n\tBall(std::string_view color)\r\n\t\t: m_color{ color }\r\n\t{\r\n            print();\r\n\t}\r\n\r\n\t\/\/ Constructor with both color and radius parameters\r\n\tBall(std::string_view color, double radius)\r\n\t\t: m_color{ color }\r\n\t\t, m_radius{ radius }\r\n\t{\r\n            print();\r\n\t}\r\n\r\n    void print() const\r\n    {\r\n        std::cout &lt;&lt; \"Ball(\" &lt;&lt; m_color &lt;&lt; \", \" &lt;&lt; m_radius &lt;&lt; \")\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Ball def{};\r\n    Ball blue{ \"blue\" };\r\n    Ball twenty{ 20.0 };\r\n    Ball blueTwenty{ \"blue\", 20.0 };\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>Reduce the number of constructors in the above program by using default arguments and delegating constructors.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Ball\r\n{\r\nprivate:\r\n\tstd::string m_color{ \"black\" };\r\n\tdouble m_radius{ 10.0 };\r\n\r\npublic:\r\n\t\/\/ Handles Ball(radius)\r\n\tBall(double radius)\r\n\t\t: Ball{ \"black\", radius } \/\/ delegate to the other constructor\r\n\t{\r\n\t\t\/\/ We don't need to call print() here since it will be called by\r\n\t\t\/\/ the constructor we delegate to\t\t\r\n\t}\r\n\r\n\t\/\/ Handles Ball(color, radius), Ball(color), and Ball()\r\n\tBall(std::string_view color=\"black\", double radius=10.0)\r\n\t\t: m_color{ color }\r\n\t\t, m_radius{ radius }\r\n\t{\r\n\t\tprint();\r\n\t}\r\n\r\n\tvoid print() const\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Ball(\" &lt;&lt; m_color &lt;&lt; \", \" &lt;&lt; m_radius &lt;&lt; \")\\n\";\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n    Ball def{};\r\n    Ball blue{ \"blue\" };\r\n    Ball twenty{ 20.0 };\r\n    Ball blueTwenty{ \"blue\", 20.0 };\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/temporary-class-objects\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.13<\/span>Temporary class objects\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/default-constructors-and-default-arguments\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.11<\/span>Default constructors and default arguments\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Whenever possible, we want to reduce redundant code (following the DRY principle &#8212; Don&#8217;t Repeat Yourself). Consider the following functions: void A() { \/\/ statements that do task A } void B() { \/\/ statements that do task A \/\/ statements that do task B } Both functions have a &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/131"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=131"}],"version-history":[{"count":58,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/131\/revisions"}],"predecessor-version":[{"id":18122,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/131\/revisions\/18122"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=131"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=131"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=131"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}