{"id":15884,"date":"2023-10-10T13:26:11","date_gmt":"2023-10-10T20:26:11","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15884"},"modified":"2023-12-28T17:32:02","modified_gmt":"2023-12-29T01:32:02","slug":"deleting-functions","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/deleting-functions\/","title":{"rendered":"11.4 &#8212; Deleting functions"},"content":{"rendered":"<p>In some cases, it is possible to write functions that don&#8217;t behave as desired when called with values of certain types.<\/p>\n<p>Consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printInt(int x)\r\n{\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    printInt(5);    \/\/ okay: prints 5\r\n    printInt('a');  \/\/ prints 97 -- does this make sense?\r\n    printInt(true); \/\/ print 1 -- does this make sense?\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>This example prints:<\/p>\n<pre>\n5\r\n97\r\n1\r\n<\/pre>\n<p>While <code>printInt(5)<\/code> is clearly okay, the other two calls to <code>printInt()<\/code> are more questionable.  With <code>printInt('a')<\/code>, the compiler will determine that it can promote <code>'a'<\/code> to int value <code>97<\/code> in order to match the function call with the function definition.  And it will promote <code>true<\/code> to int value <code>1<\/code>.  And it will do so without complaint.<\/p>\n<p>Let&#8217;s assume we don&#8217;t think it makes sense to call <code>printInt()<\/code> with a value of type <code>char<\/code> or <code>bool<\/code>.  What can we do?<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Deleting a function using the <code>= delete<\/code> specifier<\/p>\n<p>In cases where we have a function that we explicitly do not want to be callable, we can define that function as deleted by using the <strong>= delete<\/strong> specifier.  If the compiler matches a function call to a deleted function, compilation will be halted with a compile error.<\/p>\n<p>Here&#8217;s an updated version of the above making use of this syntax:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printInt(int x)\r\n{\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n';\r\n}\r\n\r\nvoid printInt(char) = delete; \/\/ calls to this function will halt compilation\r\nvoid printInt(bool) = delete; \/\/ calls to this function will halt compilation\r\n\r\nint main()\r\n{\r\n    printInt(97);   \/\/ okay\r\n\r\n    printInt('a');  \/\/ compile error: function deleted\r\n    printInt(true); \/\/ compile error: function deleted\r\n\r\n    printInt(5.0);  \/\/ compile error: ambiguous match\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>Let&#8217;s take a quick look at some of these.  First, <code>printInt('a')<\/code> is a direct match for <code>printInt(char)<\/code>, which is deleted.  The compiler thus produces a compilation error.  <code>printInt(true)<\/code> is a direct match for <code>printInt(bool)<\/code>, which is deleted, and thus also produces a compilation error.<\/p>\n<p><code>printInt(5.0)<\/code> is an interesting case, with perhaps unexpected results.  First, the compiler checks to see if exact match <code>printInt(double)<\/code> exists.  It does not.  Next, the compiler tries to find a best match.  Although <code>printInt(int)<\/code> is the only non-deleted function, the deleted functions are still considered as candidates in function overload resolution.  Because none of these functions are unambiguously the best match, the compiler will issue an ambiguous match compilation error.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p><code>= delete<\/code> means &#8220;I forbid this&#8221;, not &#8220;this doesn&#8217;t exist&#8221;. <\/p>\n<p>Deleted function participate in all stages of function overload resolution (not just in the exact match stage).  If a deleted function is selected, then a compilation error results.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Other types of functions can be similarly deleted.<\/p>\n<p>We discuss deleting member functions in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-the-copy-constructor\/\">14.14 -- Introduction to the copy constructor<\/a>, and deleting function template specializations in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-template-instantiation\/\">11.7 -- Function template instantiation<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Deleting all non-matching overloads <span class=\"cpp-section-pill cpp-section-advanced\">Advanced<\/span><\/p>\n<p>Deleting a bunch of individual function overloads works fine, but can be verbose.  There may be times when we want a certain function to be called only with arguments whose types exactly match the function parameters.  We can do this by using a function template (introduced in upcoming lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-templates\/\">11.6 -- Function templates<\/a>) as follows:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ This function will take precedence for arguments of type int\r\nvoid printInt(int x)\r\n{\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n';\r\n}\r\n\r\n\/\/ This function template will take precedence for arguments of other types\r\n\/\/ Since this function template is deleted, calls to it will halt compilation\r\ntemplate &lt;typename T&gt;\r\nvoid printInt(T x) = delete;\r\n\r\nint main()\r\n{\r\n    printInt(97);   \/\/ okay\r\n    printInt('a');  \/\/ compile error\r\n    printInt(true); \/\/ compile error\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/default-arguments\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">11.5<\/span>Default arguments\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-overload-resolution-and-ambiguous-matches\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">11.3<\/span>Function overload resolution and ambiguous matches\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In some cases, it is possible to write functions that don&#8217;t behave as desired when called with values of certain types. Consider the following example: #include &lt;iostream&gt; void printInt(int x) { std::cout &lt;&lt; x &lt;&lt; &#8216;\\n&#8217;; } int main() { printInt(5); \/\/ okay: prints 5 printInt(&#8216;a&#8217;); \/\/ prints 97 &#8212; &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15884"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15884"}],"version-history":[{"count":7,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15884\/revisions"}],"predecessor-version":[{"id":16382,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15884\/revisions\/16382"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15884"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15884"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15884"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}