{"id":212,"date":"2008-10-04T13:26:39","date_gmt":"2008-10-04T21:26:39","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=212"},"modified":"2024-05-23T08:57:22","modified_gmt":"2024-05-23T15:57:22","slug":"the-need-for-exceptions","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/the-need-for-exceptions\/","title":{"rendered":"27.1 &#8212; The need for exceptions"},"content":{"rendered":"<p>In the previous lesson on <a href=\"http:\/\/www.learncpp.com\/cpp-tutorial\/712-handling-errors-assert-cerr-exit-and-exceptions\/\">handling errors<\/a>, we talked about ways to use assert(), std::cerr, and exit() to handle errors.  However, we deferred one further topic that we will now cover: exceptions.<\/p>\n<p><strong>When return codes fail<\/strong><\/p>\n<p>When writing reusable code, error handling is a necessity.  One of the most common ways to handle potential errors is via return codes.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string_view&gt;\r\n\r\nint findFirstChar(std::string_view string, char ch)\r\n{\r\n    \/\/ Step through each character in string\r\n    for (std::size_t index{ 0 }; index &lt; string.length(); ++index)\r\n        \/\/ If the character matches ch, return its index\r\n        if (string[index] == ch)\r\n            return index;\r\n\r\n    \/\/ If no match was found, return -1\r\n    return -1;\r\n}<\/code><\/pre>\n<p>This function returns the index of the first character matching ch within string.  If the character can not be found, the function returns -1 as an indicator that the character wasn&#8217;t found.<\/p>\n<p>The primary virtue of this approach is that it is extremely simple.  However, using return codes has a number of drawbacks which can quickly become apparent when used in non-trivial cases:<\/p>\n<p>First, return values can be cryptic -- if a function returns -1, is it trying to indicate an error, or is that actually a valid return value?  It&#8217;s often hard to tell without digging into the guts of the function or consulting documentation.<\/p>\n<p>Second, functions can only return one value, so what happens when you need to return both a function result and a possible error code?  Consider the following function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">double divide(int x, int y)\r\n{\r\n    return static_cast&lt;double&gt;(x)\/y;\r\n}<\/code><\/pre>\n<p>This function is in desperate need of some error handling, because it will crash if the user passes in 0 for parameter y.  However, it also needs to return the result of x\/y.  How can it do both?  The most common answer is that either the result or the error handling will have to be passed back as a reference parameter, which makes for ugly code that is less convenient to use.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ndouble divide(int x, int y, bool&amp; outSuccess)\r\n{\r\n    if (y == 0)\r\n    {\r\n        outSuccess = false;\r\n        return 0.0;\r\n    }\r\n\r\n    outSuccess = true;\r\n    return static_cast&lt;double&gt;(x)\/y;\r\n}\r\n\r\nint main()\r\n{\r\n    bool success {}; \/\/ we must now pass in a bool value to see if the call was successful\r\n    double result { divide(5, 3, success) };\r\n\r\n    if (!success) \/\/ and check it before we use the result\r\n        std::cerr &lt;&lt; \"An error occurred\" &lt;&lt; std::endl;\r\n    else\r\n        std::cout &lt;&lt; \"The answer is \" &lt;&lt; result &lt;&lt; '\\n';\r\n}<\/code><\/pre>\n<p>Third, in sequences of code where many things can go wrong, error codes have to be checked constantly.  Consider the following snippet of code that involves parsing a text file for values that are supposed to be there:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    std::ifstream setupIni { \"setup.ini\" }; \/\/ open setup.ini for reading\r\n    \/\/ If the file couldn't be opened (e.g. because it was missing) return some error enum\r\n    if (!setupIni)\r\n        return ERROR_OPENING_FILE;\r\n\r\n    \/\/ Now read a bunch of values from a file\r\n    if (!readIntegerFromFile(setupIni, m_firstParameter)) \/\/ try to read an integer from the file\r\n        return ERROR_READING_VALUE; \/\/ Return enum value indicating value couldn't be read\r\n\r\n    if (!readDoubleFromFile(setupIni, m_secondParameter)) \/\/ try to read a double from the file\r\n        return ERROR_READING_VALUE;\r\n\r\n    if (!readFloatFromFile(setupIni, m_thirdParameter)) \/\/ try to read a float from the file\r\n        return ERROR_READING_VALUE;<\/code><\/pre>\n<p>We haven&#8217;t covered file access yet, so don&#8217;t worry if you don&#8217;t understand how the above works -- just note the fact that every call requires an error-check and return back to the caller.  Now imagine if there were twenty parameters of differing types -- you&#8217;re essentially checking for an error and returning ERROR_READING_VALUE twenty times!  All of this error checking and returning values makes determining <em>what<\/em> the function is trying to do much harder to discern.<\/p>\n<p>Fourth, return codes do not mix with constructors very well.  What happens if you&#8217;re creating an object and something inside the constructor goes catastrophically wrong?  Constructors have no return type to pass back a status indicator, and passing one back via a reference parameter is messy and must be explicitly checked.  Furthermore, even if you do this, the object will still be created and then has to be dealt with or disposed of.<\/p>\n<p>Finally, when an error code is returned to the caller, the caller may not always be equipped to handle the error.  If the caller doesn&#8217;t want to handle the error, it either has to ignore it (in which case it will be lost forever), or return the error up the stack to the function that called it.  This can be messy and lead to many of the same issues noted above.<\/p>\n<p>To summarize, the primary issue with return codes is that the error handling code ends up intricately linked to the normal control flow of the code.  This in turn ends up constraining both how the code is laid out, and how errors can be reasonably handled.<\/p>\n<p><strong>Exceptions<\/strong><\/p>\n<p>Exception handling provides a mechanism to decouple handling of errors or other exceptional circumstances from the typical control flow of your code.  This allows more freedom to handle errors when and how ever is most useful for a given situation, alleviating most (if not all) of the messiness that return codes cause.<\/p>\n<p>In the next lesson, we&#8217;ll take a look at how exceptions work in C++.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/basic-exception-handling\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">27.2<\/span>Basic exception handling\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-26-summary-and-quiz\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">26.x<\/span>Chapter 26 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the previous lesson on handling errors, we talked about ways to use assert(), std::cerr, and exit() to handle errors. However, we deferred one further topic that we will now cover: exceptions. When return codes fail When writing reusable code, error handling is a necessity. One of the most common &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[12,24,25,14,26,16],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/212"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=212"}],"version-history":[{"count":24,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/212\/revisions"}],"predecessor-version":[{"id":17090,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/212\/revisions\/17090"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=212"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=212"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=212"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}