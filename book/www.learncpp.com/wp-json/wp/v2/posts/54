{"id":54,"date":"2007-06-13T15:55:56","date_gmt":"2007-06-13T23:55:56","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/31-precedence-and-associativity\/"},"modified":"2025-02-19T17:13:44","modified_gmt":"2025-02-20T01:13:44","slug":"operator-precedence-and-associativity","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/operator-precedence-and-associativity\/","title":{"rendered":"6.1 &#8212; Operator precedence and associativity"},"content":{"rendered":"<p class=\"cpp-section\">Chapter introduction<\/p>\n<p>This chapter builds on top of the concepts from lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-literals-and-operators\/\">1.9 -- Introduction to literals and operators<\/a>.  A quick review follows:<\/p>\n<p>An <strong>operation<\/strong> is a mathematical process involving zero or more input values (called <strong>operands<\/strong>) that produces a new value (called an output value).  The specific operation to be performed is denoted by a construct (typically a symbol or pair of symbols) called an <strong>operator<\/strong>.<\/p>\n<p>For example, as children we all learn that <code>2 + 3<\/code> equals <code>5<\/code>.  In this case, the literals <code>2<\/code> and <code>3<\/code> are the operands, and the symbol <code>+<\/code> is the operator that tells us to apply mathematical addition on the operands to produce the new value <code>5<\/code>.  Because there is only one operator being used here, this is straightforward.<\/p>\n<p>In this chapter, we&#8217;ll discuss topics related to operators, and explore many of the common operators that C++ supports.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Evaluation of compound expressions<\/p>\n<p>Now, let&#8217;s consider a compound expression, such as <code>4 + 2 * 3<\/code>.  Should this be grouped as <code>(4 + 2) * 3<\/code> which evaluates to <code>18<\/code>, or <code>4 + (2 * 3)<\/code> which evaluates to <code>10<\/code>?  Using normal mathematical precedence rules (which state that multiplication is resolved before addition), we know that the above expression should be grouped as <code>4 + (2 * 3)<\/code> to produce the value <code>10<\/code>.  But how does the compiler know?<\/p>\n<p>In order to evaluate an expression, the compiler must do two things:<\/p>\n<ul>\n<li>At compile time, the compiler must parse the expression and determine how operands are grouped with operators.  This is done via the precedence and associativity rules, which we&#8217;ll discuss momentarily.\n<\/li>\n<li>At compile time or runtime, the operands are evaluated and operations executed to produce a result.\n<\/li>\n<\/ul>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Operator precedence<\/p>\n<p>To assist with parsing a compound expression, all operators are assigned a level of precedence.  Operators with a higher <strong>precedence<\/strong> level are grouped with operands first.<\/p>\n<p>You can see in the table below that multiplication and division (precedence level 5) have a higher precedence level than addition and subtraction (precedence level 6).  Thus, multiplication and division will be grouped with operands before addition and subtraction.  In other words, <code>4 + 2 * 3<\/code> will be grouped as <code>4 + (2 * 3)<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Operator associativity<\/p>\n<p>Consider a compound expression like <code>7 - 4 - 1<\/code>.  Should this be grouped as <code>(7 - 4) - 1<\/code> which evaluates to <code>2<\/code>, or <code>7 - (4 - 1)<\/code>, which evaluates to <code>4<\/code>?  Since both subtraction operators have the same precedence level, the compiler can not use precedence alone to determine how this should be grouped.<\/p>\n<p>If two operators with the same precedence level are adjacent to each other in an expression, the operator&#8217;s <strong>associativity<\/strong> tells the compiler whether to evaluate the operators (not the operands!) from left to right or from right to left.  Subtraction has precedence level 6, and the operators in precedence level 6 have an associativity of left to right.  So this expression is grouped from left to right: <code>(7 - 4) - 1<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Table of operator precedence and associativity<\/p>\n<p>The below table is primarily meant to be a reference chart that you can refer back to in the future to resolve any precedence or associativity questions you have.<\/p>\n<p>Notes:<\/p>\n<ul>\n<li>Precedence level 1 is the highest precedence level, and level 17 is the lowest.  Operators with a higher precedence level have their operands grouped first.\n<\/li>\n<li>L->R means left to right associativity.\n<\/li>\n<li>R->L means right to left associativity.\n<\/li>\n<\/ul>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<th>Prec\/Ass<\/th>\n<th>Operator<\/th>\n<th>Description<\/th>\n<th>Pattern<\/th>\n<\/tr>\n<tr>\n<td>1 L->R<\/td>\n<td>\n\t\t::<br \/>\n\t\t::\n\t<\/td>\n<td>\n\t\tGlobal scope (unary)<br \/>\n\t\tNamespace scope (binary)\n\t<\/td>\n<td>\n\t\t::name<br \/>\n\t\tclass_name::member_name<\/br>\n\t<\/td>\n<\/tr>\n<tr>\n<td>2 L->R<\/td>\n<td>\n\t\t()<br \/>\n\t\t()<br \/>\n\t\ttype()<br \/>\n\t\ttype{}<br \/>\n\t\t[]<br \/>\n\t\t.<br \/>\n\t\t-><br \/>\n\t\t++<br \/>\n\t\t&ndash;&ndash;<br \/>\n\t\ttypeid<br \/>\n\t\tconst_cast<br \/>\n\t\tdynamic_cast<br \/>\n\t\treinterpret_cast<br \/>\n\t\tstatic_cast<br \/>\n\t\tsizeof&#8230;<br \/>\n\t\tnoexcept<br \/>\n\t\talignof\n\t<\/td>\n<td>\n\t\tParentheses<br \/>\n\t\tFunction call<br \/>\n\t\tFunctional cast<br \/>\n\t\tList init temporary object (C++11)<br \/>\n\t\tArray subscript<br \/>\n\t\tMember access from object<br \/>\n\t\tMember access from object ptr<br \/>\n\t\tPost-increment<br \/>\n\t\tPost-decrement<br \/>\n\t\tRun-time type information<br \/>\n\t\tCast away const<br \/>\n\t\tRun-time type-checked cast<br \/>\n\t\tCast one type to another<br \/>\n\t\tCompile-time type-checked cast<br \/>\n\t\tGet parameter pack size<br \/>\n\t\tCompile-time exception check<br \/>\n\t\tGet type alignment\n\t<\/td>\n<td>\n\t\t(expression)<br \/>\n\t\tfunction_name(arguments)<br \/>\n\t\ttype(expression)<br \/>\n\t\ttype{expression}<br \/>\n\t\tpointer[expression]<br \/>\n\t\tobject.member_name<br \/>\n\t\tobject_pointer->member_name<br \/>\n\t\tlvalue++<br \/>\n\t\tlvalue&ndash;&ndash;<br \/>\n\t\ttypeid(type) or typeid(expression)<br \/>\n\t\tconst_cast&lt;type&gt;(expression)<br \/>\n\t\tdynamic_cast&lt;type&gt;(expression)<br \/>\n\t\treinterpret_cast&lt;type&gt;(expression)<br \/>\n\t\tstatic_cast&lt;type&gt;(expression)<br \/>\n\t\tsizeof&#8230;(expression)<br \/>\n\t\tnoexcept(expression)<br \/>\n\t\talignof(type)\n\t<\/td>\n<\/tr>\n<tr>\n<td>3 R->L<\/td>\n<td>\n\t\t+<br \/>\n\t\t-<br \/>\n\t\t++<br \/>\n\t\t&ndash;&ndash;<br \/>\n\t\t!<br \/>\n\t\tnot<br \/>\n\t\t~<br \/>\n\t\t(type)<br \/>\n\t\tsizeof<br \/>\n\t\tco_await<br \/>\n\t\t&#038;<br \/>\n\t\t*<br \/>\n\t\tnew<br \/>\n\t\tnew[]<br \/>\n\t\tdelete<br \/>\n\t\tdelete[]\n\t<\/td>\n<td>\n\t\tUnary plus<br \/>\n\t\tUnary minus<br \/>\n\t\tPre-increment<br \/>\n\t\tPre-decrement<br \/>\n\t\tLogical NOT<br \/>\n\t\tLogical NOT<br \/>\n\t\tBitwise NOT<br \/>\n\t\tC-style cast<br \/>\n\t\tSize in bytes<br \/>\n\t\tAwait asynchronous call<br \/>\n\t\tAddress of<br \/>\n\t\tDereference<br \/>\n\t\tDynamic memory allocation<br \/>\n\t\tDynamic array allocation <br \/>\n\t\tDynamic memory deletion<br \/>\n\t\tDynamic array deletion\n\t<\/td>\n<td>\n\t\t+expression<br \/>\n\t\t-expression<br \/>\n\t\t++lvalue<br \/>\n\t\t&ndash;&ndash;lvalue<br \/>\n\t\t!expression<br \/>\n\t\tnot expression<br \/>\n\t\t~expression<br \/>\n\t\t(new_type)expression<br \/>\n\t\tsizeof(type) or sizeof(expression)<br \/>\n\t\tco_await expression (C++20)<br \/>\n\t\t&#038;lvalue<br \/>\n\t\t*expression<br \/>\n\t\tnew type<br \/>\n\t\tnew type[expression]<br \/>\n\t\tdelete pointer<br \/>\n\t\tdelete[] pointer\n\t<\/td>\n<\/tr>\n<tr>\n<td>4 L->R<\/td>\n<td>\n\t\t->*<br \/>\n\t\t.*\n\t<\/td>\n<td>\n\t\tMember pointer selector<br \/>\n\t\tMember object selector\n\t<\/td>\n<td>\n\t\tobject_pointer->*pointer_to_member<br \/>\n\t\tobject.*pointer_to_member\n\t<\/td>\n<\/tr>\n<tr>\n<td>5 L->R<\/td>\n<td>\n\t\t*<br \/>\n\t\t\/<br \/>\n\t\t%\n\t<\/td>\n<td>\n\t\tMultiplication<br \/>\n\t\tDivision<br \/>\n\t\tRemainder\n\t<\/td>\n<td>\n\t\texpression * expression<br \/>\n\t\texpression \/ expression<br \/>\n\t\texpression % expression\n\t<\/td>\n<\/tr>\n<tr>\n<td>6 L->R<\/td>\n<td>\n\t\t+<br \/>\n\t\t&#45;\n\t<\/td>\n<td>\n\t\tAddition<br \/>\n\t\tSubtraction\n\t<\/td>\n<td>\n\t\texpression + expression<br \/>\n\t\texpression - expression\n\t<\/td>\n<\/tr>\n<tr>\n<td>7 L->R<\/td>\n<td>\n\t\t&lt;&lt;<br \/>\n\t\t&gt;&gt;\n\t<\/td>\n<td>\n\t\tBitwise shift left \/ Insertion<br \/>\n\t\tBitwise shift right \/ Extraction\n\t<\/td>\n<td>\n\t\texpression &lt;&lt; expression<br \/>\n\t\texpression &gt;&gt; expression\n\t<\/td>\n<\/tr>\n<tr>\n<td>8 L->R<\/td>\n<td>\n    \t&lt;=&gt;\n    <\/td>\n<td>\n    \tThree-way comparison (C++20)\n    <\/td>\n<td>\n    \texpression &lt;=&gt; expression\n    <\/td>\n<\/tr>\n<tr>\n<td>9 L->R<\/td>\n<td>\n\t\t&lt;<br \/>\n\t\t&lt;=<br \/>\n\t\t&gt;<br \/>\n\t\t&gt;=\n\t<\/td>\n<td>\n\t\tComparison less than<br \/>\n\t\tComparison less than or equals<br \/>\n\t\tComparison greater than<br \/>\n\t\tComparison greater than or equals\n\t<\/td>\n<td>\n\t\texpression &lt; expression<br \/>\n\t\texpression &lt;= expression<br \/>\n\t\texpression &gt; expression<br \/>\n\t\texpression &gt;= expression\n\t<\/td>\n<\/tr>\n<tr>\n<td>10 L->R<\/td>\n<td>\n\t\t==<br \/>\n\t\t!=\n\t<\/td>\n<td>\n\t\tEquality<br \/>\n\t\tInequality\n\t<\/td>\n<td>\n\t\texpression == expression<br \/>\n\t\texpression != expression\n\t<\/td>\n<\/tr>\n<tr>\n<td>11 L->R<\/td>\n<td>\n\t\t&#038;\n\t<\/td>\n<td>\n\t\tBitwise AND\n\t<\/td>\n<td>\n\t\texpression &#038; expression\n\t<\/td>\n<\/tr>\n<tr>\n<td>12 L->R<\/td>\n<td>\n\t\t^\n\t<\/td>\n<td>\n\t\tBitwise XOR\n\t<\/td>\n<td>\n\t\texpression ^ expression\n\t<\/td>\n<\/tr>\n<tr>\n<td>13 L->R<\/td>\n<td>\n\t\t|\n\t<\/td>\n<td>\n\t\tBitwise OR\n\t<\/td>\n<td>\n\t\texpression | expression\n\t<\/td>\n<\/tr>\n<tr>\n<td>14 L->R<\/td>\n<td>\n\t\t&#038;&#038;<br \/>\n\t\tand\n\t<\/td>\n<td>\n\t\tLogical AND<br \/>\n\t\tLogical AND\n\t<\/td>\n<td>\n\t\texpression &#038;&#038; expression<br \/>\n\t\texpression and expression<\/p>\n<\/td>\n<\/tr>\n<tr>\n<td>15 L->R<\/td>\n<td>\n\t\t||<br \/>\n\t\tor\n\t<\/td>\n<td>\n\t\tLogical OR<br \/>\n\t\tLogical OR\n\t<\/td>\n<td>\n\t\texpression || expression<br \/>\n\t\texpression or expression\n\t<\/td>\n<\/tr>\n<tr>\n<td>16 R->L<\/td>\n<td>\n\t\tthrow<br \/>\n\t\tco_yield<br \/>\n\t\t?:<br \/>\n\t\t=<br \/>\n\t\t*=<br \/>\n\t\t\/=<br \/>\n\t\t%=<br \/>\n\t\t+=<br \/>\n\t\t-=<br \/>\n\t\t&lt;&lt;=<br \/>\n\t\t&gt;&gt;=<br \/>\n\t\t&#038;=<br \/>\n\t\t|=<br \/>\n\t\t^=\n\t<\/td>\n<td>\n\t\tThrow expression<br \/>\n\t\tYield expression (C++20)<br \/>\n\t\tConditional<br \/>\n\t\tAssignment<br \/>\n\t\tMultiplication assignment<br \/>\n\t\tDivision assignment<br \/>\n\t\tRemainder assignment<br \/>\n\t\tAddition assignment<br \/>\n\t\tSubtraction assignment<br \/>\n\t\tBitwise shift left assignment<br \/>\n\t\tBitwise shift right assignment<br \/>\n\t\tBitwise AND assignment<br \/>\n\t\tBitwise OR assignment<br \/>\n\t\tBitwise XOR assignment\n\t<\/td>\n<td>\n\t\tthrow expression<br \/>\n\t\tco_yield expression<br \/>\n\t\texpression ? expression : expression<br \/>\n\t\tlvalue = expression<br \/>\n\t\tlvalue *= expression<br \/>\n\t\tlvalue \/= expression<br \/>\n\t\tlvalue %= expression<br \/>\n\t\tlvalue += expression<br \/>\n\t\tlvalue -= expression<br \/>\n\t\tlvalue &lt;&lt;= expression<br \/>\n\t\tlvalue &gt;&gt;= expression<br \/>\n\t\tlvalue &#038;= expression<br \/>\n\t\tlvalue |= expression<br \/>\n\t\tlvalue ^= expression\n\t<\/td>\n<\/tr>\n<tr>\n<td>17 L->R<\/td>\n<td>\n\t\t,\n\t<\/td>\n<td>\n\t\tComma operator\n\t<\/td>\n<td>\n\t\texpression, expression\n\t<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>You should already recognize a few of these operators, such as <code>+<\/code>, <code>-<\/code>, <code>*<\/code>, <code>\/<\/code>, <code>()<\/code>, and <code>sizeof<\/code>.  However, unless you have experience with another programming language, the majority of the operators in this table will probably be incomprehensible to you right now.  That&#8217;s expected at this point.  We&#8217;ll cover many of them in this chapter, and the rest will be introduced as there is a need for them.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Q: Where is the exponent operator?<\/p>\n<p>C++ doesn&#8217;t include an operator to do exponentiation (<code>operator^<\/code> has a different function in C++).  We discuss exponentiation more in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/remainder-and-exponentiation\/\">6.3 -- Remainder and Exponentiation<\/a>.\n<\/div>\n<p>Note that <code>operator&lt;&lt;<\/code> handles both bitwise left shift and insertion, and <code>operator&gt;&gt;<\/code> handles both bitwise right shift and extraction.  The compiler can determine which operation to perform based on the types of the operands.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Parenthesization<\/p>\n<p>Due to the precedence rules, <code>4 + 2 * 3<\/code> will be grouped as <code>4 + (2 * 3)<\/code>.  But what if we actually meant <code>(4 + 2) * 3<\/code>?  Just like in normal mathematics, in C++ we can explicitly use parentheses to set the grouping of operands as we desire.  This works because parentheses have one of the highest precedence levels, so parentheses generally evaluate before whatever is inside them.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Use parenthesis to make compound expressions easier to understand<\/p>\n<p>Now consider an expression like <code>x &amp;&amp; y || z<\/code>.  Does this evaluate as <code>(x &amp;&amp; y) || z<\/code> or <code>x &amp;&amp; (y || z)<\/code>?  You could look up in the table and see that <code>&amp;&amp;<\/code> takes precedence over <code>||<\/code>.  But there are so many operators and precedence levels that it&#8217;s hard to remember them all.  And you don&#8217;t want to have to look up operators all the time to understand how a compound expression evaluates.<\/p>\n<p>In order to reduce mistakes and make your code easier to understand without referencing a precedence table, it&#8217;s a good idea to parenthesize any non-trivial compound expression, so it&#8217;s clear what your intent is.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Use parentheses to make it clear how a non-trivial compound expression should evaluate (even if they are technically unnecessary).\n<\/p><\/div>\n<p>A good rule of thumb is: Parenthesize everything, except addition, subtraction, multiplication, and division.<\/p>\n<p>There is one additional exception to the above best practice:  Expressions that have a single assignment operator (and no comma operator) do not need to have the right operand of the assignment wrapped in parenthesis.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">x = (y + z + w);   \/\/ instead of this\r\nx = y + z + w;     \/\/ it's okay to do this\r\n\r\nx = ((y || z) &amp;&amp; w); \/\/ instead of this\r\nx = (y || z) &amp;&amp; w;   \/\/ it's okay to do this\r\n\r\nx = (y *= z); \/\/ expressions with multiple assignments still benefit from parenthesis<\/code><\/pre>\n<p>The assignment operators have the second lowest precedence (only the comma operator is lower, and it&#8217;s rarely used).  Therefore, so long as there is only one assignment (and no commas), we know the right operand will fully evaluate before the assignment.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Expressions with a single assignment operator do not need to have the right operand of the assignment wrapped in parenthesis.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Value computation of operations<\/p>\n<p>The C++ standard uses the term <strong>value computation<\/strong> to mean the execution of operators in an expression to produce a value.  The precedence and association rules determine the order in which value computation happens.<\/p>\n<p>For example, given the expression <code>4 + 2 * 3<\/code>, due to the precedence rules this groups as <code>4 + (2 * 3)<\/code>.  The value computation for <code>(2 * 3)<\/code> must happen first, so that the value computation for <code>4 + 6<\/code> can be completed.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Evaluation of operands<\/p>\n<p>The C++ standard (mostly) uses the term <strong>evaluation<\/strong> to refer to the evaluation of operands (not the evaluation of operators or expressions!).  For example, given expression <code>a + b<\/code>, <code>a<\/code> will be evaluated to produce some value, and <code>b<\/code> will be evaluated to produce some value.  These values can be then used as operands to <code>operator+<\/code> for value computation.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Nomenclature<\/p>\n<p>Informally, we typically use the term &#8220;evaluates&#8221; to mean the evaluation of an entire expression (value computation), not just the operands of an expression.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><a name=\"unspecified\"><\/a>The order of evaluation of operands (including function arguments) is mostly unspecified <a href=\"#unspecified\"><i class=\"fa fa-link\" style=\"font-size: 0.8em;\"><\/i><\/a><\/p>\n<p>In most cases, the order of evaluation for operands and function arguments is unspecified, meaning they may be evaluated in any order.<\/p>\n<p>Consider the following expression:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">a * b + c * d<\/code><\/pre>\n<p>We know from the precedence and associativity rules above that this expression will be grouped as if we had typed:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">(a * b) + (c * d)<\/code><\/pre>\n<p>If <code>a<\/code> is <code>1<\/code>, <code>b<\/code> is <code>2<\/code>, <code>c<\/code> is <code>3<\/code>, and <code>d<\/code> is <code>4<\/code>, this expression will always compute the value <code>14<\/code>.<\/p>\n<p>However, the precedence and associativity rules only tell us how operators and operands are grouped and the order in which value computation will occur.  They do not tell us the order in which the operands or subexpressions are evaluated.  The compiler is free to evaluate operands <code>a<\/code>, <code>b<\/code>, <code>c<\/code>, or <code>d<\/code> in any order.  The compiler is also free to calculate <code>a * b<\/code> or <code>c * d<\/code> first.<\/p>\n<p>For most expressions, this is irrelevant.  In our sample expression above, it doesn&#8217;t matter in which order variables <code>a<\/code>, <code>b<\/code>, <code>c<\/code>, or <code>d<\/code> are evaluated for their values: the value calculated will always be <code>14<\/code>.  There is no ambiguity here.<\/p>\n<p>But it is possible to write expressions where the order of evaluation does matter.  Consider this program, which contains a mistake often made by new C++ programmers:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint getValue()\r\n{\r\n    std::cout &lt;&lt; \"Enter an integer: \";\r\n\r\n    int x{};\r\n    std::cin &gt;&gt; x;\r\n    return x;\r\n}\r\n\r\nvoid printCalculation(int x, int y, int z)\r\n{\r\n    std::cout &lt;&lt; x + (y * z);\r\n}\r\n\r\nint main()\r\n{\r\n    printCalculation(getValue(), getValue(), getValue()); \/\/ this line is ambiguous\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>If you run this program and enter the inputs <code>1<\/code>, <code>2<\/code>, and <code>3<\/code>, you might assume that this program would calculate <code>1 + (2 * 3)<\/code> and print <code>7<\/code>.  But that is making the assumption that the arguments to <code>printCalculation()<\/code> will evaluate in left-to-right order (so parameter <code>x<\/code> gets value <code>1<\/code>, <code>y<\/code> gets value <code>2<\/code>, and <code>z<\/code> gets value <code>3<\/code>).  If instead, the arguments evaluate in right-to-left order (so parameter <code>z<\/code> gets value <code>1<\/code>, <code>y<\/code> gets value <code>2<\/code>, and <code>x<\/code> gets value <code>3<\/code>), then the program will print <code>5<\/code> instead.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>The Clang compiler evaluates arguments in left-to-right order.  The GCC compiler evaluates arguments in right-to-left order.<\/p>\n<p>If you&#8217;d like to see this behavior for yourself, you can do so on <a href=\"https:\/\/wandbox.org\/#\">Wandbox<\/a>.  Paste in the above program, enter <code>1 2 3<\/code> in the <em>Stdin<\/em> tab, select GCC or Clang, and then compile the program.  The output will appear at the bottom of the page (you may have to scroll down to see it).  You will note that the output for GCC and Clang differs!\n<\/div>\n<p>The above program can be made unambiguous by making each function call to <code>getValue()<\/code> a separate statement:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint getValue()\r\n{\r\n    std::cout &lt;&lt; \"Enter an integer: \";\r\n\r\n    int x{};\r\n    std::cin &gt;&gt; x;\r\n    return x;\r\n}\r\n\r\nvoid printCalculation(int x, int y, int z)\r\n{\r\n    std::cout &lt;&lt; x + (y * z);\r\n}\r\n\r\nint main()\r\n{\r\n    int a{ getValue() }; \/\/ will execute first\r\n    int b{ getValue() }; \/\/ will execute second\r\n    int c{ getValue() }; \/\/ will execute third\r\n\r\n    printCalculation(a, b, c); \/\/ this line is now unambiguous\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this version, <code>a<\/code> will always have value <code>1<\/code>, <code>b<\/code> will have value <code>2<\/code>, and <code>c<\/code> will have value <code>3<\/code>.  When the arguments to <code>printCalculation()<\/code> are evaluated, it doesn&#8217;t matter which order the argument evaluation happens in -- parameter <code>x<\/code> will always get value <code>1<\/code>, <code>y<\/code> will get value <code>2<\/code>, and <code>z<\/code> will get value <code>3<\/code>.  This version will deterministically print <code>7<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Operands, function arguments, and subexpressions may be evaluated in any order.<\/p>\n<p>It is a common mistake to believe that operator precedence and associativity affects order of evaluation.  Precedence and associativity is used only to determine how operands are grouped with operators, and the order of value computation.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Ensure that the expressions (or function calls) you write are not dependent on operand (or argument) evaluation order.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>Operators with side effects can also cause unexpected evaluation results.  We cover this in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/increment-decrement-operators-and-side-effects\/\">6.4 -- Increment\/decrement operators, and side effects<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #1<\/p>\n<p>You know from everyday mathematics that expressions inside of parentheses get evaluated first.  For example, in the expression <code>(2 + 3) * 4<\/code>, the <code>(2 + 3)<\/code> part is evaluated first.<\/p>\n<p>For this exercise, you are given a set of expressions that have no parentheses.  Using the operator precedence and associativity rules in the table above, add parentheses to each expression to make it clear how the compiler will evaluate the expression.<\/p>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_0'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_0\" style=\"display:none; margin-bottom: 1em\">Hint: Use the pattern column in the table above to determine whether the operator is unary (has one operand) or binary (has two operands).  Review the lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-literals-and-operators\/\">1.9 -- Introduction to literals and operators<\/a> if you need a refresher on what unary and binary operators are.<\/div>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<td>\nSample problem: x = 2 + 3 % 4<\/p>\n<p>Binary operator <code>%<\/code> has higher precedence than operator <code>+<\/code> or operator <code>=<\/code>, so it gets evaluated first:<\/p>\n<p>x = 2 + (3 % 4)<\/p>\n<p>Binary operator <code>+<\/code> has a higher precedence than operator <code>=<\/code>, so it gets evaluated next:<\/p>\n<p>Final answer: x = (2 + (3 % 4))<\/p>\n<p>We now no longer need the table above to understand how this expression will evaluate.<\/p>\n<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>a) x = 3 + 4 + 5;<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>Binary operator <code>+<\/code> has higher precedence than <code>=<\/code>:<\/p>\n<p>x = (3 + 4 + 5);<\/p>\n<p>Binary operator <code>+<\/code> has left to right association:<\/p>\n<p>Final answer: x = ((3 + 4) + 5);\n<\/p><\/div>\n<p>b) x = y = z;<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p>Binary operator <code>=<\/code> has right to left association:<\/p>\n<p>Final answer: x = (y = z);\n<\/p><\/div>\n<p>c) z *= ++y + 5;<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<p>Unary operator <code>++<\/code> has the highest precedence:<\/p>\n<p>z *= (++y) + 5;<\/p>\n<p>Binary operator <code>+<\/code> has the next highest precedence:<\/p>\n<p>Final answer: z *= ((++y) + 5);\n<\/p><\/div>\n<p>d) a || b &#038;&#038; c || d;<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<p>Binary operator <code>&amp;&amp;<\/code> has higher precedence than <code>||<\/code>:<\/p>\n<p>a || (b &#038;&#038; c) || d;<\/p>\n<p>Binary operator <code>||<\/code> has left to right association:<\/p>\n<p>Final answer: (a || (b &#038;&#038; c)) || d;\n<\/p><\/div>\n<\/p>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/arithmetic-operators\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">6.2<\/span>Arithmetic operators\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-5-summary-and-quiz\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">5.x<\/span>Chapter 5 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>This chapter builds on top of the concepts from lesson . A quick review follows: An is a mathematical process involving zero or more input values (called ) that produces a new value (called an output value). The specific operation to be performed is denoted by a construct (typically a &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/54"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=54"}],"version-history":[{"count":87,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/54\/revisions"}],"predecessor-version":[{"id":18214,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/54\/revisions\/18214"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=54"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=54"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=54"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}