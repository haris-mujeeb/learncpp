{"id":541,"date":"2011-09-11T15:45:06","date_gmt":"2011-09-11T23:45:06","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=541"},"modified":"2021-10-21T11:03:01","modified_gmt":"2021-10-21T18:03:01","slug":"stl-algorithms-overview","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/stl-algorithms-overview\/","title":{"rendered":"21.4 &#8212; STL algorithms overview"},"content":{"rendered":"<p>In addition to container classes and iterators, STL also provides a number of generic algorithms for working with the elements of the container classes.  These allow you to do things like search, sort, insert, reorder, remove, and copy elements of the container class.<\/p>\n<p>Note that algorithms are implemented as functions that operate using iterators.  This means that each algorithm only needs to be implemented once, and it will generally automatically work for all containers that provides a set of iterators (including your custom container classes).  While this is very powerful and can lead to the ability to write complex code very quickly, it&#8217;s also got a dark side: some combination of algorithms and container types may not work, may cause infinite loops, or may work but be extremely poor performing.  So use these at your risk.<\/p>\n<p>STL provides quite a few algorithms -- we will only touch on some of the more common and easy to use ones here.  The rest (and the full details) will be saved for a chapter on STL algorithms.<\/p>\n<p>To use any of the STL algorithms, simply include the algorithm header file.<\/p>\n<p><strong>min_element and max_element<\/strong><\/p>\n<p>The <code>std::min_element<\/code> and <code>std::max_element<\/code> algorithms find the min and max element in a container class. <code>std::iota<\/code> generates a contiguous series of values.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt; \/\/ std::min_element and std::max_element\r\n#include &lt;iostream&gt;\r\n#include &lt;list&gt;\r\n#include &lt;numeric&gt; \/\/ std::iota\r\n\r\nint main()\r\n{\r\n    std::list&lt;int&gt; li(6);\r\n    \/\/ Fill li with numbers starting at 0.\r\n    std::iota(li.begin(), li.end(), 0);\r\n\r\n    std::cout &lt;&lt; *std::min_element(li.begin(), li.end()) &lt;&lt; ' '\r\n              &lt;&lt; *std::max_element(li.begin(), li.end()) &lt;&lt; '\\n';\r\n\t\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Prints:<\/p>\n<p>0 5<\/p>\n<p><strong>find (and list::insert)<\/strong><\/p>\n<p>In this example, we&#8217;ll use the <code>std::find()<\/code> algorithm to find a value in the list class, and then use the list::insert() function to add a new value into the list at that point.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;list&gt;\r\n#include &lt;numeric&gt;\r\n\r\nint main()\r\n{\r\n    std::list&lt;int&gt; li(6);\r\n    std::iota(li.begin(), li.end(), 0);\r\n\r\n    \/\/ Find the value 3 in the list\r\n    auto it{ std::find(li.begin(), li.end(), 3) };\r\n    \r\n    \/\/ Insert 8 right before 3.\r\n    li.insert(it, 8);\r\n\r\n    for (int i : li) \/\/ for loop with iterators\r\n        std::cout &lt;&lt; i &lt;&lt; ' ';\r\n    \t\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints the values<\/p>\n<pre>\r\n0 1 2 8 3 4 5\r\n<\/pre>\n<p>When a searching algorithm doesn&#8217;t find what it was looking for, it returns the end iterator.<br \/>\nIf we didn&#8217;t know for sure that 3 is an element of <code>li<\/code>, we&#8217;d have to check if <code>std::find<\/code> found it before we use the returned iterator for anything else.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">if (it == li.end())\r\n{\r\n  std::cout &lt;&lt; \"3 was not found\\n\";\r\n}\r\nelse\r\n{\r\n  \/\/ ...\r\n}<\/code><\/pre>\n<p><strong>sort and reverse<\/strong><\/p>\n<p>In this example, we&#8217;ll sort a vector and then reverse it.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include &lt;algorithm&gt;\r\n\r\nint main()\r\n{\r\n    std::vector&lt;int&gt; vect{ 7, -3, 6, 2, -5, 0, 4 };\r\n\r\n    \/\/ sort the vector\r\n    std::sort(vect.begin(), vect.end());\r\n\r\n    for (int i : vect)\r\n    {\r\n        std::cout &lt;&lt; i &lt;&lt; ' ';\r\n    }\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    \/\/ reverse the vector\r\n    std::reverse(vect.begin(), vect.end());\r\n\r\n    for (int i : vect)\r\n    {\r\n        std::cout &lt;&lt; i &lt;&lt; ' ';\r\n    }\r\n \t\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This produces the result:<\/p>\n<pre>\r\n-5 -3 0 2 4 6 7\r\n7 6 4 2 0 -3 -5\r\n<\/pre>\n<p>Alternatively, we could pass a custom comparison function as the third argument to <code>std::sort<\/code>. There are several comparison functions in the &lt;functional> header which we can use so we don&#8217;t have to write our own. We can pass <code>std::greater<\/code> to <code>std::sort<\/code> and remove the call to <code>std::reverse<\/code>. The vector will be sorted from high to low right away.<\/p>\n<p>Note that <code>std::sort()<\/code> doesn&#8217;t work on list container classes -- the list class provides its own <code>sort()<\/code> member function, which is much more efficient than the generic version would be.<\/p>\n<p><strong>Conclusion<\/strong><\/p>\n<p>Although this is just a taste of the algorithms that STL provides, it should suffice to show how easy these are to use in conjunction with iterators and the basic container classes.  There are enough other algorithms to fill up a whole chapter!<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdstring-and-stdwstring\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">22.1<\/span>std::string and std::wstring\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stl-iterators-overview\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.3<\/span>STL iterators overview\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In addition to container classes and iterators, STL also provides a number of generic algorithms for working with the elements of the container classes. These allow you to do things like search, sort, insert, reorder, remove, and copy elements of the container class. Note that algorithms are implemented as functions &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/541"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=541"}],"version-history":[{"count":17,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/541\/revisions"}],"predecessor-version":[{"id":12147,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/541\/revisions\/12147"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=541"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=541"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=541"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}