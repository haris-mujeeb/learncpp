{"id":3967,"date":"2016-04-19T17:05:32","date_gmt":"2016-04-20T01:05:32","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=3967"},"modified":"2024-12-01T21:30:52","modified_gmt":"2024-12-02T05:30:52","slug":"scope-duration-and-linkage-summary","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/scope-duration-and-linkage-summary\/","title":{"rendered":"7.12 &#8212; Scope, duration, and linkage summary"},"content":{"rendered":"<p>The concepts of scope, duration, and linkage cause a lot of confusion, so we&#8217;re going to take an extra lesson to summarize everything.  Some of these things we haven&#8217;t covered yet, and they&#8217;re here just for completeness \/ reference later.<\/p>\n<p style=\"clear: both\">\n<p> <!-- break around image --><\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Scope summary<\/p>\n<p>An identifier\u2019s <em>scope<\/em> determines where the identifier can be accessed within the source code.<\/p>\n<ul>\n<li>Variables with <strong>block (local) scope<\/strong> can only be accessed from the point of declaration until the end of the block in which they are declared (including nested blocks).  This includes:<\/li>\n<ul>\n<li>Local variables<\/li>\n<li>Function parameters<\/li>\n<li>Program-defined type definitions (such as enums and classes) declared inside a block<\/li>\n<\/ul>\n<li>Variables and functions with <strong>global scope<\/strong> can be accessed from the point of declaration until the end of the file.  This includes:<\/li>\n<ul>\n<li>Global variables<\/li>\n<li>Functions<\/li>\n<li>Program-defined type definitions (such as enums and classes) declared inside a namespace or in the global scope<\/li>\n<\/ul>\n<\/ul>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Duration summary<\/p>\n<p>A variable\u2019s <em>duration<\/em> determines when it is created and destroyed.<\/p>\n<ul>\n<li>Variables with <strong>automatic duration<\/strong> are created at the point of definition, and destroyed when the block they are part of is exited.  This includes:<\/li>\n<ul>\n<li>Local variables<\/li>\n<li>Function parameters<\/li>\n<\/ul>\n<li>Variables with <strong>static duration<\/strong> are created when the program begins and destroyed when the program ends.  This includes:<\/li>\n<ul>\n<li>Global variables<\/li>\n<li>Static local variables<\/li>\n<\/ul>\n<\/li>\n<li>Variables with <strong>dynamic duration<\/strong> are created and destroyed by programmer request.  This includes:<\/li>\n<ul>\n<li>Dynamically allocated variables<\/li>\n<\/ul>\n<\/ul>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Linkage summary<\/p>\n<p>An identifier&#8217;s <strong>linkage<\/strong> determines whether a declaration of that same identifier in a different scope refers to the same entity (object, function, reference, etc&#8230;) or not.  <\/p>\n<p>Local variables have no linkage.  Each declaration of an identifier with no linkage refers to a unique object or function.<\/p>\n<ul>\n<li>An identifier with <strong>no linkage<\/strong> means another declaration of the same identifier refers to a unique entity.  Entities whose identifiers have no linkage include:<\/li>\n<ul>\n<li>Local variables<\/li>\n<li>Program-defined type identifiers (such as enums and classes) declared inside a block<\/li>\n<\/ul>\n<li>An identifier with <strong>internal linkage<\/strong> means a declaration of the same identifier within the same translation unit refers to the same object or function.  Entities whose identifiers have internal linkage include:<\/li>\n<ul>\n<li>Static global variables (initialized or uninitialized)<\/li>\n<li>Static functions<\/li>\n<li>Const global variables<\/li>\n<li>Unnamed namespaces and anything defined within them<\/li>\n<\/ul>\n<li>An identifier with <strong>external linkage<\/strong> means a declaration of the same identifier within the entire program refers to the same object or function.  Entities whose identifiers have external linkage include:<\/li>\n<ul>\n<li>Non-static functions<\/li>\n<li>Non-const global variables (initialized or uninitialized)<\/li>\n<li>Extern const global variables<\/li>\n<li>Inline const global variables<\/li>\n<li>Namespaces<\/li>\n<\/ul>\n<\/ul>\n<p>Identifiers with external linkage will generally cause a duplicate definition linker error if the definitions are compiled into more than one .cpp file (due to violating the one-definition rule).  There are some exceptions to this rule (for types, templates, and inline functions and variables) -- we&#8217;ll cover these further in future lessons when we talk about those topics.<\/p>\n<p>Also note that functions have external linkage by default.  They can be made internal by using the static keyword.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Variable scope, duration, and linkage summary<\/p>\n<p>Because variables have scope, duration, and linkage, let&#8217;s summarize in a chart:<\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<th>Type<\/th>\n<th>Example<\/th>\n<th>Scope<\/th>\n<th>Duration<\/th>\n<th>Linkage<\/th>\n<th>Notes<\/th>\n<\/tr>\n<tr>\n<td>Local variable<\/td>\n<td>int x;<\/td>\n<td>Block<\/td>\n<td>Automatic<\/td>\n<td>None<\/td>\n<td><\/td>\n<\/tr>\n<tr>\n<td>Static local variable<\/td>\n<td>static int s_x;<\/td>\n<td>Block<\/td>\n<td>Static<\/td>\n<td>None<\/td>\n<td><\/td>\n<\/tr>\n<tr>\n<td>Dynamic local variable<\/td>\n<td>int* x { new int{} };<\/td>\n<td>Block<\/td>\n<td>Dynamic<\/td>\n<td>None<\/td>\n<td><\/td>\n<\/tr>\n<tr>\n<td>Function parameter<\/td>\n<td>void foo(int x)<\/td>\n<td>Block<\/td>\n<td>Automatic<\/td>\n<td>None<\/td>\n<td><\/td>\n<\/tr>\n<tr>\n<td>Internal non-const global variable<\/td>\n<td>static int g_x;<\/td>\n<td>Global<\/td>\n<td>Static<\/td>\n<td>Internal<\/td>\n<td>Initialized or uninitialized<\/td>\n<\/tr>\n<tr>\n<td>External non-const global variable<\/td>\n<td>int g_x;<\/td>\n<td>Global<\/td>\n<td>Static<\/td>\n<td>External<\/td>\n<td>Initialized or uninitialized<\/td>\n<\/tr>\n<tr>\n<td>Inline non-const global variable (C++17)<\/td>\n<td>inline int g_x;<\/td>\n<td>Global<\/td>\n<td>Static<\/td>\n<td>External<\/td>\n<td>Initialized or uninitialized<\/td>\n<\/tr>\n<tr>\n<td>Internal constant global variable<\/td>\n<td>constexpr int g_x { 1 };<\/td>\n<td>Global<\/td>\n<td>Static<\/td>\n<td>Internal<\/td>\n<td>Must be initialized<\/td>\n<\/tr>\n<tr>\n<td>External constant global variable<\/td>\n<td>extern const int g_x { 1 };<\/td>\n<td>Global<\/td>\n<td>Static<\/td>\n<td>External<\/td>\n<td>Must be initialized<\/td>\n<\/tr>\n<tr>\n<td>Inline constant global variable (C++17)<\/td>\n<td>inline constexpr int g_x { 1 };<\/td>\n<td>Global<\/td>\n<td>Static<\/td>\n<td>External<\/td>\n<td>Must be initialized<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Forward declaration summary<\/p>\n<p>You can use a forward declaration to access a function or variable in another file.  The scope of the declared variable is as per usual (global scope for globals, block scope for locals).<\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<th>Type<\/th>\n<th>Example<\/th>\n<th>Notes<\/th>\n<\/tr>\n<tr>\n<td>Function forward declaration<\/td>\n<td>void foo(int x);<\/td>\n<td>Prototype only, no function body<\/td>\n<\/tr>\n<tr>\n<td>Non-constant variable forward declaration<\/td>\n<td>extern int g_x;<\/td>\n<td>Must be uninitialized<\/td>\n<\/tr>\n<tr>\n<td>Const variable forward declaration<\/td>\n<td>extern const int g_x;<\/td>\n<td>Must be uninitialized<\/td>\n<\/tr>\n<tr>\n<td>Constexpr variable forward declaration<\/td>\n<td>extern constexpr int g_x;<\/td>\n<td>Not allowed, constexpr cannot be forward declared<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>A constexpr variable (which is implicitly const) can be forward declared using a const variable forward declaration.  When accessed through the forward declaration, the variable will be considered const (not constexpr).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">What the heck is a storage class specifier?<\/p>\n<p>When used as part of an identifier declaration, the <code>static<\/code> and <code>extern<\/code> keywords are called <strong>storage class specifiers<\/strong>.  In this context, they set the storage duration and linkage of the identifier.<\/p>\n<p>C++ supports 4 active storage class specifiers:<\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<th>Specifier<\/th>\n<th>Meaning<\/th>\n<th>Note<\/th>\n<\/tr>\n<tr>\n<td>extern<\/td>\n<td>static (or thread_local) storage duration and external linkage<\/td>\n<td><\/td>\n<\/tr>\n<tr>\n<td>static<\/td>\n<td>static (or thread_local) storage duration and internal linkage<\/td>\n<td><\/td>\n<\/tr>\n<tr>\n<td>thread_local<\/td>\n<td>thread storage duration<\/td>\n<td><\/td>\n<\/tr>\n<tr>\n<td>mutable<\/td>\n<td>object allowed to be modified even if containing class is const<\/td>\n<td><\/td>\n<\/tr>\n<tr>\n<td>auto<\/td>\n<td>automatic storage duration<\/td>\n<td>Deprecated in C++11<\/td>\n<\/tr>\n<tr>\n<td>register<\/td>\n<td>automatic storage duration and hint to the compiler to place in a register<\/td>\n<td>Deprecated in C++17<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>The term <em>storage class specifier<\/em> is typically only used in formal documentation.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/using-declarations-and-using-directives\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.13<\/span>Using declarations and using directives\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/static-local-variables\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.11<\/span>Static local variables\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>The concepts of scope, duration, and linkage cause a lot of confusion, so we&#8217;re going to take an extra lesson to summarize everything. Some of these things we haven&#8217;t covered yet, and they&#8217;re here just for completeness \/ reference later. An identifier\u2019s scope determines where the identifier can be accessed &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/3967"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=3967"}],"version-history":[{"count":48,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/3967\/revisions"}],"predecessor-version":[{"id":17925,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/3967\/revisions\/17925"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=3967"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=3967"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=3967"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}