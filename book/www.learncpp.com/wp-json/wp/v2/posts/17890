{"id":17890,"date":"2024-11-26T16:16:29","date_gmt":"2024-11-27T00:16:29","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=17890"},"modified":"2024-12-10T00:05:33","modified_gmt":"2024-12-10T08:05:33","slug":"constexpr-functions-part-2","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-functions-part-2\/","title":{"rendered":"F.2 &#8212; Constexpr functions (part 2)"},"content":{"rendered":"<p class=\"cpp-section\">Constexpr function calls in non-required constant expressions<\/p>\n<p>You might expect that a constexpr function would evaluate at compile-time whenever possible, but unfortunately this is not the case.<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constant-expressions\/\">5.5 -- Constant expressions<\/a>, we noted that in contexts that do not <em>require<\/em> a constant expression, the compiler may choose whether to evaluate a constant expression at either compile-time or at runtime.  Accordingly, any constexpr function call that is part of a non-required constant expression may be evaluated at either compile-time or runtime.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nconstexpr int getValue(int x)\r\n{\r\n    return x;\r\n}\r\n\r\nint main()\r\n{\r\n    int x { getValue(5) }; \/\/ may evaluate at runtime or compile-time\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, because <code>getValue()<\/code> is constexpr, the call <code>getValue(5)<\/code> is a constant expression.  However, because variable <code>x<\/code> is not constexpr, it does not require a constant expression initializer.  So even though we&#8217;ve provided a constant expression initializer, the compiler is free to choose whether <code>getValue(5)<\/code> evaluates at runtime or compile-time.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Compile-time evaluation of constexpr functions is only guaranteed when a constant expression is required.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Diagnosis of constexpr functions in required constant expressions<\/p>\n<p>The compiler is <em>not<\/em> required to determine whether a constexpr function is evaluatable at compile-time until it is actually evaluated at compile-time.  It is fairly easy to write a constexpr function that compiles successfully for runtime use, but then fails to compile when evaluated at compile-time.<\/p>\n<p>As a silly example of this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint getValue(int x)\r\n{\r\n    return x;\r\n}\r\n\r\n\/\/ This function can be evaluated at runtime\r\n\/\/ When evaluated at compile-time, the function will produce a compilation error\r\n\/\/ because the call to getValue(x) cannot be resolved at compile-time\r\nconstexpr int foo(int x)\r\n{\r\n    if (x &lt; 0) return 0; \/\/ needed prior to adoption of P2448R1 in C++23 (see note below)\r\n    return getValue(x);  \/\/ call to non-constexpr function here\r\n}\r\n\r\nint main()\r\n{\r\n    int x { foo(5) };           \/\/ okay: will evaluate at runtime\r\n    constexpr int y { foo(5) }; \/\/ compile error: foo(5) can't evaluate at compile-time\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, when <code>foo(5)<\/code> is used as an initializer for non-constexpr variable <code>x<\/code>, it will be evaluated at runtime.  This works fine, and returns the value <code>5<\/code>.<\/p>\n<p>However, when <code>foo(5)<\/code>, is used as an initializer for constexpr variable <code>y<\/code>, it must be evaluated at compile-time.  At that point, the compiler will determine that the call to <code>foo(5)<\/code> can&#8217;t be evaluated at compile-time, as <code>getValue()<\/code> is not a constexpr function.<\/p>\n<p>Therefore, when writing a constexpr function, always explicitly test that it compiles when evaluated at compile-time (by calling it in a context where a constant expression is required, such as in the initialization of a constexpr variable).<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>All constexpr functions should be evaluatable at compile-time, as they will be required to do so in contexts that require a constant expression.<\/p>\n<p>Always test your constexpr functions in a context that requires a constant expression, as the constexpr function may work when evaluated at runtime but fail when evaluated at compile-time.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Prior to C++23, if no argument values exist that would allow a constexpr function to be evaluated at compile-time, the program is ill-formed (no diagnostic required).  Without the line <code>if (x &lt; 0) return 0<\/code>, the above example would contain no set of arguments that allow the function to be evaluatable at compile-time, making the program ill-formed.  Given that no diagnostic is required, the compiler may not enforce this.<\/p>\n<p>This requirement was revoked in C++23 (<a href=\"https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2022\/p2448r1.html\">P2448R1<\/a>).\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constexpr\/consteval function parameters are not constexpr<\/p>\n<p>The parameters of a constexpr function are not implicitly constexpr, nor may they be declared as <code>constexpr<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>A constexpr function parameter would imply the function could only be called with a constexpr argument.  But this is not the case -- constexpr functions can be called with non-constexpr arguments when the function is evaluated at runtime.\n<\/p><\/div>\n<p>Because such parameters are not constexpr, they cannot be used in constant expressions within the function.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">consteval int goo(int c)    \/\/ c is not constexpr, and cannot be used in constant expressions\r\n{\r\n    return c;\r\n}\r\n\r\nconstexpr int foo(int b)    \/\/ b is not constexpr, and cannot be used in constant expressions\r\n{\r\n    constexpr int b2 { b }; \/\/ compile error: constexpr variable requires constant expression initializer\r\n\r\n    return goo(b);          \/\/ compile error: consteval function call requires constant expression argument\r\n}\r\n\r\nint main()\r\n{\r\n    constexpr int a { 5 };\r\n\r\n    std::cout &lt;&lt; foo(a); \/\/ okay: constant expression a can be used as argument to constexpr function foo()\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, function parameter <code>b<\/code> is not constexpr (even though argument <code>a<\/code> is a constant expression).  This means <code>b<\/code> cannot be used anywhere a constant expression is required, such as the the initializer for a constexpr variable (e.g. <code>b2<\/code>) or in a call to a consteval function (<code>goo(b)<\/code>).<\/p>\n<p>The parameters of constexpr functions may be declared as <code>const<\/code>, in which case they are treated as runtime constants.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>If you need parameters that are constant expressions, see <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/non-type-template-parameters\/\">11.9 -- Non-type template parameters<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constexpr functions are implicitly inline<\/p>\n<p>When a constexpr function is evaluated at compile-time, the compiler must be able to see the full definition of the constexpr function prior to such function calls (so it can perform the evaluation itself).  A forward declaration will not suffice in this case, even if the actual function definition appears later in the same compilation unit.<\/p>\n<p>This means that a constexpr function called in multiple files needs to have its definition included into each translation unit -- which would normally be a violation of the one-definition rule.  To avoid such problems, constexpr functions are implicitly inline, which makes them exempt from the one-definition rule.<\/p>\n<p>As a result, constexpr functions are often defined in header files, so they can be #included into any .cpp file that requires the full definition.<\/p>\n<div class=\"cpp-note cpp-lightpurplebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Rule<\/p>\n<p>The compiler must be able to see the full definition of a constexpr (or consteval) function, not just a forward declaration.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Constexpr\/consteval functions used in a single source file (.cpp) should be defined in the source file above where they are used.<\/p>\n<p>Constexpr\/consteval functions used in multiple source files should be defined in a header file so they can be included into each source file.\n<\/p><\/div>\n<p>For constexpr function calls that are only evaluated at runtime, a forward declaration is sufficient to satisfy the compiler.  This means you can use a forward declaration to call a constexpr function defined in another translation unit, but only if you invoke it in a context that does not require compile-time evaluation.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Per <a href=\"https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/cwg_active.html#2166\">CWG2166<\/a>, the actual requirement for the forward declaration of constexpr functions that are evaluated at compile-time is that &#8220;the constexpr function must be defined prior to the outermost evaluation that eventually results in the invocation&#8221;.  Therefore, this is allowed:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nconstexpr int foo(int);\r\n\r\nconstexpr int goo(int c)\r\n{\r\n\treturn foo(c);   \/\/ note that foo is not defined yet\r\n}\r\n\r\nconstexpr int foo(int b) \/\/ okay because foo is still defined before any calls to goo\r\n{\r\n\treturn b;\r\n}\r\n\r\nint main()\r\n{\r\n\t constexpr int a{ goo(5) }; \/\/ this is the outermost invocation\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>The intent here is to allow for mutually recursive constexpr functions (where two constexpr functions call each other), which would not be possible otherwise.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Recap<\/p>\n<p>Marking a function as <code>constexpr<\/code> means it can be used in a constant expression.  It does not mean &#8220;will evaluate at compile-time&#8221;.<\/p>\n<p>A constant expression (which may contain constexpr function calls) is only required to evaluate at compile-time in contexts where a constant expression is required.<\/p>\n<p>In contexts that do not require a constant expression, the compiler may choose whether to evaluate a constant expression (which may contain constexpr function calls) at compile-time or at runtime.<\/p>\n<p>A runtime (non-constant) expression (which may contain constexpr function calls or non-constexpr function calls) will evaluate at runtime.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Another example<\/p>\n<p>Let&#8217;s do another examine to explore how a constexpr function is required or likely to evaluate further:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nconstexpr int greater(int x, int y)\r\n{\r\n    return (x &gt; y ? x : y);\r\n}\r\n\r\nint main()\r\n{\r\n    constexpr int g { greater(5, 6) };              \/\/ case 1: always evaluated at compile-time\r\n    std::cout &lt;&lt; g &lt;&lt; \" is greater!\\n\";\r\n\r\n    std::cout &lt;&lt; greater(5, 6) &lt;&lt; \" is greater!\\n\"; \/\/ case 2: may be evaluated at either runtime or compile-time\r\n\r\n    int x{ 5 }; \/\/ not constexpr but value is known at compile-time\r\n    std::cout &lt;&lt; greater(x, 6) &lt;&lt; \" is greater!\\n\"; \/\/ case 3: likely evaluated at runtime\r\n\r\n    std::cin &gt;&gt; x;\r\n    std::cout &lt;&lt; greater(x, 6) &lt;&lt; \" is greater!\\n\"; \/\/ case 4: always evaluated at runtime\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In case 1, we&#8217;re calling <code>greater()<\/code> in a context that requires a constant expression.  Thus <code>greater()<\/code> must be evaluated at compile-time.<\/p>\n<p>In case 2, the <code>greater()<\/code> function is being called in a context that does not require a constant expression, as output statements must execute at runtime.  However, since the arguments are constant expressions, the function is eligible to be evaluated at compile-time.  Thus the compiler is free to choose whether this call to <code>greater()<\/code> will be evaluated at compile-time or runtime.<\/p>\n<p>In case 3, we&#8217;re calling <code>greater()<\/code> with one argument that is not a constant expression.  So this will typically execute at runtime.<\/p>\n<p>However, this argument has a value that is known at compile-time.  Under the as-if rule, the compiler could decide to treat the evaluation of <code>x<\/code> as a constant expression, and evaluate this call to <code>greater()<\/code> at compile-time.  But more likely, it will evaluate it at runtime.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover the as-if rule in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constant-expressions\/\">5.5 -- Constant expressions<\/a>.<\/p>\n<p>Note that even non-constexpr functions could be evaluated at compile-time under the as-if rule!\n<\/p><\/div>\n<p>In case 4, the value of argument <code>x<\/code> can&#8217;t be known at compile-time, so this call to <code>greater()<\/code> will always evaluate at runtime.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Put another way, we can categorize the likelihood that a function will actually be evaluated at compile-time as follows:<\/p>\n<p>Always (required by the standard):<\/p>\n<ul>\n<li>Constexpr function is called where constant expression is required.\n<\/li>\n<li>Constexpr function is called from other function being evaluated at compile-time.\n<\/li>\n<\/ul>\n<p>Probably (there&#8217;s little reason not to):<\/p>\n<ul>\n<li>Constexpr function is called where constant expression isn&#8217;t required, all arguments are constant expressions.\n<\/li>\n<\/ul>\n<p>Possibly (if optimized under the as-if rule):<\/p>\n<ul>\n<li>Constexpr function is called where constant expression isn&#8217;t required, some arguments are not constant expressions but their values are known at compile-time.\n<\/li>\n<li>Non-constexpr function capable of being evaluated at compile-time, all arguments are constant expressions.\n<\/li>\n<\/ul>\n<p>Never (not possible):<\/p>\n<ul>\n<li>Constexpr function is called where constant expression isn&#8217;t required, some arguments have values that are not known at compile-time.\n<\/li>\n<\/ul>\n<\/div>\n<p>Note that your compiler&#8217;s optimization level setting may have an impact on whether it decides to evaluate a function at compile-time or runtime.  This also means that your compiler may make different choices for debug vs. release builds (as debug builds typically have optimizations turned off).<\/p>\n<p>For example, both gcc and Clang will not compile-time evaluate a constexpr function called where a constant expression isn&#8217;t required unless the compiler told to optimize the code (e.g. using the <code>-O2<\/code> compiler option).<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>The compiler might also choose to inline a function call, or even optimize a function call away entirely.  Both of these can affect when (or if) the content of the function call are evaluated.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-functions-part-3-and-consteval\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">F.3<\/span>Constexpr functions (part 3) and consteval\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-functions\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">F.1<\/span>Constexpr functions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Constexpr function calls in non-required constant expressions You might expect that a constexpr function would evaluate at compile-time whenever possible, but unfortunately this is not the case. In lesson , we noted that in contexts that do not require a constant expression, the compiler may choose whether to evaluate a &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/17890"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=17890"}],"version-history":[{"count":6,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/17890\/revisions"}],"predecessor-version":[{"id":17975,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/17890\/revisions\/17975"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=17890"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=17890"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=17890"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}