{"id":179,"date":"2008-01-29T15:45:11","date_gmt":"2008-01-29T23:45:11","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/121-pointers-and-references-to-the-base-class-of-derived-objects\/"},"modified":"2024-11-25T16:38:20","modified_gmt":"2024-11-26T00:38:20","slug":"pointers-and-references-to-the-base-class-of-derived-objects","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/pointers-and-references-to-the-base-class-of-derived-objects\/","title":{"rendered":"25.1 &#8212; Pointers and references to the base class of derived objects"},"content":{"rendered":"<p>In the previous chapter, you learned all about how to use inheritance to derive new classes from existing classes.  In this chapter, we are going to focus on one of the most important and powerful aspects of inheritance -- virtual functions.<\/p>\n<p>But before we discuss what virtual functions are, let&#8217;s first set the table for why we need them.<\/p>\n<p>In the chapter on <a href=\"http:\/\/www.learncpp.com\/cpp-tutorial\/113-order-of-construction-of-derived-classes\/\">construction of derived classes<\/a>, you learned that when you create a derived class, it is composed of multiple parts: one part for each inherited class, and a part for itself.<\/p>\n<p>For example, here&#8217;s a simple case:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string_view&gt;\r\n\r\nclass Base\r\n{\r\nprotected:\r\n    int m_value {};\r\n\r\npublic:\r\n    Base(int value)\r\n        : m_value{ value }\r\n    {\r\n    }\r\n\r\n    std::string_view getName() const { return \"Base\"; }\r\n    int getValue() const { return m_value; }\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\npublic:\r\n    Derived(int value)\r\n        : Base{ value }\r\n    {\r\n    }\r\n\r\n    std::string_view getName() const { return \"Derived\"; }\r\n    int getValueDoubled() const { return m_value * 2; }\r\n};<\/code><\/pre>\n<p>When we create a Derived object, it contains a Base part (which is constructed first), and a Derived part (which is constructed second).  Remember that inheritance implies an is-a relationship between two classes.  Since a Derived is-a Base, it is appropriate that Derived contain a Base part.<\/p>\n<p><strong>Pointers, references, and derived classes<\/strong><\/p>\n<p>It should be fairly intuitive that we can set Derived pointers and references to Derived objects:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    Derived derived{ 5 };\r\n    std::cout &lt;&lt; \"derived is a \" &lt;&lt; derived.getName() &lt;&lt; \" and has value \" &lt;&lt; derived.getValue() &lt;&lt; '\\n';\r\n\r\n    Derived&amp; rDerived{ derived };\r\n    std::cout &lt;&lt; \"rDerived is a \" &lt;&lt; rDerived.getName() &lt;&lt; \" and has value \" &lt;&lt; rDerived.getValue() &lt;&lt; '\\n';\r\n\r\n    Derived* pDerived{ &amp;derived };\r\n    std::cout &lt;&lt; \"pDerived is a \" &lt;&lt; pDerived-&gt;getName() &lt;&lt; \" and has value \" &lt;&lt; pDerived-&gt;getValue() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This produces the following output:<\/p>\n<pre>\r\nderived is a Derived and has value 5\r\nrDerived is a Derived and has value 5\r\npDerived is a Derived and has value 5\r\n<\/pre>\n<p>However, since Derived has a Base part, a more interesting question is whether C++ will let us set a Base pointer or reference to a Derived object.  It turns out, we can!<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    Derived derived{ 5 };\r\n\r\n    \/\/ These are both legal!\r\n    Base&amp; rBase{ derived }; \/\/ rBase is an lvalue reference (not an rvalue reference)\r\n    Base* pBase{ &amp;derived };\r\n\r\n    std::cout &lt;&lt; \"derived is a \" &lt;&lt; derived.getName() &lt;&lt; \" and has value \" &lt;&lt; derived.getValue() &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"rBase is a \" &lt;&lt; rBase.getName() &lt;&lt; \" and has value \" &lt;&lt; rBase.getValue() &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"pBase is a \" &lt;&lt; pBase-&gt;getName() &lt;&lt; \" and has value \" &lt;&lt; pBase-&gt;getValue() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This produces the result:<\/p>\n<pre>\r\nderived is a Derived and has value 5\r\nrBase is a Base and has value 5\r\npBase is a Base and has value 5\r\n<\/pre>\n<p>This result may not be quite what you were expecting at first!<\/p>\n<p>It turns out that because rBase and pBase are a Base reference and pointer, they can only see members of Base (or any classes that Base inherited).  So even though Derived::getName() shadows (hides) Base::getName() for Derived objects, the Base pointer\/reference can not see Derived::getName().  Consequently, they call Base::getName(), which is why rBase and pBase report that they are a Base rather than a Derived.<\/p>\n<p>Note that this also means it is not possible to call Derived::getValueDoubled() using rBase or pBase.  They are unable to see anything in Derived.<\/p>\n<p>Here&#8217;s another slightly more complex example that we&#8217;ll build on in the next lesson:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n#include &lt;string&gt;\r\n\r\nclass Animal\r\n{\r\nprotected:\r\n    std::string m_name;\r\n\r\n    \/\/ We're making this constructor protected because\r\n    \/\/ we don't want people creating Animal objects directly,\r\n    \/\/ but we still want derived classes to be able to use it.\r\n    Animal(std::string_view name)\r\n        : m_name{ name }\r\n    {\r\n    }\r\n    \r\n    \/\/ To prevent slicing (covered later)\r\n    Animal(const Animal&amp;) = delete;\r\n    Animal&amp; operator=(const Animal&amp;) = delete;\r\n\r\npublic:\r\n    std::string_view getName() const { return m_name; }\r\n    std::string_view speak() const { return \"???\"; }\r\n};\r\n\r\nclass Cat: public Animal\r\n{\r\npublic:\r\n    Cat(std::string_view name)\r\n        : Animal{ name }\r\n    {\r\n    }\r\n\r\n    std::string_view speak() const { return \"Meow\"; }\r\n};\r\n\r\nclass Dog: public Animal\r\n{\r\npublic:\r\n    Dog(std::string_view name)\r\n        : Animal{ name }\r\n    {\r\n    }\r\n\r\n    std::string_view speak() const { return \"Woof\"; }\r\n};\r\n\r\nint main()\r\n{\r\n    const Cat cat{ \"Fred\" };\r\n    std::cout &lt;&lt; \"cat is named \" &lt;&lt; cat.getName() &lt;&lt; \", and it says \" &lt;&lt; cat.speak() &lt;&lt; '\\n';\r\n\r\n    const Dog dog{ \"Garbo\" };\r\n    std::cout &lt;&lt; \"dog is named \" &lt;&lt; dog.getName() &lt;&lt; \", and it says \" &lt;&lt; dog.speak() &lt;&lt; '\\n';\r\n\r\n    const Animal* pAnimal{ &amp;cat };\r\n    std::cout &lt;&lt; \"pAnimal is named \" &lt;&lt; pAnimal-&gt;getName() &lt;&lt; \", and it says \" &lt;&lt; pAnimal-&gt;speak() &lt;&lt; '\\n';\r\n\r\n    pAnimal = &amp;dog;\r\n    std::cout &lt;&lt; \"pAnimal is named \" &lt;&lt; pAnimal-&gt;getName() &lt;&lt; \", and it says \" &lt;&lt; pAnimal-&gt;speak() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This produces the result:<\/p>\n<pre>\r\ncat is named Fred, and it says Meow\r\ndog is named Garbo, and it says Woof\r\npAnimal is named Fred, and it says ???\r\npAnimal is named Garbo, and it says ???\r\n<\/pre>\n<p>We see the same issue here.  Because pAnimal is an Animal pointer, it can only see the Animal portion of the class.  Consequently, <code>pAnimal-&gt;speak()<\/code> calls Animal::speak() rather than the Dog::Speak() or Cat::speak() function.<\/p>\n<p><strong>Use for pointers and references to base classes<\/strong><\/p>\n<p>Now you might be saying, &#8220;The above examples seem kind of silly.  Why would I set a pointer or reference to the base class of a derived object when I can just use the derived object?&#8221;  It turns out that there are quite a few good reasons.<\/p>\n<p>First, let&#8217;s say you wanted to write a function that printed an animal&#8217;s name and sound.  Without using a pointer to a base class, you&#8217;d have to write it using overloaded functions, like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void report(const Cat&amp; cat)\r\n{\r\n    std::cout &lt;&lt; cat.getName() &lt;&lt; \" says \" &lt;&lt; cat.speak() &lt;&lt; '\\n';\r\n}\r\n\r\nvoid report(const Dog&amp; dog)\r\n{\r\n    std::cout &lt;&lt; dog.getName() &lt;&lt; \" says \" &lt;&lt; dog.speak() &lt;&lt; '\\n';\r\n}<\/code><\/pre>\n<p>Not too difficult, but consider what would happen if we had 30 different animal types instead of 2.  You&#8217;d have to write 30 almost identical functions!   Plus, if you ever added a new type of animal, you&#8217;d have to write a new function for that one too.  This is a huge waste of time considering the only real difference is the type of the parameter.<\/p>\n<p>However, because Cat and Dog are derived from Animal, Cat and Dog have an Animal part.  Therefore, it makes sense that we should be able to do something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void report(const Animal&amp; rAnimal)\r\n{\r\n    std::cout &lt;&lt; rAnimal.getName() &lt;&lt; \" says \" &lt;&lt; rAnimal.speak() &lt;&lt; '\\n';\r\n}<\/code><\/pre>\n<p>This would let us pass in any class derived from Animal, even ones that we created after we wrote the function!  Instead of one function per derived class, we get one function that works with all classes derived from Animal!<\/p>\n<p>The problem is, of course, that because rAnimal is an Animal reference, <code>rAnimal.speak()<\/code> will call Animal::speak() instead of the derived version of speak().<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>We could also use a template function to reduce the number of overloaded functions we need to write:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;typename T&gt;\r\nvoid report(const T&amp; rAnimal)\r\n{\r\n    std::cout &lt;&lt; rAnimal.getName() &lt;&lt; \" says \" &lt;&lt; rAnimal.speak() &lt;&lt; '\\n';\r\n}<\/code><\/pre>\n<p>And while this works, it has its own issues:<\/p>\n<ol start=\"1\">\n<li>It&#8217;s not clear what type <code>T<\/code> is supposed to be, as we&#8217;ve lost the documentation that <code>T<\/code> is intended to be an <code>Animal<\/code>.\n<\/li>\n<li>This function does not enforce that <code>T<\/code> is an <code>Animal<\/code>. Rather, it will accept an object of any type that contains a <code>getName()<\/code> and <code>speak()<\/code> member function, whether that makes sense or not.\n<\/li>\n<\/ol>\n<\/div>\n<p>Second, let&#8217;s say you had 3 cats and 3 dogs that you wanted to keep in an array for easy access.  Because arrays can only hold objects of one type, without a pointer or reference to a base class, you&#8217;d have to create a different array for each derived type, like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\n\/\/ Cat and Dog from the example above\r\n\r\nint main()\r\n{\r\n    const auto&amp; cats{ std::to_array&lt;Cat&gt;({{ \"Fred\" }, { \"Misty\" }, { \"Zeke\" }}) };\r\n    const auto&amp; dogs{ std::to_array&lt;Dog&gt;({{ \"Garbo\" }, { \"Pooky\" }, { \"Truffle\" }}) };\r\n    \r\n    \/\/ Before C++20\r\n    \/\/ const std::array&lt;Cat, 3&gt; cats{{ { \"Fred\" }, { \"Misty\" }, { \"Zeke\" } }};\r\n    \/\/ const std::array&lt;Dog, 3&gt; dogs{{ { \"Garbo\" }, { \"Pooky\" }, { \"Truffle\" } }};\r\n\r\n    for (const auto&amp; cat : cats)\r\n    {\r\n        std::cout &lt;&lt; cat.getName() &lt;&lt; \" says \" &lt;&lt; cat.speak() &lt;&lt; '\\n';\r\n    }\r\n\r\n    for (const auto&amp; dog : dogs)\r\n    {\r\n        std::cout &lt;&lt; dog.getName() &lt;&lt; \" says \" &lt;&lt; dog.speak() &lt;&lt; '\\n';\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Now, consider what would happen if you had 30 different types of animals.  You&#8217;d need 30 arrays, one for each type of animal!<\/p>\n<p>However, because both Cat and Dog are derived from Animal, it makes sense that we should be able to do something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\n\/\/ Cat and Dog from the example above\r\n\r\nint main()\r\n{\r\n    const Cat fred{ \"Fred\" };\r\n    const Cat misty{ \"Misty\" };\r\n    const Cat zeke{ \"Zeke\" };\r\n\r\n    const Dog garbo{ \"Garbo\" };\r\n    const Dog pooky{ \"Pooky\" };\r\n    const Dog truffle{ \"Truffle\" };\r\n\r\n    \/\/ Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects\r\n    const auto animals{ std::to_array&lt;const Animal*&gt;({&amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke }) };\r\n    \r\n    \/\/ Before C++20, with the array size being explicitly specified\r\n    \/\/ const std::array&lt;const Animal*, 6&gt; animals{ &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke };\r\n    \r\n    for (const auto animal : animals)\r\n    {\r\n        std::cout &lt;&lt; animal-&gt;getName() &lt;&lt; \" says \" &lt;&lt; animal-&gt;speak() &lt;&lt; '\\n';\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>While this compiles and executes, unfortunately the fact that each element of array &#8220;animals&#8221; is a pointer to an Animal means that <code>animal-&gt;speak()<\/code> will call Animal::speak() instead of the derived class version of speak() that we want. The output is<\/p>\n<pre>\r\nFred says ???\r\nGarbo says ???\r\nMisty says ???\r\nPooky says ???\r\nTruffle says ???\r\nZeke says ???\r\n<\/pre>\n<p>Although both of these techniques could save us a lot of time and energy, they have the same problem.  The pointer or reference to the base class calls the base version of the function rather than the derived version.  If only there was some way to make those base pointers call the derived version of a function instead of the base version&#8230;<\/p>\n<p>Want to take a guess what virtual functions are for? :)<\/p>\n<p><strong>Quiz time<\/strong><\/p>\n<ol start=\"1\">\n<li>Our Animal\/Cat\/Dog example above doesn&#8217;t work like we want because a reference or pointer to an Animal can&#8217;t access the derived version of speak() needed to return the right value for the Cat or Dog.  One way to work around this issue would be to make the data returned by the speak() function accessible as part of the Animal base class (much like the Animal&#8217;s name is accessible via member m_name).\n<\/li>\n<\/ol>\n<p>Update the Animal, Cat, and Dog classes in the lesson above by adding a new member to Animal named m_speak.  Initialize it appropriately.  The following program should work properly:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    const Cat fred{ \"Fred\" };\r\n    const Cat misty{ \"Misty\" };\r\n    const Cat zeke{ \"Zeke\" };\r\n\r\n    const Dog garbo{ \"Garbo\" };\r\n    const Dog pooky{ \"Pooky\" };\r\n    const Dog truffle{ \"Truffle\" };\r\n\r\n    \/\/ Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects\r\n    const auto animals{ std::to_array&lt;const Animal*&gt;({ &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke }) };\r\n    \r\n    \/\/ Before C++20, with the array size being explicitly specified\r\n    \/\/ const std::array&lt;const Animal*, 6&gt; animals{ &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke };\r\n    \r\n    for (const auto animal : animals)\r\n    {\r\n        std::cout &lt;&lt; animal-&gt;getName() &lt;&lt; \" says \" &lt;&lt; animal-&gt;speak() &lt;&lt; '\\n';\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n#include &lt;iostream&gt;\r\n\r\nclass Animal\r\n{\r\nprotected:\r\n    std::string m_name;\r\n    std::string m_speak;\r\n\r\n    \/\/ We're making this constructor protected because\r\n    \/\/ we don't want people creating Animal objects directly,\r\n    \/\/ but we still want derived classes to be able to use it.\r\n    Animal(std::string_view name, std::string_view speak)\r\n        : m_name{ name }, m_speak{ speak }\r\n    {\r\n    }\r\n    \r\n    \/\/ To prevent slicing (covered later)\r\n    Animal(const Animal&amp;) = delete;\r\n    Animal&amp; operator=(const Animal&amp;) = delete;\r\n\r\npublic:\r\n    std::string_view getName() const { return m_name; }\r\n    std::string_view speak() const { return m_speak; }\r\n};\r\n\r\nclass Cat: public Animal\r\n{\r\npublic:\r\n    Cat(std::string_view name)\r\n        : Animal{ name, \"Meow\" }\r\n    {\r\n    }\r\n};\r\n\r\nclass Dog: public Animal\r\n{\r\npublic:\r\n    Dog(std::string_view name)\r\n        : Animal{ name, \"Woof\" }\r\n    {\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    const Cat fred{ \"Fred\" };\r\n    const Cat misty{ \"Misty\" };\r\n    const Cat zeke{ \"Zeke\" };\r\n\r\n    const Dog garbo{ \"Garbo\" };\r\n    const Dog pooky{ \"Pooky\" };\r\n    const Dog truffle{ \"Truffle\" };\r\n\r\n    \/\/ Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects\r\n    const auto animals{ std::to_array&lt;const Animal*&gt;({ &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke }) };\r\n    \r\n    \/\/ Before C++20, with the array size being explicitly specified\r\n    \/\/ const std::array&lt;const Animal*, 6&gt; animals{ &amp;fred, &amp;garbo, &amp;misty, &amp;pooky, &amp;truffle, &amp;zeke };\r\n    \r\n    \/\/ animal is not a reference, because we're looping over pointers\r\n    for (const auto animal : animals)\r\n    {\r\n        std::cout &lt;&lt; animal-&gt;getName() &lt;&lt; \" says \" &lt;&lt; animal-&gt;speak() &lt;&lt; '\\n';\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<ol start=\"2\">\n<li>Why is the above solution non-optimal?\n<\/li>\n<\/ol>\n<p>Hint: Think about the future state of Cat and Dog where we want to differentiate Cats and Dogs in more ways.<br \/>\nHint: Think about the ways in which having a member that needs to be set at initialization limits you.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\nThe current solution is non-optimal for a number of reasons.<\/p>\n<p>First, we need to add a member to Animal for each way we want to differentiate Cat and Dog.  Over time, our Animal class could become quite large memory-wise, and complicated!<\/p>\n<p>Second, this solution only works if the base class member can be determined at initialization time.  For example, if speak() returned a randomized result for each Animal (e.g. calling Dog::speak() could return &#8220;woof&#8221;, &#8220;arf&#8221;, or &#8220;yip&#8221;), this kind of solution starts to get awkward and fall apart.<\/p>\n<p>Third, because speak() is a member of Animal, speak() will have the same behavior for Cats and Dogs (that is, it will always return m_speak).  If we wanted <code>speak()<\/code> to have different behavior for Cats and Dogs (e.g. have Dogs return a random sound), we&#8217;d have to put all that extra logic in Animal, which makes Animal even more complex.\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/virtual-functions\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">25.2<\/span>Virtual functions and polymorphism\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-24-summary-and-quiz\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">24.x<\/span>Chapter 24 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the previous chapter, you learned all about how to use inheritance to derive new classes from existing classes. In this chapter, we are going to focus on one of the most important and powerful aspects of inheritance &#8212; virtual functions. But before we discuss what virtual functions are, let&#8217;s &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/179"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=179"}],"version-history":[{"count":36,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/179\/revisions"}],"predecessor-version":[{"id":17886,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/179\/revisions\/17886"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=179"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=179"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=179"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}