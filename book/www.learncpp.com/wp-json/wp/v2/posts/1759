{"id":1759,"date":"2015-05-09T11:06:08","date_gmt":"2015-05-09T19:06:08","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=1759"},"modified":"2024-12-02T11:10:19","modified_gmt":"2024-12-02T19:10:19","slug":"chapter-7-summary-and-quiz","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-7-summary-and-quiz\/","title":{"rendered":"7.x &#8212; Chapter 7 summary and quiz"},"content":{"rendered":"<p class=\"cpp-section\">Chapter Review<\/p>\n<p>We covered a lot of material in this chapter.  Good job, you&#8217;re doing great!<\/p>\n<p>A <strong>compound statement<\/strong> or <strong>block<\/strong> is a group of zero or more statements that is treated by the compiler as if it were a single statement.  Blocks begin with a <code>{<\/code> symbol, end with a <code>}<\/code> symbol, with the statements to be executed placed in between. Blocks can be used anywhere a single statement is allowed. No semicolon is needed at the end of a block.  Blocks are often used in conjunction with <code>if statements<\/code> to execute multiple statements.<\/p>\n<p><strong>User-defined namespaces<\/strong> are namespaces that are defined by you for your own declarations.  Namespaces provided by C++ (such as the <code>global namespace<\/code>) or by libraries (such as <code>namespace std<\/code>) are not considered user-defined namespaces.<\/p>\n<p>You can access a declaration in a namespace via the <strong>scope resolution operator (::)<\/strong>.  The scope resolution operator tells the compiler that the identifier specified by the right-hand operand should be looked for in the scope of the left-hand operand.  If no left-hand operand is provided, the global namespace is assumed.<\/p>\n<p>Local variables are variables defined within a function (including function parameters).  Local variables have <strong>block scope<\/strong>, meaning they are in-scope from their point of definition to the end of the block they are defined within.  Local variables have <strong>automatic storage duration<\/strong>, meaning they are created at the point of definition and destroyed at the end of the block they are defined in.<\/p>\n<p>A name declared in a nested block can <strong>shadow<\/strong> or <strong>name hide<\/strong> an identically named variable in an outer block.  This should be avoided.<\/p>\n<p>Global variables are variables defined outside of a function.  Global variables have <strong>file scope<\/strong>, which means they are visible from the point of declaration until the end of the file in which they are declared.  Global variables have <strong>static duration<\/strong>, which means they are created when the program starts, and destroyed when it ends.  Avoid dynamic initialization of static variables whenever possible.<\/p>\n<p>An identifier\u2019s <strong>linkage<\/strong> determines whether other declarations of that name refer to the same object or not.  Local variables have no linkage.  Identifiers with <strong>internal linkage<\/strong> can be seen and used within a single file, but are not accessible from other files.  Identifiers with <strong>external linkage<\/strong> can be seen and used both from the file in which they are defined, and from other code files (via a forward declaration).<\/p>\n<p>Avoid non-const global variables whenever possible.  Const globals are generally seen as acceptable.  Use <strong>inline variables<\/strong> for global constants if your compiler is C++17 capable.<\/p>\n<p>Local variables can be given static duration via the <strong>static<\/strong> keyword.<\/p>\n<p>A <strong>qualified name<\/strong> is a name that includes an associated scope (e.g. <code>std::string<\/code>).  An <strong>unqualified name<\/strong> is a name that does not include a scoping qualifier (e.g. <code>string<\/code>).<\/p>\n<p><strong>Using statements<\/strong> (including <strong>using declarations<\/strong> and <strong>using directives<\/strong>) can be used to avoid having to qualify identifiers with an explicit namespace.  A <strong>using declaration<\/strong> allows us to use an unqualified name (with no scope) as an alias for a qualified name.  A <strong>using directive<\/strong> imports all of the identifiers from a namespace into the scope of the using directive.  Both of these should generally be avoided.<\/p>\n<p><strong>Inline expansion<\/strong> is a process where a function call is replaced by the code from the called function\u2019s definition.  A function that is declared using the <code>inline<\/code> keyword is called an <strong>inline function<\/strong>.<\/p>\n<p>Inline functions and variables have two primary requirements:<\/p>\n<ul>\n<li>The compiler needs to be able to see the full definition of an inline function or variable in each translation unit where the function is used (a forward declaration will not suffice on its own). The definition can occur after the point of use if a forward declaration is also provided.\n<\/li>\n<li>Every definition for an inline function or variable must be identical, otherwise undefined behavior will result.\n<\/li>\n<\/ul>\n<p>In modern C++, the term inline has evolved to mean &#8220;multiple definitions are allowed&#8221;. Thus, an inline function is one that is allowed to be defined in multiple files. C++17 introduced <strong>inline variables<\/strong>, which are variables that are allowed to be defined in multiple files.<\/p>\n<p>Inline functions and variables are particularly useful for <strong>header-only libraries<\/strong>, which are one or more header files that implement some capability (no .cpp files are included).<\/p>\n<p>Finally, C++ supports <strong>unnamed namespaces<\/strong>, which implicitly treat all contents of the namespace as if it had internal linkage.  C++ also supports <strong>inline namespaces<\/strong>, which provide some primitive versioning capabilities for namespaces.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #1<\/p>\n<p>Fix the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; \"Enter a positive number: \";\r\n\tint num{};\r\n\tstd::cin &gt;&gt; num;\r\n\r\n\r\n\tif (num &lt; 0)\r\n\t\tstd::cout &lt;&lt; \"Negative number entered.  Making positive.\\n\";\r\n\t\tnum = -num;\r\n\r\n\tstd::cout &lt;&lt; \"You entered: \" &lt;&lt; num;\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; \"Enter a positive number: \";\r\n\tint num{};\r\n\tstd::cin &gt;&gt; num;\r\n\r\n\r\n\tif (num &lt; 0)\r\n\t{ \/\/ block needed here so both statements execute if num is &lt; 0\r\n\t\tstd::cout &lt;&lt; \"Negative number entered.  Making positive.\\n\";\r\n\t\tnum = -num;\r\n\t}\r\n\r\n\tstd::cout &lt;&lt; \"You entered: \" &lt;&lt; num;\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<\/div>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #2<\/p>\n<p>Write a file named constants.h that makes the following program run.  If your compiler is C++17 capable, use an inline constexpr variable.  Otherwise, use a normal constexpr variable.  <code>maxClassSize<\/code> should have value <code>35<\/code>.<\/p>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"constants.h\"\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; \"How many students are in your class? \";\r\n\tint students{};\r\n\tstd::cin &gt;&gt; students;\r\n\r\n\r\n\tif (students &gt; Constants::maxClassSize)\r\n\t\tstd::cout &lt;&lt; \"There are too many students in this class\";\r\n\telse\r\n\t\tstd::cout &lt;&lt; \"This class isn't too large\";\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p>constants.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef CONSTANTS_H\r\n#define CONSTANTS_H\r\n\r\nnamespace Constants\r\n{\r\n\tinline constexpr int maxClassSize{ 35 }; \/\/ remove inline keyword if not C++17 capable\r\n}\r\n#endif<\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"constants.h\"\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; \"How many students are in your class? \";\r\n\tint students{};\r\n\tstd::cin &gt;&gt; students;\r\n\r\n\r\n\tif (students &gt; Constants::maxClassSize)\r\n\t\tstd::cout &lt;&lt; \"There are too many students in this class\";\r\n\telse\r\n\t\tstd::cout &lt;&lt; \"This class isn't too large\";\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<\/div>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #3<\/p>\n<p>Write a function <code>int accumulate(int x)<\/code>.  This function should return the sum of all of the values of <code>x<\/code> that have been passed to this function. <\/p>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_0'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_0\" style=\"display:none; margin-bottom: 1em\">Hint: Use a static local variable to store the sum.<\/div>\n<p>The following program should run and produce the output noted in comments:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; accumulate(4) &lt;&lt; '\\n'; \/\/ prints 4\r\n    std::cout &lt;&lt; accumulate(3) &lt;&lt; '\\n'; \/\/ prints 7\r\n    std::cout &lt;&lt; accumulate(2) &lt;&lt; '\\n'; \/\/ prints 9\r\n    std::cout &lt;&lt; accumulate(1) &lt;&lt; '\\n'; \/\/ prints 10\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint accumulate(int x)\r\n{\r\n    static int sum{ 0 }; \/\/ initialize sum to 0 at start of program\r\n    sum += x;\r\n    return sum;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; accumulate(4) &lt;&lt; '\\n'; \/\/ prints 4\r\n    std::cout &lt;&lt; accumulate(3) &lt;&lt; '\\n'; \/\/ prints 7\r\n    std::cout &lt;&lt; accumulate(2) &lt;&lt; '\\n'; \/\/ prints 9\r\n    std::cout &lt;&lt; accumulate(1) &lt;&lt; '\\n'; \/\/ prints 10\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<\/div>\n<p>3b) Extra credit: What are two shortcomings of the <code>accumulate()<\/code> function above?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<ol start=\"1\">\n<li>There is no conventional way to reset the accumulation without restarting the program.\n<\/li>\n<li>There is no conventional way to have multiple accumulators running.\n<\/li>\n<\/ol>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Both of these shortcomings can be addressed using functors (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-the-parenthesis-operator\/\">21.10 -- Overloading the parenthesis operator<\/a>) instead of a static local variable.\n<\/p><\/div>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/control-flow-introduction\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">8.1<\/span>Control flow introduction\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/unnamed-and-inline-namespaces\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.14<\/span>Unnamed and inline namespaces\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Chapter Review We covered a lot of material in this chapter. Good job, you&#8217;re doing great! A or is a group of zero or more statements that is treated by the compiler as if it were a single statement. Blocks begin with a { symbol, end with a } symbol, &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1759"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=1759"}],"version-history":[{"count":51,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1759\/revisions"}],"predecessor-version":[{"id":1784,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1759\/revisions\/1784"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=1759"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=1759"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=1759"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}