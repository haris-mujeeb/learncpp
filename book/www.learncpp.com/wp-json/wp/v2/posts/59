{"id":59,"date":"2007-06-15T10:43:59","date_gmt":"2007-06-15T18:43:59","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/35-relational-operators-comparisons\/"},"modified":"2025-01-21T11:14:03","modified_gmt":"2025-01-21T19:14:03","slug":"relational-operators-and-floating-point-comparisons","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/relational-operators-and-floating-point-comparisons\/","title":{"rendered":"6.7 &#8212; Relational operators and floating point comparisons"},"content":{"rendered":"<p><strong>Relational operators<\/strong> are operators that let you compare two values.  There are 6 relational operators:<\/p>\n<p style=\"clear: both\">\n<p> <!-- break around image --><\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<th>Operator<\/th>\n<th>Symbol<\/th>\n<th>Form<\/th>\n<th>Operation<\/th>\n<\/tr>\n<tr>\n<td>Greater than<\/td>\n<td>&gt;<\/td>\n<td>x &gt; y<\/td>\n<td>true if x is greater than y, false otherwise<\/td>\n<\/tr>\n<tr>\n<td>Less than<\/td>\n<td>&lt;<\/td>\n<td>x &lt; y<\/td>\n<td>true if x is less than y, false otherwise<\/td>\n<\/tr>\n<tr>\n<td>Greater than or equals<\/td>\n<td>&gt;=<\/td>\n<td>x &gt;= y<\/td>\n<td>true if x is greater than or equal to y, false otherwise<\/td>\n<\/tr>\n<tr>\n<td>Less than or equals<\/td>\n<td>&lt;=<\/td>\n<td>x &lt;= y<\/td>\n<td>true if x is less than or equal to y, false otherwise<\/td>\n<\/tr>\n<tr>\n<td>Equality<\/td>\n<td>==<\/td>\n<td>x == y<\/td>\n<td>true if x equals y, false otherwise<\/td>\n<\/tr>\n<tr>\n<td>Inequality<\/td>\n<td>!=<\/td>\n<td>x != y<\/td>\n<td>true if x does not equal y, false otherwise<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>You have already seen how most of these work, and they are pretty intuitive.  Each of these operators evaluates to the boolean value true (1), or false (0).<\/p>\n<p>Here&#8217;s some sample code using these operators with integers:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter an integer: \";\r\n    int x{};\r\n    std::cin &gt;&gt; x;\r\n\r\n    std::cout &lt;&lt; \"Enter another integer: \";\r\n    int y{};\r\n    std::cin &gt;&gt; y;\r\n\r\n    if (x == y)\r\n        std::cout &lt;&lt; x &lt;&lt; \" equals \" &lt;&lt; y &lt;&lt; '\\n';\r\n    if (x != y)\r\n        std::cout &lt;&lt; x &lt;&lt; \" does not equal \" &lt;&lt; y &lt;&lt; '\\n';\r\n    if (x &gt; y)\r\n        std::cout &lt;&lt; x &lt;&lt; \" is greater than \" &lt;&lt; y &lt;&lt; '\\n';\r\n    if (x &lt; y)\r\n        std::cout &lt;&lt; x &lt;&lt; \" is less than \" &lt;&lt; y &lt;&lt; '\\n';\r\n    if (x &gt;= y)\r\n        std::cout &lt;&lt; x &lt;&lt; \" is greater than or equal to \" &lt;&lt; y &lt;&lt; '\\n';\r\n    if (x &lt;= y)\r\n        std::cout &lt;&lt; x &lt;&lt; \" is less than or equal to \" &lt;&lt; y &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>And the results from a sample run:<\/p>\n<pre>\r\nEnter an integer: 4\r\nEnter another integer: 5\r\n4 does not equal 5\r\n4 is less than 5\r\n4 is less than or equal to 5\r\n<\/pre>\n<p>These operators are extremely straightforward to use when comparing integers.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Boolean conditional values<\/p>\n<p>By default, conditions in an <em>if statement<\/em> or <em>conditional operator<\/em> (and a few other places) evaluate as Boolean values.<\/p>\n<p>Many new programmers will write statements like this one:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">if (b1 == true) ...<\/code><\/pre>\n<p>This is redundant, as the <code>== true<\/code> doesn&#8217;t actually add any value to the condition.  Instead, we should write:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">if (b1) ...<\/code><\/pre>\n<p>Similarly, the following:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">if (b1 == false) ...<\/code><\/pre>\n<p>is better written as:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">if (!b1) ...<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Don&#8217;t add unnecessary == or != to conditions.  It makes them harder to read without offering any additional value.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Comparison of calculated floating point values can be problematic<\/p>\n<p>Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    constexpr double d1{ 100.0 - 99.99 }; \/\/ should equal 0.01 mathematically\r\n    constexpr double d2{ 10.0 - 9.99 }; \/\/ should equal 0.01 mathematically\r\n\r\n    if (d1 == d2)\r\n        std::cout &lt;&lt; \"d1 == d2\" &lt;&lt; '\\n';\r\n    else if (d1 &gt; d2)\r\n        std::cout &lt;&lt; \"d1 &gt; d2\" &lt;&lt; '\\n';\r\n    else if (d1 &lt; d2)\r\n        std::cout &lt;&lt; \"d1 &lt; d2\" &lt;&lt; '\\n';\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>Variables d1 and d2 should both have value <em>0.01<\/em>.  But this program prints an unexpected result:<\/p>\n<pre>\r\nd1 &gt; d2\r\n<\/pre>\n<p>If you inspect the value of d1 and d2 in a debugger, you&#8217;d likely see that d1 = 0.010000000000005116 and d2 = 0.0099999999999997868.  Both numbers are close to 0.01, but d1 is greater than, and d2 is less than.<\/p>\n<p>Comparing floating point values using any of the relational operators can be dangerous.  This is because floating point values are not precise, and small rounding errors in the floating point operands may cause them to be slightly smaller or slightly larger than expected.  And this can throw off the relational operators.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We discussed rounding errors in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/floating-point-numbers\/\">4.8 -- Floating point numbers<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Floating point less-than and greater-than<\/p>\n<p>When the less-than (&lt;), greater-than (&gt;), less-than-equals (&lt;=), and greater-than-equals (&gt;=) operators are used with floating point values, they will produce a reliable answer in most cases (when the value of the operands is not similar).  However, if the operands are almost identical, these operators should be considered unreliable.  For example, <code>d1 &gt; d2<\/code> happens to produce <code>true<\/code> in the above example, but could have just as easily produced <code>false<\/code> if the numerical errors had gone a different direction.<\/p>\n<p>If the consequence of getting a wrong answer when the operands are similar is acceptable, then using these operators can be acceptable.  This is an application-specific decision.<\/p>\n<p>For example, consider a game (such as Space Invaders) where you want to determine whether two moving objects (such as a missile and an alien) intersect.  If the objects are still far apart, these operators will return the correct answer.  If the two objects are extremely close together, you might get an answer either way.  In such cases, the wrong answer probably wouldn&#8217;t even be noticed (it would just look like a near miss, or near hit) and the game would continue.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Floating point equality and inequality<\/p>\n<p>The equality operators (== and !=) are much more troublesome.  Consider operator==, which returns true only if its operands are exactly equal.  Because even the smallest rounding error will cause two floating point numbers to not be equal, operator== is at high risk for returning false when a true might be expected.  Operator!= has the same kind of problem.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; (0.3 == 0.2 + 0.1); \/\/ prints false\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>For this reason, use of these operators with floating point operands should generally be avoided.<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Avoid using operator== and operator!= to compare floating point values if there is any chance those values have been calculated.\n<\/p><\/div>\n<p>There is one notable exception case to the above: It is safe to compare a floating point literal with a variable of the same type that has been initialized with a literal of the same type, so long as the number of significant digits in each literal does not exceed the minimum precision for that type.  Float has a minimum precision of 6 significant digits, and double has a minimum precision of 15 significant digits.<\/p>\n<p>We cover the precision for the different types in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/floating-point-numbers\/\">4.8 -- Floating point numbers<\/a>.<\/p>\n<p>For example, you may occasionally see a function that returns a floating point literal (typically <code>0.0<\/code>, or sometimes <code>1.0<\/code>).  In such cases, it is safe to do a direct comparison against the same literal value of the same type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">if (someFcn() == 0.0) \/\/ okay if someFcn() returns 0.0 as a literal only\r\n    \/\/ do something<\/code><\/pre>\n<p>Instead of a literal, we can also compare a const or constexpr floating point variable that was initialized with a literal value:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">constexpr double gravity { 9.8 };\r\nif (gravity == 9.8) \/\/ okay if gravity was initialized with a literal\r\n    \/\/ we're on earth<\/code><\/pre>\n<p>It is mostly not safe to compare floating point literals of different types.  For example, comparing <code>9.8f<\/code> to <code>9.8<\/code> will return false.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>It is safe to compare a floating point literal with a variable of the same type that has been initialized with a literal of the same type, so long as the number of significant digits in each literal does not exceed the minimum precision for that type.  Float has a minimum precision of 6 significant digits, and double has a minimum precision of 15 significant digits.<\/p>\n<p>It is generally not safe to compare floating point literals of different types.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Comparing floating point numbers (advanced \/ optional reading)<\/p>\n<p>So how can we reasonably compare two floating point operands to see if they are equal?<\/p>\n<p>The most common method of doing floating point equality involves using a function that looks to see if two numbers are <em>almost<\/em> the same.  If they are &#8220;close enough&#8221;, then we call them equal.  The value used to represent &#8220;close enough&#8221; is traditionally called <strong>epsilon<\/strong>.  Epsilon is generally defined as a small positive number (e.g. 0.00000001, sometimes written 1e-8).<\/p>\n<p>New developers often try to write their own &#8220;close enough&#8221; function like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cmath&gt; \/\/ for std::abs()\r\n\r\n\/\/ absEpsilon is an absolute value\r\nbool approximatelyEqualAbs(double a, double b, double absEpsilon)\r\n{\r\n    \/\/ if the distance between a and b is less than or equal to absEpsilon, then a and b are \"close enough\"\r\n    return std::abs(a - b) &lt;= absEpsilon;\r\n}<\/code><\/pre>\n<p>std::abs() is a function in the &lt;cmath&gt; header that returns the absolute value of its argument.  So <code>std::abs(a - b) &lt;= absEpsilon<\/code> checks if the distance between <em>a<\/em> and <em>b<\/em> is less than or equal to whatever epsilon value representing &#8220;close enough&#8221; was passed in.  If <em>a<\/em> and <em>b<\/em> are close enough, the function returns true to indicate they&#8217;re equal.  Otherwise, it returns false.<\/p>\n<p>While this function can work, it&#8217;s not great.  An epsilon of <em>0.00001<\/em> is good for inputs around <em>1.0<\/em>, too big for inputs around <em>0.0000001<\/em>, and too small for inputs like <em>10,000<\/em>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>If we say any number that is within 0.00001 of another number should be treated as the same number, then:<\/p>\n<ul>\n<li>1 and 1.0001 would be different, but 1 and 1.00001 would be the same. That&#8217;s not unreasonable.\n<\/li>\n<li>0.0000001 and 0.00001 would be the same. That doesn&#8217;t seem good, as those numbers are two orders of magnitude apart.\n<\/li>\n<li>10000 and 10000.0001 would be different. That also doesn&#8217;t seem good, as those numbers are barely different given the magnitude of the number.\n<\/li>\n<\/ul>\n<\/div>\n<p>This means every time we call this function, we have to pick an epsilon that&#8217;s appropriate for our inputs.  If we know we&#8217;re going to have to scale epsilon in proportion to the magnitude of our inputs, we might as well modify the function to do that for us.<\/p>\n<p><a href=\"http:\/\/en.wikipedia.org\/wiki\/Donald_Knuth\">Donald Knuth<\/a>, a famous computer scientist, suggested the following method in his book \u201cThe Art of Computer Programming, Volume II: Seminumerical Algorithms (Addison-Wesley, 1969)\u201d:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt; \/\/ for std::max\r\n#include &lt;cmath&gt;     \/\/ for std::abs\r\n\r\n\/\/ Return true if the difference between a and b is within epsilon percent of the larger of a and b\r\nbool approximatelyEqualRel(double a, double b, double relEpsilon)\r\n{\r\n\treturn (std::abs(a - b) &lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));\r\n}<\/code><\/pre>\n<p>In this case, instead of epsilon being an absolute number, epsilon is now relative to the magnitude of <em>a<\/em> or <em>b<\/em>.<\/p>\n<p>Let&#8217;s examine in more detail how this crazy looking function works.  On the left side of the &lt;= operator, <code>std::abs(a - b)<\/code> tells us the distance between <em>a<\/em> and <em>b<\/em> as a positive number.<\/p>\n<p>On the right side of the &lt;= operator, we need to calculate the largest value of &#8220;close enough&#8221; we&#8217;re willing to accept.  To do this, the algorithm chooses the larger of <em>a<\/em> and <em>b<\/em> (as a rough indicator of the overall magnitude of the numbers), and then multiplies it by relEpsilon.  In this function, relEpsilon represents a percentage.  For example, if we want to say &#8220;close enough&#8221; means <em>a<\/em> and <em>b<\/em> are within 1% of the larger of <em>a<\/em> and <em>b<\/em>, we pass in an relEpsilon of 0.01 (1% = 1\/100 = 0.01).  The value for relEpsilon can be adjusted to whatever is most appropriate for the circumstances (e.g. an epsilon of 0.002 means within 0.2%).<\/p>\n<p>To do inequality (!=) instead of equality, simply call this function and use the logical NOT operator (!) to flip the result:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">if (!approximatelyEqualRel(a, b, 0.001))\r\n    std::cout &lt;&lt; a &lt;&lt; \" is not equal to \" &lt;&lt; b &lt;&lt; '\\n';<\/code><\/pre>\n<p>Note that while the approximatelyEqualRel() function will work for most cases, it is not perfect, especially as the numbers approach zero:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt; \/\/ for std::max\r\n#include &lt;cmath&gt;     \/\/ for std::abs\r\n#include &lt;iostream&gt;\r\n\r\n\/\/ Return true if the difference between a and b is within epsilon percent of the larger of a and b\r\nbool approximatelyEqualRel(double a, double b, double relEpsilon)\r\n{\r\n\treturn (std::abs(a - b) &lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));\r\n}\r\n\r\nint main()\r\n{\r\n    \/\/ a is really close to 1.0, but has rounding errors\r\n    constexpr double a{ 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 };\r\n\r\n    constexpr double relEps { 1e-8 };\r\n    constexpr double absEps { 1e-12 };\r\n\r\n    std::cout &lt;&lt; std::boolalpha; \/\/ print true or false instead of 1 or 0\r\n    \r\n    \/\/ First, let's compare a (almost 1.0) to 1.0.\r\n    std::cout &lt;&lt; approximatelyEqualRel(a, 1.0, relEps) &lt;&lt; '\\n';\r\n \r\n    \/\/ Second, let's compare a-1.0 (almost 0.0) to 0.0\r\n    std::cout &lt;&lt; approximatelyEqualRel(a-1.0, 0.0, relEps) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Perhaps surprisingly, this returns:<\/p>\n<pre>\ntrue\r\nfalse\r\n<\/pre>\n<p>The second call didn&#8217;t perform as expected.  The math simply breaks down close to zero.<\/p>\n<p>One way to avoid this is to use both an absolute epsilon (as we did in the first approach) and a relative epsilon (as we did in Knuth&#8217;s approach):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Return true if the difference between a and b is less than or equal to absEpsilon, or within relEpsilon percent of the larger of a and b\r\nbool approximatelyEqualAbsRel(double a, double b, double absEpsilon, double relEpsilon)\r\n{\r\n    \/\/ Check if the numbers are really close -- needed when comparing numbers near zero.\r\n    if (std::abs(a - b) &lt;= absEpsilon)\r\n        return true;\r\n\r\n    \/\/ Otherwise fall back to Knuth's algorithm\r\n    return approximatelyEqualRel(a, b, relEpsilon);\r\n}<\/code><\/pre>\n<p>In this algorithm, we first check if <em>a<\/em> and <em>b<\/em> are close together in absolute terms, which handles the case where <em>a<\/em> and <em>b<\/em> are both close to zero.  The <em>absEpsilon<\/em> parameter should be set to something very small (e.g. 1e-12).  If that fails, then we fall back to Knuth&#8217;s algorithm, using the relative epsilon.<\/p>\n<p>Here&#8217;s our previous code testing both algorithms:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt; \/\/ for std::max\r\n#include &lt;cmath&gt;     \/\/ for std::abs\r\n#include &lt;iostream&gt;\r\n\r\n\/\/ Return true if the difference between a and b is within epsilon percent of the larger of a and b\r\nbool approximatelyEqualRel(double a, double b, double relEpsilon)\r\n{\r\n\treturn (std::abs(a - b) &lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));\r\n}\r\n\r\n\/\/ Return true if the difference between a and b is less than or equal to absEpsilon, or within relEpsilon percent of the larger of a and b\r\nbool approximatelyEqualAbsRel(double a, double b, double absEpsilon, double relEpsilon)\r\n{\r\n    \/\/ Check if the numbers are really close -- needed when comparing numbers near zero.\r\n    if (std::abs(a - b) &lt;= absEpsilon)\r\n        return true;\r\n\r\n    \/\/ Otherwise fall back to Knuth's algorithm\r\n    return approximatelyEqualRel(a, b, relEpsilon);\r\n}\r\n\r\nint main()\r\n{\r\n    \/\/ a is really close to 1.0, but has rounding errors\r\n    constexpr double a{ 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 };\r\n\r\n    constexpr double relEps { 1e-8 };\r\n    constexpr double absEps { 1e-12 };\r\n\r\n    std::cout &lt;&lt; std::boolalpha; \/\/ print true or false instead of 1 or 0\r\n\r\n    std::cout &lt;&lt; approximatelyEqualRel(a, 1.0, relEps) &lt;&lt; '\\n';     \/\/ compare \"almost 1.0\" to 1.0\r\n    std::cout &lt;&lt; approximatelyEqualRel(a-1.0, 0.0, relEps) &lt;&lt; '\\n'; \/\/ compare \"almost 0.0\" to 0.0\r\n\r\n    std::cout &lt;&lt; approximatelyEqualAbsRel(a, 1.0, absEps, relEps) &lt;&lt; '\\n';     \/\/ compare \"almost 1.0\" to 1.0\r\n    std::cout &lt;&lt; approximatelyEqualAbsRel(a-1.0, 0.0, absEps, relEps) &lt;&lt; '\\n'; \/\/ compare \"almost 0.0\" to 0.0\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<pre>\ntrue\r\nfalse\r\ntrue\r\ntrue\r\n<\/pre>\n<p>You can see that approximatelyEqualAbsRel() handles the small inputs correctly.<\/p>\n<p>Comparison of floating point numbers is a difficult topic, and there&#8217;s no &#8220;one size fits all&#8221; algorithm that works for every case.  However, the approximatelyEqualAbsRel() function with an absEpsilon of 1e-12 and a relEpsilon of 1e-8 should be good enough to handle most cases you&#8217;ll encounter.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Making the <code>approximatelyEqual<\/code> functions constexpr <span class=\"cpp-section-pill cpp-section-advanced\">Advanced<\/span><\/p>\n<p>In C++23, the two <code>approximatelyEqual<\/code> functions can be made constexpr by adding the <code>constexpr<\/code> keyword:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ C++23 version\r\n#include &lt;algorithm&gt; \/\/ for std::max\r\n#include &lt;cmath&gt;     \/\/ for std::abs (constexpr in C++23)\r\n\r\n\/\/ Return true if the difference between a and b is within epsilon percent of the larger of a and b\r\nconstexpr bool approximatelyEqualRel(double a, double b, double relEpsilon)\r\n{\r\n\treturn (std::abs(a - b) &lt;= (std::max(std::abs(a), std::abs(b)) * relEpsilon));\r\n}\r\n\r\n\/\/ Return true if the difference between a and b is less than or equal to absEpsilon, or within relEpsilon percent of the larger of a and b\r\nconstexpr bool approximatelyEqualAbsRel(double a, double b, double absEpsilon, double relEpsilon)\r\n{\r\n    \/\/ Check if the numbers are really close -- needed when comparing numbers near zero.\r\n    if (std::abs(a - b) &lt;= absEpsilon)\r\n        return true;\r\n\r\n    \/\/ Otherwise fall back to Knuth's algorithm\r\n    return approximatelyEqualRel(a, b, relEpsilon);\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover constexpr functions in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-functions\/\">F.1 -- Constexpr functions<\/a>.\n<\/p><\/div>\n<p>However, prior to C++23, we run into an issue.  If these constexpr function are called in a constant expression, they will fail:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    \/\/ a is really close to 1.0, but has rounding errors\r\n    constexpr double a{ 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 };\r\n\r\n    constexpr double relEps { 1e-8 };\r\n    constexpr double absEps { 1e-12 };\r\n\r\n    std::cout &lt;&lt; std::boolalpha; \/\/ print true or false instead of 1 or 0\r\n\r\n    constexpr bool same { approximatelyEqualAbsRel(a, 1.0, absEps, relEps) }; \/\/ compile error: must be initialized by a constant expression\r\n    std::cout &lt;&lt; same &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This is because a constexpr function that is used in a constant expression can&#8217;t call a non-constexpr function, and <code>std::abs<\/code> wasn&#8217;t made constexpr until C++23.<\/p>\n<p>This is easy to fix though -- we can just ditch <code>std::abs<\/code> for our own constexpr absolute value implementation.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ C++14\/17\/20 version\r\n#include &lt;algorithm&gt; \/\/ for std::max\r\n#include &lt;iostream&gt;\r\n\r\n\/\/ Our own constexpr implementation of std::abs (for use in C++14\/17\/20)\r\n\/\/ In C++23, use std::abs\r\n\/\/ constAbs() can be called like a normal function, but can handle different types of values (e.g. int, double, etc...)\r\ntemplate &lt;typename T&gt;\r\nconstexpr T constAbs(T x)\r\n{\r\n    return (x &lt; 0 ? -x : x);\r\n}\r\n\r\n\/\/ Return true if the difference between a and b is within epsilon percent of the larger of a and b\r\nconstexpr bool approximatelyEqualRel(double a, double b, double relEpsilon)\r\n{\r\n    return (constAbs(a - b) &lt;= (std::max(constAbs(a), constAbs(b)) * relEpsilon));\r\n}\r\n\r\n\/\/ Return true if the difference between a and b is less than or equal to absEpsilon, or within relEpsilon percent of the larger of a and b\r\nconstexpr bool approximatelyEqualAbsRel(double a, double b, double absEpsilon, double relEpsilon)\r\n{\r\n    \/\/ Check if the numbers are really close -- needed when comparing numbers near zero.\r\n    if (constAbs(a - b) &lt;= absEpsilon)\r\n        return true;\r\n\r\n    \/\/ Otherwise fall back to Knuth's algorithm\r\n    return approximatelyEqualRel(a, b, relEpsilon);\r\n}\r\n\r\nint main()\r\n{\r\n    \/\/ a is really close to 1.0, but has rounding errors\r\n    constexpr double a{ 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 };\r\n\r\n    constexpr double relEps { 1e-8 };\r\n    constexpr double absEps { 1e-12 };\r\n\r\n    std::cout &lt;&lt; std::boolalpha; \/\/ print true or false instead of 1 or 0\r\n\r\n    constexpr bool same { approximatelyEqualAbsRel(a, 1.0, absEps, relEps) };\r\n    std::cout &lt;&lt; same &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>The version of <code>constAbs()<\/code> above is a function template, which allows us to write a single definition that can handle different types of values.  We cover function templates in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-templates\/\">11.6 -- Function templates<\/a>.\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/logical-operators\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">6.8<\/span>Logical operators\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/the-conditional-operator\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">6.6<\/span>The conditional operator\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>are operators that let you compare two values. There are 6 relational operators: You have already seen how most of these work, and they are pretty intuitive. Each of these operators evaluates to the boolean value true (1), or false (0). Here&#8217;s some sample code using these operators with integers: &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/59"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=59"}],"version-history":[{"count":49,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/59\/revisions"}],"predecessor-version":[{"id":18118,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/59\/revisions\/18118"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=59"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=59"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=59"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}