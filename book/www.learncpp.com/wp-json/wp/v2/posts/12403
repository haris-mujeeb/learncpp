{"id":12403,"date":"2022-01-18T10:04:58","date_gmt":"2022-01-18T18:04:58","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=12403"},"modified":"2025-01-03T14:39:26","modified_gmt":"2025-01-03T22:39:26","slug":"value-categories-lvalues-and-rvalues","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/value-categories-lvalues-and-rvalues\/","title":{"rendered":"12.2 &#8212; Value categories (lvalues and rvalues)"},"content":{"rendered":"<p>Before we talk about our first compound type (lvalue references), we&#8217;re going to take a little detour and talk about what an <code>lvalue<\/code> is.<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-expressions\/\">1.10 -- Introduction to expressions<\/a>, we defined an expression as &#8220;a combination of literals, variables, operators, and function calls that can be executed to produce a singular value&#8221;.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; 2 + 3 &lt;&lt; '\\n'; \/\/ The expression 2 + 3 produces the value 5\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above program, the expression <code>2 + 3<\/code> is evaluated to produce the value 5, which is then printed to the console.<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/increment-decrement-operators-and-side-effects\/\">6.4 -- Increment\/decrement operators, and side effects<\/a>, we also noted that expressions can produce side effects that outlive the expression:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 5 };\r\n    ++x; \/\/ This expression statement has the side-effect of incrementing x\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n'; \/\/ prints 6\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above program, the expression <code>++x<\/code> increments the value of <code>x<\/code>, and that value remains changed even after the expression has finished evaluating.<\/p>\n<p>Besides producing values and side effects, expressions can do one more thing: they can evaluate to objects or functions.  We&#8217;ll explore this point further in just a moment.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The properties of an expression<\/p>\n<p>To help determine how expressions should evaluate and where they can be used, all expressions in C++ have two properties: a type and a value category.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The type of an expression<\/p>\n<p>The type of an expression is equivalent to the type of the value, object, or function that results from the evaluated expression.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    auto v1 { 12 \/ 4 }; \/\/ int \/ int =&gt; int\r\n    auto v2 { 12.0 \/ 4 }; \/\/ double \/ int =&gt; double\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>For <code>v1<\/code>, the compiler will determine (at compile time) that a division with two <code>int<\/code> operands will produce an <code>int<\/code> result, so <code>int<\/code> is the type of this expression.  Via type inference, <code>int<\/code> will then be used as the type of <code>v1<\/code>.<\/p>\n<p>For <code>v2<\/code>, the compiler will determine (at compile time) that a division with a <code>double<\/code> operand and an <code>int<\/code> operand will produce a <code>double<\/code> result.  Remember that arithmetic operators must have operands of matching types, so in this case, the <code>int<\/code> operand gets converted to a <code>double<\/code>, and a floating point division is performed.  So <code>double<\/code> is the type of this expression.<\/p>\n<p>The compiler can use the type of an expression to determine whether an expression is valid in a given context.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid print(int x)\r\n{\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    print(\"foo\"); \/\/ error: print() was expecting an int argument, we tried to pass in a string literal\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above program, the <code>print(int)<\/code> function is expecting an <code>int<\/code> parameter.  However, the type of the expression we&#8217;re passing in (the string literal <code>\"foo\"<\/code>) does not match, and no conversion can be found.  So a compile error results.<\/p>\n<p>Note that the type of an expression must be determinable at compile time (otherwise type checking and type deduction wouldn&#8217;t work) -- however, the value of an expression may be determined at either compile time (if the expression is constexpr) or runtime (if the expression is not constexpr).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The value category of an expression<\/p>\n<p>Now consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int x{};\r\n\r\n    x = 5; \/\/ valid: we can assign 5 to x\r\n    5 = x; \/\/ error: can not assign value of x to literal value 5\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>One of these assignment statements is valid (assigning value <code>5<\/code> to variable <code>x<\/code>) and one is not (what would it mean to assign the value of <code>x<\/code> to the literal value <code>5<\/code>?).  So how does the compiler know which expressions can legally appear on either side of an assignment statement?<\/p>\n<p>The answer lies in the second property of expressions: the <code>value category<\/code>.  The <strong>value category<\/strong> of an expression (or subexpression) indicates whether an expression resolves to a value, a function, or an object of some kind.<\/p>\n<p>Prior to C++11, there were only two possible value categories: <code>lvalue<\/code> and <code>rvalue<\/code>.<\/p>\n<p>In C++11, three additional value categories (<code>glvalue<\/code>, <code>prvalue<\/code>, and <code>xvalue<\/code>) were added to support a new feature called <code>move semantics<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>In this lesson, we&#8217;ll stick to the pre-C++11 view of value categories, as this makes for a gentler introduction to value categories (and is all that we need for the moment).  We&#8217;ll cover move semantics (and the additional three value categories) in a future chapter.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Lvalue and rvalue expressions<\/p>\n<p>An <strong>lvalue<\/strong> (pronounced &#8220;ell-value&#8221;, short for &#8220;left value&#8221; or &#8220;locator value&#8221;, and sometimes written as &#8220;l-value&#8221;) is an expression that evaluates to an identifiable object or function (or bit-field).<\/p>\n<p>The term &#8220;identity&#8221; is used by the C++ standard, but is not well-defined.  An entity (such as an object or function) that has an identity can be differentiated from other similar entities (typically by comparing the addresses of the entity).<\/p>\n<p>Entities with identities can be accessed via an identifier, reference, or pointer, and typically have a lifetime longer than a single expression or statement.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int x { 5 };\r\n    int y { x }; \/\/ x is an lvalue expression\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above program, the expression <code>x<\/code> is an lvalue expression as it evaluates to variable <code>x<\/code> (which has an identifier).<\/p>\n<p>Since the introduction of constants into the language, lvalues come in two subtypes: a <strong>modifiable lvalue<\/strong> is an lvalue whose value can be modified.  A <strong>non-modifiable lvalue<\/strong> is an lvalue whose value can&#8217;t be modified (because the lvalue is const or constexpr).<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int x{};\r\n    const double d{};\r\n\r\n    int y { x }; \/\/ x is a modifiable lvalue expression\r\n    const double e { d }; \/\/ d is a non-modifiable lvalue expression\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>An <strong>rvalue<\/strong> (pronounced &#8220;arr-value&#8221;, short for &#8220;right value&#8221;, and sometimes written as <code>r-value<\/code>) is an expression that is not an lvalue.  Rvalue expressions evaluate to a value.  Commonly seen rvalues include literals (except C-style string literals, which are lvalues) and the return value of functions and operators that return by value.  Rvalues aren&#8217;t identifiable (meaning they have to be used immediately), and only exist within the scope of the expression in which they are used.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int return5()\r\n{\r\n    return 5;\r\n}\r\n\r\nint main()\r\n{\r\n    int x{ 5 }; \/\/ 5 is an rvalue expression\r\n    const double d{ 1.2 }; \/\/ 1.2 is an rvalue expression\r\n\r\n    int y { x }; \/\/ x is a modifiable lvalue expression\r\n    const double e { d }; \/\/ d is a non-modifiable lvalue expression\r\n    int z { return5() }; \/\/ return5() is an rvalue expression (since the result is returned by value)\r\n\r\n    int w { x + 1 }; \/\/ x + 1 is an rvalue expression\r\n    int q { static_cast&lt;int&gt;(d) }; \/\/ the result of static casting d to an int is an rvalue expression\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>You may be wondering why <code>return5()<\/code>, <code>x + 1<\/code>, and <code>static_cast&lt;int&gt;(d)<\/code> are rvalues: the answer is because these expressions produce temporary values that are not identifiable objects.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Lvalue expressions evaluate to an identifiable object.<br \/>\nRvalue expressions evaluate to a value.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Value categories and operators<\/p>\n<p>Unless otherwise specified, operators expect their operands to be rvalues.  For example, binary <code>operator+<\/code> expects its operands to be rvalues:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; 1 + 2; \/\/ 1 and 2 are rvalues, operator+ returns an rvalue\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The literals <code>1<\/code> and <code>2<\/code> are both rvalue expressions.  <code>operator+<\/code> will happily use these to return the rvalue expression <code>3<\/code>.<\/p>\n<p>Now we can answer the question about why <code>x = 5<\/code> is valid but <code>5 = x<\/code> is not: an assignment operation requires its left operand to be a modifiable lvalue expression.  The latter assignment (<code>5 = x<\/code>) fails because the left operand expression <code>5<\/code> is an rvalue, not a modifiable lvalue.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int x{};\r\n\r\n    \/\/ Assignment requires the left operand to be a modifiable lvalue expression and the right operand to be an rvalue expression\r\n    x = 5; \/\/ valid: x is a modifiable lvalue expression and 5 is an rvalue expression\r\n    5 = x; \/\/ error: 5 is an rvalue expression and x is a modifiable lvalue expression\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Lvalue-to-rvalue conversion<\/p>\n<p>Since assignment operations expect the right operand to be an rvalue expression, you might be wondering why the following works:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int x{ 1 };\r\n    int y{ 2 };\r\n\r\n    x = y; \/\/ y is not an rvalue, but this is legal\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In cases where an rvalue is expected but an lvalue is provided, the lvalue will undergo an lvalue-to-rvalue conversion so that it can be used in such contexts.  This basically means the lvalue is evaluated to produce its value, which is an rvalue.<\/p>\n<p>In the above example, the lvalue expression <code>y<\/code> undergoes an lvalue-to-rvalue conversion, which evaluates <code>y<\/code> to produce an rvalue (<code>2<\/code>), which is then assigned to <code>x<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>An lvalue will implicitly convert to an rvalue.  This means an lvalue can be used anywhere an rvalue is expected.<br \/>\nAn rvalue, on the other hand, will not implicitly convert to an lvalue.\n<\/p><\/div>\n<p>Now consider this example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int x { 2 };\r\n\r\n    x = x + 1;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this statement, the variable <code>x<\/code> is being used in two different contexts.  On the left side of the assignment operator (where an lvalue expression is required), <code>x<\/code> is an lvalue expression that evaluates to variable <code>x<\/code>.  On the right side of the assignment operator, <code>x<\/code> undergoes an lvalue-to-rvalue conversion and is then evaluated so that its (<code>2<\/code>) can be used as the left operand of <code>operator+<\/code>.  <code>operator+<\/code> returns the rvalue expression <code>3<\/code>, which is then used as the right operand for the assignment.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">How to differentiate lvalues and rvalues<\/p>\n<p>You may still be confused about what kind of expressions qualify as an lvalue vs an rvalue.  For example, is the result of <code>operator++<\/code> an lvalue or an rvalue?  We&#8217;ll cover various methods you can use to determine which is which here.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>A rule of thumb to identify lvalue and rvalue expressions:<\/p>\n<ul>\n<li>Lvalue expressions are those that evaluate to functions or identifiable objects (including variables) that persist beyond the end of the expression.\n<\/li>\n<li>Rvalue expressions are those that evaluate to values, including literals and temporary objects that do not persist beyond the end of the expression.\n<\/li>\n<\/ul>\n<\/div>\n<p>For a more complete list of lvalue and rvalue expressions, you can consult technical documentation.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>A full list of lvalue and rvalue expressions can be found <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/language\/value_category\">here<\/a>.  In C++11, rvalues are broken into two subtypes: prvalues and xvalues, so the rvalues we&#8217;re talking about here are the sum of both of those categories.\n<\/div>\n<p>Finally, we can write a program and have the compiler tell us what kind of expression something is.  The following code demonstrates a method that determines whether an expression is an lvalue or an rvalue:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\n\/\/ T&amp; is an lvalue reference, so this overload will be preferred for lvalues\r\ntemplate &lt;typename T&gt;\r\nconstexpr bool is_lvalue(T&amp;)\r\n{\r\n    return true;\r\n}\r\n\r\n\/\/ T&amp;&amp; is an rvalue reference, so this overload will be preferred for rvalues\r\ntemplate &lt;typename T&gt;\r\nconstexpr bool is_lvalue(T&amp;&amp;)\r\n{\r\n    return false;\r\n}\r\n\r\n\/\/ A helper macro (#expr prints whatever is passed in for expr as text)\r\n#define PRINTVCAT(expr) { std::cout &lt;&lt; #expr &lt;&lt; \" is an \" &lt;&lt; (is_lvalue(expr) ? \"lvalue\\n\" : \"rvalue\\n\"); }\r\n\r\nint getint() { return 5; }\r\n\r\nint main()\r\n{\r\n    PRINTVCAT(5);        \/\/ rvalue\r\n    PRINTVCAT(getint()); \/\/ rvalue\r\n    int x { 5 };\r\n    PRINTVCAT(x);        \/\/ lvalue\r\n    PRINTVCAT(std::string {\"Hello\"}); \/\/ rvalue\r\n    PRINTVCAT(\"Hello\");  \/\/ lvalue\r\n    PRINTVCAT(++x);      \/\/ lvalue\r\n    PRINTVCAT(x++);      \/\/ rvalue\r\n} <\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n5 is an rvalue\r\ngetint() is an rvalue\r\nx is an lvalue\r\nstd::string {\"Hello\"} is an rvalue\r\n\"Hello\" is an lvalue\r\n++x is an lvalue\r\nx++ is an rvalue\r\n<\/pre>\n<p>This method relies on two overloaded functions: one with an lvalue refrence parameter and one with an rvalue reference parameter.  The lvalue reference version will be preferred for lvalue arguments, and the rvalue reference version will be preferred for rvalue arguments.  Thus we can determine whether the argument is an lvalue or rvalue based on which function gets selected.<\/p>\n<p>So as you can see, whether <code>operator++<\/code> results in an lvalue or an rvalue depends on whether it is used as a prefix operator (which returns an lvalue) or a postfix operator (which returns an rvalue)!<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Unlike the other literals (which are rvalues), a C-style string literal is an lvalue because C-style strings (which are C-style arrays) decay to a pointer.  The decay process only works if the array is an lvalue (and thus has an address that can be stored in the pointer).  C++ inherited this for backwards compatibility.<\/p>\n<p>We cover array decay in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/c-style-array-decay\/\">17.8 -- C-style array decay<\/a>.\n<\/p><\/div>\n<p>Now that we&#8217;ve covered lvalues, we can get to our first compound type: the <code>lvalue reference<\/code>.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/lvalue-references\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.3<\/span> Lvalue references\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-compound-data-types\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.1<\/span>Introduction to compound data types\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Before we talk about our first compound type (lvalue references), we&#8217;re going to take a little detour and talk about what an lvalue is. In lesson , we defined an expression as &#8220;a combination of literals, variables, operators, and function calls that can be executed to produce a singular value&#8221;. &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12403"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=12403"}],"version-history":[{"count":22,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12403\/revisions"}],"predecessor-version":[{"id":18071,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12403\/revisions\/18071"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=12403"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=12403"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=12403"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}