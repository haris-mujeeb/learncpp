{"id":37,"date":"2007-06-04T21:41:12","date_gmt":"2007-06-05T05:41:12","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=37"},"modified":"2025-02-26T17:05:20","modified_gmt":"2025-02-27T01:05:20","slug":"introduction-to-fundamental-data-types","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-fundamental-data-types\/","title":{"rendered":"4.1 &#8212; Introduction to fundamental data types"},"content":{"rendered":"<p class=\"cpp-section\">Bits, bytes, and memory addressing<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-objects-and-variables\/\">1.3 -- Introduction to objects and variables<\/a>, we talked about the fact that variables are names for a piece of memory that can be used to store information.  To recap briefly, computers have random access memory (RAM) that is available for programs to use.  When a variable is defined, a piece of that memory is set aside for that variable.<\/p>\n<p>The smallest unit of memory is a <strong>binary digit<\/strong> (also called a <strong>bit<\/strong>), which can hold a value of 0 or 1.  You can think of a bit as being like a traditional light switch -- either the light is off (0), or it is on (1).  There is no in-between.  If you were to look at a random segment of memory, all you would see is &#8230;011010100101010&#8230; or some combination thereof.<\/p>\n<p>Memory is organized into sequential units called <strong>memory addresses<\/strong> (or <strong>addresses<\/strong> for short).  Similar to how a street address can be used to find a given house on a street, the memory address allows us to find and access the contents of memory at a particular location.<\/p>\n<p>Perhaps surprisingly, in modern computer architectures, each bit does not get its own unique memory address.  This is because the number of memory addresses is limited, and the need to access data bit-by-bit is rare.  Instead, each memory address holds 1 byte of data.  A <strong>byte<\/strong> is a group of bits that are operated on as a unit.  The modern standard is that a byte is comprised of 8 sequential bits.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>In C++, we typically work with &#8220;byte-sized&#8221; chunks of data.\n<\/p><\/div>\n<p>The following picture shows some sequential memory addresses, along with the corresponding byte of data:<\/p>\n<p><img src=\"http:\/\/www.learncpp.com\/images\/CppTutorial\/Section2\/MemoryAddresses.png\" alt=\"Memory Addressing\" \/><\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>Some older or non-standard machines may have bytes of a different size (from 1 to 48 bits) -- however, we generally need not worry about these, as the modern de-facto standard is that a byte is 8 bits.  For these tutorials, we&#8217;ll assume a byte is 8 bits.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Data types<\/p>\n<p>Because all data on a computer is just a sequence of bits, we use a <strong>data type<\/strong> (often called a <strong>type<\/strong> for short) to tell the compiler how to interpret the contents of memory in some meaningful way. You have already seen one example of a data type: the integer. When we declare a variable as an integer, we are telling the compiler &#8220;the piece of memory that this variable uses is going to be interpreted as an integer value&#8221;.<\/p>\n<p>When you give an object a value, the compiler and CPU take care of encoding your value into the appropriate sequence of bits for that data type, which are then stored in memory (remember: memory can only store bits).  For example, if you assign an integer object the value <code>65<\/code>, that value is converted to the sequence of bits <code>0100 0001<\/code> and stored in the memory assigned to the object.<\/p>\n<p>Conversely, when the object is evaluated to produce a value, that sequence of bits is reconstituted back into the original value.  Meaning that <code>0100 0001<\/code> is converted back into the value <code>65<\/code>.<\/p>\n<p>Fortunately, the compiler and CPU do all the hard work here, so you generally don&#8217;t need to worry about how values get converted into bit sequences and back.<\/p>\n<p>All you need to do is pick a data type for your object that best matches your desired use.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Fundamental data types<\/p>\n<p>The C++ language comes with many predefined data types available for your use.  The most basic of these types are called the <strong>fundamental data types<\/strong> (informally sometimes called <strong>basic types<\/strong> or <strong>primitive types<\/strong>).<\/p>\n<p>Here is a list of the fundamental data types, some of which you have already seen:<\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<th>Types<\/th>\n<th>Category<\/th>\n<th>Meaning<\/th>\n<th>Example<\/th>\n<\/tr>\n<tr>\n<td>float<br \/>double<br \/>long double<\/td>\n<td>Floating Point<\/td>\n<td>a number with a fractional part<\/td>\n<td>3.14159<\/td>\n<\/tr>\n<tr>\n<td>bool<\/td>\n<td>Integral (Boolean)<\/td>\n<td>true or false<\/td>\n<td>true<\/td>\n<\/tr>\n<tr>\n<td>char<br \/>wchar_t<br \/>char8_t (C++20)<br \/>char16_t (C++11)<br \/>char32_t (C++11)<\/td>\n<td>Integral (Character)<\/td>\n<td>a single character of text<\/td>\n<td>&#8216;c&#8217;<\/td>\n<\/tr>\n<tr>\n<td>short int<br \/>int<br \/>long int<br \/>long long int (C++11)<\/td>\n<td>Integral (Integer)<\/td>\n<td>positive and negative whole numbers, including 0<\/td>\n<td>64<\/td>\n<\/tr>\n<tr>\n<td>std::nullptr_t (C++11)<\/td>\n<td>Null Pointer<\/td>\n<td>a null pointer<\/td>\n<td>nullptr<\/td>\n<\/tr>\n<tr>\n<td>void<\/td>\n<td>Void<\/td>\n<td>no type<\/td>\n<td>n\/a<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>This chapter is dedicated to exploring these fundamental data types in detail (except <code>std::nullptr_t<\/code>, which we&#8217;ll discuss when we talk about pointers).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Integer vs integral types<\/p>\n<p>In mathematics, an &#8220;integer&#8221; is a number with no decimal or fractional part, including negative and positive numbers and zero.  The term &#8220;integral&#8221; has several different meanings, but in the context of C++ is used to mean &#8220;like an integer&#8221;.<\/p>\n<p>The C++ standard defines the following terms:<\/p>\n<ul>\n<li>The <strong>standard integer types<\/strong> are <code>short<\/code>, <code>int<\/code>, <code>long<\/code>, <code>long long<\/code> (including their signed and unsigned variants).\n<\/li>\n<li>The <strong>integral types<\/strong> are <code>bool<\/code>, the various char types, and the standard integer types.\n<\/li>\n<\/ul>\n<p>All integral types are stored in memory as integer values, but only the standard integer types will display as an integer value when output.  We&#8217;ll discuss what <code>bool<\/code> and the char types do when output in their respective lessons.<\/p>\n<p>The C++ standard also explicitly notes that &#8220;integer types&#8221; is a synonym for &#8220;integral types&#8221;.  However, conventionally, &#8220;integer types&#8221; is more often used as shorthand for the &#8220;standard integer types&#8221; instead.<\/p>\n<p>Also note that the term &#8220;integral types&#8221; only includes fundamental types.  This means non-fundamental types (such as <code>enum<\/code> and <code>enum class<\/code>) are not integral types, even when they are stored as an integer (and in the case of <code>enum<\/code>, displayed as one too).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Other sets of types<\/p>\n<p>C++ contains three sets of types.<\/p>\n<p>The first two are built-in to the language itself (and do not require the inclusion of a header to use):<\/p>\n<ul>\n<li>The &#8220;fundamental data types&#8221; provide the most the basic and essential data types.\n<\/li>\n<li>The &#8220;compound data types&#8221; provide more complex data types and allow for the creation of custom (user-defined) types.  We cover these in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-compound-data-types\/\">12.1 -- Introduction to compound data types<\/a>.\n<\/li>\n<\/ul>\n<p>The distinction between the fundamental and compound types isn&#8217;t all that interesting or relevant, so it&#8217;s generally fine to consider them as a single set of types.<\/p>\n<p>The third (and largest) set of types is provided by the C++ standard library.  Because the standard library is included in all C++ distributions, these types are broadly available and have been standardized for compatibility.  Use of the types in the standard library requires the inclusion of the appropriate header and linking in the standard library.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Nomenclature<\/p>\n<p>The term &#8220;built-in type&#8221; is most often used as a synonym for the fundamental data types.  However, Stroustrup and others use the term to mean both the fundamental and compound data types (both of which are built-in to the core language).  Since this term isn\u2019t well-defined, we recommend avoiding it accordingly.\n<\/p><\/div>\n<p>A notable omission from the table of fundamental types above is a data type to handle <strong>strings<\/strong> (a sequence of characters that is typically used to represent text).  This is because in modern C++, strings are part of the standard library.  Although we&#8217;ll be focused on fundamental types in this chapter, because basic string usage is straightforward and useful, we&#8217;ll introduce strings in the next chapter (in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdstring\/\">5.7 -- Introduction to std::string<\/a>).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The _t suffix<\/p>\n<p>Many of the types defined in newer versions of C++ (e.g. <code>std::nullptr_t<\/code>) use a _t suffix.  This suffix means &#8220;type&#8221;, and it&#8217;s a common nomenclature applied to modern types.<\/p>\n<p>If you see something with a _t suffix, it&#8217;s probably a type.  But many types don&#8217;t have a _t suffix, so this isn&#8217;t consistently applied.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/void\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">4.2<\/span>Void\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-3-summary-and-quiz\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">3.x<\/span>Chapter 3 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Bits, bytes, and memory addressing In lesson , we talked about the fact that variables are names for a piece of memory that can be used to store information. To recap briefly, computers have random access memory (RAM) that is available for programs to use. When a variable is defined, &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/37"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=37"}],"version-history":[{"count":70,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/37\/revisions"}],"predecessor-version":[{"id":1161,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/37\/revisions\/1161"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=37"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=37"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=37"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}