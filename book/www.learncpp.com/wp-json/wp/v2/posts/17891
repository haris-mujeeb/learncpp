{"id":17891,"date":"2024-11-26T16:49:38","date_gmt":"2024-11-27T00:49:38","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=17891"},"modified":"2025-03-05T17:24:04","modified_gmt":"2025-03-06T01:24:04","slug":"constexpr-functions-part-3-and-consteval","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-functions-part-3-and-consteval\/","title":{"rendered":"F.3 &#8212; Constexpr functions (part 3) and consteval"},"content":{"rendered":"<p class=\"cpp-section\">Forcing a constexpr function to be evaluated at compile-time<\/p>\n<p>There is no way to tell the compiler that a constexpr function should prefer to evaluate at compile-time whenever it can (e.g. in cases where the return value of a constexpr function is used in a non-constant expression).<\/p>\n<p>However, we can force a constexpr function that is eligible to be evaluated at compile-time to actually evaluate at compile-time by ensuring the return value is used where a constant expression is required.  This needs to be done on a per-call basis.<\/p>\n<p>The most common way to do this is to use the return value to initialize a constexpr variable (this is why we&#8217;ve been using variable &#8216;g&#8217; in prior examples).  Unfortunately, this requires introducing a new variable into our program just to ensure compile-time evaluation, which is ugly and reduces code readability.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>There are several hacky ways that people have tried to work around the problem of having to introduce a new constexpr variable each time we want to force compile-time evaluation.  See <a href=\"https:\/\/quuxplusone.github.io\/blog\/2018\/08\/07\/force-constexpr\/\">here<\/a> and <a href=\"https:\/\/artificial-mind.net\/blog\/2020\/11\/14\/cpp17-consteval\">here<\/a>.\n<\/div>\n<p>However, in C++20, there is a better workaround to this issue, which we&#8217;ll present in a moment.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Consteval <span class=\"cpp-section-pill cpp-section-standard\">C++20<\/span><\/p>\n<p>C++20 introduces the keyword <strong>consteval<\/strong>, which is used to indicate that a function <em>must<\/em> evaluate at compile-time, otherwise a compile error will result.  Such functions are called <strong>immediate functions<\/strong>.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nconsteval int greater(int x, int y) \/\/ function is now consteval\r\n{\r\n    return (x &gt; y ? x : y);\r\n}\r\n\r\nint main()\r\n{\r\n    constexpr int g { greater(5, 6) };              \/\/ ok: will evaluate at compile-time\r\n    std::cout &lt;&lt; g &lt;&lt; '\\n';\r\n\r\n    std::cout &lt;&lt; greater(5, 6) &lt;&lt; \" is greater!\\n\"; \/\/ ok: will evaluate at compile-time\r\n\r\n    int x{ 5 }; \/\/ not constexpr\r\n    std::cout &lt;&lt; greater(x, 6) &lt;&lt; \" is greater!\\n\"; \/\/ error: consteval functions must evaluate at compile-time\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, the first two calls to <code>greater()<\/code> will evaluate at compile-time.  The call to <code>greater(x, 6)<\/code> cannot be evaluated at compile-time, so a compile error will result.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Use <code>consteval<\/code> if you have a function that must evaluate at compile-time for some reason (e.g. because it does something that can only be done at compile time).\n<\/div>\n<p>Perhaps surprisingly, the parameters of a consteval function are not constexpr (even though consteval functions can only be evaluated at compile-time).  This decision was made for the sake of consistency.<\/p>\n<p class=\"cpp-section\">Determining if a constexpr function call is evaluating at compile-time or runtime<\/p>\n<p>C++ does not currently provide any reliable mechanisms to do this.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">What about <code>std::is_constant_evaluated<\/code> or <code>if consteval<\/code>? <span class=\"cpp-section-pill cpp-section-advanced\">Advanced<\/span><\/p>\n<p>Neither of these capabilities tell you whether a function call is evaluating at compile-time or runtime.<\/p>\n<p><code>std::is_constant_evaluated()<\/code> (defined in the &lt;type_traits&gt; header) returns a <code>bool<\/code> indicating whether the current function is executing in a constant-evaluated context.  A <strong>constant-evaluated context<\/strong> (also called a <strong>constant context<\/strong>) is defined as one in which a constant expression is required (such as the initialization of a constexpr variable).  So in cases where the compiler is required to evaluate a constant expression at compile-time <code>std::is_constant_evaluated()<\/code> will <code>true<\/code> as expected.<\/p>\n<p>This is intended to allow you to do something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;type_traits&gt; \/\/ for std::is_constant_evaluated()\r\n\r\nconstexpr int someFunction()\r\n{\r\n    if (std::is_constant_evaluated()) \/\/ if evaluating in constant context\r\n        doSomething();\r\n    else\r\n        doSomethingElse();\r\n}<\/code><\/pre>\n<p>However, the compiler may also choose to evaluate a constexpr function at compile-time in a context that does not require a constant expression.  In such cases, <code>std::is_constant_evaluated()<\/code> will return <code>false<\/code> even though the function did evaluate at compile-time.  So <code>std::is_constant_evaluated()<\/code> really means &#8220;the compiler is being forced to evaluate this at compile-time&#8221;, not &#8220;this is evaluating at compile-time&#8221;.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>While this may seem strange, there are several reasons for this:<\/p>\n<ol start=\"1\">\n<li>As <a href=\"https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2018\/p0595r2.html\">the paper that proposed this feature<\/a> indicates, the standard doesn&#8217;t actually make a distinction between &#8220;compile time&#8221; and &#8220;runtime&#8221;.  Defining behavior involving that distinction would have been a larger change.\n<\/li>\n<li>Optimizations should not change the observable behavior of a program (unless explicitly allowed by the standard).  If <code>std::is_constant_evaluated()<\/code> were to return <code>true<\/code> when the function was evaluated at compile-time for any reason, then the optimizer deciding to evaluate a function at compile-time instead of runtime could potentially change the observable behavior of the function.  As a result, your program might behave very differently depending on what optimization level it was compiled with!\n<\/li>\n<\/ol>\n<p>While this could be addressed in various ways, those involve adding additional complexity to the optimizer and\/or limiting its ability to optimize certain cases.\n<\/p><\/div>\n<p>Introduced in C++23, <code>if consteval<\/code> is a replacement for <code>if (std::is_constant_evaluated())<\/code> that provides a nicer syntax and fixes some other issues.  However, it evaluates the same way.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using consteval to make constexpr execute at compile-time <span class=\"cpp-section-pill cpp-section-standard\">C++20<\/span><\/p>\n<p>The downside of consteval functions is that such functions can&#8217;t evaluate at runtime, making them less flexible than constexpr functions, which can do either.  Therefore, it would still be useful to have a convenient way to force constexpr functions to evaluate at compile-time (even when the return value is being used where a constant expression is not required), so that we can explicitly force compile-time evaluation when possible, and runtime evaluation when we can&#8217;t.<\/p>\n<p>Here&#8217;s an example that shows how this is possible:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n#define CONSTEVAL(...) [] consteval { return __VA_ARGS__; }()               \/\/ C++20 version per Jan Scultke (https:\/\/stackoverflow.com\/a\/77107431\/460250)\r\n#define CONSTEVAL11(...) [] { constexpr auto _ = __VA_ARGS__; return _; }() \/\/ C++11 version per Justin (https:\/\/stackoverflow.com\/a\/63637573\/460250)\r\n\r\n\/\/ This function returns the greater of the two numbers if executing in a constant context\r\n\/\/ and the lesser of the two numbers otherwise\r\nconstexpr int compare(int x, int y) \/\/ function is constexpr\r\n{\r\n    if (std::is_constant_evaluated())\r\n        return (x &gt; y ? x : y);\r\n    else\r\n        return (x &lt; y ? x : y);\r\n}\r\n\r\nint main()\r\n{\r\n    int x { 5 };\r\n    std::cout &lt;&lt; compare(x, 6) &lt;&lt; '\\n';                  \/\/ will execute at runtime and return 5\r\n\r\n    std::cout &lt;&lt; compare(5, 6) &lt;&lt; '\\n';                  \/\/ may or may not execute at compile-time, but will always return 5\r\n    std::cout &lt;&lt; CONSTEVAL(compare(5, 6)) &lt;&lt; '\\n';       \/\/ will always execute at compile-time and return 6\r\n    \r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>This uses a variadic preprocessor macro (the #define, <code>...<\/code>, and <code>__VA_ARGS__<\/code>) to define an consteval lambda that is immediately invoked (by the trailing parentheses).<br \/>\nYou can find information on variadic macros at <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/preprocessor\/replace\">https:\/\/en.cppreference.com\/w\/cpp\/preprocessor\/replace<\/a>.<br \/>\nWe cover lambdas in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-lambdas-anonymous-functions\/\">20.6 -- Introduction to lambdas (anonymous functions)<\/a>.\n<\/div>\n<p>The following should also work (and is a bit cleaner since it doesn&#8217;t use preprocessor macros):<\/p>\n<div class=\"cpp-note cpp-lightyellowbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For gcc users<\/p>\n<p>There is a bug in GCC 14 onward that causes the following example to produce the wrong answer when any level of optimization is enabled.\n<\/p><\/div>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ Uses abbreviated function template (C++20) and `auto` return type to make this function work with any type of value\r\n\/\/ See 'related content' box below for more info (you don't need to know how these work to use this function)\r\n\/\/ We've opted to use an uppercase name here for consistency with the prior example, but it also makes it easier to see the call\r\nconsteval auto CONSTEVAL(auto value)\r\n{\r\n    return value;\r\n}\r\n\r\n\/\/ This function returns the greater of the two numbers if executing in a constant context\r\n\/\/ and the lesser of the two numbers otherwise\r\nconstexpr int compare(int x, int y) \/\/ function is constexpr\r\n{\r\n    if (std::is_constant_evaluated())\r\n        return (x &gt; y ? x : y);\r\n    else\r\n        return (x &lt; y ? x : y);\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; CONSTEVAL(compare(5, 6)) &lt;&lt; '\\n';       \/\/ will execute at compile-time\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because the arguments of consteval functions are always manifestly constant evaluated, if we call a constexpr function as an argument to a consteval function, that constexpr function must be evaluated at compile-time!  The consteval function then returns the result of the constexpr function as its own return value, so the caller can use it.<\/p>\n<p>Note that the consteval function returns by value. While this might be inefficient to do at runtime (if the value was some type that is expensive to copy, e.g. <code>std::string<\/code>), in a compile-time context, it doesn\u2019t matter because the entire call to the consteval function will simply be replaced with the calculated return value.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>We cover auto return types in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/type-deduction-for-functions\/\">10.9 -- Type deduction for functions<\/a>.<br \/>\nWe cover abbreviated function templates (auto parameters) in lesson 11.8 -- Function templates with multiple template types <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-templates-with-multiple-template-types\/\">11.8 -- Function templates with multiple template types<\/a>.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-functions-part-4\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">F.4<\/span>Constexpr functions (part 4)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-functions-part-2\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">F.2<\/span>Constexpr functions (part 2)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Forcing a constexpr function to be evaluated at compile-time There is no way to tell the compiler that a constexpr function should prefer to evaluate at compile-time whenever it can (e.g. in cases where the return value of a constexpr function is used in a non-constant expression). However, we can &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/17891"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=17891"}],"version-history":[{"count":5,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/17891\/revisions"}],"predecessor-version":[{"id":18240,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/17891\/revisions\/18240"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=17891"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=17891"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=17891"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}