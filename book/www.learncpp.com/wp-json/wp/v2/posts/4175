{"id":4175,"date":"2016-06-05T10:50:20","date_gmt":"2016-06-05T18:50:20","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=4175"},"modified":"2025-02-01T15:25:25","modified_gmt":"2025-02-01T23:25:25","slug":"converting-constructors-and-the-explicit-keyword","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/converting-constructors-and-the-explicit-keyword\/","title":{"rendered":"14.16 &#8212; Converting constructors and the explicit keyword"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/implicit-type-conversion\/\">10.1 -- Implicit type conversion<\/a>, we introduced type conversion and the concept of implicit type conversion, where the compiler will implicitly convert a value of one type to a value of another type as needed if such a conversion exists.<\/p>\n<p>This allows us to do things like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printDouble(double d) \/\/ has a double parameter\r\n{\r\n    std::cout &lt;&lt; d;\r\n}\r\n\r\nint main()\r\n{\r\n    printDouble(5); \/\/ we're supplying an int argument\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, our <code>printDouble<\/code> function has a <code>double<\/code> parameter, but we&#8217;re passing in an argument of type <code>int<\/code>.  Because the type of the parameter and the type of the argument do not match, the compiler will see if it can implicitly convert the type of the argument to the type of the parameter.  In this case, using the numeric conversion rules, int value <code>5<\/code> will be converted to double value <code>5.0<\/code> and because we&#8217;re passing by value, parameter <code>d<\/code> will be copy initialized with this value.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">User-defined conversions<\/p>\n<p>Now consider the following similar example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Foo\r\n{\r\nprivate:\r\n    int m_x{};\r\npublic:\r\n    Foo(int x)\r\n        : m_x{ x }\r\n    {\r\n    }\r\n\r\n    int getX() const { return m_x; }\r\n};\r\n\r\nvoid printFoo(Foo f) \/\/ has a Foo parameter\r\n{\r\n    std::cout &lt;&lt; f.getX();\r\n}\r\n\r\nint main()\r\n{\r\n    printFoo(5); \/\/ we're supplying an int argument\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this version, <code>printFoo<\/code> has a <code>Foo<\/code> parameter but we&#8217;re passing in an argument of type <code>int<\/code>.  Because these types do not match, the compiler will try to implicitly convert int value <code>5<\/code> into a <code>Foo<\/code> object so the function can be called.<\/p>\n<p>Unlike the first example, where our parameter and argument types were both fundamental types (and thus can be converted using the built-in numeric promotion\/conversion rules), in this case, one of our types is a program-defined type.  The C++ standard doesn&#8217;t have specific rules that tell the compiler how to convert values to (or from) a program-defined type.<\/p>\n<p>Instead, the compiler will look to see if we have defined some function that it can use to perform such a conversion.  Such a function is called a <strong>user-defined conversion<\/strong>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Converting constructors<\/p>\n<p>In the above example, the compiler will find a function that lets it convert int value <code>5<\/code> into a <code>Foo<\/code> object.  That function is the <code>Foo(int)<\/code> constructor.<\/p>\n<p>Up to this point, we&#8217;ve typically used constructors to explicitly construct objects:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    Foo x { 5 }; \/\/ Explicitly convert int value 5 to a Foo<\/code><\/pre>\n<p>Think about what this does: we&#8217;re providing an <code>int<\/code> value (<code>5<\/code>) and getting a <code>Foo<\/code> object in return.<\/p>\n<p>In the context of a function call, we&#8217;re trying to solve the same problem:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    printFoo(5); \/\/ Implicitly convert int value 5 into a Foo<\/code><\/pre>\n<p>We&#8217;re providing an <code>int<\/code> value (<code>5<\/code>), and we want a <code>Foo<\/code> object in return.  The <code>Foo(int)<\/code> constructor was designed for exactly that!<\/p>\n<p>So in this case, when <code>printFoo(5)<\/code> is called, parameter <code>f<\/code> is copy initialized using the <code>Foo(int)<\/code> constructor with <code>5<\/code> as an argument!<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>Prior to C++17, when <code>printFoo(5)<\/code> is called, <code>5<\/code> is implicitly converted to a temporary <code>Foo<\/code> using the <code>Foo(int)<\/code> constructor.  This temporary <code>Foo<\/code> is then copy constructed into parameter <code>f<\/code>.<\/p>\n<p>In C++17 onward, the copy is mandatorily elided.  Parameter <code>f<\/code> is copy initialized with value <code>5<\/code>, and no call to the copy constructor is required (and it will work even if the copy constructor is deleted).\n<\/div>\n<p>A constructor that can be used to perform an implicit conversion is called a <strong>converting constructor<\/strong>.  By default, all constructors are converting constructors.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Only one user-defined conversion may be applied<\/p>\n<p>Now consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Employee\r\n{\r\nprivate:\r\n    std::string m_name{};\r\n\r\npublic:\r\n    Employee(std::string_view name)\r\n        : m_name{ name }\r\n    {\r\n    }\r\n\r\n    const std::string&amp; getName() const { return m_name; }\r\n};\r\n\r\nvoid printEmployee(Employee e) \/\/ has an Employee parameter\r\n{\r\n    std::cout &lt;&lt; e.getName();\r\n}\r\n\r\nint main()\r\n{\r\n    printEmployee(\"Joe\"); \/\/ we're supplying an string literal argument\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this version, we&#8217;ve swapped out our <code>Foo<\/code> class for an <code>Employee<\/code> class.  <code>printEmployee<\/code> has an <code>Employee<\/code> parameter, and we&#8217;re passing in a C-style string literal.  And we have a converting constructor: <code>Employee(std::string_view)<\/code>.<\/p>\n<p>You might be surprised to find that this version doesn&#8217;t compile.  The reason is simple: only one user-defined conversion may be applied to perform an implicit conversion, and this example requires two.  First, our C-style string literal has to be converted to a <code>std::string_view<\/code> (using a <code>std::string_view<\/code> converting constructor), and then our <code>std::string_view<\/code> has to be converted into an <code>Employee<\/code> (using the <code>Employee(std::string_view)<\/code> converting constructor).<\/p>\n<p>There are two ways to make this example work:<\/p>\n<ol start=\"1\">\n<li>Use a <code>std::string_view<\/code> literal:\n<\/li>\n<\/ol>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    using namespace std::literals;\r\n    printEmployee( \"Joe\"sv); \/\/ now a std::string_view literal\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This works because only one user-defined conversion is now required (from <code>std::string_view<\/code> to <code>Employee<\/code>).<\/p>\n<ol start=\"2\">\n<li>Explicitly construct an <code>Employee<\/code> rather than implicitly create one:\n<\/li>\n<\/ol>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    printEmployee(Employee{ \"Joe\" });\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This also works because only one user-defined conversion is now required (from the string literal to the <code>std::string_view<\/code> used to initialize the <code>Employee<\/code> object).  Passing our explicitly constructed <code>Employee<\/code> object to the function does not require a second conversion to take place.<\/p>\n<p>This latter example brings up a useful technique: it is trivial to convert an implicit conversion into an explicit definition.  We&#8217;ll see more examples of this later in this lesson.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>An implicit conversion can be trivially converted into an explicit definition by using direct list initialization (or direct initialization).\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">When converting constructors go wrong<\/p>\n<p>Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Dollars\r\n{\r\nprivate:\r\n    int m_dollars{};\r\n\r\npublic:\r\n    Dollars(int d)\r\n        : m_dollars{ d }\r\n    {\r\n    }\r\n\r\n    int getDollars() const { return m_dollars; }\r\n};\r\n\r\nvoid print(Dollars d)\r\n{\r\n    std::cout &lt;&lt; \"$\" &lt;&lt; d.getDollars();\r\n}\r\n\r\nint main()\r\n{\r\n    print(5);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When we call <code>print(5)<\/code>, the <code>Dollars(int)<\/code> converting constructor will be used to convert <code>5<\/code> into a <code>Dollars<\/code> object.  Thus, this program prints:<\/p>\n<pre>\n$5\r\n<\/pre>\n<p>Although this may have been the caller&#8217;s intent, it&#8217;s hard to tell because the caller did not provide any indication that this is what they actually wanted.  It&#8217;s entirely possible that the caller assumed this would print <code>5<\/code>, and did not expect the compiler to silently and implicitly convert our <code>int<\/code> value to a <code>Dollars<\/code> object so that it could satisfy this function call.<\/p>\n<p>While this example is trivial, in a larger and more complex program, it&#8217;s fairly easy to be surprised by the compiler performing some implicit conversion that you did not expect, resulting in unexpected behavior at runtime.<\/p>\n<p>It would be better if our <code>print(Dollars)<\/code> function could only be called with a <code>Dollars<\/code> object, not any value that can be implicitly converted to a <code>Dollars<\/code> (especially a fundamental type like <code>int<\/code>).  This would reduce the possibility of inadvertent errors.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The explicit keyword<\/p>\n<p>To address such issues, we can use the <strong>explicit<\/strong> keyword to tell the compiler that a constructor should not be used as a converting constructor.<\/p>\n<p>Making a constructor <code>explicit<\/code> has two notable consequences:<\/p>\n<ul>\n<li>An explicit constructor cannot be used to do copy initialization or copy list initialization.\n<\/li>\n<li>An explicit constructor cannot be used to do implicit conversions (since this uses copy initialization or copy list initialization).\n<\/li>\n<\/ul>\n<p>Let&#8217;s update the <code>Dollars(int)<\/code> constructor from the prior example to be an explicit constructor:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\"> #include &lt;iostream&gt;\r\n\r\nclass Dollars\r\n{\r\nprivate:\r\n    int m_dollars{};\r\n\r\npublic:\r\n    explicit Dollars(int d) \/\/ now explicit\r\n        : m_dollars{ d }\r\n    {\r\n    }\r\n\r\n    int getDollars() const { return m_dollars; }\r\n};\r\n\r\nvoid print(Dollars d)\r\n{\r\n    std::cout &lt;&lt; \"$\" &lt;&lt; d.getDollars();\r\n}\r\n\r\nint main()\r\n{\r\n    print(5); \/\/ compilation error because Dollars(int) is explicit\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because the compiler can no longer use <code>Dollars(int)<\/code> as a converting constructor, it can not find a way to convert <code>5<\/code> to a <code>Dollars<\/code>.  Consequently, it will generate a compilation error.<\/p>\n<p>For constructors with a separate declaration (inside the class) and definition (outside the class), the <code>explicit<\/code> keyword is used only on the declaration.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Explicit constructors can be used for direct and direct list initialization<\/p>\n<p>An explicit constructor can still be used for direct and direct list initialization:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Assume Dollars(int) is explicit\r\nint main()\r\n{\r\n    Dollars d1(5); \/\/ ok\r\n    Dollars d2{5}; \/\/ ok\r\n}<\/code><\/pre>\n<p>Now, let&#8217;s go back to our prior example, where we made our <code>Dollars(int)<\/code> constructor explicit, and therefore the following generated a compilation error:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    print(5); \/\/ compilation error because Dollars(int) is explicit<\/code><\/pre>\n<p>What if we actually want to call <code>print()<\/code> with <code>int<\/code> value <code>5<\/code> but the constructor is explicit?  The workaround is simple: instead of having the compiler implicitly convert <code>5<\/code> into a <code>Dollars<\/code> that can be passed to <code>print()<\/code>, we can explicitly define the <code>Dollars<\/code> object ourselves:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    print(Dollars{5}); \/\/ ok: explicitly create a Dollars<\/code><\/pre>\n<p>This is allowed because we can still use explicit constructors to list initialize objects.  And since we&#8217;ve now explicitly constructed a <code>Dollars<\/code>, the argument type matches the parameter type, so no conversion is required!<\/p>\n<p>This not only compiles and runs, it also better documents our intent, as it is explicit about the fact that we meant to call this function with a <code>Dollars<\/code> object.<\/p>\n<p>Note that <code>static_cast<\/code> returns an object that is direct-initialized, so it will consider explicit constructors while performing the conversion:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    print(static_cast&lt;Dollars&gt;(5)); \/\/ ok: static_cast will use explicit constructors<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Return by value and explicit constructors<\/p>\n<p>When we return a value from a function, if that value does not match the return type of the function, an implicit conversion will occur.  Just like with pass by value, such conversions cannot use explicit constructors.<\/p>\n<p>The following programs shows a few variations in return values, and their results:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Foo\r\n{\r\npublic:\r\n    explicit Foo() \/\/ note: explicit (just for sake of example)\r\n    {\r\n    }\r\n\r\n    explicit Foo(int x) \/\/ note: explicit\r\n    {\r\n    }\r\n};\r\n\r\nFoo getFoo()\r\n{\r\n    \/\/ explicit Foo() cases\r\n    return Foo{ };   \/\/ ok\r\n    return { };      \/\/ error: can't implicitly convert initializer list to Foo\r\n\r\n    \/\/ explicit Foo(int) cases\r\n    return 5;        \/\/ error: can't implicitly convert int to Foo\r\n    return Foo{ 5 }; \/\/ ok\r\n    return { 5 };    \/\/ error: can't implicitly convert initializer list to Foo\r\n}\r\n\r\nint main()\r\n{\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Perhaps surprisingly, <code>return { 5 }<\/code> is considered a conversion.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Best practices for use of <code>explicit<\/code><\/p>\n<p>The modern best practice is to make any constructor that will accept a single argument <code>explicit<\/code> by default.  This includes constructors with multiple parameters where most or all of them have default values.  This will disallow the compiler from using that constructor for implicit conversions.  If an implicit conversion is required, only non-explicit constructors will be considered.  If no non-explicit constructor can be found to perform the conversion, the compiler will error.<\/p>\n<p>If such a conversion is actually desired in a particular case, it is trivial to convert the implicit conversion into an explicit definition using direct list initialization.<\/p>\n<p>The following <strong>should not<\/strong> be made explicit:<\/p>\n<ul>\n<li>Copy (and move) constructors (as these do not perform conversions).\n<\/li>\n<\/ul>\n<p>The following <strong>are typically not<\/strong> made explicit:<\/p>\n<ul>\n<li>Default constructors with no parameters (as these are only used to convert <code>{}<\/code> to a default object, not something we typically need to restrict).\n<\/li>\n<li>Constructors that only accept multiple arguments (as these are typically not a candidate for conversions anyway).\n<\/li>\n<\/ul>\n<p>However, if you prefer, the above can be marked as explicit to prevent implicit conversions with empty and multiple-argument lists.<\/p>\n<p>The following <strong>should usually<\/strong> be made explicit:<\/p>\n<ul>\n<li>Constructors that take a single argument.\n<\/li>\n<\/ul>\n<p>There are some occasions when it does make sense to make a single-argument constructor non-explicit.  This can be useful when all of the following are true:<\/p>\n<ul>\n<li>The constructed object is semantically equivalent to the argument value.\n<\/li>\n<li>The conversion is performant.\n<\/li>\n<\/ul>\n<p>For example, the <code>std::string_view<\/code> constructor that accepts a C-style string argument is not explicit, because there is unlikely to be a case when we wouldn&#8217;t be okay with a C-style string being treated as a <code>std::string_view<\/code> instead.  Conversely, the <code>std::string<\/code> constructor that takes a <code>std::string_view<\/code> is marked as explicit, because while a <code>std::string<\/code> value is semantically equivalent to a <code>std::string_view<\/code> value, constructing a <code>std::string<\/code> is not performant.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Make any constructor that accepts a single argument <code>explicit<\/code> by default.  If an implicit conversion between types is both semantically equivalent and performant, you can consider making the constructor non-explicit.<\/p>\n<p>Do not make copy or move constructors explicit, as these do not perform conversions.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-aggregates-and-classes\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.17<\/span>Constexpr aggregates and classes\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-initialization-and-copy-elision\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.15<\/span>Class initialization and copy elision\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we introduced type conversion and the concept of implicit type conversion, where the compiler will implicitly convert a value of one type to a value of another type as needed if such a conversion exists. This allows us to do things like this: #include &lt;iostream&gt; void printDouble(double &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4175"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=4175"}],"version-history":[{"count":46,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4175\/revisions"}],"predecessor-version":[{"id":18156,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4175\/revisions\/18156"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=4175"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=4175"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=4175"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}