{"id":5602,"date":"2017-03-15T08:32:27","date_gmt":"2017-03-15T16:32:27","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=5602"},"modified":"2024-08-20T09:16:30","modified_gmt":"2024-08-20T16:16:30","slug":"stdunique_ptr","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/stdunique_ptr\/","title":{"rendered":"22.5 &#8212; std::unique_ptr"},"content":{"rendered":"<p>At the beginning of the chapter, we discussed how the use of pointers can lead to bugs and memory leaks in some situations.  For example, this can happen when a function early returns, or throws an exception, and the pointer is not properly deleted.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n \r\nvoid someFunction()\r\n{\r\n    auto* ptr{ new Resource() };\r\n \r\n    int x{};\r\n    std::cout &lt;&lt; \"Enter an integer: \";\r\n    std::cin &gt;&gt; x;\r\n \r\n    if (x == 0)\r\n        throw 0; \/\/ the function returns early, and ptr won\u2019t be deleted!\r\n \r\n    \/\/ do stuff with ptr here\r\n \r\n    delete ptr;\r\n}<\/code><\/pre>\n<p>Now that we&#8217;ve covered the fundamentals of move semantics, we can return to the topic of smart pointer classes.  Although smart pointers can offer other features, the defining characteristic of a smart pointer is that it manages a dynamically allocated resource provided by the user of the smart pointer, and ensures the dynamically allocated object is properly cleaned up at the appropriate time (usually when the smart pointer goes out of scope).<\/p>\n<p>Because of this, smart pointers should never be dynamically allocated themselves (otherwise, there is the risk that the smart pointer may not be properly deallocated, which means the object it owns would not be deallocated, causing a memory leak).  By always allocating smart pointers on the stack (as local variables or composition members of a class), we&#8217;re guaranteed that the smart pointer will properly go out of scope when the function or object it is contained within ends, ensuring the object the smart pointer owns is properly deallocated.<\/p>\n<p>C++11 standard library ships with 4 smart pointer classes: std::auto_ptr (removed in C++17), std::unique_ptr, std::shared_ptr, and std::weak_ptr.  std::unique_ptr is by far the most used smart pointer class, so we&#8217;ll cover that one first.  In the following lessons, we&#8217;ll cover std::shared_ptr and std::weak_ptr.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">std::unique_ptr<\/p>\n<p>std::unique_ptr is the C++11 replacement for std::auto_ptr.  It should be used to manage any dynamically allocated object that is not shared by multiple objects.  That is, std::unique_ptr should completely own the object it manages, not share that ownership with other classes.  std::unique_ptr lives in the &lt;memory&gt; header.<\/p>\n<p>Let&#8217;s take a look at a simple smart pointer example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;memory&gt; \/\/ for std::unique_ptr\r\n\r\nclass Resource\r\n{\r\npublic:\r\n\tResource() { std::cout &lt;&lt; \"Resource acquired\\n\"; }\r\n\t~Resource() { std::cout &lt;&lt; \"Resource destroyed\\n\"; }\r\n};\r\n\r\nint main()\r\n{\r\n\t\/\/ allocate a Resource object and have it owned by std::unique_ptr\r\n\tstd::unique_ptr&lt;Resource&gt; res{ new Resource() };\r\n\r\n\treturn 0;\r\n} \/\/ res goes out of scope here, and the allocated Resource is destroyed<\/code><\/pre>\n<p>Because the std::unique_ptr is allocated on the stack here, it&#8217;s guaranteed to eventually go out of scope, and when it does, it will delete the Resource it is managing.<\/p>\n<p>Unlike std::auto_ptr, std::unique_ptr properly implements move semantics. <\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;memory&gt; \/\/ for std::unique_ptr\r\n#include &lt;utility&gt; \/\/ for std::move\r\n\r\nclass Resource\r\n{\r\npublic:\r\n\tResource() { std::cout &lt;&lt; \"Resource acquired\\n\"; }\r\n\t~Resource() { std::cout &lt;&lt; \"Resource destroyed\\n\"; }\r\n};\r\n\r\nint main()\r\n{\r\n\tstd::unique_ptr&lt;Resource&gt; res1{ new Resource{} }; \/\/ Resource created here\r\n\tstd::unique_ptr&lt;Resource&gt; res2{}; \/\/ Start as nullptr\r\n\r\n\tstd::cout &lt;&lt; \"res1 is \" &lt;&lt; (res1 ? \"not null\\n\" : \"null\\n\");\r\n\tstd::cout &lt;&lt; \"res2 is \" &lt;&lt; (res2 ? \"not null\\n\" : \"null\\n\");\r\n\r\n\t\/\/ res2 = res1; \/\/ Won't compile: copy assignment is disabled\r\n\tres2 = std::move(res1); \/\/ res2 assumes ownership, res1 is set to null\r\n\r\n\tstd::cout &lt;&lt; \"Ownership transferred\\n\";\r\n\r\n\tstd::cout &lt;&lt; \"res1 is \" &lt;&lt; (res1 ? \"not null\\n\" : \"null\\n\");\r\n\tstd::cout &lt;&lt; \"res2 is \" &lt;&lt; (res2 ? \"not null\\n\" : \"null\\n\");\r\n\r\n\treturn 0;\r\n} \/\/ Resource destroyed here when res2 goes out of scope<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\nResource acquired\r\nres1 is not null\r\nres2 is null\r\nOwnership transferred\r\nres1 is null\r\nres2 is not null\r\nResource destroyed\r\n<\/pre>\n<p>Because std::unique_ptr is designed with move semantics in mind, copy initialization and copy assignment are disabled.  If you want to transfer the contents managed by std::unique_ptr, you must use move semantics.  In the program above, we accomplish this via std::move (which converts res1 into an r-value, which triggers a move assignment instead of a copy assignment).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Accessing the managed object<\/p>\n<p>std::unique_ptr has an overloaded operator* and operator-&gt; that can be used to return the resource being managed.  Operator* returns a reference to the managed resource, and operator-&gt; returns a pointer.<\/p>\n<p>Remember that std::unique_ptr may not always be managing an object -- either because it was created empty (using the default constructor or passing in a nullptr as the parameter), or because the resource it was managing got moved to another std::unique_ptr.  So before we use either of these operators, we should check whether the std::unique_ptr actually has a resource.  Fortunately, this is easy: std::unique_ptr has a cast to bool that returns true if the std::unique_ptr is managing a resource.<\/p>\n<p>Here&#8217;s an example of this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;memory&gt; \/\/ for std::unique_ptr\r\n\r\nclass Resource\r\n{\r\npublic:\r\n\tResource() { std::cout &lt;&lt; \"Resource acquired\\n\"; }\r\n\t~Resource() { std::cout &lt;&lt; \"Resource destroyed\\n\"; }\r\n};\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Resource&amp;)\r\n{\r\n\tout &lt;&lt; \"I am a resource\";\r\n\treturn out;\r\n}\r\n\r\nint main()\r\n{\r\n\tstd::unique_ptr&lt;Resource&gt; res{ new Resource{} };\r\n\r\n\tif (res) \/\/ use implicit cast to bool to ensure res contains a Resource\r\n\t\tstd::cout &lt;&lt; *res &lt;&lt; '\\n'; \/\/ print the Resource that res is owning\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\nResource acquired\r\nI am a resource\r\nResource destroyed\r\n<\/pre>\n<p>In the above program, we use the overloaded operator* to get the Resource object owned by std::unique_ptr res, which we then send to std::cout for printing.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">std::unique_ptr and arrays<\/p>\n<p>Unlike std::auto_ptr, std::unique_ptr is smart enough to know whether to use scalar delete or array delete, so std::unique_ptr is okay to use with both scalar objects and arrays.<\/p>\n<p>However, std::array or std::vector (or std::string) are almost always better choices than using std::unique_ptr with a fixed array, dynamic array, or C-style string.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Favor std::array, std::vector, or std::string over a smart pointer managing a fixed array, dynamic array, or C-style string.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">std::make_unique<\/p>\n<p>C++14 comes with an additional function named std::make_unique().  This templated function constructs an object of the template type and initializes it with the arguments passed into the function.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;memory&gt; \/\/ for std::unique_ptr and std::make_unique\r\n#include &lt;iostream&gt;\r\n\r\nclass Fraction\r\n{\r\nprivate:\r\n\tint m_numerator{ 0 };\r\n\tint m_denominator{ 1 };\r\n\r\npublic:\r\n\tFraction(int numerator = 0, int denominator = 1) :\r\n\t\tm_numerator{ numerator }, m_denominator{ denominator }\r\n\t{\r\n\t}\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction &amp;f1)\r\n\t{\r\n\t\tout &lt;&lt; f1.m_numerator &lt;&lt; '\/' &lt;&lt; f1.m_denominator;\r\n\t\treturn out;\r\n\t}\r\n};\r\n\r\n\r\nint main()\r\n{\r\n\t\/\/ Create a single dynamically allocated Fraction with numerator 3 and denominator 5\r\n\t\/\/ We can also use automatic type deduction to good effect here\r\n\tauto f1{ std::make_unique&lt;Fraction&gt;(3, 5) };\r\n\tstd::cout &lt;&lt; *f1 &lt;&lt; '\\n';\r\n\r\n\t\/\/ Create a dynamically allocated array of Fractions of length 4\r\n\tauto f2{ std::make_unique&lt;Fraction[]&gt;(4) };\r\n\tstd::cout &lt;&lt; f2[0] &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>The code above prints:<\/p>\n<pre>\r\n3\/5\r\n0\/1\r\n<\/pre>\n<p>Use of std::make_unique() is optional, but is recommended over creating std::unique_ptr yourself.  This is because code using std::make_unique is simpler, and it also requires less typing (when used with automatic type deduction).  Furthermore, in C++14 it resolves an exception safety issue that can result from C++ leaving the order of evaluation for function arguments unspecified.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Use std::make_unique() instead of creating std::unique_ptr and using new yourself.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><a name=\"smartpointerexceptionsafety\"><\/a>The exception safety issue in more detail <a href=\"#smartpointerexceptionsafety\"><i class=\"fa fa-link\" style=\"font-size: 0.8em;\"><\/i><\/a><\/p>\n<p>For those wondering what the &#8220;exception safety issue&#8221; mentioned above is, here&#8217;s a description of the issue.<\/p>\n<p>Consider an expression like this one:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">some_function(std::unique_ptr&lt;T&gt;(new T), function_that_can_throw_exception());<\/code><\/pre>\n<p>The compiler is given a lot of flexibility in terms of how it handles this call.  It could create a new T, then call function_that_can_throw_exception(), then create the std::unique_ptr that manages the dynamically allocated T.  If function_that_can_throw_exception() throws an exception, then the T that was allocated will not be deallocated, because the smart pointer to do the deallocation hasn&#8217;t been created yet.  This leads to T being leaked.<\/p>\n<p>std::make_unique() doesn&#8217;t suffer from this problem because the creation of the object T and the creation of the std::unique_ptr happen inside the std::make_unique() function, where there&#8217;s no ambiguity about order of execution.<\/p>\n<p>This issue was fixed in C++17, as evaluation of function arguments can no longer be interleaved.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Returning std::unique_ptr from a function<\/p>\n<p>std::unique_ptr can be safely returned from a function by value:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;memory&gt; \/\/ for std::unique_ptr\r\n\r\nstd::unique_ptr&lt;Resource&gt; createResource()\r\n{\r\n     return std::make_unique&lt;Resource&gt;();\r\n}\r\n\r\nint main()\r\n{\r\n    auto ptr{ createResource() };\r\n\r\n    \/\/ do whatever\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above code, createResource() returns a std::unique_ptr by value.  If this value is not assigned to anything, the temporary return value will go out of scope and the Resource will be cleaned up.  If it is assigned (as shown in main()), in C++14 or earlier, move semantics will be employed to transfer the Resource from the return value to the object assigned to (in the above example, ptr), and in C++17 or newer, the return will be elided.  This makes returning a resource by std::unique_ptr much safer than returning raw pointers!<\/p>\n<p>In general, you should not return std::unique_ptr by pointer (ever) or reference (unless you have a specific compelling reason to).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Passing std::unique_ptr to a function<\/p>\n<p>If you want the function to take ownership of the contents of the pointer, pass the std::unique_ptr by value.  Note that because copy semantics have been disabled, you&#8217;ll need to use std::move to actually pass the variable in.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;memory&gt; \/\/ for std::unique_ptr\r\n#include &lt;utility&gt; \/\/ for std::move\r\n\r\nclass Resource\r\n{\r\npublic:\r\n\tResource() { std::cout &lt;&lt; \"Resource acquired\\n\"; }\r\n\t~Resource() { std::cout &lt;&lt; \"Resource destroyed\\n\"; }\r\n};\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Resource&amp;)\r\n{\r\n\tout &lt;&lt; \"I am a resource\";\r\n\treturn out;\r\n}\r\n\r\n\/\/ This function takes ownership of the Resource, which isn't what we want\r\nvoid takeOwnership(std::unique_ptr&lt;Resource&gt; res)\r\n{\r\n     if (res)\r\n          std::cout &lt;&lt; *res &lt;&lt; '\\n';\r\n} \/\/ the Resource is destroyed here\r\n\r\nint main()\r\n{\r\n    auto ptr{ std::make_unique&lt;Resource&gt;() };\r\n\r\n\/\/    takeOwnership(ptr); \/\/ This doesn't work, need to use move semantics\r\n    takeOwnership(std::move(ptr)); \/\/ ok: use move semantics\r\n\r\n    std::cout &lt;&lt; \"Ending program\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The above program prints:<\/p>\n<pre>\r\nResource acquired\r\nI am a resource\r\nResource destroyed\r\nEnding program\r\n<\/pre>\n<p>Note that in this case, ownership of the Resource was transferred to takeOwnership(), so the Resource was destroyed at the end of takeOwnership() rather than the end of main().<\/p>\n<p>However, most of the time, you won&#8217;t want the function to take ownership of the resource.<\/p>\n<p>Although you can pass a std::unique_ptr by const reference (which will allow the function to use the object without assuming ownership), it&#8217;s better to just pass the resource itself (by pointer or reference, depending on whether null is a valid argument).  This allows the function to remain agnostic of how the caller is managing its resources.<\/p>\n<p>To get a raw pointer from a std::unique_ptr, you can use the get() member function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;memory&gt; \/\/ for std::unique_ptr\r\n#include &lt;iostream&gt;\r\n\r\nclass Resource\r\n{\r\npublic:\r\n\tResource() { std::cout &lt;&lt; \"Resource acquired\\n\"; }\r\n\t~Resource() { std::cout &lt;&lt; \"Resource destroyed\\n\"; }\r\n};\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Resource&amp;)\r\n{\r\n\tout &lt;&lt; \"I am a resource\";\r\n\treturn out;\r\n}\r\n\r\n\/\/ The function only uses the resource, so we'll accept a pointer to the resource, not a reference to the whole std::unique_ptr&lt;Resource&gt;\r\nvoid useResource(const Resource* res)\r\n{\r\n\tif (res)\r\n\t\tstd::cout &lt;&lt; *res &lt;&lt; '\\n';\r\n\telse\r\n\t\tstd::cout &lt;&lt; \"No resource\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n\tauto ptr{ std::make_unique&lt;Resource&gt;() };\r\n\r\n\tuseResource(ptr.get()); \/\/ note: get() used here to get a pointer to the Resource\r\n\r\n\tstd::cout &lt;&lt; \"Ending program\\n\";\r\n\r\n\treturn 0;\r\n} \/\/ The Resource is destroyed here<\/code><\/pre>\n<p>The above program prints:<\/p>\n<pre>\r\nResource acquired\r\nI am a resource\r\nEnding program\r\nResource destroyed\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">std::unique_ptr and classes<\/p>\n<p>You can, of course, use std::unique_ptr as a composition member of your class.  This way, you don&#8217;t have to worry about ensuring your class destructor deletes the dynamic memory, as the std::unique_ptr will be automatically destroyed when the class object is destroyed.<\/p>\n<p>However, if the class object is not destroyed properly (e.g. it is dynamically allocated and not deallocated properly), then the std::unique_ptr member will not be destroyed either, and the object being managed by the std::unique_ptr will not be deallocated.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Misusing std::unique_ptr<\/p>\n<p>There are two easy ways to misuse std::unique_ptrs, both of which are easily avoided.  First, don&#8217;t let multiple objects manage the same resource.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">Resource* res{ new Resource() };\r\nstd::unique_ptr&lt;Resource&gt; res1{ res };\r\nstd::unique_ptr&lt;Resource&gt; res2{ res };<\/code><\/pre>\n<p>While this is legal syntactically, the end result will be that both res1 and res2 will try to delete the Resource, which will lead to undefined behavior.<\/p>\n<p>Second, don&#8217;t manually delete the resource out from underneath the std::unique_ptr.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">Resource* res{ new Resource() };\r\nstd::unique_ptr&lt;Resource&gt; res1{ res };\r\ndelete res;<\/code><\/pre>\n<p>If you do, the std::unique_ptr will try to delete an already deleted resource, again leading to undefined behavior.<\/p>\n<p>Note that std::make_unique() prevents both of the above cases from happening inadvertently.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #1<\/p>\n<p>\nConvert the following program from using a normal pointer to using std::unique_ptr where appropriate:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Fraction\r\n{\r\nprivate:\r\n\tint m_numerator{ 0 };\r\n\tint m_denominator{ 1 };\r\n\r\npublic:\r\n\tFraction(int numerator = 0, int denominator = 1) :\r\n\t\tm_numerator{ numerator }, m_denominator{ denominator }\r\n\t{\r\n\t}\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction &amp;f1)\r\n\t{\r\n\t\tout &lt;&lt; f1.m_numerator &lt;&lt; '\/' &lt;&lt; f1.m_denominator;\r\n\t\treturn out;\r\n\t}\r\n};\r\n\r\nvoid printFraction(const Fraction* ptr)\r\n{\r\n\tif (ptr)\r\n\t\tstd::cout &lt;&lt; *ptr &lt;&lt; '\\n';\r\n\telse\r\n\t\tstd::cout &lt;&lt; \"No fraction\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n\tauto* ptr{ new Fraction{ 3, 5 } };\r\n\r\n\tprintFraction(ptr);\r\n\r\n\tdelete ptr;\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;memory&gt; \/\/ for std::unique_ptr\r\n#include &lt;iostream&gt;\r\n\r\nclass Fraction\r\n{\r\nprivate:\r\n\tint m_numerator{ 0 };\r\n\tint m_denominator{ 1 };\r\n\r\npublic:\r\n\tFraction(int numerator = 0, int denominator = 1) :\r\n\t\tm_numerator{ numerator }, m_denominator{ denominator }\r\n\t{\r\n\t}\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction &amp;f1)\r\n\t{\r\n\t\tout &lt;&lt; f1.m_numerator &lt;&lt; '\/' &lt;&lt; f1.m_denominator;\r\n\t\treturn out;\r\n\t}\r\n};\r\n\r\n\/\/ This function uses a Fraction object, so we just pass the Fraction itself\r\n\/\/ That way we don't have to worry about what kind of smart pointer (if any) the caller may be using\r\nvoid printFraction(const Fraction* ptr)\r\n{\r\n\tif (ptr)\r\n\t\tstd::cout &lt;&lt; *ptr &lt;&lt; '\\n';\r\n\telse\r\n\t\tstd::cout &lt;&lt; \"No fraction\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n\tauto ptr{ std::make_unique&lt;Fraction&gt;(3, 5) };\r\n\r\n\tprintFraction(ptr.get());\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdshared_ptr\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">22.6<\/span>std::shared_ptr\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdmove\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">22.4<\/span>std::move\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>At the beginning of the chapter, we discussed how the use of pointers can lead to bugs and memory leaks in some situations. For example, this can happen when a function early returns, or throws an exception, and the pointer is not properly deleted. #include &lt;iostream&gt; void someFunction() { auto* &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5602"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=5602"}],"version-history":[{"count":57,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5602\/revisions"}],"predecessor-version":[{"id":17496,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5602\/revisions\/17496"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=5602"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=5602"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=5602"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}