{"id":17475,"date":"2024-10-22T12:48:59","date_gmt":"2024-10-22T19:48:59","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=17475"},"modified":"2025-01-01T22:25:13","modified_gmt":"2025-01-02T06:25:13","slug":"the-as-if-rule-and-compile-time-optimization","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/the-as-if-rule-and-compile-time-optimization\/","title":{"rendered":"5.4 &#8212; The as-if rule and compile-time optimization"},"content":{"rendered":"<p class=\"cpp-section\">Introduction to optimization<\/p>\n<p>In programming, <strong>optimization<\/strong> is the process of modifying software to make it work more efficiently (e.g. to run faster, or use fewer resources).  Optimization can have a huge impact on the overall performance level of an application.<\/p>\n<p>Some types of optimization are typically done by hand.  A program called a <strong>profiler<\/strong> can be used to see how long various parts of the program are taking to run, and which are impacting overall performance.  The programmer can then look for ways to alleviate those performance issues.  Because hand-optimization is slow, programmers typically focuses on making high-level improvements that will have a large impact (such as choosing more performant algorithms, optimizing data storage and access, reducing resource utilization, parallelizing tasks, etc&#8230;)<\/p>\n<p>Other kinds of optimization can be performed automatically.  A program that optimizes another program is called an <strong>optimizer<\/strong>.  Optimizers typically work at a low-level, looking for ways to improve statements or expressions by rewriting, reordering, or eliminating them.  For example, when you write <code>i = i * 2;<\/code>, the optimizer might rewrite this as <code> i *= 2;<\/code>, <code>i += i;<\/code>, or <code>i &lt;&lt;= 1;<\/code>.  For integral values, all of these produce the same result, but one might be faster than the others on a given architecture.  A programmer would probably not know which is the most performant choice (and the answer might vary based on architecture), but an optimizer for a given system would.  Individual low-level optimizations may only yield small performance gains, but their cumulative effect can result in a significant performance improvement overall.<\/p>\n<p>Modern C++ compilers are optimizing compilers, meaning they are capable of automatically optimizing your programs as part of the compilation process.  Just like the preprocessor, these optimizations do not modify your source code files -- rather, they are applied transparently as part of the compilation process.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Optimizing compilers allow programmers to focus on writing code that is readable and maintainable without sacrificing performance.\n<\/p><\/div>\n<p>Because optimization involves some tradeoffs (we&#8217;ll discuss this at the bottom of the lesson), compilers typically support multiple optimization levels that determine whether they optimize, how aggressively they optimize, and what kind of optimizations they prioritize (e.g. speed vs size).<\/p>\n<p>Most compilers default to no optimization, so if you&#8217;re using a command-line compiler, you&#8217;ll need to enable optimization yourself.  If you&#8217;re using an IDE, the IDE will likely automatically configure release builds to enable optimization and debug builds to disable optimization.<\/p>\n<div class=\"cpp-note cpp-lightyellowbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For gcc and Clang users<\/p>\n<p>See <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/configuring-your-compiler-build-configurations\/\">0.9 -- Configuring your compiler: Build configurations<\/a> for information on how to enable optimization.\n<\/p><\/div>\n<p class=\"cpp-section\">The as-if rule<\/p>\n<p>In C++, compilers are given a lot of leeway to optimize programs.  The <strong>as-if rule<\/strong> says that the compiler can modify a program however it likes in order to produce more optimized code, so long as those modifications do not affect a program&#8217;s &#8220;observable behavior&#8221;.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>There is one notable exception to the as-if rule: unnecessary calls to a copy (or move) constructor can be elided (omitted) even if those constructors have observable behavior.  We cover this topic in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-initialization-and-copy-elision\/\">14.15 -- Class initialization and copy elision<\/a>.\n<\/p><\/div>\n<p>Modern compilers employ a variety of different techniques in order to optimize a program effectively.  Which techniques can be applied depends on the program and the quality of the compiler and optimizer.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p><a href=\"https:\/\/en.wikipedia.org\/wiki\/Optimizing_compiler#Specific_techniques\">Wikipedia<\/a> has list of specific techniques that compilers use.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">An optimization opportunity<\/p>\n<p>Consider the following short program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tint x { 3 + 4 };\r\n\tstd::cout &lt;&lt; x &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>The output is straightforward:<\/p>\n<pre>\n7\r\n<\/pre>\n<p>However, there&#8217;s an interesting optimization possibility hidden within.<\/p>\n<p>If this program were compiled exactly as it was written (with no optimizations), the compiler would generate an executable that calculates the result of <code>3 + 4<\/code> at runtime (when the program is run).  If the program were executed a million times, <code>3 + 4<\/code> would be evaluated a million times, and the resulting value of <code>7<\/code> produced a million times.<\/p>\n<p>Because the result of <code>3 + 4<\/code> never changes (it is always <code>7<\/code>), re-calculating this result every time the program is run is wasteful.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Compile-time evaluation<\/p>\n<p>Modern C++ compilers are capable of fully or partially evaluating certain expressions at compile-time (rather than at runtime).  When the compiler fully or partially evaluates an expression at compile-time, this is called <strong>compile-time evaluation<\/strong>.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Compile-time evaluation allows the compiler to do work at compile-time that would otherwise be done at runtime.  Because such expressions no longer need to be evaluated at runtime, the resulting executables are faster and smaller (at the cost of slightly slower compilation times).\n<\/p><\/div>\n<p>For illustrative purposes, in this lesson we will look at some simple optimization techniques that make use of compile-time evaluation.  Then, we&#8217;ll continue our discussion of compile-time evaluation in subsequent lessons.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constant folding<\/p>\n<p>One of the original forms of compile-time evaluation is called &#8220;constant folding&#8221;.  <strong>Constant folding<\/strong> is an optimization technique where the compiler replaces expressions that have literal operands with the result of the expression.  Using constant folding, the compiler would recognize that the expression <code>3 + 4<\/code> has constant operands, and then replace the expression with the result <code>7<\/code>.<\/p>\n<p>The result would be equivalent to the following:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tint x { 7 };\r\n\tstd::cout &lt;&lt; x &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This program produces the same output (<code>7<\/code>) as the prior version, but the resulting executable no longer needs to spend CPU cycles calculating <code>3 + 4<\/code> at runtime!  <\/p>\n<p>Constant folding can also be applied to subexpressions, even when the full expression must execute at runtime.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; 3 + 4 &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In the above example, <code>3 + 4<\/code> is a subexpression of the full expression <code>std::cout &lt;&lt; 3 + 4 &lt;&lt; '\\n';<\/code>.  The compiler can optimize this to <code>std::cout &lt;&lt; 7 &lt;&lt; '\\n';<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constant propagation<\/p>\n<p>The following program contains another optimization opportunity:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tint x { 7 };\r\n\tstd::cout &lt;&lt; x &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>When <code>x<\/code> is initialized, the value <code>7<\/code> will be stored in the memory allocated for <code>x<\/code>.  Then on the next line, the program will go out to memory again to fetch the value <code>7<\/code> so it can be printed.  This requires two memory access operations (one to store the value, and one to fetch it).<\/p>\n<p><strong>Constant propagation<\/strong> is an optimization technique where the compiler replaces variables known to have constant values with their values.  Using constant propagation, the compiler would realize that <code>x<\/code> always has the constant value <code>7<\/code>, and replace any use of variable <code>x<\/code> with the value <code>7<\/code>.<\/p>\n<p>The result would be equivalent to the following:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tint x { 7 };\r\n\tstd::cout &lt;&lt; 7 &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This removes the need for the program to go out to memory to fetch the value of <code>x<\/code>.<\/p>\n<p>Constant propagation may produce a result that can then be optimized by constant folding:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tint x { 7 };\r\n\tint y { 3 };\r\n\tstd::cout &lt;&lt; x + y &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In this example, constant propagation would transform <code>x + y<\/code> into <code>7 + 3<\/code>, which can then be constant folded into the value <code>10<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Dead code elimination<\/p>\n<p><strong>Dead code elimination<\/strong> is an optimization technique where the compiler removes code that may be executed but has no effect on the program&#8217;s behavior.<\/p>\n<p>Back to a prior example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tint x { 7 };\r\n\tstd::cout &lt;&lt; 7 &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In this program, variable <code>x<\/code> is defined and initialized, but it is never used anywhere, so it has no effect on the program&#8217;s behavior.  Dead code elimination would remove the definition of <code>x<\/code>.<\/p>\n<p>The result would be equivalent to the following:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; 7 &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>When a variable is removed from a program because it is no longer needed, we say the variable has been <strong>optimized out<\/strong> (or <strong>optimized away<\/strong>).<\/p>\n<p>Compared to the original version, this optimized version no longer requires runtime calculation expression <code>3 + 4<\/code>, nor does it require two memory access operations (one to initialize variable <code>x<\/code> and one to read the value from <code>x<\/code>).  This means the program will be both smaller and faster.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Const variables are easier to optimize<\/p>\n<p>In some cases, there are simple things we can do to help the compiler optimize more effectively.<\/p>\n<p>Constant propagation can be challenging for the compiler.  In the section on constant propagation, we offered this example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tint x { 7 };\r\n\tstd::cout &lt;&lt; x &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Since <code>x<\/code> is defined as a non-const variable, in order to apply this optimization, the compiler must realize that the value of <code>x<\/code> actually doesn&#8217;t change (even though it could).  Whether the compiler is capable of doing so comes down to how complex the program is and how sophisticated the compiler&#8217;s optimization routines are.<\/p>\n<p>We can help the compiler optimize more effectively by using constant variables wherever possible.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tconst int x { 7 }; \/\/ x is now const\r\n\tstd::cout &lt;&lt; x &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Because <code>x<\/code> is now const, the compiler has a guarantee that <code>x<\/code> can&#8217;t be changed after initialization.  This makes it more likely the compiler will apply constant propagation, and then optimize the variable out entirely.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Using const variables can help the compiler optimize more effectively.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Optimization can make programs harder to debug<\/p>\n<p>If optimization makes our programs faster, why isn&#8217;t it turned on by default?<\/p>\n<p>When the compiler optimizes a program, the result is that variables, expressions, statements, and function calls may be rearranged, modified, replaced, or removed entirely.  Such changes can make it hard to debug a program effectively.<\/p>\n<p>At runtime, it can be hard to debug compiled code that no longer correlates very well with the original source code.  For example, if you try to watch a variable that has been optimized out, the debugger won&#8217;t be able to locate the variable.  If you try to step into a function that has been optimized away, the debugger will simply skip over it.  So if you are debugging your code and the debugger is behaving strangely, this is the most likely reason.<\/p>\n<p>At compile-time, we have little visibility and few tools to help us understand what the compiler is even doing.  If a variable or expression is replaced with a value, and that value is wrong, how do we even go about debugging the issue?  This is an ongoing challenge.<\/p>\n<p>To help minimize such issues, debug builds will typically leave optimizations turned off, so that the compiled code will more closely match the source code.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>Compile-time debugging is an underdeveloped area.  As of C++23, there are a number of papers under consideration for future language standards (such as <a href=\"https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2023\/p2758r1.html\">this one<\/a>) that (if approved) will add capabilities to the language that will help.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Nomenclature: Compile-time constants vs runtime constants<\/p>\n<p>Constants in C++ are sometimes divided into two informal categories.<\/p>\n<p>A <strong>compile-time constant<\/strong> is a constant whose value is known at compile-time.  Examples include:<\/p>\n<ul>\n<li>Literals.\n<\/li>\n<li>Constant objects whose initializers are compile-time constants.\n<\/li>\n<\/ul>\n<p>A <strong>runtime constant<\/strong> is a constant whose value is determined in a runtime context.  Examples include:<\/p>\n<ul>\n<li>Constant function parameters.\n<\/li>\n<li>Constant objects whose initializers are non-constants or runtime constants.\n<\/li>\n<\/ul>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint five()\r\n{\r\n    return 5;\r\n}\r\n\r\nint pass(const int x) \/\/ x is a runtime constant\r\n{\r\n    return x;\r\n}\r\n\r\nint main()\r\n{\r\n    \/\/ The following are non-constants:\r\n    [[maybe_unused]] int a { 5 };\r\n\r\n    \/\/ The following are compile-time constants:\r\n    [[maybe_unused]] const int b { 5 };\r\n    [[maybe_unused]] const double c { 1.2 };\r\n    [[maybe_unused]] const int d { b };       \/\/ b is a compile-time constant\r\n\r\n    \/\/ The following are runtime constants:\r\n    [[maybe_unused]] const int e { a };       \/\/ a is non-const\r\n    [[maybe_unused]] const int f { e };       \/\/ e is a runtime constant\r\n    [[maybe_unused]] const int g { five() };  \/\/ return value isn't known until runtime\r\n    [[maybe_unused]] const int h { pass(5) }; \/\/ return value isn't known until runtime\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Although you will encounter these terms out in the wild, in C++ these definitions are not all that useful:<\/p>\n<ul>\n<li>Some runtime constants (and even non-constants) can be evaluated at compile-time for optimization purposes (under the as-if rule).\n<\/li>\n<li>Some compile-time constants (e.g. <code>const double d { 1.2 };<\/code>) cannot be used in compile-time features (as defined by the language standard).  We&#8217;ll discuss this more in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constant-expressions\/\">5.5 -- Constant expressions<\/a>.\n<\/li>\n<\/ul>\n<p>For this reason, we recommend avoiding these terms.  We&#8217;ll discuss the nomenclature that you should use instead in the next lesson.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>We are in the process of phasing these terms out of future articles.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constant-expressions\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">5.5<\/span>Constant expressions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/numeral-systems-decimal-binary-hexadecimal-and-octal\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">5.3<\/span>Numeral systems (decimal, binary, hexadecimal, and octal)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Introduction to optimization In programming, optimization is the process of modifying software to make it work more efficiently (e.g. to run faster, or use fewer resources). Optimization can have a huge impact on the overall performance level of an application. Some types of optimization are typically done by hand. A &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/17475"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=17475"}],"version-history":[{"count":14,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/17475\/revisions"}],"predecessor-version":[{"id":18066,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/17475\/revisions\/18066"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=17475"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=17475"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=17475"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}