{"id":70,"date":"2007-06-20T18:34:57","date_gmt":"2007-06-21T02:34:57","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/47-structs\/"},"modified":"2024-10-04T15:58:23","modified_gmt":"2024-10-04T22:58:23","slug":"introduction-to-structs-members-and-member-selection","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-structs-members-and-member-selection\/","title":{"rendered":"13.7 &#8212; Introduction to structs, members, and member selection"},"content":{"rendered":"<p>There are many instances in programming where we need more than one variable in order to represent something of interest.  As we discussed in the introduction to the previous chapter (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-compound-data-types\/\">12.1 -- Introduction to compound data types<\/a>), a fraction has a numerator and denominator that are linked together into a single mathematical object.<\/p>\n<p>Alternatively, lets say we want to write a program where we need to store information about the employees in a company.  We might be interested in keeping track of attributes such as the employee&#8217;s name, title, age, employee id, manager id, wage, birthday, hire date, etc&#8230;<\/p>\n<p>If we were to use independent variables to track all of this information, that might look something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::string name;\r\nstd::string title;\r\nint age;\r\nint id;\r\nint managerId;\r\ndouble wage;\r\nint birthdayYear;\r\nint birthdayMonth;\r\nint birthdayDay;\r\nint hireYear;\r\nint hireMonth;\r\nint hireDay;<\/code><\/pre>\n<p>However, there are a number of problems with this approach.  First, it&#8217;s not immediately clear whether these variables are actually related or not (you&#8217;d have to read comments, or see how they are used in context).  Second, there are now 12 variables to manage.  If we wanted to pass this employee to a function, we&#8217;d have to pass 12 arguments (and in the correct order), which would make a mess of our function prototypes and function calls.  And since a function can only return a single value, how would a function even return an employee?<\/p>\n<p>And if we wanted more than one employee, we&#8217;d need to define 12 more variables for each additional employee (each of which would require a unique name)!  This clearly doesn&#8217;t scale at all.  What we really need is some way to organize all of these related pieces of data together, to make them easier to manage.<\/p>\n<p>Fortunately, C++ comes with two compound types designed to solve such challenges: structs (which we&#8217;ll introduce now) and classes (which we&#8217;ll explore soon).  A <strong>struct<\/strong> (short for <strong>structure<\/strong>) is a program-defined data type (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-program-defined-user-defined-types\/\">13.1 -- Introduction to program-defined (user-defined) types<\/a>) that allows us to bundle multiple variables together into a single type.  As you&#8217;ll see shortly, this makes management of related sets of variables much simpler!<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">A reminder<\/p>\n<p>A struct is a class type (as are classes and unions).  As such, anything that applies to class types applies to structs.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Defining structs<\/p>\n<p>Because structs are a program-defined type, we first have to tell the compiler what our struct type looks like before we can begin using it.  Here is an example of a struct definition for a simplified employee:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">struct Employee\r\n{\r\n    int id {};\r\n    int age {};\r\n    double wage {};\r\n};<\/code><\/pre>\n<p>The <code>struct<\/code> keyword is used to tell the compiler that we&#8217;re defining a struct, which we&#8217;ve named <code>Employee<\/code> (since program-defined types are typically given names starting with a capital letter).<\/p>\n<p>Then, inside a pair of curly braces, we define the variables that each Employee object will contain.  In this example, each <code>Employee<\/code> we create will have 3 variables: an <code>int id<\/code>, an <code>int age<\/code>,  and a <code>double wage<\/code>.  The variables that are part of the struct are called <strong>data members<\/strong> (or <strong>member variables<\/strong>).<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>In everyday language, a <em>member<\/em> is a individual who belongs to a group.  For example, you might be a member of the basketball team, and your sister might be a member of the choir.<\/p>\n<p>In C++, a <strong>member<\/strong> is a variable, function, or type that belongs to a struct (or class).  All members must be declared within the struct (or class) definition.<\/p>\n<p>We&#8217;ll use the term <em>member<\/em> a lot in future lessons, so make sure you remember what it means.\n<\/div>\n<p>Just like we use an empty set of curly braces to value initialize (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/variable-assignment-and-initialization\/\">1.4 -- Variable assignment and initialization<\/a>) normal variables, the empty curly braces after each member variable ensures that the member variables inside our <code>Employee<\/code> are value initialized when an <code>Employee<\/code> is created.  We&#8217;ll talk more about this when we cover default member initialization in a few lessons (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/default-member-initialization\/\">13.9 -- Default member initialization<\/a>).<\/p>\n<p>Finally, we end the type definition with a semicolon.<\/p>\n<p>As a reminder, <code>Employee<\/code> is just a type definition -- no objects are actually created at this point.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Defining struct objects<\/p>\n<p>In order to use the <code>Employee<\/code> type, we simply define a variable of type <code>Employee<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">Employee joe {}; \/\/ Employee is the type, joe is the variable name<\/code><\/pre>\n<p>This defines a variable of type <code>Employee<\/code> named <code>joe<\/code>.  When the code is executed, an Employee object is instantiated that contains the 3 data members.  The empty braces ensures our object is value-initialized.<\/p>\n<p>Just like any other type, it is possible to define multiple variables of the same struct type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">Employee joe {}; \/\/ create an Employee struct for Joe\r\nEmployee frank {}; \/\/ create an Employee struct for Frank<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Accessing members<\/p>\n<p>Consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">struct Employee\r\n{\r\n    int id {};\r\n    int age {};\r\n    double wage {};\r\n};\r\n\r\nint main()\r\n{\r\n    Employee joe {};\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, the name <code>joe<\/code> refers to the entire struct object (which contains the member variables).  To access a specific member variable, we use the <strong>member selection operator<\/strong> (<code>operator.<\/code>) in between the struct variable name and the member name.  For example, to access Joe&#8217;s age member, we&#8217;d use <code>joe.age<\/code>.<\/p>\n<p>Struct member variables work just like normal variables, so it is possible to do normal operations on them, including assignment, arithmetic, comparison, etc&#8230;<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Employee\r\n{\r\n    int id {};\r\n    int age {};\r\n    double wage {};\r\n};\r\n\r\nint main()\r\n{\r\n    Employee joe {};\r\n\r\n    joe.age = 32;  \/\/ use member selection operator (.) to select the age member of variable joe\r\n\r\n    std::cout &lt;&lt; joe.age &lt;&lt; '\\n'; \/\/ print joe's age\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n32\r\n<\/pre>\n<p>One of the biggest advantages of structs is that we only need to create one new name per struct variable (the member names are fixed as part of the struct type definition).  In the following example, we instantiate two <code>Employee<\/code> objects: <code>joe<\/code> and <code>frank<\/code>.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Employee\r\n{\r\n    int id {};\r\n    int age {};\r\n    double wage {};\r\n};\r\n\r\nint main()\r\n{\r\n    Employee joe {};\r\n    joe.id = 14;\r\n    joe.age = 32;\r\n    joe.wage = 60000.0;\r\n\r\n    Employee frank {};\r\n    frank.id = 15;\r\n    frank.age = 28;\r\n    frank.wage = 45000.0;\r\n\r\n    int totalAge { joe.age + frank.age };\r\n    std::cout &lt;&lt; \"Joe and Frank have lived \" &lt;&lt; totalAge &lt;&lt; \" total years\\n\";\r\n\r\n    if (joe.wage &gt; frank.wage)\r\n        std::cout &lt;&lt; \"Joe makes more than Frank\\n\";\r\n    else if (joe.wage &lt; frank.wage)\r\n        std::cout &lt;&lt; \"Joe makes less than Frank\\n\";\r\n    else\r\n        std::cout &lt;&lt; \"Joe and Frank make the same amount\\n\";\r\n\r\n    \/\/ Frank got a promotion\r\n    frank.wage += 5000.0;\r\n\r\n    \/\/ Today is Joe's birthday\r\n    ++joe.age; \/\/ use pre-increment to increment Joe's age by 1\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, it is very easy to tell which member variables belong to Joe and which belong to Frank.  This provides a much higher level of organization than individual variables would.  Furthermore, because Joe&#8217;s and Frank&#8217;s members have the same names, this provides consistency when you have multiple variables of the same struct type.<\/p>\n<p>We&#8217;ll continue our exploration of structs in the next lesson, including a look at how to initialize them.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/struct-aggregate-initialization\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.8<\/span>Struct aggregate initialization\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/scoped-enumerations-enum-classes\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.6<\/span>Scoped enumerations (enum classes)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>There are many instances in programming where we need more than one variable in order to represent something of interest. As we discussed in the introduction to the previous chapter (), a fraction has a numerator and denominator that are linked together into a single mathematical object. Alternatively, lets say &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/70"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=70"}],"version-history":[{"count":73,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/70\/revisions"}],"predecessor-version":[{"id":17712,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/70\/revisions\/17712"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=70"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=70"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=70"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}