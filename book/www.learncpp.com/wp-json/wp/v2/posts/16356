{"id":16356,"date":"2023-12-28T16:46:19","date_gmt":"2023-12-29T00:46:19","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=16356"},"modified":"2025-01-29T17:49:58","modified_gmt":"2025-01-30T01:49:58","slug":"global-random-numbers-random-h","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/global-random-numbers-random-h\/","title":{"rendered":"8.15 &#8212; Global random numbers (Random.h)"},"content":{"rendered":"<p>What happens if we want to use a random number generator in multiple functions or files?  One way is to create (and seed) our PRNG in our <code>main()<\/code> function, and then pass it everywhere we need it.  But that&#8217;s a lot of passing for something we may only use sporadically, and in many different places.  It would add a lot of clutter to our code to pass such an object around.<\/p>\n<p>Alternately, you could create a static local <code>std::mt19937<\/code> variable in each function that needs it (static so that it only gets seeded once).  However, it&#8217;s overkill to have every function that uses a random number generator define and seed its own local generator, and the low volume of calls to each generator may lead to lower quality results.<\/p>\n<p>What we really want is a single PRNG object that we can share and access anywhere, across all of our functions and files.  The best option here is to create a global random number generator object (inside a namespace!).  Remember how we told you to avoid non-const global variables?  This is an exception.<\/p>\n<p>Here&#8217;s a simple, header-only solution that you can #include in any code file that needs access to a randomized, self-seeded <code>std::mt19937<\/code>:<\/p>\n<p>Random.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef RANDOM_MT_H\r\n#define RANDOM_MT_H\r\n\r\n#include &lt;chrono&gt;\r\n#include &lt;random&gt;\r\n\r\n\/\/ This header-only Random namespace implements a self-seeding Mersenne Twister.\r\n\/\/ Requires C++17 or newer.\r\n\/\/ It can be #included into as many code files as needed (The inline keyword avoids ODR violations)\r\n\/\/ Freely redistributable, courtesy of learncpp.com (https:\/\/www.learncpp.com\/cpp-tutorial\/global-random-numbers-random-h\/)\r\nnamespace Random\r\n{\r\n\t\/\/ Returns a seeded Mersenne Twister\r\n\t\/\/ Note: we'd prefer to return a std::seed_seq (to initialize a std::mt19937), but std::seed can't be copied, so it can't be returned by value.\r\n\t\/\/ Instead, we'll create a std::mt19937, seed it, and then return the std::mt19937 (which can be copied).\r\n\tinline std::mt19937 generate()\r\n\t{\r\n\t\tstd::random_device rd{};\r\n\r\n\t\t\/\/ Create seed_seq with clock and 7 random numbers from std::random_device\r\n\t\tstd::seed_seq ss{\r\n\t\t\tstatic_cast&lt;std::seed_seq::result_type&gt;(std::chrono::steady_clock::now().time_since_epoch().count()),\r\n\t\t\t\trd(), rd(), rd(), rd(), rd(), rd(), rd() };\r\n\r\n\t\treturn std::mt19937{ ss };\r\n\t}\r\n\r\n\t\/\/ Here's our global std::mt19937 object.\r\n\t\/\/ The inline keyword means we only have one global instance for our whole program.\r\n\tinline std::mt19937 mt{ generate() }; \/\/ generates a seeded std::mt19937 and copies it into our global object\r\n\r\n\t\/\/ Generate a random int between [min, max] (inclusive)\r\n        \/\/ * also handles cases where the two arguments have different types but can be converted to int\r\n\tinline int get(int min, int max)\r\n\t{\r\n\t\treturn std::uniform_int_distribution{min, max}(mt);\r\n\t}\r\n\r\n\t\/\/ The following function templates can be used to generate random numbers in other cases\r\n\r\n\t\/\/ See https:\/\/www.learncpp.com\/cpp-tutorial\/function-template-instantiation\/\r\n\t\/\/ You can ignore these if you don't understand them\r\n\r\n\t\/\/ Generate a random value between [min, max] (inclusive)\r\n\t\/\/ * min and max must have the same type\r\n\t\/\/ * return value has same type as min and max\r\n\t\/\/ * Supported types:\r\n\t\/\/ *    short, int, long, long long\r\n\t\/\/ *    unsigned short, unsigned int, unsigned long, or unsigned long long\r\n\t\/\/ Sample call: Random::get(1L, 6L);             \/\/ returns long\r\n\t\/\/ Sample call: Random::get(1u, 6u);             \/\/ returns unsigned int\r\n\ttemplate &lt;typename T&gt;\r\n\tT get(T min, T max)\r\n\t{\r\n\t\treturn std::uniform_int_distribution&lt;T&gt;{min, max}(mt);\r\n\t}\r\n\r\n\t\/\/ Generate a random value between [min, max] (inclusive)\r\n\t\/\/ * min and max can have different types\r\n        \/\/ * return type must be explicitly specified as a template argument\r\n\t\/\/ * min and max will be converted to the return type\r\n\t\/\/ Sample call: Random::get&lt;std::size_t&gt;(0, 6);  \/\/ returns std::size_t\r\n\t\/\/ Sample call: Random::get&lt;std::size_t&gt;(0, 6u); \/\/ returns std::size_t\r\n\t\/\/ Sample call: Random::get&lt;std::int&gt;(0, 6u);    \/\/ returns int\r\n\ttemplate &lt;typename R, typename S, typename T&gt;\r\n\tR get(S min, T max)\r\n\t{\r\n\t\treturn get&lt;R&gt;(static_cast&lt;R&gt;(min), static_cast&lt;R&gt;(max));\r\n\t}\r\n}\r\n\r\n#endif<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using Random.h<\/p>\n<p>Generating random numbers using the above is as simple as following these three steps:<\/p>\n<ol start=\"1\">\n<li>Copy\/paste the above code into a file named <code>Random.h<\/code> in your project directory and save it.  Optionally add Random.h to your project.\n<\/li>\n<li><code>#include \"Random.h\"<\/code> from any .cpp file in your project that needs to generate random numbers.\n<\/li>\n<li>Call <code>Random::get(min, max)<\/code> to generate a random number between <code>min<\/code> and <code>max<\/code> (inclusive).  No initialization or setup is required.\n<\/li>\n<\/ol>\n<p>Here is a sample program demonstrating different uses of Random.h:<\/p>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"Random.h\" \/\/ defines Random::mt, Random::get(), and Random::generate()\r\n#include &lt;cstddef&gt; \/\/ for std::size_t\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\t\/\/ We can call Random::get() to generate random integral values\r\n\t\/\/ If the two arguments have the same type, the returned value will have that same type.\r\n\tstd::cout &lt;&lt; Random::get(1, 6) &lt;&lt; '\\n';   \/\/ returns int between 1 and 6\r\n\tstd::cout &lt;&lt; Random::get(1u, 6u) &lt;&lt; '\\n'; \/\/ returns unsigned int between 1 and 6\r\n\r\n        \/\/ In cases where we have two arguments with different types\r\n        \/\/ and\/or if we want the return type to be different than the argument types\r\n        \/\/ We must specify the return type using a template type argument (between the angled brackets)\r\n\t\/\/ See https:\/\/www.learncpp.com\/cpp-tutorial\/function-template-instantiation\/\r\n\tstd::cout &lt;&lt; Random::get&lt;std::size_t&gt;(1, 6u) &lt;&lt; '\\n'; \/\/ returns std::size_t between 1 and 6\r\n\r\n\t\/\/ If we have our own distribution, we can access Random::mt directly\r\n\r\n\t\/\/ Let's create a reusable random number generator that generates uniform numbers between 1 and 6\r\n\tstd::uniform_int_distribution die6{ 1, 6 }; \/\/ for C++14, use std::uniform_int_distribution&lt;&gt; die6{ 1, 6 };\r\n\tfor (int count{ 1 }; count &lt;= 10; ++count)\r\n\t{\r\n\t\tstd::cout &lt;&lt; die6(Random::mt) &lt;&lt; '\\t'; \/\/ generate a roll of the die here\r\n\t}\r\n\r\n\tstd::cout &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A few notes about the implementation of Random.h <span class=\"cpp-section-pill cpp-section-optional\">Optional<\/span><\/p>\n<p>Normally, defining variables and functions in a header file would cause violations of the one-definition rule (ODR) when that header file was included into more than one source file.  However, we&#8217;ve made our <code>mt<\/code> variable and supporting functions <code>inline<\/code>, which allows us to have duplicate definitions without violating the ODR so long as those definitions are all identical.  Because we&#8217;re #including those definitions from a header file (rather than typing them manually, or copy\/pasting them), we can ensure they are identical.  Inline functions and variables were added to the language largely to make doing this kind of header-only functionality possible.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover inline functions and variables in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/inline-functions-and-variables\/\">7.9 -- Inline functions and variables<\/a>.\n<\/p><\/div>\n<p>The other challenge that we have to overcome is in how we initialize our global <code>Random::mt<\/code> object, as we want it to be self-seeding so that we don&#8217;t have to remember to explicitly call an initialization function for it to work correctly.  Our initializer must be an expression.  But in order to initialize a <code>std::mt19937<\/code>, we need several helper objects (a <code>std::random_device<\/code> and a <code>std::seed_seq<\/code>) which must be defined as statements.   This is where a helper function comes in handy.  A function call is an expression, so we can use the return value of a function as an initializer.  And inside the function itself, we can have any combination of statements that we need.  Thus, our <code>generate()<\/code> function creates and returns a fully-seeded <code>std::mt19937<\/code> object (seeded using both the system clock and <code>std::random_device<\/code>) that we use as the initializer to our global <code>Random::mt<\/code> object.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-8-summary-and-quiz\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">8.x<\/span>Chapter 8 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/generating-random-numbers-using-mersenne-twister\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">8.14<\/span>Generating random numbers using Mersenne Twister\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>What happens if we want to use a random number generator in multiple functions or files? One way is to create (and seed) our PRNG in our main() function, and then pass it everywhere we need it. But that&#8217;s a lot of passing for something we may only use sporadically, &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/16356"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=16356"}],"version-history":[{"count":11,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/16356\/revisions"}],"predecessor-version":[{"id":18143,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/16356\/revisions\/18143"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=16356"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=16356"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=16356"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}