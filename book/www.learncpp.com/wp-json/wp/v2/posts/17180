{"id":17180,"date":"2024-06-11T11:06:42","date_gmt":"2024-06-11T18:06:42","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=17180"},"modified":"2024-10-20T15:39:33","modified_gmt":"2024-10-20T22:39:33","slug":"using-function-templates-in-multiple-files","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/using-function-templates-in-multiple-files\/","title":{"rendered":"11.10 &#8212; Using function templates in multiple files"},"content":{"rendered":"<p>Consider the following program, which doesn&#8217;t work correctly:<\/p>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nT addOne(T x); \/\/ function template forward declaration\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; addOne(1) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; addOne(2.3) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>add.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;typename T&gt;\r\nT addOne(T x) \/\/ function template definition\r\n{\r\n    return x + 1;\r\n}<\/code><\/pre>\n<p>If <code>addOne<\/code> were a non-template function, this program would work fine: In <em>main.cpp<\/em>, the compiler would be satisfied with the forward declaration of <code>addOne<\/code>, and the linker would connect the call to <code>addOne()<\/code> in <em>main.cpp<\/em> to the function definition in <em>add.cpp<\/em>.<\/p>\n<p>But because <code>addOne<\/code> is a template, this program doesn&#8217;t work, and we get a linker error:<\/p>\n<pre>\n1&gt;Project6.obj : error LNK2019: unresolved external symbol \"int __cdecl addOne&lt;int&gt;(int)\" (??$addOne@H@@YAHH@Z) referenced in function _main\r\n1&gt;Project6.obj : error LNK2019: unresolved external symbol \"double __cdecl addOne&lt;double&gt;(double)\" (??$addOne@N@@YANN@Z) referenced in function _main\r\n<\/pre>\n<p>In <em>main.cpp<\/em>, we call <code>addOne&lt;int&gt;<\/code> and <code>addOne&lt;double&gt;<\/code>.  However, since the compiler can&#8217;t see the definition for function template <code>addOne<\/code>, it can&#8217;t instantiate those functions inside <em>main.cpp<\/em>.  It does see the forward declaration for <code>addOne<\/code> though, and will assume those functions exist elsewhere and will be linked in later.<\/p>\n<p>When the compiler goes to compile <em>add.cpp<\/em>, it will see the definition for function template <code>addOne<\/code>.  However, there are no uses of this template in <em>add.cpp<\/em>, so the compiler will not instantiate anything.  The end result is that the linker is unable to connect the calls to <code>addOne&lt;int&gt;<\/code> and <code>addOne&lt;double&gt;<\/code> in <em>main.cpp<\/em> to the actual functions, because those functions were never instantiated.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>If <em>add.cpp<\/em> had instantiated those functions, the program would have compiled and linked just fine.  But such solutions are fragile and should be avoided: if the code in <em>add.cpp<\/em> was later changed so those functions are no longer instantiated, the program would again fail to link.  Or if <em>main.cpp<\/em> called a different version of <code>addOne<\/code> (such as <code>addOne&lt;float&gt;<\/code>) that was not instantiated in <em>add.cpp<\/em>, we run into the same problem.\n<\/div>\n<p>The most conventional way to address this issue is to put all your template code in a header (.h) file instead of a source (.cpp) file:<\/p>\n<p>add.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef ADD_H\r\n#define ADD_H\r\n\r\ntemplate &lt;typename T&gt;\r\nT addOne(T x) \/\/ function template definition\r\n{\r\n    return x + 1;\r\n}\r\n\r\n#endif<\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"add.h\" \/\/ import the function template definition\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; addOne(1) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; addOne(2.3) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>That way, any files that need access to the template can #include the relevant header, and the template definition will be copied by the preprocessor into the source file.  The compiler will then be able to instantiate any functions that are needed.<\/p>\n<p>You may be wondering why this doesn&#8217;t cause a violation of the one-definition rule (ODR).  The ODR says that types, templates, inline functions, and inline variables are allowed to have identical definitions in different files.  So there is no problem if the template definition is copied into multiple files (as long as each definition is identical).<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We covered the ODR in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/forward-declarations\/#ODR\">2.7 -- Forward declarations and definitions<\/a>.\n<\/p><\/div>\n<p>But what about the instantiated functions themselves?  If a function is instantiated in multiple files, how does that not cause a violation of the ODR?  The answer is that functions implicitly instantiated from templates are implicitly inline.  And as you know, inline functions can be defined in multiple files, so long as the definition is identical in each.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Template definitions are exempt from the part of the one-definition rule that requires only one definition per program, so it is not a problem to have the same template definition #included into multiple source files.  And functions implicitly instantiated from function templates are implicitly inline, so they can be defined in multiple files, so long as each definition is identical.<\/p>\n<p>The templates themselves are not inline, as the concept of inline only applies to variables and functions.\n<\/p><\/div>\n<p>Here&#8217;s another example of a function template being placed in a header file, so it can be included into multiple source files:<\/p>\n<p>max.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef MAX_H\r\n#define MAX_H\r\n\r\ntemplate &lt;typename T&gt;\r\nT max(T x, T y)\r\n{\r\n    return (x &lt; y) ? y : x;\r\n}\r\n\r\n#endif<\/code><\/pre>\n<p>foo.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"max.h\" \/\/ import template definition for max&lt;T&gt;(T, T)\r\n#include &lt;iostream&gt;\r\n\r\nvoid foo()\r\n{\r\n\tstd::cout &lt;&lt; max(3, 2) &lt;&lt; '\\n';\r\n}<\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"max.h\" \/\/ import template definition for max&lt;T&gt;(T, T)\r\n#include &lt;iostream&gt;\r\n\r\nvoid foo(); \/\/ forward declaration for function foo\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; max(3, 5) &lt;&lt; '\\n';\r\n    foo();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, both main.cpp and foo.cpp <code>#include \"max.h\"<\/code> so the code in both files can make use of the <code>max&lt;T&gt;(T, T)<\/code> function template.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Templates that are needed in multiple files should be defined in a header file, and then #included wherever needed.  This allows the compiler to see the full template definition and instantiate the template when needed.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-11-summary-and-quiz\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">11.x<\/span>Chapter 11 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/non-type-template-parameters\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">11.9<\/span>Non-type template parameters\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Consider the following program, which doesn&#8217;t work correctly: main.cpp: #include &lt;iostream&gt; template &lt;typename T&gt; T addOne(T x); \/\/ function template forward declaration int main() { std::cout &lt;&lt; addOne(1) &lt;&lt; &#8216;\\n&#8217;; std::cout &lt;&lt; addOne(2.3) &lt;&lt; &#8216;\\n&#8217;; return 0; } add.cpp: template &lt;typename T&gt; T addOne(T x) \/\/ function template definition { &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/17180"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=17180"}],"version-history":[{"count":3,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/17180\/revisions"}],"predecessor-version":[{"id":17776,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/17180\/revisions\/17776"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=17180"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=17180"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=17180"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}