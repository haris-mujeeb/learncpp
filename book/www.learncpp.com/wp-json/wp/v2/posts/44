{"id":44,"date":"2007-06-09T11:47:32","date_gmt":"2007-06-09T19:47:32","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=44"},"modified":"2024-12-28T19:11:52","modified_gmt":"2024-12-29T03:11:52","slug":"signed-integers","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/signed-integers\/","title":{"rendered":"4.4 &#8212; Signed integers"},"content":{"rendered":"<p>An <strong>integer<\/strong> is an integral type that can represent positive and negative whole numbers, including 0 (e.g. -2, -1, 0, 1, 2).  C++ has <em>4<\/em> primary fundamental integer types available for use:<\/p>\n<p style=\"clear: both\">\n<p> <!-- break around image --><\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<th>Type<\/th>\n<th>Minimum Size<\/th>\n<th>Note<\/th>\n<\/tr>\n<tr>\n<td>short int<\/td>\n<td>16 bits<\/td>\n<td><\/td>\n<\/tr>\n<tr>\n<td>int<\/td>\n<td>16 bits<\/td>\n<td>Typically 32 bits on modern architectures<\/td>\n<\/tr>\n<tr>\n<td>long int<\/td>\n<td>32 bits<\/td>\n<td><\/td>\n<\/tr>\n<tr>\n<td>long long int<\/td>\n<td>64 bits<\/td>\n<td><\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>The key difference between the various integer types is that they have varying sizes -- the larger integers can hold bigger numbers.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">A reminder<\/p>\n<p>C++ only guarantees that integers will have a certain minimum size, not that they will have a specific size.  See lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/object-sizes-and-the-sizeof-operator\/\">4.3 -- Object sizes and the sizeof operator<\/a> for information on how to determine how large each type is on your machine.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>Technically, the <code>bool<\/code> and <code>char<\/code> types are considered to be integral types (because these types store their values as integer values).  For the purpose of the next few lessons, we&#8217;ll exclude these types from our discussion.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Signed integers<\/p>\n<p>When writing negative numbers in everyday life, we use a negative sign.  For example, <em>-3<\/em> means &#8220;negative 3&#8221;.  We&#8217;d also typically recognize <em>+3<\/em> as &#8220;positive 3&#8221; (though common convention dictates that we typically omit plus prefixes). <\/p>\n<p>This attribute of being positive, negative, or zero is called the number&#8217;s <strong>sign<\/strong>.<\/p>\n<p>By default, integers in C++ are <strong>signed<\/strong>, which means the number&#8217;s sign is stored as part of the value.  Therefore, a signed integer can hold both positive and negative numbers (and 0).<\/p>\n<p>In this lesson, we&#8217;ll focus on signed integers.  We&#8217;ll discuss unsigned integers (which can only hold non-negative numbers) in the next lesson.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Defining signed integers<\/p>\n<p>Here is the preferred way to define the four types of signed integers:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">short s;      \/\/ prefer \"short\" instead of \"short int\"\r\nint i;\r\nlong l;       \/\/ prefer \"long\" instead of \"long int\"\r\nlong long ll; \/\/ prefer \"long long\" instead of \"long long int\"<\/code><\/pre>\n<p>Although <em>short int<\/em>, <em>long int<\/em>, or <em>long long int<\/em> will work, we prefer the short names for these types (that do not use the <em>int<\/em> suffix).  In addition to being more typing, adding the <em>int<\/em> suffix makes the type harder to distinguish from variables of type <em>int<\/em>.  This can lead to mistakes if the short or long modifier is inadvertently missed.<\/p>\n<p>The integer types can also take an optional <em>signed<\/em> keyword, which by convention is typically placed before the type name:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">signed short ss;\r\nsigned int si;\r\nsigned long sl;\r\nsigned long long sll;<\/code><\/pre>\n<p>However, this keyword should not be used, as it is redundant, since integers are signed by default.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Prefer the shorthand types that do not use the <code>int<\/code> suffix or <code>signed<\/code> prefix.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Signed integer ranges<\/p>\n<p>As you learned in the last section, a variable with <em>n<\/em> bits can hold 2<sup>n<\/sup> possible values.  But which specific values?  We call the set of specific values that a data type can hold its <strong>range<\/strong>.  The range of an integer variable is determined by two factors: its size (in bits), and whether it is signed or not.<\/p>\n<p>For example, an 8-bit signed integer has a range of -128 to 127.  This means an 8-bit signed integer can store any integer value between -128 and 127 (inclusive) safely.<\/p>\n<p>Here&#8217;s a table containing the range of signed integers of different sizes:<\/p>\n<div class=\"cpp-table-wrapper\">\n<table class=\"cpp-table\">\n<tr>\n<th> Size \/ Type <\/th>\n<th> Range <\/th>\n<\/tr>\n<tr>\n<td> 8-bit signed  <\/td>\n<td> -128 to 127 <\/td>\n<\/tr>\n<tr>\n<td> 16-bit signed <\/td>\n<td> -32,768 to 32,767 <\/td>\n<\/tr>\n<tr>\n<td> 32-bit signed <\/td>\n<td> -2,147,483,648 to 2,147,483,647 <\/td>\n<\/tr>\n<tr>\n<td> 64-bit signed <\/td>\n<td> -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807 <\/td>\n<\/tr>\n<\/table>\n<\/div>\n<p>For the math inclined, an n-bit signed variable has a range of -(2<sup>n-1<\/sup>) to (2<sup>n-1<\/sup>)-1. <\/p>\n<p>For the non-math inclined&#8230; use the table. :)<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>The above ranges assume &#8220;two&#8217;s complement&#8221; binary representation.  This representation is the de-facto standard for modern architectures (as it is easier to implement in hardware), and is now required by the C++20 standard.  We discuss two&#8217;s complement in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/converting-integers-between-binary-and-decimal-representation\/\">O.4 -- Converting integers between binary and decimal representation<\/a>.<\/p>\n<p>In prior standards, sign-magnitude and ones complement representations were permitted for historical reasons.  Such representations produce values in the range -(2<sup>n-1<\/sup>-1) to +(2<sup>n-1<\/sup>-1).\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Overflow<\/p>\n<p>What happens if we try to assign the value <em>140<\/em> to an 8-bit signed integer?  This number is outside the range that an 8-bit signed integer can hold.  The number 140 requires 9 bits to represent (8 magnitude bits and 1 sign bit), but we only have 8 bits (7 magnitude bits and 1 sign bit) available in an 8-bit signed integer.<\/p>\n<p>The C++20 standard makes this blanket statement: &#8220;If during the evaluation of an expression, the result is not mathematically defined or not in the range of representable values for its type, the behavior is undefined&#8221;.  Colloquially, this is called <strong>overflow<\/strong>.<\/p>\n<p>Therefore, assigning value 140 to an 8-bit signed integer will result in undefined behavior.  <\/p>\n<p>If an arithmetic operation (such as addition or multiplication) attempts to create a value outside the range that can be represented, this is called <strong>integer overflow<\/strong> (or <strong>arithmetic overflow<\/strong>).  For signed integers, integer overflow will result in undefined behavior.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    \/\/ assume 4 byte integers\r\n    int x { 2'147'483'647 }; \/\/ the maximum value of a 4-byte signed integer\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n';\r\n\r\n    x = x + 1; \/\/ integer overflow, undefined behavior\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>On the author&#8217;s machine, the above printed:<\/p>\n<pre>\n2147483647\r\n-2147483648\r\n<\/pre>\n<p>However, because the second output is the result of undefined behavior, the value output may vary on your machine.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>We cover what happens when unsigned integers overflow in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/unsigned-integers-and-why-to-avoid-them\/\">4.5 -- Unsigned integers, and why to avoid them<\/a>.\n<\/p><\/div>\n<p>In general, overflow results in information being lost, which is almost never desirable.  If there is <em>any<\/em> suspicion that an object might need to store a value that falls outside its range, use a type with a bigger range!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Integer division<\/p>\n<p>When dividing two integers, C++ works like you&#8217;d expect when the quotient is a whole number:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; 20 \/ 4 &lt;&lt; '\\n';\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This produces the expected result:<\/p>\n<pre>\r\n5\r\n<\/pre>\n<p>But let&#8217;s look at what happens when integer division causes a fractional result:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; 8 \/ 5 &lt;&lt; '\\n';\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This produces a possibly unexpected result:<\/p>\n<pre>\r\n1\r\n<\/pre>\n<p>When doing division with two integers (called <strong>integer division<\/strong>), C++ always produces an integer result.  Since integers can&#8217;t hold fractional values, any fractional portion is simply dropped (not rounded!).<\/p>\n<p>Taking a closer look at the above example, 8 \/ 5 produces the value 1.6.  The fractional part (0.6) is dropped, and the result of 1 remains.  Alternatively, we can say 8 \/ 5 equals 1 remainder 3.  The remainder is dropped, leaving 1.<\/p>\n<p>Similarly, -8 \/ 5 results in the value -1.<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Be careful when using integer division, as you will lose any fractional parts of the quotient.  However, if it&#8217;s what you want, integer division is safe to use, as the results are predictable.<\/p>\n<\/div>\n<p>If fractional results are desired, we show a method to do this in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/arithmetic-operators\/\">6.2 -- Arithmetic operators<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>What would the range of a 5-bit signed integer be?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>A 5-bit number can support 2<sup>5<\/sup> = 32 unique values.  For a signed integer, these are split almost evenly amongst positive and negative numbers, with negative receiving an extra value.  So the range would be -16 to 15.<\/p>\n<p>Another way to think about this: 1 of the 5 bits is required to hold the sign.  That leaves 4 bits for the magnitude.  With 4 bits, we have 16 unique values available.  On the negative side, these magnitude bits represent values -1 to -16.  On the non-negative side, these magnitude bits represent values 0 to 15.  The non-negative side has one less value of range because it includes 0.\n<\/p><\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>a) What is the result of 13 \/ 5?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p>13 \/ 5 = 2 remainder 3.  The remainder is dropped, leaving 2.\n<\/p><\/div>\n<p>b) What is the result of -13 \/ 5?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<p>-13 \/ 5 = -2 remainder -3.  The remainder is dropped, leaving -2.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/unsigned-integers-and-why-to-avoid-them\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">4.5<\/span>Unsigned integers, and why to avoid them\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/object-sizes-and-the-sizeof-operator\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">4.3<\/span>Object sizes and the sizeof operator\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>An is an integral type that can represent positive and negative whole numbers, including 0 (e.g. -2, -1, 0, 1, 2). C++ has 4 primary fundamental integer types available for use: The key difference between the various integer types is that they have varying sizes &#8212; the larger integers can &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/44"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=44"}],"version-history":[{"count":54,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/44\/revisions"}],"predecessor-version":[{"id":18027,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/44\/revisions\/18027"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=44"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=44"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=44"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}