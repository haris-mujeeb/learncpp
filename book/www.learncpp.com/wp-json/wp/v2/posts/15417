{"id":15417,"date":"2023-09-11T14:56:33","date_gmt":"2023-09-11T21:56:33","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15417"},"modified":"2025-02-04T21:23:18","modified_gmt":"2025-02-05T05:23:18","slug":"chapter-16-summary-and-quiz","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-16-summary-and-quiz\/","title":{"rendered":"16.x &#8212; Chapter 16 summary and quiz"},"content":{"rendered":"<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Words of encouragement<\/p>\n<p>This chapter isn&#8217;t an easy one.  We covered a lot of material, and unearthed some of C++&#8217;s warts.  Congrats on making it through!<\/p>\n<p>Arrays are one of the keys that unlock a huge amount of power within your C++ programs.<\/p>\n<p class=\"cpp-section\">Chapter Review<\/p>\n<p>A <strong>container<\/strong> is a data type that provides storage for a collection of unnamed objects (called <strong>elements<\/strong>).  We typically use containers when we need to work with a set of related values.<\/p>\n<p>The number of elements in a container is often called it&#8217;s <strong>length<\/strong> (or sometimes <strong>count<\/strong>).  In C++, the term <strong>size<\/strong> is also commonly used for the number of elements in a container.  In most programming languages (including C++), containers are <strong>homogenous<\/strong>, meaning the elements of a container are required to have the same type.<\/p>\n<p>The <strong>Containers library<\/strong> is a part of the C++ standard library that contains various class types that implement some common types of containers.  A class type that implements a container is sometimes called a <strong>container class<\/strong>.<\/p>\n<p>An <strong>array<\/strong> is a container data type that stores a sequence of values <strong>contiguously<\/strong> (meaning each element is placed in an adjacent memory location, with no gaps).  Arrays allow fast, direct access to any element.<\/p>\n<p>C++ contains three primary array types: (C-style) arrays, the <code>std::vector<\/code> container class, and the <code>std::array<\/code> container class.<\/p>\n<p><code>std::vector<\/code> is one of the container classes in the C++ standard containers library that implements an array.  <code>std::vector<\/code> is defined in the &lt;vector&gt; header as a class template, with a template type parameter that defines the type of the elements.  Thus, <code>std::vector&lt;int&gt;<\/code> declares a <code>std::vector<\/code> whose elements are of type <code>int<\/code>.<\/p>\n<p>Containers typically have a special constructor called a <strong>list constructor<\/strong> that allows us to construct an instance of the container using an initializer list.  Use list initialization with an initializer list of values to construct a container with those element values.<\/p>\n<p>In C++, the most common way to access array elements is by using the name of the array along with the subscript operator (<code>operator[]<\/code>).  To select a specific element, inside the square brackets of the subscript operator, we provide an integral value that identifies which element we want to select.  This integral value is called a <strong>subscript<\/strong> (or informally, an <strong>index<\/strong>).  The first element is accessed using index 0, the second is accessed using index 1, etc&#8230;  Because the indexing starts with 0 rather than 1, we say arrays in C++ are <strong>zero-based<\/strong>.<\/p>\n<p><code>operator[]<\/code> does not do any kind of <strong>bounds checking<\/strong>, meaning it does not check to see whether the index is within the bounds of 0 to N-1 (inclusive).  Passing an invalid index to <code>operator[]<\/code> will result in undefined behavior.<\/p>\n<p>Arrays are one of the few container types that allow <strong>random access<\/strong>, meaning every element in the container can be accessed directly and with equal speed, regardless of the number of elements in the container.<\/p>\n<p>When constructing a class type object, a matching list constructor is selected over other matching constructors.  When constructing a container (or any type that has a list constructor) with initializers that are not element values, use direct initialization.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::vector v1 { 5 }; \/\/ defines a 1 element vector containing value `5`.\r\nstd::vector v2 ( 5 ); \/\/ defines a 5 element vector where elements are value-initialized.<\/code><\/pre>\n<p><code>std::vector<\/code> can be made const but not constexpr.<\/p>\n<p>Each of the standard library container classes defines a nested typedef member named <code>size_type<\/code> (sometimes written as <code>T::size_type<\/code>), which is an alias for the type used for the length (and indices, if supported) of the container.  <code>size_type<\/code> is almost always an alias for <code>std::size_t<\/code>, but can be overridden (in rare cases) to use a different type.  We can reasonably assume <code>size_type<\/code> is an alias for <code>std::size_t<\/code>.<\/p>\n<p>When accessing the <code>size_type<\/code> member of a container class, we must scope qualify it with the fully templated name of the container class.  For example, <code>std::vector&lt;int&gt;::size_type<\/code>.<\/p>\n<p>We can ask a container class object for its length using the <code>size()<\/code> member function, which returns the length as unsigned <code>size_type<\/code>.  In C++17, we can also use the <code>std::size()<\/code> non-member function.<\/p>\n<p>In C++20, the <code>std::ssize()<\/code> non-member function, which returns the length as a large <em>signed<\/em> integral type (usually <code>std::ptrdiff_t<\/code>, which is the type normally used as the signed counterpart to <code>std::size_t<\/code>).<\/p>\n<p>Accessing array elements using the <code>at()<\/code> member function does runtime bounds checking (and throws an exception of type <code>std::out_of_range<\/code> if the bounds are out of range).  If the exception isn&#8217;t caught, the application will be terminated.<\/p>\n<p>Both <code>operator[]<\/code> and the <code>at()<\/code> member function support indexing with non-const indices.  However, both expect the index to be of type <code>size_type<\/code>, which is an unsigned integral type.  This causes sign conversion problems when the indices are non-constexpr.<\/p>\n<p>An object of type <code>std::vector<\/code> can be passed to a function just like any other object.  That means if we pass a <code>std::vector<\/code> by value, an expensive copy will be made.  Therefore, we typically pass <code>std::vector<\/code> by (const) reference to avoid such copies.<\/p>\n<p>We can use a function template to be able to pass a <code>std::vector<\/code> with any element type into a function.  You can use an <code>assert()<\/code> to ensure the vector passed in has the correct length.<\/p>\n<p>The term <strong>copy semantics<\/strong> refers to the rules that determine how copies of objects are made.  When we say copy semantics are being invoked, that means we&#8217;ve done something that will make a copy of an object.<\/p>\n<p>When ownership of data is transfered from one object to another, we say that data has been <strong>moved<\/strong>.<\/p>\n<p><strong>Move semantics<\/strong> refers to the rules that determine how the data from one object is moved to another object.  When move semantics is invoked, any data member that can be moved is moved, and any data member that can&#8217;t be moved is copied.  The ability to move data instead of copying it can make move semantics more efficient than copy semantics, especially when we can replace an expensive copy with an inexpensive move.<\/p>\n<p>Normally, when an object is being initialized with or assigned an object of the same type, copy semantics will be used (assuming the copy isn&#8217;t elided).  Move semantics will be automatically used instead when the type of the object supports move semantics, and the initializer or object being assigned from is an rvalue.<\/p>\n<p>We can return move-capable types (like <code>std::vector<\/code> and <code>std::string<\/code>) by value.  Such types will inexpensively move their values instead of making an expensive copy.<\/p>\n<p>Accessing each element of a container in some order is called <strong>traversal<\/strong>, or <strong>traversing<\/strong> the container.  Traversal is also sometimes called <strong>iterating over<\/strong> or <strong>iterating through<\/strong> the container.<\/p>\n<p>Loops are often used to traverse through an array, with a loop variable being used as an index.  Beware of off-by-one errors, where the loop body executes one too many or one too few times.<\/p>\n<p>A <strong>range-based for loop<\/strong> (also sometimes called a <strong>for-each loop<\/strong>) allows traversal of a container without having to do explicit indexing.  Favor range-based-for loops over regular for-loops when traversing containers.<\/p>\n<p>Use type deduction (<code>auto<\/code>) with ranged-based for-loops to have the compiler deduce the type of the array element.  The element declaration should use a (const) reference whenever you would normally pass that element type by (const) reference.  Consider always using <code>const auto&amp;<\/code> unless you need to work with copies.  This will ensure copies aren&#8217;t made even if the element type is later changed.<\/p>\n<p>Unscoped enumerations can be used as indices, and help provide any information about the meaning of the index.<\/p>\n<p>Adding an additional &#8220;count&#8221; enumerator is useful whenever we need an enumerator that represents the array length.  You can assert or static_assert that an array&#8217;s length is equal to the count enumerator to ensure an array is initialized with the expected number of initializers.<\/p>\n<p>Arrays where the length of the array must be defined at the point of instantiation and then cannot be changed are called <strong>fixed-size arrays<\/strong> or <strong>fixed-length arrays<\/strong>.  A <strong>dynamic array<\/strong> (also called a <strong>resizable array<\/strong>) is an array whose size can be changed after instantiation.  This ability to be resized is what makes <code>std::vector<\/code> special.<\/p>\n<p>A <code>std::vector<\/code> can be resized after instantiation by calling the <code>resize()<\/code> member function with the new desired length.<\/p>\n<p>In the context of a <code>std::vector<\/code>, <strong>capacity<\/strong> is how many elements the <code>std::vector<\/code> has allocated storage for, and <strong>length<\/strong> is how many elements are currently being used.  We can ask a <code>std::vector<\/code> for its capacity via the <code>capacity()<\/code> member function.<\/p>\n<p>When a <code>std::vector<\/code> changes the amount of storage it is managing, this process is called <strong>reallocation<\/strong>.  Because reallocation typically requires every element in the array to be copied, reallocation is an expensive process.  As a result, we want to avoid reallocation as much as reasonable.<\/p>\n<p>Valid indices for the subscript operator (<code>operator[]<\/code>) and <code>at()<\/code> member function is based on the vector&#8217;s length, not the capacity.<\/p>\n<p><code>std::vector<\/code> has a member function called <code>shrink_to_fit()<\/code> that requests that the vector shrink its capacity to match its length.  This request is non-binding.<\/p>\n<p>The order in which items are added to and removed from a stack can be described as <strong>last-in, first-out (LIFO)<\/strong>.  The last plate added onto the stack will be the first plate that is removed.  In programming, a <strong>stack<\/strong> is a container data type where the insertion and removal of elements occurs in a LIFO manner.  This is commonly implemented via two operations named <strong>push<\/strong> and <strong>pop<\/strong>.<\/p>\n<p>The <code>std::vector<\/code> member functions <code>push_back()<\/code> and <code>emplace_back()<\/code> will increment the length of a <code>std::vector<\/code>, and will cause a reallocation to occur if the capacity is not sufficient to insert the value.  When pushing triggers a reallocation, <code>std::vector<\/code> will typically allocate some extra capacity to allow additional elements to be added without triggering another reallocation the next time an element is added.<\/p>\n<p>The <code>resize()<\/code> member function changes the length of the vector, and the capacity (if necessary).<br \/>\nThe <code>reserve()<\/code> member function changes just the capacity (if necessary)<\/p>\n<p>To increase the number of elements in a <code>std::vector<\/code>:<\/p>\n<ul>\n<li>Use <code>resize()<\/code> when accessing a vector via indexing.  This changes the length of the vector so your indices will be valid.\n<\/li>\n<li>Use <code>reserve()<\/code> when accessing a vector using stack operations.  This adds capacity without changing the length of the vector.\n<\/li>\n<\/ul>\n<p>Both <code>push_back()<\/code> and <code>emplace_back()<\/code> push an element onto the stack.  If the object to be pushed already exists, <code>push_back()<\/code> and <code>emplace_back()<\/code> are equivalent.  However, in cases where we are creating a temporary object for the purpose of pushing it onto the vector, <code>emplace_back()<\/code> can be more efficient.  Prefer emplace_back() when creating a new temporary object to add to the container, or when you need to access an explicit constructor. Prefer push_back() otherwise.<\/p>\n<p>There is a special implementation for <code>std::vector&lt;bool&gt;<\/code> that may be more space efficient for Boolean values by similarly compacting 8 Boolean values into a byte.<\/p>\n<p><code>std::vector&lt;bool&gt;<\/code> is not a vector (it is not required to be contiguous in memory), nor does it hold <code>bool<\/code> values (it holds a collection of bits), nor does it meet C++&#8217;s definition of a container.  Although <code>std::vector&lt;bool&gt;<\/code> behaves like a vector in most cases, it is not fully compatible with the rest of the standard library.  Code that works with other element types may not work with <code>std::vector&lt;bool&gt;<\/code>.   As a result, <code>std::vector&lt;bool&gt;<\/code> should generally be avoided.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Write definitions for the following.  Use CTAD where possible (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-template-argument-deduction-ctad-and-deduction-guides\/\">13.14 -- Class template argument deduction (CTAD) and deduction guides<\/a>).<\/p>\n<p>a) A <code>std::vector<\/code> initialized with the first 6 even numbers.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::vector evens { 2, 4, 6, 8, 10, 12 };<\/code><\/pre>\n<\/div>\n<p>b) A constant <code>std::vector<\/code> initialized with the values <code>1.2<\/code>, <code>3.4<\/code>, <code>5.6<\/code>, and <code>7.8<\/code>.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">const std::vector d { 1.2, 3.4, 5.6, 7.8 }; \/\/ reminder: std::vector can't be constexpr<\/code><\/pre>\n<\/div>\n<p>c) A constant <code>std::vector<\/code> of <code>std::string_view<\/code> initialized with the names &#8220;Alex&#8221;, &#8220;Brad&#8221;, &#8220;Charles&#8221;, and &#8220;Dave&#8221;.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">using namespace std::literals::string_view_literals; \/\/ for sv suffix\r\nconst std::vector names { \"Alex\"sv, \"Brad\"sv, \"Charles\"sv, \"Dave\"sv }; \/\/ sv suffix needed for CTAD to infer std::string_view<\/code><\/pre>\n<\/div>\n<p>d) A <code>std::vector<\/code> with the single element value <code>12<\/code>.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::vector v { 12 };<\/code><\/pre>\n<p>When initializing a <code>std::vector<\/code> with element values, we should use list initialization.\n<\/div>\n<p>e) A <code>std::vector<\/code> with 12 int elements, initialized to the default values.<\/p>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_0'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_0\" style=\"display:none; margin-bottom: 1em\">Hint: Think about whether CTAD is usable in this case.<\/div>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::vector&lt;int&gt; v( 12 );<\/code><\/pre>\n<p>When initializing a <code>std::vector<\/code> with an initial length, we must use direct initialization.  We also must explicitly specify the type template argument since there are no initializers in which to infer the element type from.\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>Let&#8217;s say you&#8217;re writing a game where the player can hold 3 types of items: health potions, torches, and arrows.<\/p>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #1<\/p>\n<p>Define an unscoped enum in a namespace to identify the different types of items.  Define an <code>std::vector<\/code> to store the number of each item type the player is carrying.  The player should start with 1 health potion, 5 torches, and 10 arrows.  Assert to make sure the array has the correct number of initializers.<\/p>\n<p>Hint: Define a count enumerator and use it inside the assert.<\/p>\n<p>The program should output the following:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">You have 16 total items<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_5'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_5\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nnamespace Items\r\n{\r\n    enum Type\r\n    {\r\n        health_potion,\r\n        torch,\r\n        arrow,\r\n        max_items\r\n    };\r\n}\r\n\r\n\/\/ Inventory items should have integral quantities, so we don't need a function template here\r\nint countTotalItems(const std::vector&lt;int&gt;&amp; inventory)\r\n{\r\n    int sum { 0 };\r\n    for (auto e: inventory)\r\n        sum += e;\r\n    return sum;\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector inventory { 1, 5, 10 };\r\n    assert(std::size(inventory) == Items::max_items); \/\/ make sure our inventory has the correct number of initializers\r\n\r\n    std::cout &lt;&lt; \"You have \" &lt;&lt; countTotalItems(inventory) &lt;&lt; \" total items\\n\";\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #2<\/p>\n<p>Modify your program from the prior step so it now outputs:<\/p>\n<pre>\nYou have 1 health potion\r\nYou have 5 torches\r\nYou have 10 arrows\r\nYou have 16 total items\r\n<\/pre>\n<p>Use a loop to print out the number of items and the item names for each inventory item.  Handle proper pluralization of the names.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_6'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_6\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n#include &lt;type_traits&gt; \/\/ for std::is_integral and std::is_enum\r\n#include &lt;vector&gt;\r\n\r\nnamespace Items\r\n{\r\n    enum Type: int\r\n    {\r\n        health_potion,\r\n        torch,\r\n        arrow,\r\n        max_items\r\n    };\r\n}\r\n\r\nstd::string_view getItemNamePlural(Items::Type type)\r\n{\r\n    switch (type)\r\n    {\r\n        case Items::health_potion:  return \"health potions\";\r\n        case Items::torch:          return \"torches\";\r\n        case Items::arrow:          return \"arrows\";\r\n\r\n        default:                    return \"???\";\r\n    }\r\n}\r\n\r\nstd::string_view getItemNameSingular(Items::Type type)\r\n{\r\n    switch (type)\r\n    {\r\n        case Items::health_potion:  return \"health potion\";\r\n        case Items::torch:          return \"torch\";\r\n        case Items::arrow:          return \"arrow\";\r\n\r\n        default:                    return \"???\";\r\n    }\r\n}\r\n\r\n\/\/ Helper function to convert `value` into an object of type std::size_t\r\n\/\/ UZ is the suffix for literals of type std::size_t.\r\ntemplate &lt;typename T&gt;\r\nconstexpr std::size_t toUZ(T value)\r\n{\r\n    \/\/ make sure T is an integral type\r\n    static_assert(std::is_integral&lt;T&gt;() || std::is_enum&lt;T&gt;());\r\n    \r\n    return static_cast&lt;std::size_t&gt;(value);\r\n}\r\n\r\n\r\nvoid printInventoryItem(const std::vector&lt;int&gt;&amp; inventory, Items::Type type)\r\n{\r\n    bool plural { inventory[toUZ(type)] != 1 };\r\n    std::cout &lt;&lt; \"You have \" &lt;&lt; inventory[toUZ(type)] &lt;&lt; ' ';\r\n    std::cout &lt;&lt; (plural ? getItemNamePlural(type) : getItemNameSingular(type)) &lt;&lt; '\\n';\r\n}\r\n\r\n\/\/ Inventory items should have integral quantities, so we don't need a function template here\r\nint countTotalItems(const std::vector&lt;int&gt;&amp; inventory)\r\n{\r\n    int sum { 0 };\r\n    for (auto e: inventory)\r\n        sum += e;\r\n    return sum;\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector inventory { 1, 5, 10 };\r\n    assert(std::size(inventory) == Items::max_items); \/\/ make sure our inventory has the correct number of initializers\r\n\r\n    \/\/ Since we can't iterate over an enumerated type using a ranged-for, we'll need to use a traditional for-loop here\r\n    for (int i=0; i &lt; Items::max_items; ++i)\r\n    {\r\n        auto item { static_cast&lt;Items::Type&gt;(i) };\r\n        printInventoryItem(inventory, item);\r\n    }\r\n\r\n    std::cout &lt;&lt; \"You have \" &lt;&lt; countTotalItems(inventory) &lt;&lt; \" total items\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #3<\/p>\n<p>Write a function that takes a <code>std::vector<\/code>, returns a <code>std::pair<\/code> containing the indices of the elements with the min and max values in the array.  The documentation for <code>std::pair<\/code> can be found <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/utility\/pair\">here<\/a>.  Call the function on the following two vectors:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    std::vector v1 { 3, 8, 2, 5, 7, 8, 3 };\r\n    std::vector v2 { 5.5, 2.7, 3.3, 7.6, 1.2, 8.8, 6.6 };<\/code><\/pre>\n<p>The program should output the following:<\/p>\n<pre>\nWith array ( 3, 8, 2, 5, 7, 8, 3 ):\r\nThe min element has index 2 and value 2\r\nThe max element has index 1 and value 8\r\n\r\nWith array ( 5.5, 2.7, 3.3, 7.6, 1.2, 8.8, 6.6 ):\r\nThe min element has index 4 and value 1.2\r\nThe max element has index 5 and value 8.8\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_7'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_7\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nstd::pair&lt;std::size_t, std::size_t&gt; findMinMaxIndices(const std::vector&lt;T&gt;&amp; v)\r\n{\r\n    \/\/ Assume element 0 is the minimum and the maximum\r\n    std::size_t minIndex { 0 };\r\n    std::size_t maxIndex { 0 };\r\n\r\n    \/\/ Look through the remaining elements to see if we can find a smaller or larger element\r\n    for (std::size_t index { 1 }; index &lt; v.size(); ++index)\r\n    {\r\n        if (v[index] &lt; v[minIndex])\r\n            minIndex = index;\r\n        if (v[index] &gt; v[maxIndex])\r\n            maxIndex = index;\r\n    }\r\n\r\n    return { minIndex, maxIndex };\r\n}\r\n\r\ntemplate &lt;typename T&gt;\r\nvoid printArray(const std::vector&lt;T&gt;&amp; v)\r\n{\r\n    bool comma { false };\r\n    std::cout &lt;&lt; \"With array ( \";\r\n    for (const auto&amp; e: v)\r\n    {\r\n        if (comma)\r\n            std::cout &lt;&lt; \", \";\r\n\r\n        std::cout &lt;&lt; e;\r\n        comma = true;\r\n    }\r\n    std::cout &lt;&lt; \" ):\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector v1 { 3, 8, 2, 5, 7, 8, 3 };\r\n    printArray(v1);\r\n    \r\n    auto m1 { findMinMaxIndices(v1) };\r\n    std::cout &lt;&lt; \"The min element has index \" &lt;&lt; m1.first &lt;&lt; \" and value \" &lt;&lt; v1[m1.first] &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"The max element has index \" &lt;&lt; m1.second &lt;&lt; \" and value \" &lt;&lt; v1[m1.second] &lt;&lt; '\\n';\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n    \r\n    std::vector v2 { 5.5, 2.7, 3.3, 7.6, 1.2, 8.8, 6.6 };\r\n    printArray(v2);\r\n\r\n    auto m2 { findMinMaxIndices(v2) };\r\n    std::cout &lt;&lt; \"The min element has index \" &lt;&lt; m2.first &lt;&lt; \" and value \" &lt;&lt; v2[m2.first] &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"The max element has index \" &lt;&lt; m2.second &lt;&lt; \" and value \" &lt;&lt; v2[m2.second] &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #4<\/p>\n<p>Modify the prior program so that the user can enter as many integers as they like. Stop accepting input when the user enters <code>-1<\/code>.<\/p>\n<p>Print the vector and find the min and max elements.<\/p>\n<p>When run with the input <code>3 8 5 2 3 7 -1<\/code>, the program should produce the following output:<\/p>\n<pre>\nEnter numbers to add (use -1 to stop): 3 8 5 2 3 7 -1\r\nWith array ( 3, 8, 5, 2, 3, 7 ):\r\nThe min element has index 3 and value 2\r\nThe max element has index 1 and value 8\r\n<\/pre>\n<p>Do something reasonable when the user enters <code>-1<\/code> as the first input.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_8'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_8\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;limits&gt;\r\n#include &lt;vector&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nstd::pair&lt;std::size_t, std::size_t&gt; findMinMaxIndices(const std::vector&lt;T&gt;&amp; v)\r\n{\r\n    \/\/ Assume element 0 is the minimum and the maximum\r\n    std::size_t minIndex { 0 };\r\n    std::size_t maxIndex { 0 };\r\n\r\n    \/\/ Look through the remaining elements to see if we can find a smaller or larger element\r\n    for (std::size_t index { 1 }; index &lt; v.size(); ++index)\r\n    {\r\n        if (v[index] &lt; v[minIndex])\r\n            minIndex = index;\r\n        if (v[index] &gt; v[maxIndex])\r\n            maxIndex = index;\r\n    }\r\n\r\n    return { minIndex, maxIndex };\r\n}\r\n\r\ntemplate &lt;typename T&gt;\r\nvoid printArray(const std::vector&lt;T&gt;&amp; v)\r\n{\r\n    bool comma { false };\r\n    std::cout &lt;&lt; \"With array ( \";\r\n    for (const auto&amp; e: v)\r\n    {\r\n        if (comma)\r\n            std::cout &lt;&lt; \", \";\r\n\r\n        std::cout &lt;&lt; e;\r\n        comma = true;\r\n    }\r\n    std::cout &lt;&lt; \" ):\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector&lt;int&gt; v1 { };\r\n    std::cout &lt;&lt; \"Enter numbers to add (use -1 to stop): \";\r\n\r\n    while (true)\r\n    {\r\n        int input{};\r\n        std::cin &gt;&gt; input;\r\n        if (input == -1)\r\n            break;\r\n\r\n        if (!std::cin) \/\/ if the previous extraction failed\r\n        {\r\n            std::cin.clear(); \/\/ put us back in 'normal' operation mode\r\n            std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n'); \/\/ and remove the bad input\r\n            continue;\r\n        }\r\n\r\n        v1.push_back(input);\r\n    }\r\n\r\n    \/\/ If the array is empty\r\n    if (v1.size() == 0)\r\n    {\r\n        std::cout &lt;&lt; \"The array has no elements\\n\";\r\n    }\r\n    else\r\n    {\r\n        printArray(v1);\r\n\r\n        auto m1 { findMinMaxIndices(v1) };\r\n        std::cout &lt;&lt; \"The min element has index \" &lt;&lt; m1.first &lt;&lt; \" and value \" &lt;&lt; v1[m1.first] &lt;&lt; '\\n';\r\n        std::cout &lt;&lt; \"The max element has index \" &lt;&lt; m1.second &lt;&lt; \" and value \" &lt;&lt; v1[m1.second] &lt;&lt; '\\n';\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #5<\/p>\n<p>Let&#8217;s implement the game C++man (which will be our version of the classic children&#8217;s lynching game <a href=\"https:\/\/en.wikipedia.org\/wiki\/Hangman_(game%29\">Hangman<\/a>.<\/p>\n<p>In case you&#8217;ve never played it before, here are the abbreviated rules:<\/p>\n<p>High level:<\/p>\n<ul>\n<li>The computer will pick a word at random and draw an underscore for each letter in the word.\n<\/li>\n<li>The player wins if they guess all the letters in the word before making X wrong guesses (where X is configurable).\n<\/li>\n<\/ul>\n<p>Each turn:<\/p>\n<ul>\n<li>The player will guess a single letter.\n<\/li>\n<li>If the player has already guessed that letter, it doesn&#8217;t count, and play continues.\n<\/li>\n<li>If any of the underscores represent that letter, those underscores are replaced with that letter, and play continues.\n<\/li>\n<li>If no underscores represent that letter, the player uses up one of their wrong guesses.\n<\/li>\n<\/ul>\n<p>Status:<\/p>\n<ul>\n<li>The player should know how many wrong guesses they have left.\n<\/li>\n<li>The player should know what letters they have guessed incorrectly (in alphabetical order).\n<\/li>\n<\/ul>\n<p>Because this is C++man, we&#8217;ll use a <code>+<\/code> symbol to indicate the number of wrong guesses left.  If you run out of <code>+<\/code> symbols, you lose.<\/p>\n<p>Here&#8217;s sample output from the finished game:<\/p>\n<pre>\nWelcome to C++man (a variant of Hangman)\r\nTo win: guess the word.  To lose: run out of pluses.\r\n\r\nThe word: ________   Wrong guesses: ++++++\r\nEnter your next letter: a\r\nNo, 'a' is not in the word!\r\n\r\nThe word: ________   Wrong guesses: +++++a\r\nEnter your next letter: b\r\nYes, 'b' is in the word!\r\n\r\nThe word: b_______   Wrong guesses: +++++a\r\nEnter your next letter: c\r\nYes, 'c' is in the word!\r\n\r\nThe word: b__cc___   Wrong guesses: +++++a\r\nEnter your next letter: d\r\nNo, 'd' is not in the word!\r\n\r\nThe word: b__cc___   Wrong guesses: ++++ad\r\nEnter your next letter: %\r\nThat wasn't a valid input.  Try again.\r\n\r\nThe word: b__cc___   Wrong guesses: ++++ad\r\nEnter your next letter: d\r\nYou already guessed that.  Try again.\r\n\r\nThe word: b__cc___   Wrong guesses: ++++ad\r\nEnter your next letter: e\r\nNo, 'e' is not in the word!\r\n\r\nThe word: b__cc___   Wrong guesses: +++ade\r\nEnter your next letter: f\r\nNo, 'f' is not in the word!\r\n\r\nThe word: b__cc___   Wrong guesses: ++adef\r\nEnter your next letter: g\r\nNo, 'g' is not in the word!\r\n\r\nThe word: b__cc___   Wrong guesses: +adefg\r\nEnter your next letter: h\r\nNo, 'h' is not in the word!\r\n\r\nThe word: b__cc___   Wrong guesses: adefgh\r\nYou lost!  The word was: broccoli\r\n<\/pre>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #1<\/p>\n<p>Goals:<\/p>\n<ul>\n<li>We&#8217;ll start by defining our list of words and writing a random word picker.  You can use the Random.h from lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/global-random-numbers-random-h\/#RandomH\">8.15 -- Global random numbers (Random.h)<\/a> to assist.\n<\/li>\n<\/ul>\n<p>Tasks:<\/p>\n<ul>\n<li>First define a namespace named <code>WordList<\/code>.  The starter list of words is: &#8220;mystery&#8221;, &#8220;broccoli&#8221; , &#8220;account&#8221;, &#8220;almost&#8221;, &#8220;spaghetti&#8221;, &#8220;opinion&#8221;, &#8220;beautiful&#8221;, &#8220;distance&#8221;, &#8220;luggage&#8221;.  You can add others if you like.\n<\/li>\n<li>Write a function to pick a random word and display the word picked.  Run the program several times to make sure the word is randomized.\n<\/li>\n<\/ul>\n<p>Here is a sample output from this step:<\/p>\n<pre>\nWelcome to C++man (a variant of Hangman)\r\nTo win: guess the word.  To lose: run out of pluses.\r\n\r\nThe word is: broccoli\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_9'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_9\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include \"Random.h\"\r\n\r\nnamespace WordList\r\n{\r\n    \/\/ Define your list of words here\r\n    std::vector&lt;std::string_view&gt; words { \"mystery\", \"broccoli\" , \"account\", \"almost\", \"spaghetti\", \"opinion\", \"beautiful\", \"distance\", \"luggage\" };\r\n\r\n    std::string_view getRandomWord()\r\n    {\r\n        return words[Random::get&lt;std::size_t&gt;(0, words.size()-1)];\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Welcome to C++man (a variant of Hangman)\\n\";\r\n    std::cout &lt;&lt; \"To win: guess the word.  To lose: run out of pluses.\\n\";\r\n\r\n    std::cout &lt;&lt; \"The word is: \" &lt;&lt; WordList::getRandomWord();\r\n  \r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #2<\/p>\n<p>As we develop complex programs, we want to work incrementally, adding one or two things at a time and then making sure they work.  What makes sense to add next?<\/p>\n<p>Goals:<\/p>\n<ul>\n<li>Be able to draw the basic state of the game, showing the word as underscores.\n<\/li>\n<li>Accept a letter of input from the user, with basic error validation.\n<\/li>\n<\/ul>\n<p>In this step, we will not yet keep track of which letters the user has entered.<\/p>\n<p>Here is the sample output from this step:<\/p>\n<pre>\nWelcome to C++man (a variant of Hangman)\r\nTo win: guess the word.  To lose: run out of pluses.\r\n\r\nThe word: ________\r\nEnter your next letter: %\r\nThat wasn't a valid input.  Try again.\r\nEnter your next letter: a\r\nYou entered: a\r\n<\/pre>\n<p>Tasks:<\/p>\n<ul>\n<li>Create a class named <code>Session<\/code> that will be used to store all of the data the game needs to manage in a game session.  For now, we just need to know what the random word is.\n<\/li>\n<li>Create a function to display the basic state of the game, where the word is displayed as underscores.\n<\/li>\n<li>Create a function to accept a letter of input from the user.  Do basic input validation to filter out non-letters or extraneous input.\n<\/li>\n<\/ul>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_10'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_10\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n#include &lt;vector&gt;\r\n#include \"Random.h\"\r\n\r\nnamespace WordList\r\n{\r\n    \/\/ Define your list of words here\r\n    std::vector&lt;std::string_view&gt; words { \"mystery\", \"broccoli\" , \"account\", \"almost\", \"spaghetti\", \"opinion\", \"beautiful\", \"distance\", \"luggage\" };\r\n\r\n    std::string_view getRandomWord()\r\n    {\r\n        return words[Random::get&lt;std::size_t&gt;(0, words.size()-1)];\r\n    }\r\n}\r\n\r\nclass Session\r\n{\r\nprivate:\r\n    \/\/ Game session data\r\n    std::string_view m_word { WordList::getRandomWord() };\r\n\r\npublic:\r\n    std::string_view getWord() const { return m_word; }\r\n};\r\n\r\nvoid draw(const Session&amp; s)\r\n{\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    std::cout &lt;&lt; \"The word: \";\r\n    for ([[maybe_unused]] auto c: s.getWord()) \/\/ step through each letter of word\r\n    {\r\n        std::cout &lt;&lt; '_';\r\n    }\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n}\r\n\r\nchar getGuess()\r\n{\r\n    while (true)\r\n    {\r\n        std::cout &lt;&lt; \"Enter your next letter: \";\r\n\r\n        char c{};\r\n        std::cin &gt;&gt; c;\r\n\r\n        \/\/ If user did something bad, try again\r\n        if (!std::cin)\r\n        {\r\n            \/\/ Fix it\r\n            std::cin.clear();\r\n            std::cout &lt;&lt; \"That wasn't a valid input.  Try again.\\n\";\r\n            std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\r\n            continue;\r\n        }\r\n        \r\n        \/\/ Clear out any extraneous input\r\n        std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\r\n\r\n        \/\/ If the user entered an invalid char, try again\r\n        if (c &lt; 'a' || c &gt; 'z')\r\n        {\r\n            std::cout &lt;&lt; \"That wasn't a valid input.  Try again.\\n\";\r\n            continue;\r\n        }\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Welcome to C++man (a variant of Hangman)\\n\";\r\n    std::cout &lt;&lt; \"To win: guess the word.  To lose: run out of pluses.\\n\";\r\n\r\n    Session s{};\r\n\r\n    draw(s);\r\n    char c { getGuess() };\r\n    std::cout &lt;&lt; \"You guessed: \" &lt;&lt; c &lt;&lt; '\\n';\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #3<\/p>\n<p>Now that we can display some game state and get input from the user, let&#8217;s integrate that user input into the game.<\/p>\n<p>Goals:<\/p>\n<ul>\n<li>Keep track of which letters the user has guessed.\n<\/li>\n<li>Display correctly guessed letters.\n<\/li>\n<li>Implement a basic game loop.\n<\/li>\n<\/ul>\n<p>Tasks:<\/p>\n<ul>\n<li>Update the Session class to track which letters have been guessed so far.\n<\/li>\n<li>Modify the game state function to display both underscores and correctly guessed letters.\n<\/li>\n<li>Update the input routine to reject letters that have already been guessed.\n<\/li>\n<li>Write a loop that executes 6 times before quitting (so we can test the above).\n<\/li>\n<\/ul>\n<p>In this step, we will not tell the user whether the letter they guessed is in the word (but we will show it as part of the game state display).<\/p>\n<p>The tricky part of this step is deciding how to store information on which letters the user has guessed.  There are several different viable ways to do this.  A hint: there are a fixed number of letters, and you&#8217;re going to be doing this a lot.<\/p>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_1'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_1\" style=\"display:none; margin-bottom: 1em\">Hint: It&#8217;s easier and faster to use a <code>bool<\/code> for each letter than it is to keep a list of letters and have to search that list to determine whether a letter exists.<\/div>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_2'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_2\" style=\"display:none; margin-bottom: 1em\">Hint: It is okay to use <code>std::vector&lt;bool&gt;<\/code> here since we won&#8217;t be using any of the other functionality of the standard library.<\/div>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_3'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_3\" style=\"display:none; margin-bottom: 1em\">Hint: You can convert a letter into an array index via <code>(letter % 32)-1<\/code>.  This works with both lower case and upper case letters.<\/div>\n<p>Here&#8217;s sample output for this step:<\/p>\n<pre>\nWelcome to C++man (a variant of Hangman)\r\nTo win: guess the word.  To lose: run out of pluses.\r\n\r\nThe word: ________\r\nEnter your next letter: a\r\n\r\nThe word: ____a___\r\nEnter your next letter: a\r\nYou already guessed that.  Try again.\r\nEnter your next letter: b\r\n\r\nThe word: ____a___\r\nEnter your next letter: c\r\n\r\nThe word: ____a___\r\nEnter your next letter: d\r\n\r\nThe word: d___a___\r\nEnter your next letter: e\r\n\r\nThe word: d___a__e\r\nEnter your next letter: f\r\n\r\nThe word: d___a__e\r\nEnter your next letter: g\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_11'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_11\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n#include &lt;vector&gt;\r\n#include \"Random.h\"\r\n\r\nnamespace WordList\r\n{\r\n    \/\/ Define your list of words here\r\n    std::vector&lt;std::string_view&gt; words { \"mystery\", \"broccoli\" , \"account\", \"almost\", \"spaghetti\", \"opinion\", \"beautiful\", \"distance\", \"luggage\" };\r\n\r\n    std::string_view getRandomWord()\r\n    {\r\n        return words[Random::get&lt;std::size_t&gt;(0, words.size()-1)];\r\n    }\r\n}\r\n\r\nclass Session\r\n{\r\nprivate:\r\n    \/\/ Game session data\r\n    std::string_view m_word { WordList::getRandomWord() };\r\n    std::vector&lt;bool&gt; m_letterGuessed { std::vector&lt;bool&gt;(26) };\r\n\r\n    std::size_t toIndex(char c) const { return static_cast&lt;std::size_t&gt;((c % 32)-1); }\r\n\r\npublic:\r\n    std::string_view getWord() const { return m_word; }\r\n\r\n    bool isLetterGuessed(char c) const { return m_letterGuessed[toIndex(c)]; }\r\n    void setLetterGuessed(char c) { m_letterGuessed[toIndex(c)] = true; }\r\n};\r\n\r\nvoid draw(const Session&amp; s)\r\n{\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    std::cout &lt;&lt; \"The word: \";\r\n    for (auto c: s.getWord()) \/\/ step through each letter of word\r\n    {\r\n        if (s.isLetterGuessed(c))\r\n            std::cout &lt;&lt; c;\r\n        else\r\n            std::cout &lt;&lt; '_';\r\n    }\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n}\r\n\r\nchar getGuess(const Session&amp; s)\r\n{\r\n    while (true)\r\n    {\r\n        std::cout &lt;&lt; \"Enter your next letter: \";\r\n\r\n        char c{};\r\n        std::cin &gt;&gt; c;\r\n\r\n        \/\/ If user did something bad, try again\r\n        if (!std::cin)\r\n        {\r\n            \/\/ Fix it\r\n            std::cin.clear();\r\n            std::cout &lt;&lt; \"That wasn't a valid input.  Try again.\\n\";\r\n            std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\r\n            continue;\r\n        }\r\n        \r\n        \/\/ Clear out any extraneous input\r\n        std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\r\n\r\n        \/\/ If the user entered an invalid char, try again\r\n        if (c &lt; 'a' || c &gt; 'z')\r\n        {\r\n            std::cout &lt;&lt; \"That wasn't a valid input.  Try again.\\n\";\r\n            continue;\r\n        }\r\n\r\n        \/\/ If the letter was already guessed, try again\r\n        if (s.isLetterGuessed(c))\r\n        {\r\n            std::cout &lt;&lt; \"You already guessed that.  Try again.\\n\";\r\n            continue;\r\n        }\r\n\r\n        \/\/ If we got here, this must be a valid guess\r\n        return c;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Welcome to C++man (a variant of Hangman)\\n\";\r\n    std::cout &lt;&lt; \"To win: guess the word.  To lose: run out of pluses.\\n\";\r\n\r\n    Session s {};\r\n\r\n    int count { 6 };\r\n    while (--count)\r\n    {\r\n        draw(s);\r\n        char c { getGuess(s) };\r\n        s.setLetterGuessed(c);\r\n    }\r\n\r\n    \/\/ Draw the final state of the game\r\n    draw(s);\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #4<\/p>\n<p>Goal: Finish the game.<\/p>\n<p>Tasks:<\/p>\n<ul>\n<li>Add in display of total wrong guesses left\n<\/li>\n<li>Add in display of incorrect letters guessed\n<\/li>\n<li>Add in win\/loss condition and win\/loss text.\n<\/li>\n<\/ul>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_12'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_12\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n#include &lt;vector&gt;\r\n#include \"Random.h\"\r\n\r\nnamespace Settings\r\n{\r\n    constexpr int wrongGuessesAllowed { 6 };\r\n}\r\n\r\nnamespace WordList\r\n{\r\n    \/\/ Define your list of words here\r\n    std::vector&lt;std::string_view&gt; words { \"mystery\", \"broccoli\" , \"account\", \"almost\", \"spaghetti\", \"opinion\", \"beautiful\", \"distance\", \"luggage\" };\r\n\r\n    std::string_view getRandomWord()\r\n    {\r\n        return words[Random::get&lt;std::size_t&gt;(0, words.size()-1)];\r\n    }\r\n}\r\n\r\nclass Session\r\n{\r\nprivate:\r\n    \/\/ Game session data\r\n    std::string_view m_word { WordList::getRandomWord() };\r\n    int m_wrongGuessesLeft { Settings::wrongGuessesAllowed };\r\n    std::vector&lt;bool&gt; m_letterGuessed { std::vector&lt;bool&gt;(26) };\r\n\r\n    std::size_t toIndex(char c) const { return static_cast&lt;std::size_t&gt;((c % 32)-1); }\r\n\r\npublic:\r\n    std::string_view getWord() const { return m_word; }\r\n\r\n    int wrongGuessesLeft() const { return m_wrongGuessesLeft; }\r\n    void removeGuess() { --m_wrongGuessesLeft; }\r\n\r\n    bool isLetterGuessed(char c) const { return m_letterGuessed[toIndex(c)]; }\r\n    void setLetterGuessed(char c) { m_letterGuessed[toIndex(c)] = true; }\r\n\r\n    bool isLetterInWord(char c) const\r\n    {\r\n        for (auto ch: m_word) \/\/ step through each letter of word\r\n        {\r\n            if (ch == c)\r\n                return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    bool won()\r\n    {\r\n        for (auto c: m_word) \/\/ step through each letter of word\r\n        {\r\n            if (!isLetterGuessed(c))\r\n                return false;\r\n        }\r\n        \r\n        return true;\r\n    }\r\n};\r\n\r\nvoid draw(const Session&amp; s)\r\n{\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    std::cout &lt;&lt; \"The word: \";\r\n    for (auto c: s.getWord()) \/\/ step through each letter of word\r\n    {\r\n        if (s.isLetterGuessed(c))\r\n            std::cout &lt;&lt; c;\r\n        else\r\n            std::cout &lt;&lt; '_';\r\n    }\r\n\r\n    std::cout &lt;&lt; \"   Wrong guesses: \";\r\n    for (int i=0; i &lt; s.wrongGuessesLeft(); ++i)\r\n        std::cout &lt;&lt; '+';\r\n\r\n\r\n    for (char c='a'; c &lt;= 'z'; ++c)\r\n        if (s.isLetterGuessed(c) &amp;&amp; !s.isLetterInWord(c))\r\n            std::cout &lt;&lt; c;\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n}\r\n\r\nchar getGuess(const Session&amp; s)\r\n{\r\n    while (true)\r\n    {\r\n        std::cout &lt;&lt; \"Enter your next letter: \";\r\n\r\n        char c{};\r\n        std::cin &gt;&gt; c;\r\n\r\n        \/\/ If user did something bad, try again\r\n        if (!std::cin)\r\n        {\r\n            \/\/ Fix it\r\n            std::cin.clear();\r\n            std::cout &lt;&lt; \"That wasn't a valid input.  Try again.\\n\";\r\n            std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\r\n            continue;\r\n        }\r\n        \r\n        \/\/ Clear out any extraneous input\r\n        std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\r\n\r\n        \/\/ If the user entered an invalid char, try again\r\n        if (c &lt; 'a' || c &gt; 'z')\r\n        {\r\n            std::cout &lt;&lt; \"That wasn't a valid input.  Try again.\\n\";\r\n            continue;\r\n        }\r\n\r\n        \/\/ If the letter was already guessed, try again\r\n        if (s.isLetterGuessed(c))\r\n        {\r\n            std::cout &lt;&lt; \"You already guessed that.  Try again.\\n\";\r\n            continue;\r\n        }\r\n\r\n        \/\/ If we got here, this must be a valid guess\r\n        return c;\r\n    }\r\n}\r\n\r\nvoid handleGuess(Session &amp;s, char c)\r\n{\r\n    s.setLetterGuessed(c);\r\n    \r\n    if (s.isLetterInWord(c))\r\n    {\r\n        std::cout &lt;&lt; \"Yes, '\" &lt;&lt; c &lt;&lt; \"' is in the word!\\n\";\r\n        return;\r\n    }\r\n    \r\n    std::cout &lt;&lt; \"No, '\" &lt;&lt; c &lt;&lt; \"' is not in the word!\\n\";\r\n    s.removeGuess();\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Welcome to C++man (a variant of Hangman)\\n\";\r\n    std::cout &lt;&lt; \"To win: guess the word.  To lose: run out of pluses.\\n\";\r\n\r\n    Session s{};\r\n\r\n    while (s.wrongGuessesLeft() &amp;&amp; !s.won())\r\n    {\r\n        draw(s);\r\n        char c { getGuess(s) };\r\n        handleGuess(s, c);\r\n    }\r\n\r\n    \/\/ Draw the final state of the game\r\n    draw(s);\r\n\r\n    if (!s.wrongGuessesLeft())\r\n        std::cout &lt;&lt; \"You lost!  The word was: \" &lt;&lt; s.getWord() &lt;&lt; '\\n';\r\n    else\r\n        std::cout &lt;&lt; \"You won!\\n\";\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdarray\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.1<\/span>Introduction to std::array\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdvector-bool\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">16.12<\/span>std::vector&lt;bool&gt;\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Words of encouragement This chapter isn&#8217;t an easy one. We covered a lot of material, and unearthed some of C++&#8217;s warts. Congrats on making it through! Arrays are one of the keys that unlock a huge amount of power within your C++ programs. Chapter Review A container is a data &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15417"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15417"}],"version-history":[{"count":27,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15417\/revisions"}],"predecessor-version":[{"id":18163,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15417\/revisions\/18163"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15417"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15417"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15417"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}