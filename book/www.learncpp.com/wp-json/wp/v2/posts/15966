{"id":15966,"date":"2023-10-23T13:42:40","date_gmt":"2023-10-23T20:42:40","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15966"},"modified":"2025-02-14T12:20:19","modified_gmt":"2025-02-14T20:20:19","slug":"the-conditional-operator","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/the-conditional-operator\/","title":{"rendered":"6.6 &#8212; The conditional operator"},"content":{"rendered":"<div class=\"cpp-table-wrapper\">\n<table class=\"cpp-table\">\n<tr>\n<th> Operator <\/th>\n<th> Symbol <\/th>\n<th> Form <\/th>\n<th> Meaning <\/th>\n<\/tr>\n<tr>\n<td> Conditional <\/td>\n<td> ?: <\/td>\n<td> <nobr>c ? x : y<\/nobr> <\/td>\n<td> If conditional <code>c<\/code> is <code>true<\/code> then evaluate <code>x<\/code>, otherwise evaluate <code>y<\/code> <\/td>\n<\/tr>\n<\/table>\n<\/div>\n<p>The <strong>conditional operator<\/strong> (<code>?:<\/code>) (also sometimes called the <strong>arithmetic if<\/strong> operator) is a ternary operator (an operator that takes 3 operands).  Because it has historically been C++&#8217;s only ternary operator, it&#8217;s also sometimes referred to as &#8220;the ternary operator&#8221;.<\/p>\n<p>The <code>?:<\/code> operator provides a shorthand method for doing a particular type of if-else statement.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover if-else statements in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-if-statements\/\">4.10 -- Introduction to if statements<\/a>.\n<\/p><\/div>\n<p>To recap, an if-else statement takes the following form:<\/p>\n<pre>\nif (condition)\r\n    statement1;\r\nelse\r\n    statement2;\r\n<\/pre>\n<p>If <code>condition<\/code> evaluates to <code>true<\/code>, then <code>statement1<\/code> is executed, otherwise <code>statement2<\/code> is executed.  The <code>else<\/code> and <code>statement2<\/code> are optional.<\/p>\n<p>The <code>?:<\/code> operator takes the following form:<\/p>\n<pre>\ncondition ? expression1 : expression2;\r\n<\/pre>\n<p>If <code>condition<\/code> evaluates to <code>true<\/code>, then <code>expression1<\/code> is evaluated, otherwise <code>expression2<\/code> is evaluated.  The <code>:<\/code> and <code>expression2<\/code> are not optional.<\/p>\n<p>Consider an if-else statement that looks like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">if (x &gt; y)\r\n    max = x;\r\nelse\r\n    max = y;<\/code><\/pre>\n<p>This can be rewritten as:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">max = ((x &gt; y) ? x : y);<\/code><\/pre>\n<p>In such cases, the conditional operator can help compact code without losing readability.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">An example<\/p>\n<p>Consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint getValue()\r\n{\r\n    std::cout &lt;&lt; \"Enter a number: \";\r\n    int x{};\r\n    std::cin &gt;&gt; x;\r\n    return x;\r\n}\r\n\r\nint main()\r\n{\r\n    int x { getValue() };\r\n    int y { getValue() };\r\n    int max { (x &gt; y) ? x : y };\r\n    std::cout &lt;&lt; \"The max of \" &lt;&lt; x &lt;&lt;\" and \" &lt;&lt; y &lt;&lt; \" is \" &lt;&lt; max &lt;&lt; \".\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>First, let&#8217;s enter <code>5<\/code> and <code>7<\/code> as input (so <code>x<\/code> is <code>5<\/code>, and <code>y<\/code> is <code>7<\/code>).  When <code>max<\/code> is initialized, the expression <code>(5 &gt; 7) ? 5 : 7<\/code> is evaluated.  Since <code>5 &gt; 7<\/code> is false, this yields <code>false ? 5 : 7<\/code>, which evaluates to <code>7<\/code>.  The program prints:<\/p>\n<pre>\nThe max of 5 and 7 is 7.\r\n<\/pre>\n<p>Now let&#8217;s enter <code>7<\/code> and <code>5<\/code> as input (so <code>x<\/code> is <code>7<\/code>, and <code>y<\/code> is <code>5<\/code>).  In this case, we get <code>(7 &gt; 5) ? 7 : 5<\/code>, which is <code>true ? 7 : 5<\/code>, which evaluates to <code>7<\/code>.  The program prints:<\/p>\n<pre>\nThe max of 7 and 5 is 7.\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The conditional operator evaluates as part of an expression<\/p>\n<p>Since the conditional operator is evaluated as part of an expression, it can be used anywhere an expression is accepted.  In cases where the operands of the conditional operator are constant expressions, the conditional operator can be used in a constant expression.<\/p>\n<p>This allows the conditional operator to be used in places where statements cannot be used.<\/p>\n<p>For example, when initializing a variable:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    constexpr bool inBigClassroom { false };\r\n    constexpr int classSize { inBigClassroom ? 30 : 20 };\r\n    std::cout &lt;&lt; \"The class size is: \" &lt;&lt; classSize &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>There&#8217;s no direct if-else replacement for this.<\/p>\n<p>You might think to try something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    constexpr bool inBigClassroom { false };\r\n\r\n    if (inBigClassroom)\r\n        constexpr int classSize { 30 };\r\n    else\r\n        constexpr int classSize { 20 }; \r\n\r\n    std::cout &lt;&lt; \"The class size is: \" &lt;&lt; classSize &lt;&lt; '\\n'; \/\/ Compile error: classSize not defined\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, this won&#8217;t compile, and you&#8217;ll get an error message that <code>classSize<\/code> isn&#8217;t defined.  Much like how variables defined inside functions die at the end of the function, variables defined inside an if-statement or else-statement die at the end of the if-statement or else-statement.  Thus, <code>classSize<\/code> has already been destroyed by the time we try to print it.<\/p>\n<p>If you want to use an if-else, you&#8217;d have to do something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint getClassSize(bool inBigClassroom)\r\n{\r\n    if (inBigClassroom)\r\n        return 30;\r\n    else\r\n        return 20;\r\n}\r\n\r\nint main()\r\n{\r\n    const int classSize { getClassSize(false) };\r\n    std::cout &lt;&lt; \"The class size is: \" &lt;&lt; classSize &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This one works because <code>getClassSize(false)<\/code> is an expression, and the if-else logic is inside a function (where we can use statements).  But this is a lot of extra code when we could just use the conditional operator instead.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Parenthesizing the conditional operator<\/p>\n<p>Because C++ prioritizes the evaluation of most operators above the evaluation of the conditional operator, it&#8217;s quite easy to write expressions using the conditional operator that don&#8217;t evaluate as expected.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover the way that C++ prioritizes the evaluation of operators in future lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/operator-precedence-and-associativity\/\">6.1 -- Operator precedence and associativity<\/a>.\n<\/p><\/div>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 2 };\r\n    int y { 1 };\r\n    int z { 10 - x &gt; y ? x : y };\r\n    std::cout &lt;&lt; z;\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>You might expect this to evaluate as <code>10 - (x &gt; y ? x : y)<\/code> (which would evaluate to <code>8<\/code>) but it actually evaluates as <code>(10 - x) &gt; y ? x : y<\/code> (which evaluates to <code>2<\/code>).<\/p>\n<p>Here&#8217;s another example that exhibits a common mistake:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 2 };\r\n    std::cout &lt;&lt; (x &lt; 0) ? \"negative\" : \"non-negative\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>You might expect this to print <code>non-negative<\/code>, but it actually prints <code>0<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Optional reading<\/p>\n<p>Here&#8217;s what&#8217;s happening in the above example.  First, <code>x &lt; 0<\/code> evaluates to <code>false<\/code>.  The partially evaluated expression is now <code>std::cout &lt;&lt; false ? \"negative\" : \"non-negative\"<\/code>.  Because <code>operator&lt;&lt;<\/code> has higher precedence than <code>operator?:<\/code>, this expression evaluates as if it were written as <code>(std::cout &lt;&lt; false) ? \"negative\" : \"non-negative\"<\/code>.  Thus <code>std::cout &lt;&lt; false<\/code> is evaluated, which prints <code>0<\/code> (and returns <code>std::cout<\/code>).<\/p>\n<p>The partially evaluated expression is now <code>std::cout ? \"negative\" : \"non-negative\"<\/code>.  Since <code>std::cout<\/code> is all that is remaining in the condition, the compiler will try to convert it to a <code>bool<\/code> so the condition can be resolved.  Perhaps surprisingly, <code>std::cout<\/code> has a defined conversion to <code>bool<\/code>, which will most likely return <code>false<\/code>.  Assuming it returns <code>false<\/code>, we now have <code>false ? \"negative\" : \"non-negative\"<\/code>, which evaluates to <code>\"non-negative\"<\/code>.  So our fully evaluated statement is <code>\"non-negative\";<\/code>.  An expression statement that is just a literal (in this case, a string literal) has no effect, so we&#8217;re done.\n<\/div>\n<p>To avoid such evaluation prioritization issues, the conditional operator should be parenthesized as follows:<\/p>\n<ul>\n<li>Parenthesize the entire conditional operation (including operands) when used in a compound expression (an expression with other operators).\n<\/li>\n<li>For readability, consider parenthesizing the condition if it contains any operators (other than the function call operator).\n<\/li>\n<\/ul>\n<p>The operands of the conditional operator do not need to be parenthesized.<\/p>\n<p>Let&#8217;s take a look at some statements containing the conditional operator and how they should be parenthesized:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">return isStunned ? 0 : movesLeft;           \/\/ not used in compound expression, condition contains no operators\r\nint z { (x &gt; y) ? x : y };                  \/\/ not used in compound expression, condition contains operators\r\nstd::cout &lt;&lt; (isAfternoon() ? \"PM\" : \"AM\"); \/\/ used in compound expression, condition contains no operators (function call operator excluded)\r\nstd::cout &lt;&lt; ((x &gt; y) ? x : y);             \/\/ used in compound expression, condition contains operators<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Parenthesize the entire conditional operation (including operands) when used in a compound expression.<\/p>\n<p>For readability, consider parenthesizing the condition if it contains any operators (other than the function call operator).\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The type of the expressions must match or be convertible<\/p>\n<p>To comply with C++&#8217;s type checking rules, one of the following must be true:<\/p>\n<ul>\n<li>The type of the second and third operand must match.\n<\/li>\n<li>The compiler must be able to find a way to convert one or both of the second and third operands to matching types.  The conversion rules the compiler uses are fairly complex and may yield surprising results in some cases.\n<\/li>\n<\/ul>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Alternatively, one or both of the second and third operands is allowed to be a throw expression.  We cover <code>throw<\/code> in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/basic-exception-handling\/\">27.2 -- Basic exception handling<\/a>.\n<\/div>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; (true ? 1 : 2) &lt;&lt; '\\n';    \/\/ okay: both operands have matching type int\r\n\r\n    std::cout &lt;&lt; (false ? 1 : 2.2) &lt;&lt; '\\n'; \/\/ okay: int value 1 converted to double\r\n\r\n    std::cout &lt;&lt; (true ? -1 : 2u) &lt;&lt; '\\n';  \/\/ surprising result: -1 converted to unsigned int, result out of range\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Assuming 4 byte integers, the above prints:<\/p>\n<pre>\n1\r\n2.2\r\n4294967295\r\n<\/pre>\n<p>In general, it&#8217;s okay to mix operands with fundamental types (excluding mixing signed and unsigned values).  If either operand is not a fundamental type, it&#8217;s generally best to explicitly convert one or both operands to a matching type yourself so you know exactly what you&#8217;ll get.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>The surprising case above related to mixing signed and unsigned values is due to the arithmetic conversion rules, which we cover in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/arithmetic-conversions\/\">10.5 -- Arithmetic conversions<\/a>.\n<\/p><\/div>\n<p>If the compiler can&#8217;t find a way to convert the second and third operands to a matching type, a compile error will result:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    constexpr int x{ 5 };\r\n    std::cout &lt;&lt; ((x != 5) ? x : \"x is 5\"); \/\/ compile error: compiler can't find common type for constexpr int and C-style string literal\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, one of the expressions is an integer, and the other is a C-style string literal.  The compiler will not be able to find a matching type on its own, so a compile error will result.<\/p>\n<p>In such cases, you can either do an explicit conversion, or use an if-else statement:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nint main()\r\n{\r\n    int x{ 5 }; \/\/ intentionally non-constexpr for this example\r\n\r\n    \/\/ We can explicitly convert the types to match\r\n    std::cout &lt;&lt; ((x != 5) ? std::to_string(x) : std::string{\"x is 5\"}) &lt;&lt; '\\n';\r\n\r\n    \/\/ Or use an if-else statement\r\n    if (x != 5)\r\n        std::cout &lt;&lt; x &lt;&lt; '\\n';\r\n    else\r\n        std::cout &lt;&lt; \"x is 5\" &lt;&lt; '\\n';\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>If <code>x<\/code> is constexpr, then the condition <code>x != 5<\/code> is a constant expression.  In such cases, using <code>if constexpr<\/code> should be preferred over <code>if<\/code>, and your compiler may generate a warning indicating so (which will be promoted to an error if you are treating warnings as errors).<\/p>\n<p>Since we haven&#8217;t covered <code>if constexpr<\/code> yet (we do so in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-if-statements\/\">8.4 -- Constexpr if statements<\/a>), <code>x<\/code> is non-constexpr in this example to avoid the potential compiler warning.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">So when should you use the conditional operator?<\/p>\n<p>The conditional operator is most useful when doing one of the following:<\/p>\n<ul>\n<li>Initializing an object with one of two values.\n<\/li>\n<li>Assigning one of two values to an object.\n<\/li>\n<li>Passing one of two values to a function.\n<\/li>\n<li>Returning one of two values from a function.\n<\/li>\n<li>Printing one of two values.\n<\/li>\n<\/ul>\n<p>Complicated expressions should generally avoid use of the conditional operator, as they tend to be error prone and hard to read.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Prefer to avoid the conditional operator in complicated expressions.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/relational-operators-and-floating-point-comparisons\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">6.7<\/span>Relational operators and floating point comparisons\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/the-comma-operator\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">6.5<\/span>The comma operator\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Operator Symbol Form Meaning Conditional ?: c ? x : y If conditional c is true then evaluate x, otherwise evaluate y The conditional operator (?:) (also sometimes called the arithmetic if operator) is a ternary operator (an operator that takes 3 operands). Because it has historically been C++&#8217;s only &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15966"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15966"}],"version-history":[{"count":21,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15966\/revisions"}],"predecessor-version":[{"id":18198,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15966\/revisions\/18198"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15966"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15966"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15966"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}