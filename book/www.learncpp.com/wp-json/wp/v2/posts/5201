{"id":5201,"date":"2016-12-21T10:57:35","date_gmt":"2016-12-21T18:57:35","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=5201"},"modified":"2025-02-27T00:54:55","modified_gmt":"2025-02-27T08:54:55","slug":"nested-types-member-types","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/nested-types-member-types\/","title":{"rendered":"15.3 &#8212; Nested types (member types)"},"content":{"rendered":"<p>Consider the following short program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nenum class FruitType\r\n{\r\n\tapple,\r\n\tbanana,\r\n\tcherry\r\n};\r\n\r\nclass Fruit\r\n{\r\nprivate:\r\n\tFruitType m_type { };\r\n\tint m_percentageEaten { 0 };\r\n\r\npublic:\r\n\tFruit(FruitType type) :\r\n\t\tm_type { type }\r\n\t{\r\n\t}\r\n\r\n\tFruitType getType() { return m_type; }\r\n\tint getPercentageEaten() { return m_percentageEaten; }\r\n\r\n\tbool isCherry() { return m_type == FruitType::cherry; }\r\n\r\n};\r\n\r\nint main()\r\n{\r\n\tFruit apple { FruitType::apple };\r\n\t\r\n\tif (apple.getType() == FruitType::apple)\r\n\t\tstd::cout &lt;&lt; \"I am an apple\";\r\n\telse\r\n\t\tstd::cout &lt;&lt; \"I am not an apple\";\r\n\t\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>There&#8217;s nothing wrong with this program.  But because <code>enum class FruitType<\/code> is meant to be used in conjunction with the <code>Fruit<\/code> class, having it exist independently of the class leaves us to infer how they are connected.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Nested types (member types)<\/p>\n<p>So far, we&#8217;ve seen class types with two different kinds of members: data members and member functions.  Our <code>Fruit<\/code> class in the example above has both of these.<\/p>\n<p>Class types support another kind of member: <strong>nested types<\/strong> (also called <strong>member types<\/strong>).  To create a nested type, you simply define the type inside the class, under the appropriate access specifier.<\/p>\n<p>Here&#8217;s the same program as above, rewritten to use a nested type defined inside the <code>Fruit<\/code> class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Fruit\r\n{\r\npublic:\r\n\t\/\/ FruitType has been moved inside the class, under the public access specifier\r\n        \/\/ We've also renamed it Type and made it an enum rather than an enum class\r\n\tenum Type\r\n\t{\r\n\t\tapple,\r\n\t\tbanana,\r\n\t\tcherry\r\n\t};\r\n\r\nprivate:\r\n\tType m_type {};\r\n\tint m_percentageEaten { 0 };\r\n\r\npublic:\r\n\tFruit(Type type) :\r\n\t\tm_type { type }\r\n\t{\r\n\t}\r\n\r\n\tType getType() { return m_type;  }\r\n\tint getPercentageEaten() { return m_percentageEaten;  }\r\n\r\n\tbool isCherry() { return m_type == cherry; } \/\/ Inside members of Fruit, we no longer need to prefix enumerators with FruitType::\r\n};\r\n\r\nint main()\r\n{\r\n\t\/\/ Note: Outside the class, we access the enumerators via the Fruit:: prefix now\r\n\tFruit apple { Fruit::apple };\r\n\t\r\n\tif (apple.getType() == Fruit::apple)\r\n\t\tstd::cout &lt;&lt; \"I am an apple\";\r\n\telse\r\n\t\tstd::cout &lt;&lt; \"I am not an apple\";\r\n\t\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>There are a few things worth pointing out here.<\/p>\n<p>First, note that <code>FruitType<\/code> is now defined inside the class, where it has been renamed <code>Type<\/code> for reasons that we will discuss shortly.<\/p>\n<p>Second, nested type <code>Type<\/code> has been defined at the top of the class.  Nested type names must be fully defined before they can be used, so they are usually defined first.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Define any nested types at the top of your class type.\n<\/p><\/div>\n<p>Third, nested types follow normal access rules.  <code>Type<\/code> is defined under the <code>public<\/code> access specifier, so that the type name and enumerators can be directly accessed by the public.<\/p>\n<p>Fourth, class types act as a scope region for names declared within, just as namespaces do.  Therefore the fully qualified name of <code>Type<\/code> is <code>Fruit::Type<\/code>, and the fully qualified name of the <code>apple<\/code> enumerator is <code>Fruit::apple<\/code>.<\/p>\n<p>Within the members of the class, we do not need to use the fully qualified name.  For example, in member function <code>isCherry()<\/code> we access the <code>cherry<\/code> enumerator without the <code>Fruit::<\/code> scope qualifier.<\/p>\n<p>Outside the class, we must use the fully qualified name (e.g. <code>Fruit::apple<\/code>).  We renamed <code>FruitType<\/code> to <code>Type<\/code> so we can access it as <code>Fruit::Type<\/code> (rather than the more redundant <code>Fruit::FruitType<\/code>).<\/p>\n<p>Finally, we changed our enumerated type from scoped to unscoped.  Since the class itself is now acting as a scope region, it&#8217;s somewhat redundant to use a scoped enumerator as well.  Changing to an unscoped enum means we can access enumerators as <code>Fruit::apple<\/code> rather than the longer <code>Fruit::Type::apple<\/code> we&#8217;d have to use if the enumerator were scoped.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Nested typedefs and type aliases<\/p>\n<p>Class types can also contain nested typedefs or type aliases:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Employee\r\n{\r\npublic:\r\n    using IDType = int;\r\n\r\nprivate:\r\n    std::string m_name{};\r\n    IDType m_id{};\r\n    double m_wage{};\r\n\r\npublic:\r\n    Employee(std::string_view name, IDType id, double wage)\r\n        : m_name { name }\r\n        , m_id { id }\r\n        , m_wage { wage }\r\n    {\r\n    }\r\n\r\n    const std::string&amp; getName() { return m_name; }\r\n    IDType getId() { return m_id; } \/\/ can use unqualified name within class\r\n};\r\n\r\nint main()\r\n{\r\n    Employee john { \"John\", 1, 45000 };\r\n    Employee::IDType id { john.getId() }; \/\/ must use fully qualified name outside class\r\n\r\n    std::cout &lt;&lt; john.getName() &lt;&lt; \" has id: \" &lt;&lt; id &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nJohn has id: 1\r\n<\/pre>\n<p>Note that inside the class we can just use <code>IDType<\/code>, but outside the class we must use the fully qualified name <code>Employee::IDType<\/code>.<\/p>\n<p>We discuss the benefits of type aliases in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/typedefs-and-type-aliases\/\">10.7 -- Typedefs and type aliases<\/a>, and they serve the same purpose here.  It is very common for classes in the C++ standard library to make use of nested typedefs.  As of the time of writing, <code>std::string<\/code> defines ten nested typedefs!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Nested classes and access to outer class members<\/p>\n<p>It is fairly uncommon for classes to have other classes as a nested type, but it is possible.  In C++, a nested class does not have access to the <code>this<\/code> pointer of the outer (containing) class, so nested classes can not directly access the members of the outer class.  This is because a nested class can be instantiated independently of the outer class (and in such a case, there would be no outer class members to access!)<\/p>\n<p>However, because nested classes are members of the outer class, they can access any private members of the outer class that are in scope.<\/p>\n<p>Let&#8217;s illustrate with an example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Employee\r\n{\r\npublic:\r\n    using IDType = int;\r\n\r\n    class Printer\r\n    {\r\n    public:\r\n        void print(const Employee&amp; e) const\r\n        {\r\n            \/\/ Printer can't access Employee's `this` pointer\r\n            \/\/ so we can't print m_name and m_id directly\r\n            \/\/ Instead, we have to pass in an Employee object to use\r\n            \/\/ Because Printer is a member of Employee,\r\n            \/\/ we can access private members e.m_name and e.m_id directly\r\n            std::cout &lt;&lt; e.m_name &lt;&lt; \" has id: \" &lt;&lt; e.m_id &lt;&lt; '\\n';\r\n        }\r\n    };\r\n\r\nprivate:\r\n    std::string m_name{};\r\n    IDType m_id{};\r\n    double m_wage{};\r\n\r\npublic:\r\n    Employee(std::string_view name, IDType id, double wage)\r\n        : m_name{ name }\r\n        , m_id{ id }\r\n        , m_wage{ wage }\r\n    {\r\n    }\r\n\r\n    \/\/ removed the access functions in this example (since they aren't used)\r\n};\r\n\r\nint main()\r\n{\r\n    const Employee john{ \"John\", 1, 45000 };\r\n    const Employee::Printer p{}; \/\/ instantiate an object of the inner class\r\n    p.print(john);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nJohn has id: 1\r\n<\/pre>\n<p>There is one case where nested classes are more commonly used.  In the standard library, most iterator classes are implemented as nested classes of the container they are designed to iterate over.  For example, <code>std::string::iterator<\/code> is implemented as a nested class of <code>std::string<\/code>.  We&#8217;ll cover iterators in a future chapter.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Nested types and forward declarations<\/p>\n<p>A nested type can be forward declared within the class that encloses it.  The nested type can then be defined later, either within the enclosing class, or outside of it.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass outer\r\n{\r\npublic:\r\n    class inner1;   \/\/ okay: forward declaration inside the enclosing class okay\r\n    class inner1{}; \/\/ okay: definition of forward declared type inside the enclosing class\r\n    class inner2;   \/\/ okay: forward declaration inside the enclosing class okay\r\n};\r\n\r\nclass inner2 \/\/ okay: definition of forward declared type outside the enclosing class\r\n{\r\n};\r\n\r\nint main()\r\n{\r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, a nested type cannot be forward declared prior to the definition of the enclosing class.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass outer;         \/\/ okay: can forward declare non-nested type\r\nclass outer::inner1; \/\/ error: can't forward declare nested type prior to outer class definition\r\n\r\nclass outer\r\n{\r\npublic:\r\n    class inner1{}; \/\/ note: nested type declared here\r\n};\r\n\r\nclass outer::inner1; \/\/ okay (but redundant) since nested type has already been declared as part of outer class definition\r\n\r\nint main()\r\n{\r\n    return 0;\r\n}<\/code><\/pre>\n<p>While you can forward declare a nested type after the definition of the enclosing class, since the enclosing class will already contain a declaration for the nested type, doing so is redundant.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-destructors\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">15.4<\/span>Introduction to destructors\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/classes-and-header-files\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">15.2<\/span>Classes and header files\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Consider the following short program: #include &lt;iostream&gt; enum class FruitType { apple, banana, cherry }; class Fruit { private: FruitType m_type { }; int m_percentageEaten { 0 }; public: Fruit(FruitType type) : m_type { type } { } FruitType getType() { return m_type; } int getPercentageEaten() { return m_percentageEaten; } &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5201"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=5201"}],"version-history":[{"count":24,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5201\/revisions"}],"predecessor-version":[{"id":15365,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5201\/revisions\/15365"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=5201"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=5201"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=5201"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}