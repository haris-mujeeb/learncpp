{"id":11244,"date":"2021-06-17T17:42:09","date_gmt":"2021-06-18T01:42:09","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=11244"},"modified":"2024-12-18T10:15:38","modified_gmt":"2024-12-18T18:15:38","slug":"type-deduction-for-functions","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/type-deduction-for-functions\/","title":{"rendered":"10.9 &#8212; Type deduction for functions"},"content":{"rendered":"<p>Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int add(int x, int y)\r\n{\r\n    return x + y;\r\n}<\/code><\/pre>\n<p>When this function is compiled, the compiler will determine that <code>x + y<\/code>evaluates to an <code>int<\/code>, then ensure that type of the return value matches the declared return type of the function (or that the return value type can be converted to the declared return type).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Return type deduction with <code>auto<\/code><\/p>\n<p>Since the compiler already has to deduce the return type from the return statement (to ensure that the value can be converted to the function&#8217;s declared return type), in C++14, the <code>auto<\/code> keyword was extended to do function return type deduction.  This works by using the <code>auto<\/code> keyword in place of the function&#8217;s return type.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">auto add(int x, int y)\r\n{\r\n    return x + y;\r\n}<\/code><\/pre>\n<p>Because the return statement is returning an <code>int<\/code> value, the compiler will deduce that the return type of this function is <code>int<\/code>.<\/p>\n<p>When using an <code>auto<\/code> return type, all return statements within the function must return values of the same type, otherwise an error will result.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">auto someFcn(bool b)\r\n{\r\n    if (b)\r\n        return 5; \/\/ return type int\r\n    else\r\n        return 6.7; \/\/ return type double\r\n}<\/code><\/pre>\n<p>In the above function, the two return statements return values of different types, so the compiler will give an error.<\/p>\n<p>If such a case is desired for some reason, you can either explicitly specify a return type for your function (in which case the compiler will try to implicitly convert any non-matching return expressions to the explicit return type), or you can explicitly convert all of your return statements to the same type.  In the example above, the latter could be done by changing <code>5<\/code> to <code>5.0<\/code>, but <code>static_cast<\/code> can also be used for non-literal types.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Benefits of return type deduction<\/p>\n<p>The biggest advantage of return type deduction is that having the compiler deduce the function&#8217;s return type negates the risk of a mismatched return type (preventing unexpected conversions).<\/p>\n<p>This can be particularly useful when a function&#8217;s return type is fragile (cases where return type is likely to change if the implementation changes).  In such cases, being explicit about the return type means having to update all relevant return types when an impacting change is made to the implementation.  If we&#8217;re lucky, the compiler will error until we update the relevant return types.  If we&#8217;re not lucky, we&#8217;ll get implicit conversions where we don&#8217;t desire them.<\/p>\n<p>In other cases, the return type of a function may either be long and complex, or not be that obvious.  In such cases, <code>auto<\/code> can be used to simplify:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ let compiler determine the return type of unsigned short + char\r\nauto add(unsigned short x, char y)\r\n{\r\n    return x + y;\r\n}<\/code><\/pre>\n<p>We discuss this case a bit more (and how to express the actual return type of such a function) in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-templates-with-multiple-template-types\/\">11.8 -- Function templates with multiple template types<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Downsides of return type deduction<\/p>\n<p>There are two major downsides to return type deduction:<\/p>\n<ol start=\"1\">\n<li>Functions that use an <code>auto<\/code> return type must be fully defined before they can be used (a forward declaration is not sufficient).  For example:\n<\/li>\n<\/ol>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nauto foo();\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; foo() &lt;&lt; '\\n'; \/\/ the compiler has only seen a forward declaration at this point\r\n\r\n    return 0;\r\n}\r\n\r\nauto foo()\r\n{\r\n    return 5;\r\n}<\/code><\/pre>\n<p>On the author&#8217;s machine, this gives the following compile error:<\/p>\n<pre>\nerror C3779: 'foo': a function that returns 'auto' cannot be used before it is defined.\r\n<\/pre>\n<p>This makes sense: a forward declaration does not have enough information for the compiler to deduce the function&#8217;s return type.  This means normal functions that return <code>auto<\/code> are typically only callable from within the file in which they are defined.<\/p>\n<ol start=\"2\">\n<li>When using type deduction with objects, the initializer is always present as part of the same statement, so it&#8217;s usually not overly burdensome to determine what type will be deduced.  With type deduction for functions, that is not the case -- the function&#8217;s prototype gives no indication as to what type the function actually returns.  A good programming IDE should make clear what the deduced type of the function is, but in absence of having that available, a user would actually have to dig into the function body itself to determine what type the function returned.  The odds of mistakes being made are higher.  Generally we prefer to be explicit about types that are part of an interface (a function&#8217;s declaration is an interface).\n<\/li>\n<\/ol>\n<p>Unlike type deduction for objects, there isn&#8217;t as much consensus on best practices for function return type deduction.  We recommend generally avoiding return type deduction for functions.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Prefer explicit return types over return type deduction (except in cases where the return type is unimportant, difficult to express, or fragile).\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Trailing return type syntax<\/p>\n<p>The <code>auto<\/code> keyword can also be used to declare functions using a <strong>trailing return syntax<\/strong>, where the return type is specified after the rest of the function prototype.<\/p>\n<p>Consider the following function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int add(int x, int y)\r\n{\r\n  return (x + y);\r\n}<\/code><\/pre>\n<p>Using the trailing return syntax, this could be equivalently written as:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">auto add(int x, int y) -&gt; int\r\n{\r\n  return (x + y);\r\n}<\/code><\/pre>\n<p>In this case, <code>auto<\/code> does not perform type deduction -- it is just part of the syntax to use a trailing return type.<\/p>\n<p>Why would you want to use this?  Here are some reasons:<\/p>\n<ol start=\"1\">\n<li>For functions with complex return types, a trailing return type can make the function easier to read:\n<\/li>\n<\/ol>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;type_traits&gt; \/\/ for std::common_type\r\n\r\nstd::common_type_t&lt;int, double&gt; compare(int, double);         \/\/ harder to read (where is the name of the function in this mess?)\r\nauto compare(int, double) -&gt; std::common_type_t&lt;int, double&gt;; \/\/ easier to read (we don't have to read the return type unless we care)<\/code><\/pre>\n<ol start=\"2\">\n<li>The trailing return type syntax can be used to align the names of your functions, which makes consecutive function declarations easier to read:\n<\/li>\n<\/ol>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">auto add(int x, int y) -&gt; int;\r\nauto divide(double x, double y) -&gt; double;\r\nauto printSomething() -&gt; void;\r\nauto generateSubstring(const std::string &amp;s, int start, int len) -&gt; std::string;<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<ol start=\"3\">\n<li>If we have a function whose return type must be deduced based on the type of the function parameters, a normal return type will not suffice, because the compiler has not yet seen the parameters at that point.\n<\/li>\n<\/ol>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;type_traits&gt;\r\n\/\/ note: decltype(x) evaluates to the type of x\r\n\r\nstd::common_type_t&lt;decltype(x), decltype(y)&gt; add(int x, double y);         \/\/ Compile error: compiler hasn't seen definitions of x and y yet\r\nauto add(int x, double y) -&gt; std::common_type_t&lt;decltype(x), decltype(y)&gt;; \/\/ ok<\/code><\/pre>\n<ol start=\"4\">\n<li>The trailing return syntax is also required for some advanced features of C++, such as lambdas (which we cover in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-lambdas-anonymous-functions\/\">20.6 -- Introduction to lambdas (anonymous functions)<\/a>).\n<\/li>\n<\/ol>\n<\/div>\n<p>For now, we recommend the continued use of the traditional function return syntax except in situations that require the trailing return syntax.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Type deduction can&#8217;t be used for function parameter types<\/p>\n<p>Many new programmers who learn about type deduction try something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid addAndPrint(auto x, auto y)\r\n{\r\n    std::cout &lt;&lt; x + y &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    addAndPrint(2, 3); \/\/ case 1: call addAndPrint with int parameters\r\n    addAndPrint(4.5, 6.7); \/\/ case 2: call addAndPrint with double parameters\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Unfortunately, type deduction doesn&#8217;t work for function parameters, and prior to C++20, the above program won&#8217;t compile (you&#8217;ll get an error about function parameters not being able to have an auto type).<\/p>\n<p>In C++20, the <code>auto<\/code> keyword was extended so that the above program will compile and function correctly -- however, <code>auto<\/code> is not invoking type deduction in this case.  Rather, it is triggering a different feature called <code>function templates<\/code> that was designed to actually handle such cases.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We introduce function templates in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-templates\/\">11.6 -- Function templates<\/a>, and discuss use of <code>auto<\/code> in the context of function templates in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-templates-with-multiple-template-types\/\">11.8 -- Function templates with multiple template types<\/a>.\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-10-summary-and-quiz\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">10.x<\/span>Chapter 10 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/type-deduction-for-objects-using-the-auto-keyword\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">10.8<\/span>Type deduction for objects using the auto keyword\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Consider the following program: int add(int x, int y) { return x + y; } When this function is compiled, the compiler will determine that x + yevaluates to an int, then ensure that type of the return value matches the declared return type of the function (or that the &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/11244"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=11244"}],"version-history":[{"count":15,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/11244\/revisions"}],"predecessor-version":[{"id":17997,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/11244\/revisions\/17997"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=11244"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=11244"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=11244"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}