{"id":15414,"date":"2023-09-11T14:54:59","date_gmt":"2023-09-11T21:54:59","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15414"},"modified":"2024-01-10T19:23:12","modified_gmt":"2024-01-11T03:23:12","slug":"stdvector-bool","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/stdvector-bool\/","title":{"rendered":"16.12 &#8212; std::vector&lt;bool&gt;"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/bit-flags-and-bit-manipulation-via-stdbitset\/\">O.1 -- Bit flags and bit manipulation via std::bitset<\/a>, we discussed how <code>std::bitset<\/code> has the capability to compact 8 Boolean values into a byte.  Those bits can then be modified via the member functions of <code>std::bitset<\/code>.<\/p>\n<p><code>std::vector<\/code> has an interesting trick up its sleeves.  There is a special implementation for <code>std::vector&lt;bool&gt;<\/code> that may be more space efficient for Boolean values by similarly compacting 8 Boolean values into a byte.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>When a template class has a different implementation for a particular template type argument, this is called <strong>class template specialization<\/strong>.  We discuss this topic further in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-template-specialization\/\">26.4 -- Class template specialization<\/a>.\n<\/div>\n<p>Unlike <code>std::bitset<\/code>, which was designed for bit manipulation, <code>std::vector&lt;bool&gt;<\/code> lacks bit manipulation member functions.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using <code>std::vector&lt;bool&gt;<\/code><\/p>\n<p>For the most part, <code>std::vector&lt;bool&gt;<\/code> works just like a normal <code>std::vector<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::vector&lt;bool&gt; v { true, false, false, true, true };\r\n    \r\n    for (int i : v)\r\n        std::cout &lt;&lt; i &lt;&lt; ' ';\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    \/\/ Change the Boolean value with index 4 to false\r\n    v[4] = false;\r\n\r\n    for (int i : v)\r\n        std::cout &lt;&lt; i &lt;&lt; ' ';\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>On the author&#8217;s 64-bit machine, this prints:<\/p>\n<pre>\n1 0 0 1 1\r\n1 0 0 1 0\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><code>std::vector&lt;bool&gt;<\/code> tradeoffs<\/p>\n<p>However, <code>std::vector&lt;bool&gt;<\/code> has some tradeoffs that users should be aware of.<\/p>\n<p>First, <code>std::vector&lt;bool&gt;<\/code> has a fairly high amount of overhead (<code>sizeof(std::vector&lt;bool&gt;)<\/code> is 40 bytes on the author&#8217;s machine), so you won&#8217;t save memory unless you&#8217;re allocating more Boolean values than the overhead for your architecture.<\/p>\n<p>Second, the performance of <code>std::vector&lt;bool&gt;<\/code> is highly dependent upon the implementation (as implementations aren&#8217;t even required to do optimization, let alone do it well).  Per <a href=\"https:\/\/isocpp.org\/blog\/2012\/11\/on-vectorbool\">this article<\/a>, a highly optimized implementation can be significantly faster than alternatives.  However, a poorly optimized implementation will be slower.<\/p>\n<p>Third and most importantly, <code>std::vector&lt;bool&gt;<\/code> is not a vector (it is not required to be contiguous in memory), nor does it hold <code>bool<\/code> values (it holds a collection of bits), nor does it meet C++&#8217;s definition of a container.  <\/p>\n<p>Although <code>std::vector&lt;bool&gt;<\/code> behaves like a vector in most cases, it is not fully compatible with the rest of the standard library.  Code that works with other element types may not work with <code>std::vector&lt;bool&gt;<\/code>.<\/p>\n<p>For example, the following code works when <code>T<\/code> is any type except <code>bool<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template&lt;typename T&gt;\r\nvoid foo( std::vector&lt;T&gt;&amp; v )\r\n{\r\n    T&amp; first = v[0]; \/\/ get a reference to the first element\r\n    \/\/ Do something with first\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Avoid <code>std::vector&lt;bool&gt;<\/code><\/p>\n<p>The modern consensus is that <code>std::vector&lt;bool&gt;<\/code> should generally be avoided, as the performance gains are unlikely to be worth the incompatibility headaches due to it not being a proper container.<\/p>\n<p>Unfortunately, this optimizing version of <code>std::vector&lt;bool&gt;<\/code> is enabled by default, and there is no way to disable it in favor of a non-optimized version that is actually a container.  There have been calls to deprecate <code>std::vector&lt;bool&gt;<\/code>, and work is underway to determine what a replacement compacted vector of <code>bool<\/code> might look like (perhaps as a future <code>std::dynamic_bitset<\/code>).<\/p>\n<p>Our recommendation is as follows:<\/p>\n<ul>\n<li>Use (constexpr) <code>std::bitset<\/code> when the number of bits you need is known at compile-time, you don&#8217;t have more than a moderate number of Boolean values to store (e.g. under 64k), and the limited set of operators and member functions (e.g. lack of iterator support) meets your requirements.\n<\/li>\n<li>Prefer <code>std::vector&lt;char&gt;<\/code> when you need a resizable container of Boolean values and space-savings isn&#8217;t a necessity.  This type behaves like a normal container.\n<\/li>\n<li>Favor a 3rd party implementation of a dynamic bitset (such as <code>boost::dynamic_bitset<\/code>) when you need a dynamic bitset to do bit operations on.  Such types won&#8217;t pretend to be standard library containers when they aren&#8217;t.\n<\/li>\n<\/ul>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Favor <code>constexpr std::bitset<\/code>, <code>std::vector&lt;char&gt;<\/code>, or 3rd party dynamic bitsets over <code>std::vector&lt;bool&gt;<\/code>.\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-16-summary-and-quiz\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">16.x<\/span>Chapter 16 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdvector-and-stack-behavior\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">16.11<\/span>std::vector and stack behavior\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we discussed how std::bitset has the capability to compact 8 Boolean values into a byte. Those bits can then be modified via the member functions of std::bitset. std::vector has an interesting trick up its sleeves. There is a special implementation for std::vector&lt;bool&gt; that may be more space &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15414"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15414"}],"version-history":[{"count":5,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15414\/revisions"}],"predecessor-version":[{"id":16506,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15414\/revisions\/16506"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15414"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15414"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15414"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}