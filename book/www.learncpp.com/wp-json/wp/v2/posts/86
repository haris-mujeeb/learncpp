{"id":86,"date":"2007-07-09T16:35:54","date_gmt":"2007-07-10T00:35:54","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/66-c-style-strings\/"},"modified":"2024-05-25T16:20:02","modified_gmt":"2024-05-25T23:20:02","slug":"c-style-strings","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/c-style-strings\/","title":{"rendered":"17.10 &#8212; C-style strings"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-c-style-arrays\/\">17.7 -- Introduction to C-style arrays<\/a>, we introduced C-style arrays, which allow us to define a sequential collection of elements:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    int testScore[30] {}; \/\/ an array of 30 ints, indices 0 through 29<\/code><\/pre>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/literals\/\">5.2 -- Literals<\/a>, we defined a string as a collection of sequential characters (such as &#8220;Hello, world!&#8221;), and introduced C-style string literals.  We also noted that the C-style string literal &#8220;Hello, world!&#8221; has type <code>const char[14]<\/code> (13 explicit characters plus 1 hidden null-terminator character).<\/p>\n<p>If you hadn&#8217;t connected the dots before, it should be obvious now that C-style strings are just C-style arrays whose element type is <code>char<\/code> or <code>const char<\/code>!<\/p>\n<p>Although C-style string literals are fine to use in our code, C-style string objects have fallen out of favor in modern C++ because they are hard to use and dangerous (with <code>std::string<\/code> and <code>std::string_view<\/code> being the modern replacements).  Regardless, you may still run across uses of C-style string objects in older code, and we would be remiss not to cover them at all.<\/p>\n<p>Therefore, in this lesson, we&#8217;ll take a look at the most important points regarding C-style string objects in modern C++.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Defining C-style strings<\/p>\n<p>To define a C-style string variable, simply declare a C-style array variable of <code>char<\/code> (or <code>const char<\/code> \/ <code>constexpr char<\/code>):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">char str1[8]{};                    \/\/ an array of 8 char, indices 0 through 7\r\n\r\nconst char str2[]{ \"string\" };     \/\/ an array of 7 char, indices 0 through 6\r\nconstexpr char str3[] { \"hello\" }; \/\/ an array of 6 const char, indices 0 through 5<\/code><\/pre>\n<p>Remember that we need an extra character for the implicit null terminator.<\/p>\n<p>When defining C-style strings with an initializer, we highly recommend omitting the array length and letting the compiler calculate the length.  That way if the initializer changes in the future, you won&#8217;t have to remember to update the length, and there is no risk in forgetting to include an extra element to hold the null terminator.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">C-style strings will decay<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/c-style-array-decay\/\">17.8 -- C-style array decay<\/a>, we discussed how C-style arrays will decay into a pointer in most circumstances.  Because C-style strings are C-style arrays, they will decay -- C-style string literals decay into a <code>const char*<\/code>, and C-style string arrays decay into either a <code>const char*<\/code> or <code>char*<\/code> depending on whether the array is const.  And when a C-style string decays into a pointer, the length of the string (encoded in the type information) is lost.<\/p>\n<p>This loss of length information is the reason C-style strings have a null-terminator.  The length of the string can be (inefficiently) regenerated by counting the number of elements between the start of the string and the null terminator.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Outputting a C-style string<\/p>\n<p>When outputting a C-style string, <code>std::cout<\/code> outputs characters until it encounters the null terminator.  This null terminator marks the end of the string, so that decayed strings (which have lost their length information) can still be printed.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid print(char ptr[])\r\n{\r\n    std::cout &lt;&lt; ptr &lt;&lt; '\\n'; \/\/ output string\r\n}\r\n\r\nint main()\r\n{\r\n    char str[]{ \"string\" };\r\n    std::cout &lt;&lt; str &lt;&lt; '\\n'; \/\/ outputs string\r\n\r\n    print(str);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>If you try to print a string that does not have a null terminator (e.g. because the null-terminator was overwritten somehow), the result will be undefined behavior.  The most likely outcome in this case will be that all the characters in the string are printed, and then it will just keep printing everything in adjacent memory slots (interpreted as a character) until it happens to hit a byte of memory containing a 0 (which will be interpreted as a null terminator)!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Inputting C-style strings<\/p>\n<p>Consider the case where we are asking the user to roll a die as many times as they wish and enter the numbers rolled without spaces (e.g. <code>524412616<\/code>).  How many characters will the user enter?  We have no idea.<\/p>\n<p>Because C-style strings are fixed-size arrays, the solution is to declare an array larger than we are ever likely to need:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    char rolls[255] {}; \/\/ declare array large enough to hold 254 characters + null terminator\r\n    std::cout &lt;&lt; \"Enter your rolls: \";\r\n    std::cin &gt;&gt; rolls;\r\n    std::cout &lt;&lt; \"You entered: \" &lt;&lt; rolls &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Prior to C++20, <code>std::cin &gt;&gt; rolls<\/code> would extract as many characters as possible to <code>rolls<\/code> (stopping at the first non-leading whitespace).  Nothing is stopping the user from entering more than 254 characters (either unintentionally, or maliciously).  And if that happens, the user&#8217;s input will overflow the <code>rolls<\/code> array and undefined behavior will result.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p><strong>Array overflow<\/strong> or <strong>buffer overflow<\/strong> is a computer security issue that occurs when more data is copied into storage than the storage can hold.  In such cases, the memory just beyond the storage will be overwritten, leading to undefined behavior.  Malicious actors can potentially exploit such flaws to overwrite the contents of memory, hoping to change the program&#8217;s behavior in some advantageous way.\n<\/div>\n<p>In C++20, <code>operator&gt;&gt;<\/code> was changed so that it only works for inputting non-decayed C-style strings.  This allows <code>operator&gt;&gt;<\/code> to extract only as many characters as the C-style string&#8217;s length will allow, preventing overflow.  But this also means you can no longer use <code>operator&gt;&gt;<\/code> to input to decayed C-style strings.<\/p>\n<p>The recommended way of reading C-style strings using <code>std::cin<\/code> is as follows:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;iterator&gt; \/\/ for std::size\r\n\r\nint main()\r\n{\r\n    char rolls[255] {}; \/\/ declare array large enough to hold 254 characters + null terminator\r\n    std::cout &lt;&lt; \"Enter your rolls: \";\r\n    std::cin.getline(rolls, std::size(rolls));\r\n    std::cout &lt;&lt; \"You entered: \" &lt;&lt; rolls &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This call to <code>cin.getline()<\/code> will read up to 254 characters (including whitespace) into <code>rolls<\/code>.  Any excess characters will be discarded.  Because <code>getline()<\/code> takes a length, we can provide the maximum number of characters to accept.  With a non-decayed array, this is easy -- we can use <code>std::size()<\/code> to get the array length.  With a decayed array, we have to determine the length in some other way.  And if we provide the wrong length, our program may malfunction or have security issues.<\/p>\n<p>In modern C++, when storing inputted text from the user, it&#8217;s safer to use <code>std::string<\/code>, as <code>std::string<\/code> will adjust automatically to hold as many characters as needed.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Modifying C-style strings<\/p>\n<p>One important point to note is that C-style strings follow the same rules as C-style arrays.  This means you can initialize the string upon creation, but you can not assign values to it using the assignment operator after that!<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">char str[]{ \"string\" }; \/\/ ok\r\nstr = \"rope\";           \/\/ not ok!<\/code><\/pre>\n<p>This makes using C-style strings a bit awkward.<\/p>\n<p>Since C-style strings are arrays, you can use the [] operator to change individual characters in the string:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    char str[]{ \"string\" };\r\n    std::cout &lt;&lt; str &lt;&lt; '\\n';\r\n    str[1] = 'p';\r\n    std::cout &lt;&lt; str &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\nstring\r\nspring\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Getting the length of an C-style string<\/p>\n<p>Because C-style strings are C-style arrays, you can use <code>std::size()<\/code> (or in C++20, <code>std::ssize()<\/code>) to get the length of the string as an array.  There are two caveats here:<\/p>\n<ol start=\"1\">\n<li>This doesn&#8217;t work on decayed strings.\n<\/li>\n<li>Returns the actual length of the C-style array, not the length of the string.\n<\/li>\n<\/ol>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    char str[255]{ \"string\" }; \/\/ 6 characters + null terminator\r\n    std::cout &lt;&lt; \"length = \" &lt;&lt; std::size(str) &lt;&lt; '\\n'; \/\/ prints length = 255\r\n\r\n    char *ptr { str };\r\n    std::cout &lt;&lt; \"length = \" &lt;&lt; std::size(ptr) &lt;&lt; '\\n'; \/\/ compile error\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>An alternate solution is to use the <code>strlen()<\/code> function, which lives in the <code>&lt;cstring&gt;<\/code> header.  <code>strlen()<\/code> will work on decayed arrays, and returns the length of the string being held, excluding the null terminator:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cstring&gt; \/\/ for std::strlen\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    char str[255]{ \"string\" }; \/\/ 6 characters + null terminator\r\n    std::cout &lt;&lt; \"length = \" &lt;&lt; std::strlen(str) &lt;&lt; '\\n'; \/\/ prints length = 6\r\n\r\n    char *ptr { str };\r\n    std::cout &lt;&lt; \"length = \" &lt;&lt; std::strlen(ptr) &lt;&lt; '\\n';   \/\/ prints length = 6\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, <code>std::strlen()<\/code> is slow, as it has to traverse through the whole array, counting characters until it hits the null terminator.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Other C-style string manipulating functions<\/p>\n<p>Because C-style strings are the primary string type in C, the C language provides many functions for manipulating C-style strings.  These functions have been inherited by C++ as part of the <code>&lt;cstring&gt;<\/code> header.<\/p>\n<p>Here are a few of the most useful that you may see in older code:<\/p>\n<ul>\n<li>strlen() -- returns the length of a C-style string\n<\/li>\n<li>strcpy(), strncpy(), strcpy_s() -- overwrites one C-style string with another\n<\/li>\n<li>strcat(), strncat() -- Appends one C-style string to the end of another\n<\/li>\n<li>strcmp(), strncmp() -- Compares two C-style strings (returns <code>0<\/code> if equal)\n<\/li>\n<\/ul>\n<p>Except for <code>strlen()<\/code>, we generally recommend avoiding these.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Avoid non-const C-style string objects<\/p>\n<p>Unless you have a specific, compelling reason to use non-const C-style strings, they are best avoided, as they are awkward to work with and are prone to overruns, which will cause undefined behavior (and are potential security issues).<\/p>\n<p>In the rare case that you do need to work with C-style strings or fixed buffer sizes (e.g. for memory-limited devices), we&#8217;d recommend using a well-tested 3rd party fixed-length string library designed for the purpose.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Avoid non-const C-style string objects in favor of <code>std::string<\/code>.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Write a function to print a C-style string character by character.  Use a pointer and pointer arithmetic to step through each character of the string and print that character.  Write a <code>main<\/code> function that tests the function with the string literal &#8220;Hello, world!&#8221;.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ str will point to the first letter of the C-style string.\r\n\/\/ Note that str points to a const char, so we can not change the values it points to.\r\n\/\/ However, we can point str at something else.  This does not change the value of the argument.\r\nvoid printCString(const char str[])\r\n{\r\n    \/\/ While we haven't encountered a null terminator\r\n    while (*str != '\\0')\r\n    {\r\n        \/\/ print the current character\r\n        std::cout &lt;&lt; *str;\r\n\r\n        \/\/ and use pointer arithmetic to move str to the next character\r\n        ++str;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    printCString(\"Hello world!\");\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>Repeat quiz #1, but this time the function should print the string backwards.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printCStringBackwards(const char str[])\r\n{\r\n    \/\/ We can't modify str this time (we need it later)\r\n    \/\/ So we'll define a new pointer with the same address as str\r\n    const char *ptr{ str };\r\n\r\n    \/\/ Find the null terminator\r\n    while (*ptr != '\\0')\r\n        ++ptr;\r\n\r\n    \/\/ Now walk backwards and print characters until ptr reaches str again\r\n    while (ptr-- != str)\r\n    {\r\n        std::cout &lt;&lt; *ptr;\r\n    } \r\n}\r\n\r\nint main()\r\n{\r\n    printCStringBackwards(\"Hello world!\");\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/c-style-string-symbolic-constants\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.11<\/span>C-style string symbolic constants\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pointer-arithmetic-and-subscripting\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.9<\/span>Pointer arithmetic and subscripting\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we introduced C-style arrays, which allow us to define a sequential collection of elements: int testScore[30] {}; \/\/ an array of 30 ints, indices 0 through 29 In lesson , we defined a string as a collection of sequential characters (such as &#8220;Hello, world!&#8221;), and introduced C-style &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/86"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=86"}],"version-history":[{"count":50,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/86\/revisions"}],"predecessor-version":[{"id":954,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/86\/revisions\/954"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=86"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=86"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=86"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}