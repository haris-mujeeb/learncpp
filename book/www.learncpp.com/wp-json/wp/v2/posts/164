{"id":164,"date":"2007-12-27T09:32:37","date_gmt":"2007-12-27T17:32:37","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/814-anonymous-variables-and-objects\/"},"modified":"2024-12-20T01:35:37","modified_gmt":"2024-12-20T09:35:37","slug":"temporary-class-objects","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/temporary-class-objects\/","title":{"rendered":"14.13 &#8212; Temporary class objects"},"content":{"rendered":"<p>Consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y)\r\n{\r\n    int sum{ x + y }; \/\/ stores x + y in a variable\r\n    return sum;       \/\/ returns value of that variable\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; add(5, 3) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the <code>add()<\/code> function, the variable <code>sum<\/code> is used to store the result of the expression <code>x + y<\/code>.  This variable is then evaluated in the return statement to produce the value to be returned.  While this might be occasionally useful for debugging (so we can inspect the value of <code>sum<\/code> if desired), it actually makes the function more complex than it needs to be by defining an object that is then only used one time.<\/p>\n<p>In most cases where a variable is used only once, we actually don&#8217;t need a variable.  Instead, we can substitute in the expression used to initialize the variable where the variable would have been used.  Here is the <code>add()<\/code> function rewritten in this manner:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y)\r\n{\r\n    return x + y; \/\/ just return x + y directly\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; add(5, 3) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This works not only with return values, but also with most function arguments.  For example, instead of this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printValue(int value)\r\n{\r\n    std::cout &lt;&lt; value;\r\n}\r\n\r\nint main()\r\n{\r\n    int sum{ 5 + 3 };\r\n    printValue(sum);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>We can write this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printValue(int value)\r\n{\r\n    std::cout &lt;&lt; value;\r\n}\r\n\r\nint main()\r\n{\r\n    printValue(5 + 3);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Note how much cleaner this keeps our code.  We don&#8217;t have to define and give a name to a variable.  And we don&#8217;t have to scan through the entire function to determine whether that variable is actually used elsewhere.  Because <code>5 + 3<\/code> is an expression, we know it is only used on that one line.<\/p>\n<p>Do note that this only works in cases where an rvalue expression is accepted.  In cases where an lvalue expression is required, we must have an object:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid addOne(int&amp; value) \/\/ pass by non-const references requires lvalue\r\n{\r\n    ++value;\r\n}\r\n\r\nint main()\r\n{\r\n    int sum { 5 + 3 };\r\n    addOne(sum);   \/\/ okay, sum is an lvalue\r\n\r\n    addOne(5 + 3); \/\/ compile error: not an lvalue\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Temporary class objects<\/p>\n<p>The same issue applies in the context of class types.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>We&#8217;ll use a class here, but everything in this lesson that uses list initialization is equally applicable to structs that are initialized using aggregate initialization.\n<\/p><\/div>\n<p>The following example is similar to the ones above, but uses program-defined class type <code>IntPair<\/code> instead of <code>int<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass IntPair\r\n{\r\nprivate:\r\n    int m_x{};\r\n    int m_y{};\r\n\r\npublic:\r\n    IntPair(int x, int y)\r\n        : m_x { x }, m_y { y }\r\n    {}\r\n\r\n    int x() const { return m_x; }\r\n    int y() const { return m_y; }\r\n};\r\n\r\nvoid print(IntPair p)\r\n{\r\n    std::cout &lt;&lt; \"(\" &lt;&lt; p.x() &lt;&lt; \", \" &lt;&lt; p.y() &lt;&lt; \")\\n\";        \r\n}\r\n        \r\nint main()\r\n{\r\n    \/\/ Case 1: Pass variable\r\n    IntPair p { 3, 4 };\r\n    print(p); \/\/ prints (3, 4)\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>In case 1, we&#8217;re instantiating variable <code>IntPair p<\/code> and then passing <code>p<\/code> to function <code>print()<\/code>.<\/p>\n<p>However, <code>p<\/code> is only used once, and function <code>print()<\/code> will accept rvalues, so there is really no reason to define a variable here.  So let&#8217;s get rid of <code>p<\/code>.<\/p>\n<p>We can do that by passing a temporary object instead of a named variable.  A <strong>temporary object<\/strong> (sometimes called an <strong>anonymous object<\/strong> or an <strong>unnamed object<\/strong>) is an object that has no name and exists only for the duration of a single expression.<\/p>\n<p>There are two common ways to create temporary class type objects:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass IntPair\r\n{\r\nprivate:\r\n    int m_x{};\r\n    int m_y{};\r\n\r\npublic:\r\n    IntPair(int x, int y)\r\n        : m_x { x }, m_y { y }\r\n    {}\r\n\r\n    int x() const { return m_x; }\r\n    int y() const{ return m_y; }\r\n};\r\n\r\nvoid print(IntPair p)\r\n{\r\n    std::cout &lt;&lt; \"(\" &lt;&lt; p.x() &lt;&lt; \", \" &lt;&lt; p.y() &lt;&lt; \")\\n\";        \r\n}\r\n        \r\nint main()\r\n{\r\n    \/\/ Case 1: Pass variable\r\n    IntPair p { 3, 4 };\r\n    print(p);\r\n\r\n    \/\/ Case 2: Construct temporary IntPair and pass to function\r\n    print(IntPair { 5, 6 } );\r\n\r\n    \/\/ Case 3: Implicitly convert { 7, 8 } to a temporary Intpair and pass to function\r\n    print( { 7, 8 } );\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>In case 2, we&#8217;re telling the compiler to construct an <code>IntPair<\/code> object, and initializing it with <code>{ 5, 6 }<\/code>.  Because this object has no name, it is a temporary.  The temporary object is then passed to parameter <code>p<\/code> of function <code>print()<\/code>.  When the function call returns, the temporary object is destroyed.<\/p>\n<p>In case 3, we&#8217;re also creating a temporary <code>IntPair<\/code> object to pass to function <code>print()<\/code>.  However, because we have not explicitly specified what type to construct, the compiler will deduce the necessary type (<code>IntPair<\/code>) from the function parameter, and then implicitly convert <code>{ 7, 8 }<\/code> to an <code>IntPair<\/code> object.<\/p>\n<p>To summarize:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">IntPair p { 1, 2 }; \/\/ create named object p initialized with { 1, 2 }\r\nIntPair { 1, 2 };   \/\/ create temporary object initialized with { 1, 2 }\r\n{ 1, 2 };           \/\/ compiler will try to convert { 1, 2 } to temporary object matching expected type (typically a parameter or return type)<\/code><\/pre>\n<p>We&#8217;ll discuss this last case in more detail in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/converting-constructors-and-the-explicit-keyword\/\">14.16 -- Converting constructors and the explicit keyword<\/a>.<\/p>\n<p>A few more examples:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::string { \"Hello\" }; \/\/ create a temporary std::string initialized with \"Hello\"\r\nstd::string {};          \/\/ create a temporary std::string using value initialization \/ default constructor<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Creating temporary objects via direct initialization <span class=\"cpp-section-pill cpp-section-optional\">Optional<\/span><\/p>\n<p>Since we can create temporary objects via direct-list-initialization, you might be wondering whether you can create temporary objects via the other initialization forms.  There is no syntax to create temporary objects using copy initialization.<\/p>\n<p>However, you can create temporary objects using direct initialization.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">Foo (1, 2); \/\/  temporary Foo, direct-initialized with (1, 2) (similar to `Foo { 1, 2 }`)<\/code><\/pre>\n<p>Putting aside the fact that it looks like a function call at first glance, this produces the same result as <code>Foo { 1, 2 }<\/code> (just with no narrowing conversion prevention).  Pretty normal right?<\/p>\n<p>We&#8217;ll now spend the remainder of this section showing you why you probably shouldn&#8217;t do this.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>This is mostly here for your reading pleasure, not as something you need to digest, memorize, and be able to explain.<\/p>\n<p>Even if you don&#8217;t have that much fun reading it, it might help you understand why list initialization is preferred in modern C++!\n<\/p><\/div>\n<p>Now let&#8217;s look at the case where we don&#8217;t have any arguments:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">Foo();     \/\/ temporary Foo, value-initialized (identical to `Foo {}`)<\/code><\/pre>\n<p>You probably didn&#8217;t expect that <code>Foo()<\/code> would create a value-initialized temporary just like <code>Foo {}<\/code> does.  And that&#8217;s probably because this syntax has a completely different meaning when used with a named variable!<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">Foo bar{}; \/\/ definition of variable bar, value-initialized\r\nFoo bar(); \/\/ declaration of function bar that has no parameters and returns a Foo (inconsistent with `Foo bar{}` and `Foo()`)<\/code><\/pre>\n<p>Ready to get real weird?!?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">Foo(1);    \/\/ Function-style cast of literal 1, returns temporary Foo (similar to `Foo { 1 }`)\r\nFoo(bar);  \/\/ Defines variable bar of type Foo (inconsistent with `Foo { bar }` and `Foo(1)`)<\/code><\/pre>\n<p>Wait, what?<\/p>\n<ul>\n<li>The version with literal <code>1<\/code> in parentheses behaves consistently with all the other versions of this syntax that create temporary objects.\n<\/li>\n<li>The version with identifier <code>bar<\/code> in parentheses defines a variable named <code>bar<\/code> (identical to <code>Foo bar;<\/code>).  If <code>bar<\/code> is already defined, this will cause a redefinition compile-error.\n<\/li>\n<\/ul>\n<p>The compiler knows that literals can&#8217;t be used as identifiers for variables, so it&#8217;s able to treat that case consistently with the others.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>If you&#8217;re wondering why <code>Foo(bar);<\/code> behaves identically to <code>Foo bar;<\/code>&#8230; <\/p>\n<p>One of the most common uses of parentheses is to group things.  For example, in mathematics: <code>(1 + 2) * 3<\/code> produces the result <code>9<\/code>, which is different than <code>1 + 2 * 3<\/code>, which produces the result <code>7<\/code>.  If we can do <code>(1 + 2) * 3<\/code>, there&#8217;s no reason we shouldn&#8217;t be able to do <code>(3) * 3<\/code>.<\/p>\n<p>For similar reasons, the declaration syntax allows parenthesis-based grouping, and those groups can have a single thing in them.  <code>Foo(bar)<\/code> is interpreted as a variable definition consisting of type <code>Foo<\/code> followed by a group that consists only of identifier <code>bar<\/code>.  It just looks funny to us, mainly because the parentheses don&#8217;t serve any useful purpose in this case.  But there&#8217;s no compelling reason to disallow doing so (as that would just make the syntax of the language that much more complicated).\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Let&#8217;s look at a slightly more complicated case.  Consider the statement <code>Foo * bar();<\/code>.  By using (or not using) parentheses, we can completely change the meaning of this statement:<\/p>\n<ul>\n<li><code>Foo * bar();<\/code> (with no additional parenthesis) groups the <code>*<\/code> with <code>Foo<\/code> by default.  <code>Foo* bar();<\/code> is the declaration of a function named <code>bar<\/code> that has no parameters and returns a <code>Foo*<\/code>.\n<\/li>\n<li><code>Foo (*bar)();<\/code> explicitly groups the <code>*<\/code> with <code>bar<\/code>.  This defines a function pointer named <code>bar<\/code> that holds the address of a function that takes no parameters and returns a <code>Foo<\/code>.\n<\/li>\n<li><code>Foo (* bar());<\/code> is the same as <code>Foo * bar();<\/code> -- the parentheses are superfluous in this case.\n<\/li>\n<\/ul>\n<p>Finally:<\/p>\n<ul>\n<li><code>(Foo *) bar();<\/code>.  You might expect this to be the same as <code>Foo* bar()<\/code>, but this is actually an expression statement that calls function <code>bar()<\/code>, C-style casts the return value to type <code>Foo*<\/code>, and then discards it!\n<\/li>\n<\/ul>\n<p>C++ is so weird sometimes.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Parentheses are complex because they are so overloaded, and used in the syntax of vastly different things.  This includes function calls, direct-initialization of objects, value initialization of temporaries, C-style casts, groupings of symbols\/identifiers, and variable definitions.  So when you see parentheses in some syntax&#8230; it&#8217;s not always obvious what you&#8217;re going to get!<\/p>\n<p>On the other hand, if we see curly braces, we know we&#8217;re dealing with objects.\n<\/p><\/div>\n<p>Okay, fun over.  Back to the boring stuff.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Temporary objects and return by value<\/p>\n<p>When a function returns by value, the object that is returned is a temporary object (initialized using the value or object identified in the return statement).<\/p>\n<p>Here are some examples:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass IntPair\r\n{\r\nprivate:\r\n    int m_x{};\r\n    int m_y{};\r\n\r\npublic:\r\n    IntPair(int x, int y)\r\n        : m_x { x }, m_y { y }\r\n    {}\r\n\r\n    int x() const { return m_x; }\r\n    int y() const { return m_y; }\r\n};\r\n\r\nvoid print(IntPair p)\r\n{\r\n    std::cout &lt;&lt; \"(\" &lt;&lt; p.x() &lt;&lt; \", \" &lt;&lt; p.y() &lt;&lt; \")\\n\";        \r\n}\r\n\r\n\/\/ Case 1: Create named variable and return\r\nIntPair ret1()\r\n{\r\n    IntPair p { 3, 4 };\r\n    return p; \/\/ returns temporary object (initialized using p)\r\n}\r\n\r\n\/\/ Case 2: Create temporary IntPair and return\r\nIntPair ret2()\r\n{\r\n    return IntPair { 5, 6 }; \/\/ returns temporary object (initialized using another temporary object)\r\n}\r\n\r\n\/\/ Case 3: implicitly convert { 7, 8 } to IntPair and return\r\nIntPair ret3()\r\n{\r\n    return { 7, 8 }; \/\/ returns temporary object (initialized using another temporary object)\r\n}\r\n     \r\nint main()\r\n{\r\n    print(ret1());\r\n    print(ret2());\r\n    print(ret3());\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In case 1, when we <code>return p<\/code>, a temporary object is created and initialized using <code>p<\/code>.<\/p>\n<p>The cases in this example are analogous to the cases in the prior example.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A few notes<\/p>\n<p>First, just as in the case of an <code>int<\/code>, when used in an expression, a temporary class object is an rvalue.  Thus, such objects can only be used where rvalue expressions are accepted.<\/p>\n<p>Second, temporary objects are created at the point of definition, and destroyed at the end of the full expression in which they are defined .  A full expression is an expression that is not a subexpression.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><code>static_cast<\/code> vs explicit instantiation of a temporary object<\/p>\n<p>In cases where we need to convert a value from one type to another but narrowing conversions aren&#8217;t involved, we often have the option to use either <code>static_cast<\/code> or explicit instantiation of a temporary object.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    char c { 'a' };\r\n\r\n    std::cout &lt;&lt; static_cast&lt;int&gt;( c ) &lt;&lt; '\\n'; \/\/ static_cast returns a temporary int direct-initialized with value of c\r\n    std::cout &lt;&lt; int { c } &lt;&lt; '\\n';             \/\/ explicitly creates a temporary int list-initialized with value c\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><code>static_cast&lt;int&gt;(c)<\/code> returns a temporary <code>int<\/code> that is direct-initialized with the value of <code>c<\/code>.  <code>int { c }<\/code> creates a temporary <code>int<\/code> that is list-initialized with the value of <code>c<\/code>.  Either way, we get a temporary int initialized with the value of <code>c<\/code>, which is what we want.<\/p>\n<p>Let&#8217;s show a slightly more complex example:<\/p>\n<p>printString.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\nvoid printString(const std::string &amp;s)\r\n{\r\n    std::cout &lt;&lt; s &lt;&lt; '\\n';\r\n}<\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"printString.h\"\r\n#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nint main()\r\n{\r\n    std::string_view sv { \"Hello\" };\r\n\r\n    \/\/ We want to print sv using the printString() function\r\n    \r\n\/\/    printString(sv); \/\/ compile error: a std::string_view won't implicitly convert to a std::string\r\n\r\n    printString( static_cast&lt;std::string&gt;(sv) ); \/\/ Case 1: static_cast returns a temporary std::string direct-initialized with sv\r\n    printString( std::string { sv } );           \/\/ Case 2: explicitly creates a temporary std::string list-initialized with sv\r\n    printString( std::string ( sv ) );           \/\/ Case 3: C-style cast returns temporary std::string direct-initialized with sv (avoid this one!)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Let&#8217;s say the code in header file <code>printString.h<\/code> isn&#8217;t code we can modify (e.g. because it&#8217;s distributed with some 3rd party library we&#8217;re using, and has been written to be compatible with C++11, which doesn&#8217;t support <code>std::string_view<\/code>).  So how do we call <code>printString()<\/code> with <code>sv<\/code>?  Because a <code>std::string_view<\/code> won&#8217;t implicitly convert to a <code>std::string<\/code> (for efficiency reasons), we can&#8217;t just use <code>sv<\/code> as an argument.  We must use some explicit form of conversion.<\/p>\n<p>In case 1, <code>static_cast&lt;std::string&gt;(sv)<\/code> invokes the static_cast operator to cast <code>sv<\/code> to a <code>std::string<\/code>.  This returns a temporary <code>std::string<\/code> that has been direct-initialized using <code>sv<\/code>, which is then used as the argument for the function call.<\/p>\n<p>In case 2, <code>std::string { sv }<\/code> creates a temporary <code>std::string<\/code> that is list-initialized using <code>sv<\/code>.  Since this is an explicit construction, the conversion is allowed.  This temporary is then used as the argument for the function call.<\/p>\n<p>In case 3, <code>std::string ( sv )<\/code> use a C-style cast to cast <code>sv<\/code> to a <code>std::string<\/code>.  Although this works here, C-style casting can be dangerous in general and should be avoided.  Notice how similar this looks to the prior case!<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>As a quick rule of thumb: Prefer <code>static_cast<\/code> when converting to a fundamental type, and a list-initialized temporary when converting to a class type.<\/p>\n<p>Prefer <code>static_cast<\/code> when to create a temporary object when any of the following are true:<\/p>\n<ul>\n<li>We need to performing a narrowing conversion.\n<\/li>\n<li>We want to make it really obvious that we&#8217;re converting to a type that will result in some different behavior (e.g. a <code>char<\/code> to an <code>int<\/code>).\n<\/li>\n<li>We want to use direct-initialization for some reason (e.g. to avoid list constructors taking precedence).\n<\/li>\n<\/ul>\n<p>Prefer creating a new object (using list initialization) to create a temporary object when any of the following are true:<\/p>\n<ul>\n<li>We want to use list-initialization (e.g. for the protection against narrowing conversions, or because we need to invoke a list constructor).\n<\/li>\n<li>We need to provide additional arguments to a constructor to facilitate the conversion.\n<\/li>\n<\/ul>\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover list constructors in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdvector-and-list-constructors\/\">16.2 -- Introduction to std::vector and list constructors<\/a>.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-the-copy-constructor\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.14<\/span>Introduction to the copy constructor\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/delegating-constructors\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.12<\/span>Delegating constructors\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Consider the following example: #include &lt;iostream&gt; int add(int x, int y) { int sum{ x + y }; \/\/ stores x + y in a variable return sum; \/\/ returns value of that variable } int main() { std::cout &lt;&lt; add(5, 3) &lt;&lt; &#8216;\\n&#8217;; return 0; } In the add() &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/164"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=164"}],"version-history":[{"count":31,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/164\/revisions"}],"predecessor-version":[{"id":18005,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/164\/revisions\/18005"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=164"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=164"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=164"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}