{"id":83,"date":"2007-06-27T17:48:43","date_gmt":"2007-06-28T01:48:43","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/62-arrays-part-ii\/"},"modified":"2024-04-20T14:39:32","modified_gmt":"2024-04-20T21:39:32","slug":"arrays-part-ii","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/arrays-part-ii\/","title":{"rendered":"11.2 &#8212; Arrays (Part II)"},"content":{"rendered":"<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>This lesson has been deprecated and replaced with the updated lessons in the latter half of chapter 17 (starting with lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-c-style-arrays\/\">17.7 -- Introduction to C-style arrays<\/a>).\n<\/p><\/div>\n<p>This lesson continues the discussion of arrays that began in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-c-style-arrays\/\">17.7 -- Introduction to C-style arrays<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Initializing fixed arrays<\/p>\n<p>Array elements are treated just like normal variables, and as such, they are not initialized when created.<\/p>\n<p>One way to &#8220;initialize&#8221; an array is to do it element by element:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int prime[5]; \/\/ hold the first 5 prime numbers\r\nprime[0] = 2;\r\nprime[1] = 3;\r\nprime[2] = 5;\r\nprime[3] = 7;\r\nprime[4] = 11;<\/code><\/pre>\n<p>However, this is a pain, especially as the array gets larger. Furthermore, it&#8217;s not initialization, but assignment. Assignments don&#8217;t work if the array is <code>const<\/code>.<\/p>\n<p>Fortunately, C++ provides a more convenient way to initialize entire arrays via use of an <strong>initializer list<\/strong>.  The following example initializes the array with the same values as the one above:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int prime[5]{ 2, 3, 5, 7, 11 }; \/\/ use initializer list to initialize the fixed array<\/code><\/pre>\n<p>If there are more initializers in the list than the array can hold, the compiler will generate an error.<\/p>\n<p>However, if there are less initializers in the list than the array can hold, the remaining elements are initialized to 0 (or whatever value 0 converts to for a non-integral fundamental type -- e.g. 0.0 for double).  This is called <strong>zero initialization<\/strong>.<\/p>\n<p>The following example shows this in action:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int array[5]{ 7, 4, 5 }; \/\/ only initialize first 3 elements\r\n\r\n    std::cout &lt;&lt; array[0] &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; array[1] &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; array[2] &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; array[3] &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; array[4] &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\n7\r\n4\r\n5\r\n0\r\n0\r\n<\/pre>\n<p>Consequently, to initialize all the elements of an array to 0, you can do this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int array[5]{};          \/\/ Initialize all elements to 0\r\ndouble array[5] {};      \/\/ Initialize all elements to 0.0\r\nstd::string array[5] {}; \/\/ Initialize all elements to an empty string<\/code><\/pre>\n<p>If the initializer list is omitted, the elements are uninitialized, unless they are a class-type that self-initializes.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int array[5];         \/\/ uninitialized (since int doesn't self-initialize)\r\ndouble array[5];      \/\/ uninitialized (since double doesn't self-initialize)\r\nstd::string array[5]; \/\/ Initialize all elements to an empty string<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Explicitly initialize your arrays (even when the element type is self-initializing).\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Omitted length<\/p>\n<p>If you are initializing a fixed array of elements using an initializer list, the compiler can figure out the length of the array for you, and you can omit explicitly declaring the length of the array.<\/p>\n<p>The following two lines are equivalent:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int array[5]{ 0, 1, 2, 3, 4 }; \/\/ explicitly define the length of the array\r\nint array[]{ 0, 1, 2, 3, 4 }; \/\/ let the initializer list set length of the array<\/code><\/pre>\n<p>This not only saves typing, it also means you don&#8217;t have to update the array length if you add or remove elements later.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Arrays and enums<\/p>\n<p>One of the big documentation problems with arrays is that integer indices do not provide any information to the programmer about the meaning of the index.  Consider a class of 5 students:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">constexpr int numberOfStudents{5};\r\nint testScores[numberOfStudents]{};\r\ntestScores[2] = 76;<\/code><\/pre>\n<p>Who is represented by testScores[2]?  It&#8217;s not clear.<\/p>\n<p>This can be solved by setting up an enumeration where one enumerator maps to each of the possible array indices:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">enum StudentNames\r\n{\r\n    kenny, \/\/ 0\r\n    kyle, \/\/ 1\r\n    stan, \/\/ 2\r\n    butters, \/\/ 3\r\n    cartman, \/\/ 4\r\n    max_students \/\/ 5\r\n};\r\n\r\nint main()\r\n{\r\n    int testScores[max_students]{}; \/\/ allocate 5 integers\r\n    testScores[stan] = 76;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this way, it&#8217;s much clearer what each of the array elements represents.  Note that an extra enumerator named max_students has been added.  This enumerator is used during the array declaration to ensure the array has the proper length (as the array length should be one greater than the largest index).  This is useful both for documentation purposes, and because the array will automatically be resized if another enumerator is added:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">enum StudentNames\r\n{\r\n    kenny, \/\/ 0\r\n    kyle, \/\/ 1\r\n    stan, \/\/ 2\r\n    butters, \/\/ 3\r\n    cartman, \/\/ 4\r\n    wendy, \/\/ 5\r\n    max_students \/\/ 6\r\n};\r\n\r\nint main()\r\n{\r\n    int testScores[max_students]{}; \/\/ allocate 6 integers\r\n    testScores[stan] = 76; \/\/ still works\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Note that this &#8220;trick&#8221; only works if you do not change the enumerator values manually!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Arrays and enum classes<\/p>\n<p>Enum classes don&#8217;t have an implicit conversion to integer, so if you try the following:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">enum class StudentNames\r\n{\r\n    kenny, \/\/ 0\r\n    kyle, \/\/ 1\r\n    stan, \/\/ 2\r\n    butters, \/\/ 3\r\n    cartman, \/\/ 4\r\n    wendy, \/\/ 5\r\n    max_students \/\/ 6\r\n};\r\n\r\nint main()\r\n{\r\n    int testScores[StudentNames::max_students]{}; \/\/ allocate 6 integers\r\n    testScores[StudentNames::stan] = 76;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>You&#8217;ll get a compiler error.  This can be addressed by using a static_cast to convert the enumerator to an integer:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int testScores[static_cast&lt;int&gt;(StudentNames::max_students)]{}; \/\/ allocate 6 integers\r\n    testScores[static_cast&lt;int&gt;(StudentNames::stan)] = 76;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, doing this is somewhat of a pain, so it might be better to use a standard enum inside of a namespace:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">namespace StudentNames\r\n{\r\n    enum StudentNames\r\n    {\r\n        kenny, \/\/ 0\r\n        kyle, \/\/ 1\r\n        stan, \/\/ 2\r\n        butters, \/\/ 3\r\n        cartman, \/\/ 4\r\n        wendy, \/\/ 5\r\n        max_students \/\/ 6\r\n    };\r\n}\r\n\r\nint main()\r\n{\r\n    int testScores[StudentNames::max_students]{}; \/\/ allocate 6 integers\r\n    testScores[StudentNames::stan] = 76;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Passing arrays to functions<\/p>\n<p>Although passing an array to a function at first glance looks just like passing a normal variable, underneath the hood, C++ treats arrays differently.<\/p>\n<p>When a normal variable is passed by value, C++ copies the value of the argument into the function parameter.  Because the parameter is a copy, changing the value of the parameter does not change the value of the original argument.<\/p>\n<p>However, because copying large arrays can be very expensive, C++ does <em>not<\/em> copy an array when an array is passed into a function.  Instead, the <em>actual<\/em> array is passed.  This has the side effect of allowing functions to directly change the value of array elements!<\/p>\n<p>The following example illustrates this concept:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid passValue(int value) \/\/ value is a copy of the argument\r\n{\r\n    value = 99; \/\/ so changing it here won't change the value of the argument\r\n}\r\n\r\nvoid passArray(int prime[5]) \/\/ prime is the actual array\r\n{\r\n    prime[0] = 11; \/\/ so changing it here will change the original argument!\r\n    prime[1] = 7;\r\n    prime[2] = 5;\r\n    prime[3] = 3;\r\n    prime[4] = 2;\r\n}\r\n\r\nint main()\r\n{\r\n    int value{ 1 };\r\n    std::cout &lt;&lt; \"before passValue: \" &lt;&lt; value &lt;&lt; '\\n';\r\n    passValue(value);\r\n    std::cout &lt;&lt; \"after passValue: \" &lt;&lt; value &lt;&lt; '\\n';\r\n\r\n    int prime[]{ 2, 3, 5, 7, 11 }; \/\/ type deduced as int prime[5]\r\n    std::cout &lt;&lt; \"before passArray: \" &lt;&lt; prime[0] &lt;&lt; \" \" &lt;&lt; prime[1] &lt;&lt; \" \" &lt;&lt; prime[2] &lt;&lt; \" \" &lt;&lt; prime[3] &lt;&lt; \" \" &lt;&lt; prime[4] &lt;&lt; '\\n';\r\n    passArray(prime);\r\n    std::cout &lt;&lt; \"after passArray: \" &lt;&lt; prime[0] &lt;&lt; \" \" &lt;&lt; prime[1] &lt;&lt; \" \" &lt;&lt; prime[2] &lt;&lt; \" \" &lt;&lt; prime[3] &lt;&lt; \" \" &lt;&lt; prime[4] &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<pre>\r\nbefore passValue: 1\r\nafter passValue: 1\r\nbefore passArray: 2 3 5 7 11\r\nafter passArray: 11 7 5 3 2\r\n<\/pre>\n<p>In the above example, value is not changed in main() because the parameter value in function passValue() was a copy of variable value in function main(), not the actual variable.  However, because the parameter array in function passArray() is the actual array, passArray() is able to directly change the value of the elements!<\/p>\n<p>Why this happens is related to the way arrays are implemented in C++, a topic we\u2019ll revisit in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/c-style-array-decay\/\">17.8 -- C-style array decay<\/a>. For now, you can consider this as a quirk of the language.<\/p>\n<p>As a side note, if you want to ensure a function does not modify the array elements passed into it, you can make the array const:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ even though prime is the actual array, within this function it should be treated as a constant\r\nvoid passArray(const int prime[5])\r\n{\r\n    \/\/ so each of these lines will cause a compile error!\r\n    prime[0] = 11;\r\n    prime[1] = 7;\r\n    prime[2] = 5;\r\n    prime[3] = 3;\r\n    prime[4] = 2;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Determining the length of an array<\/p>\n<p>The std::size() function from the &lt;iterator> header can be used to determine the length of arrays.<\/p>\n<p>Here&#8217;s an example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;iterator&gt; \/\/ for std::size\r\n\r\nint main()\r\n{\r\n    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };\r\n    std::cout &lt;&lt; \"The array has: \" &lt;&lt; std::size(array) &lt;&lt; \" elements\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\nThe array has: 8 elements\r\n<\/pre>\n<p>Note that due to the way C++ passes arrays to functions, this will <em>not<\/em> work for arrays that have been passed to functions!<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;iterator&gt;\r\n\r\nvoid printSize(int array[])\r\n{\r\n    std::cout &lt;&lt; std::size(array) &lt;&lt; '\\n'; \/\/ Error\r\n}\r\n\r\nint main()\r\n{\r\n    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };\r\n    std::cout &lt;&lt; std::size(array) &lt;&lt; '\\n'; \/\/ will print the length of the array\r\n    printSize(array);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>std::size() will work with other kinds of objects (such as std::array and std::vector), and it will cause a compiler error if you try to use it on a fixed array that has been passed to a function!  Note that std::size returns an unsigned value.  If you need a signed value, you can either cast the result or, since C++20, use std::ssize() (stands for signed size).<\/p>\n<p>std::size() was added in C++17.  If you&#8217;re using C++11 or C++14, you can use this function instead:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T, std::size_t N&gt;\r\nconstexpr std::size_t length(const T(&amp;)[N]) noexcept\r\n{\r\n\treturn N;\r\n}\r\n\r\nint main() {\r\n\r\n\tint array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };\r\n\tstd::cout &lt;&lt; \"The array has: \" &lt;&lt; length(array) &lt;&lt; \" elements\\n\";\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In older code, you may see the length calculated using the sizeof operator instead. sizeof isn&#8217;t as easy to use as std::size() and there are a few things you have to watch out for.<\/p>\n<p>The sizeof operator can be used on arrays, and it will return the total size of the array (array length multiplied by element size).  <\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };\r\n    std::cout &lt;&lt; sizeof(array) &lt;&lt; '\\n'; \/\/ will print the size of the array multiplied by the size of an int\r\n    std::cout &lt;&lt; sizeof(int) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>On a machine with 4 byte integers and 8 byte pointers, this printed:<\/p>\n<pre>\r\n32\r\n4\r\n<\/pre>\n<p>(You may get a different result if the size of your types are different).<\/p>\n<p>One neat trick: we can determine the length of a fixed array by dividing the size of the entire array by the size of an array element:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };\r\n    std::cout &lt;&lt; \"The array has: \" &lt;&lt; sizeof(array) \/ sizeof(array[0]) &lt;&lt; \" elements\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This printed<\/p>\n<pre>\r\nThe array has: 8 elements\r\n<\/pre>\n<p>How does this work?  First, note that the size of the entire array is equal to the array&#8217;s length multiplied by the size of an element.  Put more compactly: array size = array length * element size.<\/p>\n<p>Using algebra, we can rearrange this equation: array length = array size \/ element size.  sizeof(array) is the array size, and sizeof(array[0]) is the element size, so our equation becomes array length = sizeof(array) \/ sizeof(array[0]).  Sometimes <code>*array<\/code> is used instead of <code>array[0]<\/code> (we discuss what <code>*array<\/code> is in <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pointer-arithmetic-and-subscripting\/\">17.9 -- Pointer arithmetic and subscripting<\/a>).<\/p>\n<p>Note that this will only work if the array is a fixed-length array, and you&#8217;re doing this trick in the same function that array is declared in (we&#8217;ll talk more about why this restriction exists in a future lesson in this chapter).<\/p>\n<p>When sizeof is used on an array that has been passed to a function, it doesn&#8217;t error out like std::size() does. Instead, it returns the size of a pointer.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printSize(int array[])\r\n{\r\n    std::cout &lt;&lt; sizeof(array) \/ sizeof(array[0]) &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    int array[]{ 1, 1, 2, 3, 5, 8, 13, 21 };\r\n    std::cout &lt;&lt; sizeof(array) \/ sizeof(array[0]) &lt;&lt; '\\n';\r\n    printSize(array);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Again assuming 8 byte pointers and 4 byte integers, this prints<\/p>\n<pre>\r\n8\r\n2\r\n<\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>A properly configured compiler should print a warning if you try to use sizeof() on an array that was passed to a function.\n<\/p><\/div>\n<p>The calculation in main() was correct, but the sizeof() in printSize() returned 8 (the size of a pointer), and 8 divided by 4 is 2.<\/p>\n<p>For this reason, be careful about using sizeof() on arrays!<\/p>\n<p>Note: In common usage, the terms &#8220;array size&#8221; and &#8220;array length&#8221; are both most often used to refer to the array&#8217;s length (the size of the array isn&#8217;t useful in most cases, outside of the trick we&#8217;ve shown you above).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Indexing an array out of range<\/p>\n<p>Remember that an array of length N has array elements 0 through N-1.  So what happens if you try to access an array with a subscript outside of that range?<\/p>\n<p>Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int prime[5]{}; \/\/ hold the first 5 prime numbers\r\n    prime[5] = 13;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this program, our array is of length 5, but we&#8217;re trying to write a prime number into the 6th element (index 5).<\/p>\n<p>C++ does <em>not<\/em> do any checking to make sure that your indices are valid for the length of your array.  So in the above example, the value of 13 will be inserted into memory where the 6th element would have been had it existed.  When this happens, you will get undefined behavior -- for example, this could overwrite the value of another variable, or cause your program to crash.<\/p>\n<p>Although it happens less often, C++ will also let you use a negative index, with similarly undesirable results.<\/p>\n<div class=\"cpp-note cpp-lightpurplebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Rule<\/p>\n<p>When using arrays, ensure that your indices are valid for the range of your array!\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz<\/p>\n<ol start=\"1\">\n<li>Declare an array to hold the high temperature (to the nearest tenth of a degree) for each day of a year (assume 365 days in a year).  Initialize the array with a value of 0.0 for each day.\n<\/li>\n<li>Set up an enum with the names of the following animals: chicken, dog, cat, elephant, duck, and snake.  Put the enum in a namespace.  Define an array with an element for each of these animals, and use an initializer list to initialize each element to hold the number of legs that animal has.\n<\/li>\n<\/ol>\n<p>Write a main function that prints the number of legs an elephant has, using the enumerator.<\/p>\n<p><strong>Quiz answers<\/strong><\/p>\n<ol start=\"1\">\n<li><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/li>\n<\/ol>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">double temperature[365] { };<\/code><\/pre>\n<\/div>\n<ol start=\"2\">\n<li><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/li>\n<\/ol>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;iterator&gt; \/\/ for std::size\r\n\r\nnamespace Animals\r\n{\r\n    enum Animals \/\/ The name of this enum could be omitted since it isn't used anywhere\r\n    {\r\n        chicken,\r\n        dog,\r\n        cat,\r\n        elephant,\r\n        duck,\r\n        snake,\r\n        max_animals\r\n    };\r\n}\r\n\r\nint main()\r\n{\r\n    int legs[]{ 2, 4, 4, 4, 2, 0 };\r\n    static_assert(std::size(legs) == Animals::max_animals);\r\n\r\n    std::cout &lt;&lt; \"An elephant has \" &lt;&lt; legs[Animals::elephant] &lt;&lt; \" legs.\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<font color=\"FF0000\">%Missing lookup for lesson id 83%<\/font>\n","protected":false},"excerpt":{"rendered":"<p>Warning This lesson has been deprecated and replaced with the updated lessons in the latter half of chapter 17 (starting with lesson ). This lesson continues the discussion of arrays that began in lesson . Initializing fixed arrays Array elements are treated just like normal variables, and as such, they &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/83"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=83"}],"version-history":[{"count":60,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/83\/revisions"}],"predecessor-version":[{"id":16960,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/83\/revisions\/16960"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=83"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=83"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=83"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}