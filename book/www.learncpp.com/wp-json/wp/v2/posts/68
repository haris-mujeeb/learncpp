{"id":68,"date":"2007-06-19T20:24:48","date_gmt":"2007-06-20T04:24:48","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/45-enumerated-types\/"},"modified":"2024-10-28T16:43:38","modified_gmt":"2024-10-28T23:43:38","slug":"unscoped-enumerations","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/unscoped-enumerations\/","title":{"rendered":"13.2 &#8212; Unscoped enumerations"},"content":{"rendered":"<p>C++ contains many useful fundamental and compound data types (which we introduced in lessons <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-fundamental-data-types\/\">4.1 -- Introduction to fundamental data types<\/a> and <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-compound-data-types\/\">12.1 -- Introduction to compound data types<\/a>).  But these types aren&#8217;t always sufficient for the kinds of things we want to do.<\/p>\n<p>For example, let&#8217;s say you&#8217;re writing a program that needs to keep track of whether an apple is red, yellow, or green, or what color a shirt is (from a preset list of colors).  If only fundamental types were available, how might you do this?<\/p>\n<p>You might store the color as an integer value, using some kind of implicit mapping (0 = red , 1 = green, 2 = blue):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int appleColor{ 0 }; \/\/ my apple is red\r\n    int shirtColor{ 1 }; \/\/ my shirt is green\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>But this isn&#8217;t at all intuitive, and we&#8217;ve already discussed why magic numbers are bad (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/literals\/\">5.2 -- Literals<\/a>).  We can get rid of the magic numbers by using symbolic constants:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">constexpr int red{ 0 };\r\nconstexpr int green{ 1 };\r\nconstexpr int blue{ 2 };\r\n\r\nint main()\r\n{\r\n    int appleColor{ red };\r\n    int shirtColor{ green };\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>While this is a bit better for reading, the programmer is still left to deduce that <code>appleColor<\/code> and <code>shirtColor<\/code> (which are of type <code>int<\/code>) are meant to hold one of the values defined in the set of color symbolic constants (which are likely defined elsewhere, probably in a separate file).<\/p>\n<p>We can make this program a little more clear by using a type alias:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">using Color = int; \/\/ define a type alias named Color\r\n\r\n\/\/ The following color values should be used for a Color\r\nconstexpr Color red{ 0 };\r\nconstexpr Color green{ 1 };\r\nconstexpr Color blue{ 2 };\r\n\r\nint main()\r\n{\r\n    Color appleColor{ red };\r\n    Color shirtColor{ green };\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>We&#8217;re getting closer.  Someone reading this code still has to understand that these color symbolic constants are meant to be used with variables of type <code>Color<\/code>, but at least the type has a unique name now so someone searching for <code>Color<\/code> would be able to find the set of associated symbolic constants.<\/p>\n<p>However, because <code>Color<\/code> is just an alias for an <code>int<\/code>, we still have the problem that nothing enforces proper usage of these color symbolic constants.  We can still do something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">Color eyeColor{ 8 }; \/\/ syntactically valid, semantically meaningless<\/code><\/pre>\n<p>Also, if we debug any of these variables in our debugger, we&#8217;ll only see the integer value of the color (e.g. <code>0<\/code>), not the symbolic meaning (<code>red<\/code>), which can make it harder to tell if our program is correct.<\/p>\n<p>Fortunately, we can do better.<\/p>\n<p>As inspiration, consider the <code>bool<\/code> type.  What makes <code>bool<\/code> particularly interesting is that it only has two defined values: <code>true<\/code> and <code>false<\/code>.  We can use <code>true<\/code> or <code>false<\/code> directly (as literals), or we can instantiate a <code>bool<\/code> object and have it hold either one of those values.  Additionally, the compiler is able to differentiate <code>bool<\/code> from other types.  This means we can overload functions, and customize how those functions behave when passed a <code>bool<\/code> value.<\/p>\n<p>If we had the ability to define our own custom types, where <em>we<\/em> could define the set of named values associated with that type, then we would have the perfect tool to elegantly solve the challenge above&#8230;<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Enumerations<\/p>\n<p>An <strong>enumeration<\/strong> (also called an <strong>enumerated type<\/strong> or an <strong>enum<\/strong>) is a compound data type whose values are restricted to a set of named symbolic constants (called <strong>enumerators<\/strong>).<\/p>\n<p>C++ supports two kinds of enumerations: unscoped enumerations (which we&#8217;ll cover now) and scoped enumerations (which we&#8217;ll cover later in this chapter).<\/p>\n<p>Because enumerations are program-defined types <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-program-defined-user-defined-types\/\">13.1 -- Introduction to program-defined (user-defined) types<\/a>, each enumeration needs to be fully defined before we can use it (a forward declaration is not sufficient).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Unscoped enumerations<\/p>\n<p>Unscoped enumerations are defined via the <code>enum<\/code> keyword.<\/p>\n<p>Enumerated types are best taught by example, so let&#8217;s define an unscoped enumeration that can hold some color values.  We&#8217;ll explain how it all works below.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Define a new unscoped enumeration named Color\r\nenum Color\r\n{\r\n    \/\/ Here are the enumerators\r\n    \/\/ These symbolic constants define all the possible values this type can hold\r\n    \/\/ Each enumerator is separated by a comma, not a semicolon\r\n    red,\r\n    green,\r\n    blue, \/\/ trailing comma optional but recommended\r\n}; \/\/ the enum definition must end with a semicolon\r\n\r\nint main()\r\n{\r\n    \/\/ Define a few variables of enumerated type Color\r\n    Color apple { red };   \/\/ my apple is red\r\n    Color shirt { green }; \/\/ my shirt is green\r\n    Color cup { blue };    \/\/ my cup is blue\r\n\r\n    Color socks { white }; \/\/ error: white is not an enumerator of Color\r\n    Color hat { 2 };       \/\/ error: 2 is not an enumerator of Color\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>We start our example by using the <code>enum<\/code> keyword to tell the compiler that we are defining an unscoped enumeration, which we&#8217;ve named <code>Color<\/code>.<\/p>\n<p>Inside a pair of curly braces, we define the enumerators for the <code>Color<\/code> type: <code>red<\/code>, <code>green<\/code>, and <code>blue<\/code>.  These enumerators define the specific values that type <code>Color<\/code> is restricted to.  Each enumerator must be separated by a comma (not a semicolon) -- a trailing comma after the last enumerator is optional but recommended for consistency.<\/p>\n<p>It is most common to define one enumerator per line, but in simple cases (where there are a small number of enumerators and no comments are needed), they may all be defined on a single line.<\/p>\n<p>The type definition for <code>Color<\/code> ends with a semicolon.  We&#8217;ve now fully defined what enumerated type <code>Color<\/code> is!  <\/p>\n<p>Inside <code>main()<\/code>, we instantiate three variables of type <code>Color<\/code>: <code>apple<\/code> is initialized with the color <code>red<\/code>, <code>shirt<\/code> is initialized with the color <code>green<\/code>, and <code>cup<\/code> is initialized with the color <code>blue<\/code>.  Memory is allocated for each of these objects.  Note that the initializer for an enumerated type must be one of the defined enumerators for that type.  The variables <code>socks<\/code> and <code>hat<\/code> cause compile errors because the initializers <code>white<\/code> and <code>2<\/code> are not enumerators of <code>Color<\/code>.<\/p>\n<p>Enumerators are implicitly constexpr.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">A reminder<\/p>\n<p>To quickly recap on nomenclature:<\/p>\n<ul>\n<li>An <em>enumeration<\/em> or <em>enumerated type<\/em> is the program-defined type itself (e.g. <code>Color<\/code>).\n<\/li>\n<li>An <em>enumerator<\/em> is a specific named value belonging to the enumeration (e.g. <code>red<\/code>).\n<\/li>\n<\/ul>\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Naming enumerations and enumerators<\/p>\n<p>By convention, the names of enumerated types start with a capital letter (as do all program-defined types).<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Enumerations don&#8217;t have to be named, but unnamed enumerations should be avoided in modern C++.\n<\/p><\/div>\n<p>Enumerators must be given names.  Unfortunately, there is no common naming convention for enumerator names.  Common choices include starting with lower case (e.g. red), starting with caps (Red), all caps (RED), all caps with a prefix (COLOR_RED), or prefixed with a &#8220;k&#8221; and intercapped (kColorRed).  <\/p>\n<p>Modern C++ guidelines typically recommend avoiding the all caps naming conventions, as all caps is typically used for preprocessor macros and may conflict.  We recommend also avoiding the conventions starting with a capital letter, as names beginning with a capital letter are typically reserved for program-defined types.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Name your enumerated types starting with a capital letter.  Name your enumerators starting with a lower case letter.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Enumerated types are distinct types<\/p>\n<p>Each enumerated type you create is considered to be a <strong>distinct type<\/strong>, meaning the compiler can distinguish it from other types (unlike typedefs or type aliases, which are considered non-distinct from the types they are aliasing).<\/p>\n<p>Because enumerated types are distinct, enumerators defined as part of one enumerated type can&#8217;t be used with objects of another enumerated type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">enum Pet\r\n{\r\n    cat,\r\n    dog,\r\n    pig,\r\n    whale,\r\n};\r\n\r\nenum Color\r\n{\r\n    black,\r\n    red,\r\n    blue,\r\n};\r\n\r\nint main()\r\n{\r\n    Pet myPet { black }; \/\/ compile error: black is not an enumerator of Pet\r\n    Color shirt { pig }; \/\/ compile error: pig is not an enumerator of Color\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>You probably didn&#8217;t want a pig shirt anyway.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Putting enumerations to use<\/p>\n<p>Because enumerators are descriptive, they are useful for enhancing code documentation and readability.  Enumerated types are best used when you have a smallish set of related constants, and objects only need to hold one of those values at a time.  <\/p>\n<p>Commonly defined enumerations include days of the week, the cardinal directions, and the suits in a deck of cards:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">enum DaysOfWeek\r\n{\r\n    sunday,\r\n    monday,\r\n    tuesday,\r\n    wednesday,\r\n    thursday,\r\n    friday,\r\n    saturday,\r\n};\r\n\r\nenum CardinalDirections\r\n{\r\n    north,\r\n    east,\r\n    south,\r\n    west,\r\n};\r\n\r\nenum CardSuits\r\n{\r\n    clubs,\r\n    diamonds,\r\n    hearts,\r\n    spades,\r\n};<\/code><\/pre>\n<p>Sometimes functions will return a status code to the caller to indicate whether the function executed successfully or encountered an error.  Traditionally, small negative numbers were used to represent different possible error codes.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int readFileContents()\r\n{\r\n    if (!openFile())\r\n        return -1;\r\n    if (!readFile())\r\n        return -2;\r\n    if (!parseFile())\r\n        return -3;\r\n\r\n    return 0; \/\/ success\r\n}<\/code><\/pre>\n<p>However, using magic numbers like this isn&#8217;t very descriptive.  A better method would be to use an enumerated type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">enum FileReadResult\r\n{\r\n    readResultSuccess,\r\n    readResultErrorFileOpen,\r\n    readResultErrorFileRead,\r\n    readResultErrorFileParse,\r\n};\r\n\r\nFileReadResult readFileContents()\r\n{\r\n    if (!openFile())\r\n        return readResultErrorFileOpen;\r\n    if (!readFile())\r\n        return readResultErrorFileRead;\r\n    if (!parseFile())\r\n        return readResultErrorFileParse;\r\n\r\n    return readResultSuccess;\r\n}<\/code><\/pre>\n<p>Then the caller can test the function&#8217;s return value against the appropriate enumerator, which is easier to understand than testing the return result for a specific integer value.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">if (readFileContents() == readResultSuccess)\r\n{\r\n    \/\/ do something\r\n}\r\nelse\r\n{\r\n    \/\/ print error message\r\n}<\/code><\/pre>\n<p>Enumerated types can also be put to good use in games, to identify different types of items, or monsters, or terrain.  Basically, anything that is a small set of related objects.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">enum ItemType\r\n{\r\n\tsword,\r\n\ttorch,\r\n\tpotion,\r\n};\r\n\r\nint main()\r\n{\r\n\tItemType holding{ torch };\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Enumerated types can also make for useful function parameters when the user needs to make a choice between two or more options:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">enum SortOrder\r\n{\r\n    alphabetical,\r\n    alphabeticalReverse,\r\n    numerical,\r\n};\r\n\r\nvoid sortData(SortOrder order)\r\n{\r\n    switch (order)\r\n    {\r\n        case alphabetical:\r\n            \/\/ sort data in forwards alphabetical order\r\n            break;\r\n        case alphabeticalReverse:\r\n            \/\/ sort data in backwards alphabetical order\r\n            break;\r\n        case numerical:\r\n            \/\/ sort data numerically\r\n            break;\r\n    }\r\n}<\/code><\/pre>\n<p>Many languages use enumerations to define Booleans -- after all, a Boolean is essentially just an enumeration with 2 enumerators: <code>false<\/code> and <code>true<\/code>!  However, in C++, <code>true<\/code> and <code>false<\/code> are defined as keywords instead of enumerators.<\/p>\n<p>Because enumerations are small and inexpensive to copy, it is fine to pass (and return) them by value.<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/bit-flags-and-bit-manipulation-via-stdbitset\/\">O.1 -- Bit flags and bit manipulation via std::bitset<\/a>, we discussed bit flags.  Enums can also be used to define a collection of related bit flag positions for use with <code>std::bitset<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;bitset&gt;\r\n#include &lt;iostream&gt;\r\n\r\nnamespace Flags\r\n{\r\n    enum State\r\n    {\r\n        isHungry,\r\n        isSad,\r\n        isMad,\r\n        isHappy,\r\n        isLaughing,\r\n        isAsleep,\r\n        isDead,\r\n        isCrying,\r\n    };\r\n}\r\n\r\nint main()\r\n{\r\n    std::bitset&lt;8&gt; me{};\r\n    me.set(Flags::isHappy);\r\n    me.set(Flags::isLaughing);\r\n\r\n    std::cout &lt;&lt; std::boolalpha; \/\/ print bool as true\/false\r\n\r\n    \/\/ Query a few states (we use the any() function to see if any bits remain set)\r\n    std::cout &lt;&lt; \"I am happy? \" &lt;&lt; me.test(Flags::isHappy) &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"I am laughing? \" &lt;&lt; me.test(Flags::isLaughing) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>If you&#8217;re wondering how we can use an enumerator where an integral value is expected, unscoped enumerators will implicitly convert to integral values.  We will explore this further in the next lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/unscoped-enumerator-integral-conversions\/\">13.3 -- Unscoped enumerator integral conversions<\/a>).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The scope of unscoped enumerations<\/p>\n<p>Unscoped enumerations are named such because they put their enumerator names into the same scope as the enumeration definition itself (as opposed to creating a new scope region like a namespace does).<\/p>\n<p>For example, given this program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">enum Color \/\/ this enum is defined in the global namespace\r\n{\r\n    red, \/\/ so red is put into the global namespace\r\n    green,\r\n    blue, \r\n};\r\n\r\nint main()\r\n{\r\n    Color apple { red }; \/\/ my apple is red\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The <code>Color<\/code> enumeration is defined in the global scope.  Therefore, all the enumeration names (<code>red<\/code>, <code>green<\/code>, and <code>blue<\/code>) also go into the global scope.  This pollutes the global scope and significantly raises the chance of naming collisions.<\/p>\n<p>One consequence of this is that an enumerator name can&#8217;t be used in multiple enumerations within the same scope:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">enum Color\r\n{\r\n    red,\r\n    green,\r\n    blue, \/\/ blue is put into the global namespace\r\n};\r\n\r\nenum Feeling\r\n{\r\n    happy,\r\n    tired,\r\n    blue, \/\/ error: naming collision with the above blue\r\n};\r\n\r\nint main()\r\n{\r\n    Color apple { red }; \/\/ my apple is red\r\n    Feeling me { happy }; \/\/ I'm happy right now (even though my program doesn't compile)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, both unscoped enumerations (<code>Color<\/code> and <code>Feeling<\/code>) put enumerators with the same name <code>blue<\/code> into the global scope.  This leads to a naming collision and subsequent compile error.<\/p>\n<p>Unscoped enumerations also provide a named scope region for their enumerators (much like a namespace acts as a named scope region for the names declared within).  This means we can access the enumerators of an unscoped enumeration as follows:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">enum Color\r\n{\r\n    red,\r\n    green,\r\n    blue, \/\/ blue is put into the global namespace\r\n};\r\n\r\nint main()\r\n{\r\n    Color apple { red }; \/\/ okay, accessing enumerator from global namespace\r\n    Color raspberry { Color::red }; \/\/ also okay, accessing enumerator from scope of Color\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Most often, unscoped enumerators are accessed without using the scope resolution operator.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Avoiding enumerator naming collisions<\/p>\n<p>There are quite a few common ways to prevent unscoped enumerator naming collisions.<\/p>\n<p>One option is to prefix each enumerator with the name of the enumeration itself:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">enum Color\r\n{\r\n    color_red,\r\n    color_blue,\r\n    color_green,\r\n};\r\n\r\nenum Feeling\r\n{\r\n    feeling_happy,\r\n    feeling_tired,\r\n    feeling_blue, \/\/ no longer has a naming collision with color_blue\r\n};\r\n\r\nint main()\r\n{\r\n    Color paint { color_blue };\r\n    Feeling me { feeling_blue };\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This still pollutes the namespace but reduces the chance for naming collisions by making the names longer and more unique.<\/p>\n<p>A better option is to put the enumerated type inside something that provides a separate scope region, such as a namespace:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">namespace Color\r\n{\r\n    \/\/ The names Color, red, blue, and green are defined inside namespace Color\r\n    enum Color\r\n    {\r\n        red,\r\n        green,\r\n        blue,\r\n    };\r\n}\r\n\r\nnamespace Feeling\r\n{\r\n    enum Feeling\r\n    {\r\n        happy,\r\n        tired,\r\n        blue, \/\/ Feeling::blue doesn't collide with Color::blue\r\n    };\r\n}\r\n\r\nint main()\r\n{\r\n    Color::Color paint{ Color::blue };\r\n    Feeling::Feeling me{ Feeling::blue };\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This means we now have to prefix our enumeration and enumerator names with the name of the scoped region.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Classes also provide a scope region, and it&#8217;s common to put enumerated types related to a class inside the scope region of the class.  We discuss this in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/nested-types-member-types\/\">15.3 -- Nested types (member types)<\/a>.\n<\/p><\/div>\n<p>A related option is to use a scoped enumeration (which defines its own scope region).  We&#8217;ll discuss scoped enumerations shortly (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/scoped-enumerations-enum-classes\/\">13.6 -- Scoped enumerations (enum classes)<\/a>).<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Prefer putting your enumerations inside a named scope region (such as a namespace or class) so the enumerators don&#8217;t pollute the global namespace.\n<\/p><\/div>\n<p>Alternatively, if an enumeration is only used within the body of a single function, the enumeration should be defined inside the function.  This limits the scope of the enumeration and its enumerators to just that function.  The enumerators of such an enumeration will shadow identically named enumerators defined in the global scope.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Comparing against enumerators<\/p>\n<p>We can use the equality operators (<code>operator==<\/code> and <code>operator!=<\/code>) to test whether an enumeration has the value of a particular enumerator or not.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nenum Color\r\n{\r\n    red,\r\n    green,\r\n    blue,\r\n};\r\n\r\nint main()\r\n{\r\n    Color shirt{ blue };\r\n\r\n    if (shirt == blue) \/\/ if the shirt is blue\r\n        std::cout &lt;&lt; \"Your shirt is blue!\";\r\n    else\r\n        std::cout &lt;&lt; \"Your shirt is not blue!\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, we use an if-statement to test whether <code>shirt<\/code> is equal to the enumerator <code>blue<\/code>.  This gives us a way to conditionalize our program&#8217;s behavior based on what enumerator our enumeration is holding.<\/p>\n<p>We&#8217;ll make more use of this in the next lesson.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Define an unscoped enumerated type named MonsterType to choose between the following monster races: orc, goblin, troll, ogre, and skeleton.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">enum MonsterType\r\n{\r\n    orc,\r\n    goblin,\r\n    troll,\r\n    ogre,\r\n    skeleton,\r\n};<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>Put the MonsterType enumeration inside a namespace.  Then, create a main() function and instantiate a troll.  The program should compile.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">namespace Monster\r\n{\r\n    enum MonsterType\r\n    {\r\n        orc,\r\n        goblin,\r\n        troll,\r\n        ogre,\r\n        skeleton,\r\n    };\r\n}\r\n\r\nint main()\r\n{\r\n    \/\/ We use [[maybe_unused]] to avoid warnings about unused variables\r\n    \/\/ You could also output the monster instead\r\n    [[maybe_unused]] Monster::MonsterType monster{ Monster::troll };\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because <code>MonsterType<\/code> is an unscoped enumeration, its enumerators (e.g. <code>troll<\/code>) are placed into namespace of the enumeration itself (which in this case is <code>namespace Monster<\/code>).  Thus, we can access <code>troll<\/code> as <code>Monster::troll<\/code>.<\/p>\n<p>Because unscoped enumerations also put their enumerators into their own namespace, <code>troll<\/code> can also be accessed as <code>Monster::MonsterType::troll<\/code>.  However, there is no real benefit to doing so.<\/p>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/unscoped-enumerator-integral-conversions\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.3<\/span>Unscoped enumerator integral conversions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-program-defined-user-defined-types\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.1<\/span>Introduction to program-defined (user-defined) types\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>C++ contains many useful fundamental and compound data types (which we introduced in lessons and ). But these types aren&#8217;t always sufficient for the kinds of things we want to do. For example, let&#8217;s say you&#8217;re writing a program that needs to keep track of whether an apple is red, &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/68"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=68"}],"version-history":[{"count":92,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/68\/revisions"}],"predecessor-version":[{"id":17811,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/68\/revisions\/17811"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=68"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=68"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=68"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}