{"id":119,"date":"2007-08-08T16:52:10","date_gmt":"2007-08-09T00:52:10","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/78-function-pointers\/"},"modified":"2024-12-14T23:17:57","modified_gmt":"2024-12-15T07:17:57","slug":"function-pointers","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/function-pointers\/","title":{"rendered":"20.1 &#8212; Function Pointers"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-pointers\/\">12.7 -- Introduction to pointers<\/a>, you learned that a pointer is a variable that holds the address of another variable.  Function pointers are similar, except that instead of pointing to variables, they point to functions!<\/p>\n<p>Consider the following function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int foo()\r\n{\r\n    return 5;\r\n}<\/code><\/pre>\n<p>Identifier <code>foo()<\/code> is the function&#8217;s name.  But what type is the function?  Functions have their own function type -- in this case, a function type that returns an integer and takes no parameters.  Much like variables, functions live at an assigned address in memory (making them lvalues).<\/p>\n<p>When a function is called (via <code>operator()<\/code>), execution jumps to the address of the function being called:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int foo() \/\/ code for foo starts at memory address 0x002717f0\r\n{\r\n    return 5;\r\n}\r\n\r\nint main()\r\n{\r\n    foo(); \/\/ jump to address 0x002717f0\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>At some point in your programming career (if you haven&#8217;t already), you&#8217;ll probably make a simple mistake:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint foo() \/\/ code starts at memory address 0x002717f0\r\n{\r\n    return 5;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; foo &lt;&lt; '\\n'; \/\/ we meant to call foo(), but instead we're printing foo itself!\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Instead of calling function <code>foo()<\/code> and printing the return value, we&#8217;ve unintentionally sent function <code>foo<\/code> directly to <code>std::cout<\/code>.  What happens in this case?<\/p>\n<p>When a function is referred to by name (without parenthesis), C++ converts the function into a function pointer (holding the address of the function).  Then <code>operator&lt;&lt;<\/code> tries to print the function pointer, which it fails at because <code>operator&lt;&lt;<\/code> does not know how to print function pointers.  The standard says that in this case, <code>foo<\/code> should be converted to a <code>bool<\/code> (which <code>operator&lt;&lt;<\/code> does know how to print).  And since the function pointer for <code>foo<\/code> is a non-null pointer, it should always evaluate to Boolean <code>true<\/code>.  Thus, this should print:<\/p>\n<pre>\n1\r\n<\/pre>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>Some compilers (e.g. Visual Studio) have a compiler extension that prints the address of the function instead:<\/p>\n<pre>\n0x002717f0\r\n<\/pre>\n<p>If your platform doesn&#8217;t print the function&#8217;s address and you want it to, you may be able to force it to do so by converting the function to a void pointer and printing that:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint foo() \/\/ code starts at memory address 0x002717f0\r\n{\r\n    return 5;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; reinterpret_cast&lt;void*&gt;(foo) &lt;&lt; '\\n'; \/\/ Tell C++ to interpret function foo as a void pointer (implementation-defined behavior)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This is implementation-defined behavior, so it may not work on all platforms.\n<\/p><\/div>\n<p>Just like it is possible to declare a non-constant pointer to a normal variable, it&#8217;s also possible to declare a non-constant pointer to a function.  In the rest of this lesson, we&#8217;ll examine these function pointers and their uses.  Function pointers are a fairly advanced topic, and the rest of this lesson can be safely skipped or skimmed by those only looking for C++ basics.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Pointers to functions<\/p>\n<p>The syntax for creating a non-const function pointer is one of the ugliest things you will ever see in C++:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ fcnPtr is a pointer to a function that takes no arguments and returns an integer\r\nint (*fcnPtr)();<\/code><\/pre>\n<p>In the above snippet, fcnPtr is a pointer to a function that has no parameters and returns an integer.  fcnPtr can point to any function that matches this type.<\/p>\n<p>The parentheses around *fcnPtr are necessary for precedence reasons, as <code>int* fcnPtr()<\/code> would be interpreted as a forward declaration for a function named fcnPtr that takes no parameters and returns a pointer to an integer.<\/p>\n<p>To make a const function pointer, the const goes after the asterisk:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int (*const fcnPtr)();<\/code><\/pre>\n<p>If you put the const before the int, then that would indicate the function being pointed to would return a const int.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>The function pointer syntax can be hard to understand.  The following articles demonstrates a method for parsing such declarations:<\/p>\n<ul>\n<li><a href=\"https:\/\/c-faq.com\/decl\/spiral.anderson.html\">https:\/\/c-faq.com\/decl\/spiral.anderson.html<\/a>\n<\/li>\n<li><a href=\"https:\/\/web.archive.org\/web\/20110818081319\/http:\/\/ieng9.ucsd.edu\/~cs30x\/rt_lt.rule.html\">https:\/\/web.archive.org\/web\/20110818081319\/http:\/\/ieng9.ucsd.edu\/~cs30x\/rt_lt.rule.html<\/a>\n<\/li>\n<\/ul>\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Assigning a function to a function pointer<\/p>\n<p>Function pointers can be initialized with a function (and non-const function pointers can be assigned a function). Like with pointers to variables, we can also use &amp;foo to get a function pointer to foo.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int foo()\r\n{\r\n    return 5;\r\n}\r\n\r\nint goo()\r\n{\r\n    return 6;\r\n}\r\n\r\nint main()\r\n{\r\n    int (*fcnPtr)(){ &amp;foo }; \/\/ fcnPtr points to function foo\r\n    fcnPtr = &amp;goo; \/\/ fcnPtr now points to function goo\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>One common mistake is to do this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">fcnPtr = goo();<\/code><\/pre>\n<p>This tries to assign the return value from a call to function goo() (which has type <code>int<\/code>) to fcnPtr (which is expecting a value of type <code>int(*)()<\/code>), which isn&#8217;t what we want.  We want fcnPtr to be assigned the address of function goo, not the return value from function goo().  So no parentheses are needed.<\/p>\n<p>Note that the type (parameters and return type) of the function pointer must match the type of the function.  Here are some examples of this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ function prototypes\r\nint foo();\r\ndouble goo();\r\nint hoo(int x);\r\n\r\n\/\/ function pointer initializers\r\nint (*fcnPtr1)(){ &amp;foo };    \/\/ okay\r\nint (*fcnPtr2)(){ &amp;goo };    \/\/ wrong -- return types don't match!\r\ndouble (*fcnPtr4)(){ &amp;goo }; \/\/ okay\r\nfcnPtr1 = &amp;hoo;              \/\/ wrong -- fcnPtr1 has no parameters, but hoo() does\r\nint (*fcnPtr3)(int){ &amp;hoo }; \/\/ okay<\/code><\/pre>\n<p>Unlike fundamental types, C++ <em>will<\/em> implicitly convert a function into a function pointer if needed (so you don&#8217;t need to use the address-of operator (&#038;) to get the function&#8217;s address).  However, function pointers will not convert to void pointers, or vice-versa (though some compilers like Visual Studio may allow this anyway).<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\t\/\/ function prototypes\r\n\tint foo();\r\n\r\n\t\/\/ function initializations\r\n\tint (*fcnPtr5)() { foo }; \/\/ okay, foo implicitly converts to function pointer to foo\r\n\tvoid* vPtr { foo };       \/\/ not okay, though some compilers may allow<\/code><\/pre>\n<p>Function pointers can also be initialized or assigned the value nullptr:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int (*fcnptr)() { nullptr }; \/\/ okay<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Calling a function using a function pointer<\/p>\n<p>The other primary thing you can do with a function pointer is use it to actually call the function.  There are two ways to do this.  The first is via explicit dereference:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int foo(int x)\r\n{\r\n    return x;\r\n}\r\n\r\nint main()\r\n{\r\n    int (*fcnPtr)(int){ &amp;foo }; \/\/ Initialize fcnPtr with function foo\r\n    (*fcnPtr)(5); \/\/ call function foo(5) through fcnPtr.\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The second way is via implicit dereference:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int foo(int x)\r\n{\r\n    return x;\r\n}\r\n\r\nint main()\r\n{\r\n    int (*fcnPtr)(int){ &amp;foo }; \/\/ Initialize fcnPtr with function foo\r\n    fcnPtr(5); \/\/ call function foo(5) through fcnPtr.\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>As you can see, the implicit dereference method looks just like a normal function call -- which is what you&#8217;d expect, since normal function names are pointers to functions anyway!  However, some older compilers do not support the implicit dereference method, but all modern compilers should.<\/p>\n<p>Also note that because function pointers can be set to nullptr, it&#8217;s a good idea to assert or conditionally test whether your function pointer is a null pointer before calling it.  Just like with normal pointers, dereferencing a null function pointer leads to undefined behavior.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int foo(int x)\r\n{\r\n    return x;\r\n}\r\n\r\nint main()\r\n{\r\n    int (*fcnPtr)(int){ &amp;foo }; \/\/ Initialize fcnPtr with function foo\r\n    if (fcnPtr) \/\/ make sure fcnPtr isn't a null pointer    \r\n        fcnPtr(5); \/\/ otherwise this will lead to undefined behavior\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Default arguments don&#8217;t work for functions called through function pointers <span class=\"cpp-section-pill cpp-section-advanced\">Advanced<\/span><\/p>\n<p>When the compiler encounters a normal function call to a function with one or more default arguments, it rewrites the function call to include the default arguments.  This process happens at compile-time, and thus can only be applied to functions that can be resolved at compile time.<\/p>\n<p>However, when a function is called through a function pointer, it is resolved at runtime.  In this case, there is no rewriting of the function call to include default arguments.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Because the resolution happens at runtime, default arguments are not resolved when a function is called through a function pointer.\n<\/p><\/div>\n<p>This means that we can use a function pointer to disambiguate a function call that would otherwise be ambiguous due to default arguments.  In the following example, we show two ways to do this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid print(int x)\r\n{\r\n    std::cout &lt;&lt; \"print(int)\\n\";\r\n}\r\n\r\nvoid print(int x, int y = 10)\r\n{\r\n    std::cout &lt;&lt; \"print(int, int)\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n\/\/    print(1); \/\/ ambiguous function call\r\n\r\n    \/\/ Deconstructed method\r\n    using vnptr = void(*)(int); \/\/ define a type alias for a function pointer to a void(int) function\r\n    vnptr pi { print }; \/\/ initialize our function pointer with function print\r\n    pi(1); \/\/ call the print(int) function through the function pointer\r\n\r\n    \/\/ Concise method\r\n    static_cast&lt;void(*)(int)&gt;(print)(1); \/\/ call void(int) version of print with argument 1\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Passing functions as arguments to other functions<\/p>\n<p>One of the most useful things to do with function pointers is pass a function as an argument to another function.  Functions used as arguments to another function are sometimes called <strong>callback functions<\/strong>.<\/p>\n<p>Consider a case where you are writing a function to perform a task (such as sorting an array), but you want the user to be able to define how a particular part of that task will be performed (such as whether the array is sorted in ascending or descending order).  Let&#8217;s take a closer look at this problem as applied specifically to sorting, as an example that can be generalized to other similar problems.<\/p>\n<p>Many comparison-based sorting algorithms work on a similar concept: the sorting algorithm iterates through a list of numbers, does comparisons on pairs of numbers, and reorders the numbers based on the results of those comparisons.  Consequently, by varying the comparison, we can change the way the algorithm sorts without affecting the rest of the sorting code.<\/p>\n<p>Here is our selection sort routine from a previous lesson:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;utility&gt; \/\/ for std::swap\r\n\r\nvoid SelectionSort(int* array, int size)\r\n{\r\n    if (!array)\r\n        return;\r\n\r\n    \/\/ Step through each element of the array\r\n    for (int startIndex{ 0 }; startIndex &lt; (size - 1); ++startIndex)\r\n    {\r\n        \/\/ smallestIndex is the index of the smallest element we've encountered so far.\r\n        int smallestIndex{ startIndex };\r\n \r\n        \/\/ Look for smallest element remaining in the array (starting at startIndex+1)\r\n        for (int currentIndex{ startIndex + 1 }; currentIndex &lt; size; ++currentIndex)\r\n        {\r\n            \/\/ If the current element is smaller than our previously found smallest\r\n            if (array[smallestIndex] &gt; array[currentIndex]) \/\/ COMPARISON DONE HERE\r\n            {\r\n                \/\/ This is the new smallest number for this iteration\r\n                smallestIndex = currentIndex;\r\n            }\r\n        }\r\n \r\n        \/\/ Swap our start element with our smallest element\r\n        std::swap(array[startIndex], array[smallestIndex]);\r\n    }\r\n}<\/code><\/pre>\n<p>Let&#8217;s replace that comparison with a function to do the comparison.  Because our comparison function is going to compare two integers and return a boolean value to indicate whether the elements should be swapped, it will look something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">bool ascending(int x, int y)\r\n{\r\n    return x &gt; y; \/\/ swap if the first element is greater than the second\r\n}<\/code><\/pre>\n<p>And here&#8217;s our selection sort routine using the ascending() function to do the comparison:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;utility&gt; \/\/ for std::swap\r\n\r\nvoid SelectionSort(int* array, int size)\r\n{\r\n    if (!array)\r\n        return;\r\n\r\n    \/\/ Step through each element of the array\r\n    for (int startIndex{ 0 }; startIndex &lt; (size - 1); ++startIndex)\r\n    {\r\n        \/\/ smallestIndex is the index of the smallest element we've encountered so far.\r\n        int smallestIndex{ startIndex };\r\n \r\n        \/\/ Look for smallest element remaining in the array (starting at startIndex+1)\r\n        for (int currentIndex{ startIndex + 1 }; currentIndex &lt; size; ++currentIndex)\r\n        {\r\n            \/\/ If the current element is smaller than our previously found smallest\r\n            if (ascending(array[smallestIndex], array[currentIndex])) \/\/ COMPARISON DONE HERE\r\n            {\r\n                \/\/ This is the new smallest number for this iteration\r\n                smallestIndex = currentIndex;\r\n            }\r\n        }\r\n \r\n        \/\/ Swap our start element with our smallest element\r\n        std::swap(array[startIndex], array[smallestIndex]);\r\n    }\r\n}<\/code><\/pre>\n<p>Now, in order to let the caller decide how the sorting will be done, instead of using our own hard-coded comparison function, we&#8217;ll allow the caller to provide their own sorting function!  This is done via a function pointer.<\/p>\n<p>Because the caller&#8217;s comparison function is going to compare two integers and return a boolean value, a pointer to such a function would look something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">bool (*comparisonFcn)(int, int);<\/code><\/pre>\n<p>So, we&#8217;ll allow the caller to pass our sort routine a pointer to their desired comparison function as the third parameter, and then we&#8217;ll use the caller&#8217;s function to do the comparison.<\/p>\n<p>Here&#8217;s a full example of a selection sort that uses a function pointer parameter to do a user-defined comparison, along with an example of how to call it:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;utility&gt; \/\/ for std::swap\r\n#include &lt;iostream&gt;\r\n\r\n\/\/ Note our user-defined comparison is the third parameter\r\nvoid selectionSort(int* array, int size, bool (*comparisonFcn)(int, int))\r\n{\r\n    if (!array || !comparisonFcn)\r\n        return;\r\n\r\n    \/\/ Step through each element of the array\r\n    for (int startIndex{ 0 }; startIndex &lt; (size - 1); ++startIndex)\r\n    {\r\n        \/\/ bestIndex is the index of the smallest\/largest element we've encountered so far.\r\n        int bestIndex{ startIndex };\r\n \r\n        \/\/ Look for smallest\/largest element remaining in the array (starting at startIndex+1)\r\n        for (int currentIndex{ startIndex + 1 }; currentIndex &lt; size; ++currentIndex)\r\n        {\r\n            \/\/ If the current element is smaller\/larger than our previously found smallest\r\n            if (comparisonFcn(array[bestIndex], array[currentIndex])) \/\/ COMPARISON DONE HERE\r\n            {\r\n                \/\/ This is the new smallest\/largest number for this iteration\r\n                bestIndex = currentIndex;\r\n            }\r\n        }\r\n \r\n        \/\/ Swap our start element with our smallest\/largest element\r\n        std::swap(array[startIndex], array[bestIndex]);\r\n    }\r\n}\r\n\r\n\/\/ Here is a comparison function that sorts in ascending order\r\n\/\/ (Note: it's exactly the same as the previous ascending() function)\r\nbool ascending(int x, int y)\r\n{\r\n    return x &gt; y; \/\/ swap if the first element is greater than the second\r\n}\r\n\r\n\/\/ Here is a comparison function that sorts in descending order\r\nbool descending(int x, int y)\r\n{\r\n    return x &lt; y; \/\/ swap if the second element is greater than the first\r\n}\r\n\r\n\/\/ This function prints out the values in the array\r\nvoid printArray(int* array, int size)\r\n{\r\n    if (!array)\r\n        return;\r\n\r\n    for (int index{ 0 }; index &lt; size; ++index)\r\n    {\r\n        std::cout &lt;&lt; array[index] &lt;&lt; ' ';\r\n    }\r\n    \r\n    std::cout &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    int array[9]{ 3, 7, 9, 5, 6, 1, 8, 2, 4 };\r\n\r\n    \/\/ Sort the array in descending order using the descending() function\r\n    selectionSort(array, 9, descending);\r\n    printArray(array, 9);\r\n\r\n    \/\/ Sort the array in ascending order using the ascending() function\r\n    selectionSort(array, 9, ascending);\r\n    printArray(array, 9);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program produces the result:<\/p>\n<pre>\r\n9 8 7 6 5 4 3 2 1\r\n1 2 3 4 5 6 7 8 9\r\n<\/pre>\n<p>Is that cool or what?  We&#8217;ve given the caller the ability to control how our selection sort does its job.<\/p>\n<p>The caller can even define their own &#8220;strange&#8221; comparison functions:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">bool evensFirst(int x, int y)\r\n{\r\n\t\/\/ if x is even and y is odd, x goes first (no swap needed)\r\n\tif ((x % 2 == 0) &amp;&amp; !(y % 2 == 0))\r\n\t\treturn false;\r\n \r\n\t\/\/ if x is odd and y is even, y goes first (swap needed)\r\n\tif (!(x % 2 == 0) &amp;&amp; (y % 2 == 0))\r\n\t\treturn true;\r\n\r\n        \/\/ otherwise sort in ascending order\r\n\treturn ascending(x, y);\r\n}\r\n\r\nint main()\r\n{\r\n    int array[9]{ 3, 7, 9, 5, 6, 1, 8, 2, 4 };\r\n\r\n    selectionSort(array, 9, evensFirst);\r\n    printArray(array, 9);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The above snippet produces the following result:<\/p>\n<pre>\r\n2 4 6 8 1 3 5 7 9\r\n<\/pre>\n<p>As you can see, using a function pointer in this context provides a nice way to allow a caller to &#8220;hook&#8221; their own functionality into something you&#8217;ve previously written and tested, which helps facilitate code reuse!  Previously, if you wanted to sort one array in descending order and another in ascending order, you&#8217;d need multiple versions of the sort routine.  Now you can have one version that can sort any way the caller desires!<\/p>\n<p>Note: If a function parameter is of a function type, it will be converted to a pointer to the function type.  This means:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void selectionSort(int* array, int size, bool (*comparisonFcn)(int, int))<\/code><\/pre>\n<p>can be equivalently written as:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void selectionSort(int* array, int size, bool comparisonFcn(int, int))<\/code><\/pre>\n<p>This only works for function parameters, and so is of somewhat limited use.  On a non-function parameter, the latter is interpreted as a forward declaration:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    bool (*ptr)(int, int); \/\/ definition of function pointer ptr\r\n    bool fcn(int, int);    \/\/ forward declaration of function fcn<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Providing default functions<\/p>\n<p>If you&#8217;re going to allow the caller to pass in a function as a parameter, it can often be useful to provide some standard functions for the caller to use for their convenience.  For example, in the selection sort example above, providing the ascending() and descending() function along with the selectionSort() function would make the caller&#8217;s life easier, as they wouldn&#8217;t have to rewrite ascending() or descending() every time they want to use them.<\/p>\n<p>You can even set one of these as a default parameter:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Default the sort to ascending sort\r\nvoid selectionSort(int* array, int size, bool (*comparisonFcn)(int, int) = ascending);<\/code><\/pre>\n<p>In this case, as long as the user calls selectionSort normally (not through a function pointer), the comparisonFcn parameter will default to ascending.  You will need to make sure that the <code>ascending<\/code> function is declared prior to this point, otherwise the compiler will complain it doesn&#8217;t know what <code>ascending<\/code> is.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Making function pointers prettier with type aliases<\/p>\n<p>Let&#8217;s face it -- the syntax for pointers to functions is ugly.  However, type aliases can be used to make pointers to functions look more like regular variables:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">using ValidateFunction = bool(*)(int, int);<\/code><\/pre>\n<p>This defines a type alias called &#8220;ValidateFunction&#8221; that is a pointer to a function that takes two ints and returns a bool.<\/p>\n<p>Now instead of doing this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">bool validate(int x, int y, bool (*fcnPtr)(int, int)); \/\/ ugly<\/code><\/pre>\n<p>You can do this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">bool validate(int x, int y, ValidateFunction pfcn) \/\/ clean<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using std::function<\/p>\n<p>An alternate method of defining and storing function pointers is to use std::function, which is part of the standard library &lt;functional&gt; header.  To define a function pointer using this method, declare a std::function object like so:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;functional&gt;\r\nbool validate(int x, int y, std::function&lt;bool(int, int)&gt; fcn); \/\/ std::function method that returns a bool and takes two int parameters<\/code><\/pre>\n<p>As you see, both the return type and parameters go inside angled brackets, with the parameters inside parentheses.  If there are no parameters, the parentheses can be left empty.<\/p>\n<p>Updating our earlier example with std::function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;functional&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint foo()\r\n{\r\n    return 5;\r\n}\r\n\r\nint goo()\r\n{\r\n    return 6;\r\n}\r\n\r\nint main()\r\n{\r\n    std::function&lt;int()&gt; fcnPtr{ &amp;foo }; \/\/ declare function pointer that returns an int and takes no parameters\r\n    fcnPtr = &amp;goo; \/\/ fcnPtr now points to function goo\r\n    std::cout &lt;&lt; fcnPtr() &lt;&lt; '\\n'; \/\/ call the function just like normal\r\n\r\n    std::function fcnPtr2{ &amp;foo }; \/\/ can also use CTAD to infer template arguments\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Type aliasing std::function can be helpful for readability:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">using ValidateFunctionRaw = bool(*)(int, int); \/\/ type alias to raw function pointer\r\nusing ValidateFunction = std::function&lt;bool(int, int)&gt;; \/\/ type alias to std::function<\/code><\/pre>\n<p>Also note that std::function only allows calling the function via implicit dereference (e.g. <code>fcnPtr()<\/code>), not explicit dereference (e.g. <code>(*fcnPtr)()<\/code>).<\/p>\n<p>When defining a type alias, we must explicitly specify any template arguments.  We can&#8217;t use CTAD in this case since there is no initializer to deduce the template arguments from.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Type inference for function pointers<\/p>\n<p>Much like the <em>auto<\/em> keyword can be used to infer the type of normal variables, the <em>auto<\/em> keyword can also infer the type of a function pointer.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint foo(int x)\r\n{\r\n\treturn x;\r\n}\r\n\r\nint main()\r\n{\r\n\tauto fcnPtr{ &amp;foo };\r\n\tstd::cout &lt;&lt; fcnPtr(5) &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This works exactly like you&#8217;d expect, and the syntax is very clean.  The downside is, of course, that all of the details about the function&#8217;s parameters types and return type are hidden, so it&#8217;s easier to make a mistake when making a call with the function, or using its return value.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Conclusion<\/p>\n<p>Function pointers are useful primarily when you want to store functions in an array (or other structure), or when you need to pass a function to another function.  Because the native syntax to declare function pointers is ugly and error prone, we recommend using std::function.  In places where a function pointer type is only used once (e.g. a single parameter or return value), std::function can be used directly.  In places where a function pointer type is used multiple times, a type alias to a std::function is a better choice (to prevent repeating yourself).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<ol start=\"1\">\n<li>In this quiz, we&#8217;re going to write a version of our basic calculator using function pointers.\n<\/li>\n<\/ol>\n<p>1a) Create a short program asking the user for two integer inputs and a mathematical operation (&#8216;+&#8217;, &#8216;-&#8216;, &#8216;*&#8217;, &#8216;\/&#8217;).  Ensure the user enters a valid operation.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint getInteger()\r\n{\r\n    std::cout &lt;&lt; \"Enter an integer: \";\r\n    int x{};\r\n    std::cin &gt;&gt; x;\r\n    return x;\r\n}\r\n\r\nchar getOperation()\r\n{\r\n    char op{};\r\n\r\n    do\r\n    {   \r\n        std::cout &lt;&lt; \"Enter an operation ('+', '-', '*', '\/'): \";\r\n        std::cin &gt;&gt; op;\r\n    }\r\n    while (op!='+' &amp;&amp; op!='-' &amp;&amp; op!='*' &amp;&amp; op!='\/');\r\n\r\n    return op;\r\n}\r\n\r\nint main()\r\n{\r\n    int x{ getInteger() };\r\n    char op{ getOperation() };\r\n    int y{ getInteger() };\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>1b) Write functions named add(), subtract(), multiply(), and divide().  These should take two integer parameters and return an integer.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int add(int x, int y)\r\n{\r\n    return x + y;\r\n}\r\n\r\nint subtract(int x, int y)\r\n{\r\n    return x - y;\r\n}\r\n\r\nint multiply(int x, int y)\r\n{\r\n    return x * y;\r\n}\r\n\r\nint divide(int x, int y)\r\n{\r\n    return x \/ y;\r\n}<\/code><\/pre>\n<\/div>\n<p>1c) Create a type alias named ArithmeticFunction for a pointer to a function that takes two integer parameters and returns an integer.  Use std::function, and include the appropriate header.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;functional&gt;\r\nusing ArithmeticFunction = std::function&lt;int(int, int)&gt;;<\/code><\/pre>\n<\/div>\n<p>1d) Write a function named getArithmeticFunction() that takes an operator character and returns the appropriate function as a function pointer.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">ArithmeticFunction getArithmeticFunction(char op)\r\n{\r\n    switch (op)\r\n    {\r\n    case '+': return &amp;add;\r\n    case '-': return &amp;subtract;\r\n    case '*': return &amp;multiply;\r\n    case '\/': return &amp;divide;\r\n    }\r\n\r\n    return nullptr;\r\n}<\/code><\/pre>\n<\/div>\n<p>1e) Modify your main() function to call getArithmeticFunction().  Call the return value from that function with your inputs and print the result.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x{ getInteger() };\r\n    char op{ getOperation() };\r\n    int y{ getInteger() };\r\n\r\n    ArithmeticFunction fcn{ getArithmeticFunction(op) };\r\n    if (fcn)\r\n        std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; op &lt;&lt; ' ' &lt;&lt; y &lt;&lt; \" = \" &lt;&lt; fcn(x, y) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>Here&#8217;s the full program:<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_5'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_5\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;functional&gt;\r\n\r\nint getInteger()\r\n{\r\n    std::cout &lt;&lt; \"Enter an integer: \";\r\n    int x{};\r\n    std::cin &gt;&gt; x;\r\n    return x;\r\n}\r\n\r\nchar getOperation()\r\n{\r\n    char op{};\r\n\r\n    do\r\n    {   \r\n        std::cout &lt;&lt; \"Enter an operation ('+', '-', '*', '\/'): \";\r\n        std::cin &gt;&gt; op;\r\n    }\r\n    while (op!='+' &amp;&amp; op!='-' &amp;&amp; op!='*' &amp;&amp; op!='\/');\r\n\r\n    return op;\r\n}\r\n\r\nint add(int x, int y)\r\n{\r\n    return x + y;\r\n}\r\n\r\nint subtract(int x, int y)\r\n{\r\n    return x - y;\r\n}\r\n\r\nint multiply(int x, int y)\r\n{\r\n    return x * y;\r\n}\r\n\r\nint divide(int x, int y)\r\n{\r\n    return x \/ y;\r\n}\r\n\r\nusing ArithmeticFunction = std::function&lt;int(int, int)&gt;;\r\n\r\nArithmeticFunction getArithmeticFunction(char op)\r\n{\r\n    switch (op)\r\n    {\r\n    case '+': return &amp;add;\r\n    case '-': return &amp;subtract;\r\n    case '*': return &amp;multiply;\r\n    case '\/': return &amp;divide;\r\n    }\r\n\r\n    return nullptr;\r\n}\r\n\r\nint main()\r\n{\r\n    int x{ getInteger() };\r\n    char op{ getOperation() };\r\n    int y{ getInteger() };\r\n\r\n    ArithmeticFunction fcn{ getArithmeticFunction(op) };\r\n    if (fcn)\r\n        std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; op &lt;&lt; ' ' &lt;&lt; y &lt;&lt; \" = \" &lt;&lt; fcn(x, y) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/the-stack-and-the-heap\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">20.2<\/span>The stack and the heap\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/void-pointers\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">19.5<\/span>Void pointers\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , you learned that a pointer is a variable that holds the address of another variable. Function pointers are similar, except that instead of pointing to variables, they point to functions! Consider the following function: int foo() { return 5; } Identifier foo() is the function&#8217;s name. But &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/119"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=119"}],"version-history":[{"count":79,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/119\/revisions"}],"predecessor-version":[{"id":17990,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/119\/revisions\/17990"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=119"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=119"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=119"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}