{"id":61,"date":"2007-06-17T13:12:16","date_gmt":"2007-06-17T21:12:16","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/38-bitwise-operators\/"},"modified":"2025-02-26T22:49:10","modified_gmt":"2025-02-27T06:49:10","slug":"bitwise-operators","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/bitwise-operators\/","title":{"rendered":"O.2 &#8212; Bitwise operators"},"content":{"rendered":"<p class=\"cpp-section\">The bitwise operators<\/p>\n<p>C++ provides 6 bit manipulation operators, often called <strong>bitwise<\/strong> operators:<\/p>\n<p style=\"clear: both\">\n<div class=\"cpp-table-wrapper\">\n<table class=\"cpp-table\">\n<tr>\n<th> Operator <\/th>\n<th> Symbol <\/th>\n<th> Form <\/th>\n<th> The operation returns a value where: <\/th>\n<\/tr>\n<tr>\n<td> left shift  <\/td>\n<td> &lt;&lt; <\/td>\n<td> x &lt;&lt; n <\/td>\n<td> the bits from <code>x<\/code> are shifted left by <code>n<\/code> positions, new bits are <code>0<\/code>. <\/td>\n<\/tr>\n<tr>\n<td> right shift <\/td>\n<td> &gt;&gt; <\/td>\n<td> x &gt;&gt; n <\/td>\n<td> the bits from <code>x<\/code> are shifted right by <code>n<\/code> positions, new bits are <code>0<\/code>. <\/td>\n<\/tr>\n<tr>\n<td> bitwise NOT <\/td>\n<td> ~    <\/td>\n<td> ~x       <\/td>\n<td> each bit from <code>x<\/code> is flipped. <\/td>\n<\/tr>\n<tr>\n<td> bitwise AND <\/td>\n<td> &#038;    <\/td>\n<td> x &#038; y    <\/td>\n<td> each bit is set when both corresponding bits in <code>x<\/code> and <code>y<\/code> are <code>1<\/code>. <\/td>\n<\/tr>\n<tr>\n<td> bitwise OR  <\/td>\n<td> &#124;   <\/td>\n<td> x &#124; y   <\/td>\n<td> each bit is set when either corresponding bit in <code>x<\/code> and <code>y<\/code> is <code>1<\/code>. <\/td>\n<\/tr>\n<tr>\n<td> bitwise XOR <\/td>\n<td> ^    <\/td>\n<td> x ^ y    <\/td>\n<td> each bit is set when the corresponding bits in <code>x<\/code> and <code>y<\/code> are different. <\/td>\n<\/tr>\n<\/table>\n<\/div>\n<p>These are non-modifying operators (they do not modify their operands).<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>In the following examples, we will largely be working with 4-bit binary values.  This is for the sake of convenience and keeping the examples simple.  In actual programs, the number of bits used is based on the size of the object (e.g. a 2 byte object would store 16 bits).<\/p>\n<p>To improve readability, we may also omit the <code>0b<\/code> prefix for binary literals outside of code examples (e.g. instead of <code>0b0101<\/code>, we may opt to use <code>0101<\/code>).\n<\/div>\n<p>The bitwise operators are defined for integral types and <code>std::bitset<\/code>.  We&#8217;ll use <code>std::bitset<\/code> in our examples because it&#8217;s easier to print the output in binary.<\/p>\n<p>Avoid using the bitwise operators with signed integral operands, as many operators will return implementation-defined results prior to C++20 or have other potential gotchas that are easily avoided by using unsigned operands (or <code>std::bitset<\/code>).<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>To avoid surprises, use the bitwise operators with unsigned integral operands or <code>std::bitset<\/code>.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Bitwise left shift (&lt;&lt;) and bitwise right shift (&gt;&gt;) operators<\/p>\n<p>The <strong>bitwise left shift<\/strong> (&lt;&lt;) operator shifts bits to the left.  The left operand is an expression that provides the initial bit sequence, and the right operand is an integer number that specifies the number of bit-positions to move the bits over by.  For example, when we write <code>x &lt;&lt; 2<\/code>, we are saying &#8220;produce a value where the bits from <code>x<\/code> have been moved 2 positions to the left.&#8221;<\/p>\n<p>The left operand is not modified, and new bits shifted in from the right size are <code>0<\/code>.<\/p>\n<p>Here are some examples of left shifting the bit sequence <code>0011<\/code>:<\/p>\n<pre>\n0011 \\&lt;\\&lt; 1 is 0110\r\n0011 \\&lt;\\&lt; 2 is 1100\r\n0011 \\&lt;\\&lt; 3 is 1000\r\n<\/pre>\n<p>Note that in the third case, we shifted a <code>1<\/code> bit off the end of the number!  Bits that are shifted off the end of the bit sequence are lost forever.<\/p>\n<p>The <strong>bitwise right shift<\/strong> (>>) operator works similarly but shifts bits to the right.<\/p>\n<p>Here are some examples of right shifting the bit sequence <code>1100<\/code>:<\/p>\n<pre>\n1100 \/&gt;\/&gt; 1 is 0110\r\n1100 \/&gt;\/&gt; 2 is 0011\r\n1100 \/&gt;\/&gt; 3 is 0001\r\n<\/pre>\n<p>Note that in the third case we shifted a bit off the right end of the number, so it is lost.<\/p>\n<p>Let&#8217;s do an example in C++ that you can compile and run:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;bitset&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::bitset&lt;4&gt; x { 0b1100 };\r\n\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; (x &gt;&gt; 1) &lt;&lt; '\\n'; \/\/ shift right by 1, yielding 0110\r\n    std::cout &lt;&lt; (x &lt;&lt; 1) &lt;&lt; '\\n'; \/\/ shift left by 1, yielding 1000\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n1100\r\n0110\r\n1000\r\n<\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Bit-shifting in C++ is <a href=\"https:\/\/en.wikipedia.org\/wiki\/Endianness\">endian<\/a>-agnostic.  Left-shift is always towards the most significant bit, and right-shift towards the least significant bit.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">What!?  Aren&#8217;t operator&lt;&lt; and operator&gt;&gt; used for input and output?<\/p>\n<p>They sure are.<\/p>\n<p>Programs today typically do not make much use of the bitwise left and right shift operators to shift bits.  Rather, the bitwise left shift operator is more often used with <code>std::cout<\/code> (or other output stream objects) to output text.  Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;bitset&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    unsigned int x { 0b0100 };\r\n    x = x &lt;&lt; 1; \/\/ use operator&lt;&lt; for left shift\r\n    std::cout &lt;&lt; std::bitset&lt;4&gt;{ x } &lt;&lt; '\\n'; \/\/ use operator&lt;&lt; for output\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\n1000\r\n<\/pre>\n<p>In the above program, how does <code>operator&lt;&lt;<\/code> know to shift bits in one case and output <code>x<\/code> in another case?  The answer is that it looks at the type of the operands.  If the left operand is an integral type, then <code>operator&lt;&lt;<\/code> knows to do its usual bit-shifting behavior.  If the left operand is an output stream object like <code>std::cout<\/code>, then it knows it should do output instead.<\/p>\n<p>The same applies for <code>operator&gt;&gt;<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>This ability for operators to change their behavior based on the type of the arguments leverages a feature called <em>operator overloading<\/em>, which we introduce later in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-overloading-the-i-o-operators\/\">13.5 -- Introduction to overloading the I\/O operators<\/a>.\n<\/div>\n<p>Note that if you&#8217;re using <code>operator&lt;&lt;<\/code> for both output and left shift, parenthesization is required to use for left-shifting:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;bitset&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tstd::bitset&lt;4&gt; x{ 0b0110 };\r\n\r\n\tstd::cout &lt;&lt; x &lt;&lt; 1 &lt;&lt; '\\n'; \/\/ print value of x (0110), then 1\r\n\tstd::cout &lt;&lt; (x &lt;&lt; 1) &lt;&lt; '\\n'; \/\/ print x left shifted by 1 (1100)\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n01101\r\n1100\r\n<\/pre>\n<p>The first line prints the value of <code>x<\/code> (<code>0110<\/code>), and then the literal <code>1<\/code>.  The second line prints the value of <code>x<\/code> left-shifted by <code>1<\/code> (<code>1100<\/code>).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Bitwise NOT<\/p>\n<p>The <strong>bitwise NOT<\/strong> operator (~) is conceptually straightforward: It simply flips each bit from a <code>0<\/code> to a <code>1<\/code>, or vice versa.<\/p>\n<pre>\n~0011 is 1100\r\n~0000 0100 is 1111 1011\r\n<\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>When interpreted as an integer, the number of bits in the result of a bitwise NOT affects the value produced.<\/p>\n<p>The following program illustrates this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;bitset&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::bitset&lt;4&gt; b4{ 0b100 }; \/\/ b4 is 0100\r\n    std::bitset&lt;8&gt; b8{ 0b100 }; \/\/ b8 is 0000 0100\r\n\r\n    std::cout &lt;&lt; \"Initial values:\\n\";\r\n    std::cout &lt;&lt; \"Bits: \" &lt;&lt; b4 &lt;&lt; ' ' &lt;&lt; b8 &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"Values: \" &lt;&lt; b4.to_ulong() &lt;&lt; ' ' &lt;&lt; b8.to_ulong() &lt;&lt; \"\\n\\n\";    \r\n\r\n    b4 = ~b4; \/\/ flip b4 to 1011\r\n    b8 = ~b8; \/\/ flip b8 to 1111 1011\r\n    \r\n    std::cout &lt;&lt; \"After bitwise NOT:\\n\";\r\n    std::cout &lt;&lt; \"Bits: \" &lt;&lt; b4 &lt;&lt; ' ' &lt;&lt; b8 &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"Values: \" &lt;&lt; b4.to_ulong() &lt;&lt; ' ' &lt;&lt; b8.to_ulong() &lt;&lt; '\\n';    \r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nInitial values:\r\nBits: 0100 00000100\r\nValues: 4 4\r\n\r\nAfter bitwise NOT:\r\nBits: 1011 11111011\r\nValues: 11 251\r\n<\/pre>\n<p>Initially, <code>b4<\/code> and <code>b8<\/code> are both set to <code>0b100<\/code>.  When padded with leading zeros, <code>b4<\/code> ends up as <code>0100<\/code> and <code>b8<\/code> as <code>00000100<\/code>, which is printed on the next line.<\/p>\n<p>We then use the <code>to_ulong()<\/code> member function to interpret the value of the bits, interpreted as a <code>long<\/code> integer.  You can see that both <code>b4<\/code> and <code>b8<\/code> print the value <code>4<\/code>.  Despite the different number of bits, they both represent the same value.  This is because leading zero bits contribute no value to the interpreted integer.<\/p>\n<p>Then we use bitwise NOT to flip the bits of each, so <code>b4<\/code> now has bits <code>1011<\/code> and <code>b8<\/code> now has bits <code>1111 1011<\/code>.  When printed as an integer, this prints the values <code>11<\/code> and <code>251<\/code>.  As you can see, these values are no longer identical.  This is because leading ones do contribute value to the interpreted integer, and <code>b8<\/code> has more leading ones than <code>b4<\/code>.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Bitwise OR<\/p>\n<p><strong>Bitwise OR<\/strong> (|) works much like its logical OR counterpart.  If you remember, logical OR evaluates to <code>true<\/code> (<code>1<\/code>) if either of the <em>operands<\/em> are <code>true<\/code>, otherwise it evaluates to <code>false<\/code> (<code>0<\/code>). <\/p>\n<p>However, whereas logical OR is applied to the entire operand (to produce a single true or false result), bitwise OR is applied to each pair of bits in the operands (to produce a single true or false result for each bit).<\/p>\n<p>Let&#8217;s illustrate this with an example.  Consider the expression <code>0b0101 | 0b0110<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>To do any binary bitwise operation by hand, it is easiest to line the two operands up like this:<\/p>\n<pre>\n0 1 0 1 OR (or whatever bitwise operation you are doing)\r\n0 1 1 0\r\n<\/pre>\n<p>Then, apply the operation to each <em>column<\/em> of bits, and write the result underneath.\n<\/div>\n<p>In the first column, <code>0<\/code> OR <code>0<\/code> is <code>0<\/code>, so we put a 0 underneath the line.<\/p>\n<pre>\n0 1 0 1 OR\r\n0 1 1 0\r\n-------\r\n0\r\n<\/pre>\n<p>Second column, <code>1<\/code> OR <code>1<\/code> is <code>1<\/code>.  Third column <code>0<\/code> or <code>1<\/code> is <code>1<\/code>.  And fourth column, <code>1<\/code> or <code>0<\/code> is <code>1<\/code>.<\/p>\n<pre>\n0 1 0 1 OR\r\n0 1 1 0\r\n-------\r\n0 1 1 1\r\n<\/pre>\n<p>Our result is <code>0111<\/code> binary.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;bitset&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; (std::bitset&lt;4&gt;{ 0b0101 } | std::bitset&lt;4&gt;{ 0b0110 }) &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n0111\r\n<\/pre>\n<p>We can do the same thing to compound bitwise OR expressions, such as <code>0b0111 | 0b0011 | 0b0001<\/code>.  If any of the bits in a column are <code>1<\/code>, the result of that column is <code>1<\/code>:<\/p>\n<pre>\n0 1 1 1 OR\r\n0 0 1 1 OR\r\n0 0 0 1\r\n--------\r\n0 1 1 1\r\n<\/pre>\n<p>Here&#8217;s code for the above:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;bitset&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; (std::bitset&lt;4&gt;{ 0b0111 } | std::bitset&lt;4&gt;{ 0b0011 } | std::bitset&lt;4&gt;{ 0b0001 }) &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n0111\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Bitwise AND<\/p>\n<p><strong>Bitwise AND<\/strong> (&#038;) works similarly to the above, except it uses AND logic instead of OR logic.  That is, for each pair of bits in the operands, Bitwise AND sets the resulting bit to <code>true<\/code> (<code>1<\/code>) if both paired bits are <code>1<\/code>, and <code>false<\/code> (<code>0<\/code>) otherwise.<\/p>\n<p>Consider the expression <code>0b0101 &amp; 0b0110<\/code>.  Lining each of the bits up and applying bitwise AND to each column of bits:<\/p>\n<pre>\n0 1 0 1 AND\r\n0 1 1 0\r\n--------\r\n0 1 0 0\r\n<\/pre>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;bitset&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; (std::bitset&lt;4&gt;{ 0b0101 } &amp; std::bitset&lt;4&gt;{ 0b0110 }) &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n0100\r\n<\/pre>\n<p>Similarly, we can do the same thing to compound bitwise AND expressions, such as <code>0b0001 &amp; 0b0011 &amp; 0b0111<\/code>.  If all of the bits in a column are <code>1<\/code>, the result of that column is <code>1<\/code>.<\/p>\n<pre>\n0 0 0 1 AND\r\n0 0 1 1 AND\r\n0 1 1 1\r\n--------\r\n0 0 0 1\r\n<\/pre>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;bitset&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tstd::cout &lt;&lt; (std::bitset&lt;4&gt;{ 0b0001 } &amp; std::bitset&lt;4&gt;{ 0b0011 } &amp; std::bitset&lt;4&gt;{ 0b0111 }) &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n0001\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Bitwise XOR<\/p>\n<p>The last operator is the <strong>bitwise XOR<\/strong> (^), also known as <strong>exclusive or<\/strong>.<\/p>\n<p>For each pair of bits in the operands, Bitwise XOR sets the resulting bit to <code>true<\/code> (<code>1<\/code>) when exactly one of the paired bits is <code>1<\/code>, and <code>false<\/code> (<code>0<\/code>) otherwise.  Put another way, Bitwise XOR sets the resulting bit to <code>true<\/code> when the paired bits are different (one is a <code>0<\/code> and the other a <code>1<\/code>).<\/p>\n<p>Consider the expression <code>0b0110 ^ 0b0011<\/code>:<\/p>\n<pre>\n0 1 1 0 XOR\r\n0 0 1 1\r\n-------\r\n0 1 0 1\r\n<\/pre>\n<p>It is also possible to evaluate compound XOR expression column style, such as <code>0b0001 ^ 0b0011 ^ 0b0111<\/code>.  If there are an even number of <code>1<\/code> bits in a column, the result is <code>0<\/code>.  If there are an odd number of <code>1<\/code> bits in a column, the result is <code>1<\/code>.<\/p>\n<pre>\n0 0 0 1 XOR\r\n0 0 1 1 XOR\r\n0 1 1 1\r\n--------\r\n0 1 0 1\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Bitwise assignment operators<\/p>\n<p>Similar to the arithmetic assignment operators, C++ provides bitwise assignment operators.  These do modify the left operand.<\/p>\n<div class=\"cpp-table-wrapper\">\n<table class=\"cpp-table\">\n<tr>\n<th> Operator <\/th>\n<th> Symbol <\/th>\n<th> Form <\/th>\n<th> The operation modifies the left operand where: <\/th>\n<\/tr>\n<tr>\n<td> left shift  <\/td>\n<td> &lt;&lt; <\/td>\n<td> x &lt;&lt;= n <\/td>\n<td> the bits in <code>x<\/code> are shifted left by <code>n<\/code> positions, new bits are <code>0<\/code>. <\/td>\n<\/tr>\n<tr>\n<td> right shift <\/td>\n<td> &gt;&gt; <\/td>\n<td> x &gt;&gt;= n <\/td>\n<td> the bits in <code>x<\/code> are shifted right by <code>n<\/code> positions, new bits are <code>0<\/code>. <\/td>\n<\/tr>\n<tr>\n<td> bitwise AND <\/td>\n<td> &#038;    <\/td>\n<td> x &#038;= y    <\/td>\n<td> each bit is set when both corresponding bits in <code>x<\/code> and <code>y<\/code> are <code>1<\/code>. <\/td>\n<\/tr>\n<tr>\n<td> bitwise OR  <\/td>\n<td> &#124;   <\/td>\n<td> x &#124;= y   <\/td>\n<td> each bit is set when either corresponding bit in <code>x<\/code> and <code>y<\/code> is <code>1<\/code>. <\/td>\n<\/tr>\n<tr>\n<td> bitwise XOR <\/td>\n<td> ^    <\/td>\n<td> x ^= y    <\/td>\n<td> each bit is set when the corresponding bits in <code>x<\/code> and <code>y<\/code> are different. <\/td>\n<\/tr>\n<\/table>\n<\/div>\n<p>For example, instead of writing <code>x = x &gt;&gt; 1;<\/code>, you can write <code>x &gt;&gt;= 1;<\/code>.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;bitset&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::bitset&lt;4&gt; bits { 0b0100 };\r\n    bits &gt;&gt;= 1;\r\n    std::cout &lt;&lt; bits &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\n0010\r\n<\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>There is no bitwise NOT assignment operator.  This is because the other bitwise operators are binary, but bitwise NOT is unary (so what would go on the right-hand side of a <code>~=<\/code> operator?).  If you want to flip all of the bits of an object, you can use normal assignment: <code>x = ~x;<\/code>\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Bitwise operators perform integral promotion on smaller integral types <span class=\"cpp-section-pill cpp-section-advanced\">Advanced<\/span><\/p>\n<p>If the operand(s) of a bitwise operator are an integral type smaller than an <code>int<\/code>, those operands will be promoted (converted) to <code>int<\/code> or <code>unsigned int<\/code>, and the result returned will also be an <code>int<\/code> or <code>unsigned int<\/code>.  For example, if our operands are <code>unsigned short<\/code>, they will be promoted (converted) to <code>unsigned int<\/code>, and the result of the operation will be returned as an <code>unsigned int<\/code>.<\/p>\n<p>In many cases, this won&#8217;t matter.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover integral promotion in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/floating-point-and-integral-promotion\/\">10.2 -- Floating-point and integral promotion<\/a>.\n<\/p><\/div>\n<p>However, when using bitwise operators on integral types narrower than <code>int<\/code> or <code>unsigned int<\/code>, there are two cases to watch out for:<\/p>\n<ul>\n<li><code>operator~<\/code> and <code>operator&lt;&lt;<\/code> are width-sensitive and may produce different results depending on the width of the operand.\n<\/li>\n<li>Initializing or assigning the result to a variable of the smaller integral type is a narrowing conversion (since converting an <code>int<\/code> or <code>unsigned int<\/code> to a smaller integral type may result in data loss).  This is disallowed in list initialization, and your compiler may or may not complain about a narrowing assignment.\n<\/li>\n<\/ul>\n<p>The following program exhibits these issues (assuming 32-bit ints):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;bitset&gt;\r\n#include &lt;cstdint&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::uint8_t c { 0b00001111 };\r\n    \r\n    std::cout &lt;&lt; std::bitset&lt;32&gt;(~c) &lt;&lt; '\\n';     \/\/ incorrect: prints 11111111111111111111111111110000\r\n    std::cout &lt;&lt; std::bitset&lt;32&gt;(c &lt;&lt; 6) &lt;&lt; '\\n'; \/\/ incorrect: prints 0000000000000000001111000000\r\n    std::uint8_t cneg { ~c };                     \/\/ error: narrowing conversion from unsigned int to std::uint8_t\r\n    c = ~c;                                       \/\/ possible warning: narrowing conversion from unsigned int to std::uint8_t\r\n \r\n    return 0;\r\n}<\/code><\/pre>\n<p>These issues can be addressed by using <code>static_cast<\/code> to convert the result of your bitwise operation back to the narrower integral type.  The following program produces the correct results:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;bitset&gt;\r\n#include &lt;cstdint&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::uint8_t c { 0b00001111 };\r\n\r\n    std::cout &lt;&lt; std::bitset&lt;32&gt;(static_cast&lt;std::uint8_t&gt;(~c)) &lt;&lt; '\\n';     \/\/ correct: prints 00000000000000000000000011110000\r\n    std::cout &lt;&lt; std::bitset&lt;32&gt;(static_cast&lt;std::uint8_t&gt;(c &lt;&lt; 6)) &lt;&lt; '\\n'; \/\/ correct: prints 0000000000000000000011000000\r\n    std::uint8_t cneg { static_cast&lt;std::uint8_t&gt;(~c) };                     \/\/ compiles\r\n    c = static_cast&lt;std::uint8_t&gt;(~c);                                       \/\/ no warning\r\n \r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Bitwise operators will promote operands with narrower integral types to <code>int<\/code> or <code>unsigned int<\/code>.<\/p>\n<p><code>operator~<\/code> and <code>operator&lt;&lt;<\/code> are width-sensitive and may produce different results depending on the width of the operand.  <code>static_cast<\/code> the result of such bitwise operations back to the narrower integral type before using to ensure correct results.\n<\/div>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Avoid bit shifting on integral types smaller than <code>int<\/code> whenever possible.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Summary<\/p>\n<p>Summarizing how to evaluate bitwise operations utilizing the column method:<\/p>\n<p>When evaluating bitwise OR, if any bit in a column is 1, the result for that column is 1.<br \/>\nWhen evaluating bitwise AND, if all bits in a column are 1, the result for that column is 1.<br \/>\nWhen evaluating bitwise XOR, if there are an odd number of 1 bits in a column, the result for that column is 1.<\/p>\n<p>In the next lesson, we&#8217;ll explore how these operators can be used in conjunction with bit masks to facilitate bit manipulation.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>a) What does 0110 >> 2 evaluate to in binary?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>0110 >> 2 evaluates to 0001\n<\/p><\/div>\n<p>b) What does the following evaluate to in binary: 0011 | 0101?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<pre>\n0 0 1 1 OR\r\n0 1 0 1\r\n--------\r\n0 1 1 1\r\n<\/pre>\n<\/div>\n<p>c) What does the following evaluate to in binary: 0011 &#038; 0101?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<pre>\n0 0 1 1 AND\r\n0 1 0 1\r\n--------\r\n0 0 0 1\r\n<\/pre>\n<\/div>\n<p>d) What does the following evaluate to in binary (0011 | 0101) &#038; 1001?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<pre>\nInside the parenthesis:\r\n\r\n0 0 1 1 OR\r\n0 1 0 1\r\n--------\r\n0 1 1 1\r\n\r\nThen:\r\n\r\n0 1 1 1 AND\r\n1 0 0 1\r\n--------\r\n0 0 0 1\r\n<\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>A bitwise rotation is like a bitwise shift, except that any bits shifted off one end are added back to the other end.  For example <code>0b1001 &lt;&lt; 1<\/code> would be <code>0b0010<\/code>, but a left rotate by 1 would result in <code>0b0011<\/code> instead.  Implement a function that does a left rotate on a <code>std::bitset&lt;4&gt;<\/code>.  For this one, it&#8217;s okay to use test() and set().<\/p>\n<p>The following code should execute:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;bitset&gt;\r\n#include &lt;iostream&gt;\r\n\r\n\/\/ \"rotl\" stands for \"rotate left\"\r\nstd::bitset&lt;4&gt; rotl(std::bitset&lt;4&gt; bits)\r\n{\r\n\/\/ Your code here\r\n}\r\n\r\nint main()\r\n{\r\n\tstd::bitset&lt;4&gt; bits1{ 0b0001 };\r\n\tstd::cout &lt;&lt; rotl(bits1) &lt;&lt; '\\n';\r\n\r\n\tstd::bitset&lt;4&gt; bits2{ 0b1001 };\r\n\tstd::cout &lt;&lt; rotl(bits2) &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>and print the following:<\/p>\n<pre>\n0010\r\n0011\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;bitset&gt;\r\n#include &lt;iostream&gt;\r\n\r\nstd::bitset&lt;4&gt; rotl(std::bitset&lt;4&gt; bits)\r\n{\r\n\t\/\/ keep track of whether the leftmost bit was a 1\r\n\tconst bool leftbit{ bits.test(3) };\r\n\r\n\tbits &lt;&lt;= 1; \/\/ do left shift (which shifts the leftmost bit off the end)\r\n\r\n\t\/\/ if the left bit was a 1\r\n\tif (leftbit)\r\n\t\tbits.set(0); \/\/ set the rightmost bit to a 1\r\n\r\n\treturn bits;\r\n}\r\n\r\nint main()\r\n{\r\n\tstd::bitset&lt;4&gt; bits1{ 0b0001 };\r\n\tstd::cout &lt;&lt; rotl(bits1) &lt;&lt; '\\n';\r\n\r\n\tstd::bitset&lt;4&gt; bits2{ 0b1001 };\r\n\tstd::cout &lt;&lt; rotl(bits2) &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>We have named the function &#8220;rotl&#8221; rather than &#8220;rotateLeft&#8221;, because &#8220;rotl&#8221; is a well-established name in computer science and also the name of the standard function, <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/numeric\/rotl\"><code>std::rotl<\/code><\/a>.\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #3<\/p>\n<p>Extra credit: Redo quiz #2 but don&#8217;t use the test and set functions (use bitwise operators).<\/p>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_0'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_0\" style=\"display:none; margin-bottom: 1em\">Hint: How might we get the leftmost bit into the rightmost position?<\/div>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_1'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_1\" style=\"display:none; margin-bottom: 1em\">Hint: Consider a &#8220;shift&#8221; in your perspective<\/div>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_5'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_5\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;bitset&gt;\r\n#include &lt;iostream&gt;\r\n\r\n\/\/ h\/t to reader Chris for this solution\r\nstd::bitset&lt;4&gt; rotl(std::bitset&lt;4&gt; bits)\r\n{\r\n\t\/\/ bits &lt;&lt; 1 does the left shift\r\n\t\/\/ bits &gt;&gt; 3 handle the rotation of the leftmost bit\r\n\treturn (bits&lt;&lt;1) | (bits&gt;&gt;3);\r\n}\r\n\r\nint main()\r\n{\r\n\tstd::bitset&lt;4&gt; bits1{ 0b0001 };\r\n\tstd::cout &lt;&lt; rotl(bits1) &lt;&lt; '\\n';\r\n\r\n\tstd::bitset&lt;4&gt; bits2{ 0b1001 };\r\n\tstd::cout &lt;&lt; rotl(bits2) &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/bit-manipulation-with-bitwise-operators-and-bit-masks\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">O.3<\/span>Bit manipulation with bitwise operators and bit masks\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/bit-flags-and-bit-manipulation-via-stdbitset\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">O.1<\/span>Bit flags and bit manipulation via std::bitset\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>The bitwise operators C++ provides 6 bit manipulation operators, often called operators: Operator Symbol Form The operation returns a value where: left shift &lt;&lt; x &lt;&lt; n the bits from x are shifted left by n positions, new bits are 0. right shift &gt;&gt; x &gt;&gt; n the bits from &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/61"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=61"}],"version-history":[{"count":61,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/61\/revisions"}],"predecessor-version":[{"id":18229,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/61\/revisions\/18229"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=61"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=61"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=61"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}