{"id":2809,"date":"2015-10-05T16:20:13","date_gmt":"2015-10-06T00:20:13","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=2809"},"modified":"2025-01-06T14:06:38","modified_gmt":"2025-01-06T22:06:38","slug":"chapter-17-summary-and-quiz","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-17-summary-and-quiz\/","title":{"rendered":"17.x &#8212; Chapter 17 summary and quiz"},"content":{"rendered":"<p class=\"cpp-section\">Chapter Review<\/p>\n<p><strong>Fixed-size arrays<\/strong> (or <strong>fixed-length arrays<\/strong>) require that the length of the array be known at the point of instantiation, and that length cannot be changed afterward.    C-style arrays and <code>std::array<\/code> are both fixed-size arrays.  Dynamic arrays can be resized at runtime.  <code>std::vector<\/code> is a dynamic array.<\/p>\n<p>The length of a <code>std::array<\/code> must be a constant expression. Most often, the value provided for the length will be an integer literal, constexpr variable, or an unscoped enumerator.<\/p>\n<p><code>std::array<\/code> is an aggregate. This means it has no constructors, and instead is initialized using aggregate initialization.<\/p>\n<p>Define your <code>std::array<\/code> as constexpr whenever possible.  If your <code>std::array<\/code> is not constexpr, consider using a <code>std::vector<\/code> instead.<\/p>\n<p>Use class template argument deduction (CTAD) to have the compiler deduce the type and length of a std::array from its initializers. <\/p>\n<p><code>std::array<\/code> is implemented as a template struct whose declaration looks like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template&lt;typename T, std::size_t N&gt; \/\/ N is a non-type template parameter\r\nstruct array;<\/code><\/pre>\n<p>The non-type template parameter representing the array length (<code>N<\/code>) has type <code>std::size_t<\/code>.<\/p>\n<p>To get the length of a <code>std::array<\/code>:<\/p>\n<ul>\n<li>We can ask a <code>std::array<\/code> object for its length using the <code>size()<\/code> member function (which returns the length as unsigned <code>size_type<\/code>).\n<\/li>\n<li>In C++17, we can use the <code>std::size()<\/code> non-member function (which for <code>std::array<\/code> just calls the <code>size()<\/code> member function, thus returning the length as unsigned <code>size_type<\/code>).\n<\/li>\n<li>In C++20, we can use the <code>std::ssize()<\/code> non-member function, which returns the length as a large <em>signed<\/em> integral type (usually<code>std::ptrdiff_t<\/code>).\n<\/li>\n<\/ul>\n<p>All three of these functions will return the length as a constexpr value, except when called on a <code>std::array<\/code> passed by reference.  This defect has been addressed in C++23 by <a href=\"https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2022\/p2280r4.html\">P2280<\/a>.<\/p>\n<p>To index a <code>std::array<\/code>:<\/p>\n<ul>\n<li>Use the subscript operator (<code>operator[]<\/code>).  No bounds checking is done in this case, and passing in an invalid index will result in undefined behavior.\n<\/li>\n<li>Use the <code>at()<\/code> member function that does subscripting with runtime bounds checking.  We recommend avoiding this function since we typically want to do bounds checking before indexing, or we want compile-time bounds checking.\n<\/li>\n<li>Use the <code>std::get()<\/code> function template, which takes the index as a non-type template argument, and does compile-time bounds checking.\n<\/li>\n<\/ul>\n<p>You can pass <code>std::array<\/code> with different element types and lengths to a function using a function template with the template parameter declaration <code>template &lt;typename T, std::size_t N&gt;<\/code>.  Or in C++20, use <code>template &lt;typename T, auto N&gt;<\/code>.<\/p>\n<p>Returning a <code>std::array<\/code> by value will make a copy of the array and all elements, but this may be okay if the array is small and the elements aren&#8217;t expensive to copy.  Using an out parameter instead may be a better choice in some contexts.<\/p>\n<p>When initializing a <code>std::array<\/code> with a struct, class, or array and not providing the element type with each initializer, you\u2019ll need an extra pair of braces so that the compiler will properly interpret what to initialize.  This is an artifact of aggregate initialization, and other standard library container types (that use list constructors) do not require the double braces in these cases. <\/p>\n<p>Aggregates in C++ support a concept called <strong>brace elision<\/strong>, which lays out some rules for when multiple braces may be omitted. Generally, you can omit braces when initializing a <code>std::array<\/code> with scalar (single) values, or when initializing with class types or arrays where the type is explicitly named with each element.<\/p>\n<p>You can not have an array of references, but you can have an array of <code>std::reference_wrapper<\/code>, which behaves like a modifiable lvalue reference.<\/p>\n<p>There are a few things worth noting about <code>std::reference_wrapper<\/code>:<\/p>\n<ul>\n<li><code>Operator=<\/code> will reseat a <code>std::reference_wrapper<\/code> (change which object is being referenced).\n<\/li>\n<li><code>std::reference_wrapper&lt;T&gt;<\/code> will implicitly convert to <code>T&amp;<\/code>.\n<\/li>\n<li>The <code>get()<\/code> member function can be used to get a <code>T&amp;<\/code>. This is useful when we want to update the value of the object being referenced.\n<\/li>\n<\/ul>\n<p>The <code>std::ref()<\/code> and <code>std::cref()<\/code> functions were provided as shortcuts to create <code>std::reference_wrapper<\/code> and <code>const std::reference_wrapper<\/code> wrapped objects.<\/p>\n<p>Use <code>static_assert<\/code> whenever possible to ensure a <code>constexpr std::array<\/code> using CTAD has the correct number of initializers.<\/p>\n<p>C-style arrays were inherited from the C language, and are built-in to the core language of C++.  Because they are part of the core language, C-style arrays have their own special declaration syntax. In an C-style array declaration, we use square brackets ([]) to tell the compiler that a declared object is a C-style array. Inside the square brackets, we can optionally provide the length of the array, which is an integral value of type std::size_t that tells the compiler how many elements are in the array.  The length of a C-style array must be a constant expression.<\/p>\n<p>C-style arrays are aggregates, which means they can be initialized using aggregate initialization.  When using an initializer list to initialize all elements of a C-style array, it\u2019s preferable to omit the length and let the compiler calculate the length of the array.<\/p>\n<p>C-style arrays can be indexed via <code>operator[]<\/code>.  The index of a C-style array can be either a signed or an unsigned integer, or an unscoped enumeration. This means that C-style arrays are not subject to all of the sign conversion indexing issues that the standard library container classes have!<\/p>\n<p>C-style arrays can be const or constexpr.<\/p>\n<p>To get the length of a C-style array:<\/p>\n<ul>\n<li>In C++17, we can use the <code>std::size()<\/code> non-member function, which returns the length as unsigned <code>std::size_t<\/code>.\n<\/li>\n<li>In C++20, we can use the <code>std::ssize()<\/code> non-member function, which returns the length as a large <em>signed<\/em> integral type (usually<code>std::ptrdiff_t<\/code>).\n<\/li>\n<\/ul>\n<p>In most cases, when a C-style array is used in an expression, the array will be implicitly converted into a pointer to the element type, initialized with the address of the first element (with index 0). Colloquially, this is called <strong>array decay<\/strong> (or just decay for short).<\/p>\n<p><strong>Pointer arithmetic<\/strong> is a feature the allows us to apply certain integer arithmetic operators (addition, subtraction, increment, or decrement) to a pointer to produce a new memory address.  Given some pointer <code>ptr<\/code>, <code>ptr + 1<\/code> returns the address of the next <em>object<\/em> in memory (based on the type being pointed to).<\/p>\n<p>Use subscripting when indexing from the start of the array (element 0), so the array indices line up with the element.<br \/>\nUse pointer arithmetic when doing relative positioning from a given element.<\/p>\n<p>C-style strings are just C-style arrays whose element type is <code>char<\/code> or <code>const char<\/code>.  As such, C-style strings will decay.<\/p>\n<p>The <strong>dimension<\/strong> of an array is the number of indices needed to select an element.<\/p>\n<p>An array containing only a single dimension is called a <strong>single-dimensional array<\/strong> or a <strong>one-dimensional array<\/strong> (sometimes abbreviated as a <strong>1d array<\/strong>).  An array of arrays is called a <strong>two-dimensional array<\/strong> (sometimes abbreviated as a <strong>2d array<\/strong>) because it has two subscripts.  Arrays with more than one dimension are called <strong>multidimensional arrays<\/strong>.  <strong>Flattening<\/strong> an array is a process of reducing the dimensionality of an array (often down to a single dimension).<\/p>\n<p>In C++23, <code>std::mdspan<\/code> is a view that provides a multidimensional array interface for a contiguous sequence of elements.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>What&#8217;s wrong with each of these snippets, and how would you fix it?<\/p>\n<p>a)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::array arr { 0, 1, 2, 3 };\r\n\r\n    for (std::size_t count{ 0 }; count &lt;= std::size(arr); ++count)\r\n    {\r\n        std::cout &lt;&lt; arr[count] &lt;&lt; ' ';\r\n    }\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>The for-loop has an off-by-one error, and tries to access the array element with index 4, which does not exist.<\/p>\n<p>Solution: the conditional in the for loop should use &lt; instead of &lt;=.\n<\/p><\/div>\n<p>b)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printArray(int array[])\r\n{\r\n    for (int element : array)\r\n    {\r\n        std::cout &lt;&lt; element &lt;&lt; ' ';\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int array[] { 9, 7, 5, 3, 1 };\r\n\r\n    printArray(array);\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p><code>array<\/code> decays to a pointer when it is passed to <code>printArray()<\/code>.  Range-based for-loops can&#8217;t work with a pointer to an array because the size of the array isn&#8217;t known.<\/p>\n<p>Solution: use <code>std::array<\/code> instead, which doesn&#8217;t decay.\n<\/div>\n<p>c)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter the number of test scores: \";\r\n    std::size_t length{};\r\n    std::cin &gt;&gt; length;\r\n\r\n    std::array&lt;int, length&gt; scores;\r\n\r\n    for (std::size_t i { 0 } ; i &lt; length; ++i)\r\n    {\r\n        std::cout &lt;&lt; \"Enter score \" &lt;&lt; i &lt;&lt; \": \";\r\n        std::cin &gt;&gt; scores[i];\r\n    }\r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<p><code>length<\/code> is not a constant expression, and cannot be used to define the length of <code>std::array<\/code>.<\/p>\n<p>Solution: use a <code>std::vector<\/code> instead.\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>In this quiz, we&#8217;re going to implement Roscoe&#8217;s potion emporium, the finest potion shop in the land!  This is going to be a bigger challenge.<\/p>\n<p>Implement a program that outputs the following:<\/p>\n<pre>\nWelcome to Roscoe's potion emporium!\r\nEnter your name: Alex\r\nHello, Alex, you have 85 gold.\r\n\r\nHere is our selection for today:\r\n0) healing costs 20\r\n1) mana costs 30\r\n2) speed costs 12\r\n3) invisibility costs 50\r\nEnter the number of the potion you'd like to buy, or 'q' to quit: a\r\nThat is an invalid input.  Try again: 3\r\nYou purchased a potion of invisibility.  You have 35 gold left.\r\n\r\nHere is our selection for today:\r\n0) healing costs 20\r\n1) mana costs 30\r\n2) speed costs 12\r\n3) invisibility costs 50\r\nEnter the number of the potion you'd like to buy, or 'q' to quit: 4\r\nThat is an invalid input.  Try again: 2\r\nYou purchased a potion of speed.  You have 23 gold left.\r\n\r\nHere is our selection for today:\r\n0) healing costs 20\r\n1) mana costs 30\r\n2) speed costs 12\r\n3) invisibility costs 50\r\nEnter the number of the potion you'd like to buy, or 'q' to quit: 2\r\nYou purchased a potion of speed.  You have 11 gold left.\r\n\r\nHere is our selection for today:\r\n0) healing costs 20\r\n1) mana costs 30\r\n2) speed costs 12\r\n3) invisibility costs 50\r\nEnter the number of the potion you'd like to buy, or 'q' to quit: 4\r\nYou can not afford that.\r\n\r\nHere is our selection for today:\r\n0) healing costs 20\r\n1) mana costs 30\r\n2) speed costs 12\r\n3) invisibility costs 50\r\nEnter the number of the potion you'd like to buy, or 'q' to quit: q\r\n\r\nYour inventory contains: \r\n2x potion of speed\r\n1x potion of invisibility\r\nYou escaped with 11 gold remaining.\r\n\r\nThanks for shopping at Roscoe's potion emporium!\r\n<\/pre>\n<p>The player starts with a randomized amount of gold, between 80 and 120.<\/p>\n<p>Sound fun?  Let&#8217;s do it!  Because this will be hard to implement all at once, we&#8217;ll develop this in steps.<\/p>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #1<\/p>\n<p>Create a <code>Potion<\/code> namespace containing an enum named <code>Type<\/code> containing the potion types.  Create two <code>std::array<\/code>: an <code>int<\/code> array to hold the potion costs, and a <code>std::string_view<\/code> array to hold the potion names.<\/p>\n<p>Also write a function named <code>shop()<\/code> that enumerates through the list of <code>Potions<\/code> and prints their numbers, names, and cost.<\/p>\n<p>The program should output the following:<\/p>\n<pre>\nHere is our selection for today:\r\n0) healing costs 20\r\n1) mana costs 30\r\n2) speed costs 12\r\n3) invisibility costs 50\r\n<\/pre>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_0'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_0\" style=\"display:none; margin-bottom: 1em\">Hint: We show a method for iterating through an enumeration using a range-based for-loop in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdarray-and-enumerations\/\">17.6 -- std::array and enumerations<\/a>.<\/div>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nnamespace Potion\r\n{\r\n    enum Type\r\n    {\r\n    healing,\r\n    mana,\r\n    speed,\r\n    invisibility,\r\n    max_potions\r\n    };\r\n\r\n    constexpr std::array types { healing, mana, speed, invisibility }; \/\/ An array of our enumerators\r\n\r\n    \/\/ We could put these in a struct, but since we only have two attributes we'll keep them separate for now\r\n    \/\/ We will explicitly define the element type so we don't have to use the sv suffix\r\n    constexpr std::array&lt;std::string_view, max_potions&gt; name { \"healing\", \"mana\", \"speed\", \"invisibility\" };\r\n    constexpr std::array cost { 20, 30, 12, 50 };\r\n\r\n    static_assert(std::size(types) == max_potions);  \/\/ ensure 'all' contains the correct number of enumerators\r\n    static_assert(std::size(cost) == max_potions);\r\n    static_assert(std::size(name) == max_potions);\r\n}\r\n\r\nvoid shop()\r\n{\r\n    std::cout &lt;&lt; \"Here is our selection for today:\\n\";\r\n\r\n    for (auto p: Potion::types)\r\n        std::cout &lt;&lt; p &lt;&lt; \") \" &lt;&lt; Potion::name[p] &lt;&lt; \" costs \" &lt;&lt; Potion::cost[p] &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    shop();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #2<\/p>\n<p>Create a <code>Player<\/code> class to store the player&#8217;s name, potion inventory, and gold.  Add the introductory and goodbye text for Roscoe&#8217;s emporium.  Get the player&#8217;s name and randomize their gold.<\/p>\n<p>Use the &#8220;Random.h&#8221; file in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/global-random-numbers-random-h\/#RandomH\">8.15 -- Global random numbers (Random.h)<\/a> to make randomization easy.<\/p>\n<p>The program should output the following:<\/p>\n<pre>\nWelcome to Roscoe's potion emporium!\r\nEnter your name: Alex\r\nHello, Alex, you have 84 gold.\r\n\r\nHere is our selection for today:\r\n0) healing costs 20\r\n1) mana costs 30\r\n2) speed costs 12\r\n3) invisibility costs 50\r\n\r\nThanks for shopping at Roscoe's potion emporium!\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n#include \"Random.h\"\r\n\r\nnamespace Potion\r\n{\r\n    enum Type\r\n    {\r\n        healing,\r\n        mana,\r\n        speed,\r\n        invisibility,\r\n        max_potions\r\n    };\r\n\r\n    constexpr std::array types { healing, mana, speed, invisibility }; \/\/ An array of our enumerators\r\n\r\n    \/\/ We could put these in a struct, but since we only have two attributes we'll keep them separate for now\r\n    \/\/ We will explicitly define the element type so we don't have to use the sv suffix\r\n    constexpr std::array&lt;std::string_view, max_potions&gt; name { \"healing\", \"mana\", \"speed\", \"invisibility\" };\r\n    constexpr std::array cost { 20, 30, 12, 50 };\r\n\r\n    static_assert(std::size(types) == max_potions);  \/\/ ensure 'all' contains the correct number of enumerators\r\n    static_assert(std::size(cost) == max_potions);\r\n    static_assert(std::size(name) == max_potions);\r\n}\r\n\r\nclass Player\r\n{\r\nprivate:\r\n    static constexpr int s_minStartingGold { 80 };\r\n    static constexpr int s_maxStartingGold { 120 };\r\n\r\n    std::string m_name {};\r\n    int m_gold {};\r\n    std::array&lt;int, Potion::max_potions&gt; m_inventory { };\r\n\r\npublic:\r\n    explicit Player(std::string_view name) :\r\n        m_name { name },\r\n        m_gold { Random::get(s_minStartingGold, s_maxStartingGold) }\r\n    { \r\n    }\r\n\r\n    int gold() const { return m_gold; }\r\n    int inventory(Potion::Type p) const { return m_inventory[p]; }\r\n};\r\n\r\nvoid shop()\r\n{\r\n    std::cout &lt;&lt; \"Here is our selection for today:\\n\";\r\n\r\n    for (auto p: Potion::types)\r\n        std::cout &lt;&lt; p &lt;&lt; \") \" &lt;&lt; Potion::name[p] &lt;&lt; \" costs \" &lt;&lt; Potion::cost[p] &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Welcome to Roscoe's potion emporium!\\n\";\r\n    std::cout &lt;&lt; \"Enter your name: \";\r\n\r\n    std::string name{};\r\n    std::getline(std::cin &gt;&gt; std::ws, name); \/\/ read a full line of text into name\r\n\r\n    Player player { name };\r\n\r\n    std::cout &lt;&lt; \"Hello, \" &lt;&lt; name &lt;&lt; \", you have \" &lt;&lt; player.gold() &lt;&lt; \" gold.\\n\\n\";\r\n\r\n    shop();\r\n\r\n    std::cout &lt;&lt; \"\\nThanks for shopping at Roscoe's potion emporium!\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #3<\/p>\n<p>Add the ability to purchase potions, handling invalid input (treat any extraneous input as a failure).  Print the player&#8217;s inventory after they leave.  The program should be complete after this step.<\/p>\n<p>Make sure you test for the following cases:<\/p>\n<ul>\n<li>User enters an invalid potion number (e.g. &#8216;d&#8217;)\n<\/li>\n<li>User enters a valid potion number but with extraneous input (e.g. <code>2d<\/code>, <code>25<\/code>)\n<\/li>\n<\/ul>\n<p>We cover invalid input handling in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdcin-and-handling-invalid-input\/\">9.5 -- std::cin and handling invalid input<\/a>.<\/p>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_1'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_1\" style=\"display:none; margin-bottom: 1em\">Hint: The user can enter either a number or &#8216;q&#8217;, so extract the user&#8217;s input to type <code>char<\/code>.<\/p>\n<p>To convert an ASCII number character to an int (e.g. <code>'5'<\/code> to <code>5<\/code>), you can use the following:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int charNumToInt(char c)\r\n{\r\n    return c - '0';\r\n}<\/code><\/pre>\n<\/div>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_2'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_2\" style=\"display:none; margin-bottom: 1em\">Hint: Write a function to handle user input.  It should return the <code>Potion::Type<\/code> the user selected.  If the user quit instead, the function can return <code>Potion::max_potions<\/code>.  You will need to static_cast the user&#8217;s input to a <code>Potion::Type<\/code>.<\/div>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_5'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_5\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;limits&gt; \/\/ for std::numeric_limits\r\n#include &lt;string_view&gt;\r\n#include \"Random.h\"\r\n\r\nnamespace Potion\r\n{\r\n    enum Type\r\n    {\r\n        healing,\r\n        mana,\r\n        speed,\r\n        invisibility,\r\n        max_potions\r\n    };\r\n\r\n    constexpr std::array types { healing, mana, speed, invisibility }; \/\/ An array of our enumerators\r\n\r\n    \/\/ We could put these in a struct, but since we only have two attributes we'll keep them separate for now\r\n    \/\/ We will explicitly define the element type so we don't have to use the sv suffix\r\n    constexpr std::array&lt;std::string_view, max_potions&gt; name { \"healing\", \"mana\", \"speed\", \"invisibility\" };\r\n    constexpr std::array cost { 20, 30, 12, 50 };\r\n\r\n    static_assert(std::size(types) == max_potions);  \/\/ ensure 'all' contains the correct number of enumerators\r\n    static_assert(std::size(cost) == max_potions);\r\n    static_assert(std::size(name) == max_potions);\r\n}\r\n\r\nclass Player\r\n{\r\nprivate:\r\n    static constexpr int s_minStartingGold { 80 };\r\n    static constexpr int s_maxStartingGold { 120 };\r\n\r\n    std::string m_name {};\r\n    int m_gold {};\r\n    std::array&lt;int, Potion::max_potions&gt; m_inventory { };\r\n\r\npublic:\r\n    explicit Player(std::string_view name) :\r\n        m_name { name },\r\n        m_gold { Random::get(s_minStartingGold, s_maxStartingGold) }\r\n    { \r\n    }\r\n\r\n    \/\/ returns false if can't afford, true if purchased\r\n    bool buy(Potion::Type type)\r\n    {\r\n        if (m_gold &lt; Potion::cost[type])\r\n            return false;\r\n\r\n        m_gold -= Potion::cost[type];\r\n        ++m_inventory[type];\r\n        return true;\r\n    }\r\n\r\n    int gold() const { return m_gold; }\r\n    int inventory(Potion::Type p) const { return m_inventory[p]; }\r\n};\r\n\r\nvoid ignoreLine()\r\n{\r\n    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), '\\n');\r\n}\r\n\r\nint charNumToInt(char c)\r\n{\r\n    return c - '0';\r\n}\r\n\r\nPotion::Type whichPotion()\r\n{\r\n    std::cout &lt;&lt; \"Enter the number of the potion you'd like to buy, or 'q' to quit: \";\r\n    char input{};\r\n    while (true)\r\n    {\r\n        std::cin &gt;&gt; input;\r\n        if (!std::cin)\r\n        {\r\n            std::cin.clear(); \/\/ put us back in 'normal' operation mode\r\n            ignoreLine(); \/\/ and remove the bad input\r\n            continue;\r\n        }\r\n\r\n        \/\/ If there is extraneous input, treat as failure case\r\n        if (!std::cin.eof() &amp;&amp; std::cin.peek() != '\\n')\r\n        {\r\n            std::cout &lt;&lt; \"I didn't understand what you said.  Try again: \";\r\n            ignoreLine(); \/\/ ignore any extraneous input\r\n            continue;\r\n        }\r\n\r\n        if (input == 'q')\r\n            return Potion::max_potions;\r\n\r\n        \/\/ Convert the char to a number and see if it's a valid potion selection\r\n        int val { charNumToInt(input) };\r\n        if (val &gt;= 0 &amp;&amp; val &lt; Potion::max_potions)\r\n            return static_cast&lt;Potion::Type&gt;(val);\r\n\r\n        \/\/ It wasn't a valid potion selection\r\n        std::cout &lt;&lt; \"I didn't understand what you said.  Try again: \";\r\n        ignoreLine();\r\n    }\r\n}\r\n\r\nvoid shop(Player &amp;player)\r\n{\r\n    while (true)\r\n    {\r\n        std::cout &lt;&lt; \"Here is our selection for today:\\n\";\r\n\r\n        for (auto p: Potion::types)\r\n            std::cout &lt;&lt; p &lt;&lt; \") \" &lt;&lt; Potion::name[p] &lt;&lt; \" costs \" &lt;&lt; Potion::cost[p] &lt;&lt; '\\n';\r\n        \r\n        Potion::Type which { whichPotion() };\r\n        if (which == Potion::max_potions)\r\n            return;\r\n\r\n        bool success { player.buy(which) };\r\n        if (!success)\r\n            std::cout &lt;&lt; \"You can not afford that.\\n\\n\";\r\n        else\r\n            std::cout &lt;&lt; \"You purchased a potion of \" &lt;&lt; Potion::name[which] &lt;&lt; \".  You have \" &lt;&lt; player.gold() &lt;&lt; \" gold left.\\n\\n\";\r\n    }\r\n}\r\n\r\nvoid printInventory(Player&amp; player)\r\n{\r\n    std::cout &lt;&lt; \"Your inventory contains: \\n\";\r\n    \r\n    for (auto p: Potion::types)\r\n    {\r\n        if (player.inventory(p) &gt; 0)\r\n            std::cout &lt;&lt; player.inventory(p) &lt;&lt; \"x potion of \" &lt;&lt; Potion::name[p] &lt;&lt; '\\n';\r\n    }\r\n\r\n    std::cout &lt;&lt; \"You escaped with \" &lt;&lt; player.gold() &lt;&lt; \" gold remaining.\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Welcome to Roscoe's potion emporium!\\n\";\r\n    std::cout &lt;&lt; \"Enter your name: \";\r\n\r\n    std::string name{};\r\n    std::cin &gt;&gt; name;\r\n\r\n    Player player { name };\r\n\r\n    std::cout &lt;&lt; \"Hello, \" &lt;&lt; name &lt;&lt; \", you have \" &lt;&lt; player.gold() &lt;&lt; \" gold.\\n\\n\";\r\n\r\n    shop(player);\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    printInventory(player);\r\n\r\n    std::cout &lt;&lt; \"\\nThanks for shopping at Roscoe's potion emporium!\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #3<\/p>\n<p>Let&#8217;s say we want to write a card game that uses a standard deck of cards.  In order to do that, we&#8217;re going to need some way to represent those cards, and decks of cards.  Let&#8217;s build that functionality.<\/p>\n<p>We&#8217;ll use it in the next quiz question to actually implement a game.<\/p>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #1<\/p>\n<p>A deck of cards has 52 unique cards (13 card ranks of 4 suits).  Create enumerations for the card ranks (ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, jack, queen, king) and suits (clubs, diamonds, hearts, spades).<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_6'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_6\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Because identifiers can't start with a number, we'll use a \"rank_\" prefix for these\r\nenum Rank\r\n{\r\n    rank_ace,\r\n    rank_2,\r\n    rank_3,\r\n    rank_4,\r\n    rank_5,\r\n    rank_6,\r\n    rank_7,\r\n    rank_8,\r\n    rank_9,\r\n    rank_10,\r\n    rank_jack,\r\n    rank_queen,\r\n    rank_king,\r\n\r\n    max_ranks\r\n};\r\n\r\n\/\/ We'll also prefix these for consistency\r\nenum Suit\r\n{\r\n    suit_club,\r\n    suit_diamond,\r\n    suit_heart,\r\n    suit_spade,\r\n\r\n    max_suits\r\n};<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #2<\/p>\n<p>Each card will be represented by a struct named <code>Card<\/code> that contains a rank and a suit member.  Create the struct and move the enums into it.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_7'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_7\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">struct Card\r\n{\r\n    enum Rank\r\n    {\r\n        rank_ace,\r\n        rank_2,\r\n        rank_3,\r\n        rank_4,\r\n        rank_5,\r\n        rank_6,\r\n        rank_7,\r\n        rank_8,\r\n        rank_9,\r\n        rank_10,\r\n        rank_jack,\r\n        rank_queen,\r\n        rank_king,\r\n\r\n        max_ranks\r\n    };\r\n\r\n    enum Suit\r\n    {\r\n        suit_club,\r\n        suit_diamond,\r\n        suit_heart,\r\n        suit_spade,\r\n\r\n        max_suits\r\n    };\r\n\r\n    Rank rank{};\r\n    Suit suit{};\r\n};<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #3<\/p>\n<p>Next, let&#8217;s add some useful functions to our Card struct.  First, overload <code>operator&lt;&lt;<\/code> to print the card rank and suit as a 2-letter code (e.g. the jack of spades would print as JS).  You can do that by completing the following function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">struct Card\r\n{\r\n    \/\/ Your other stuff here\r\n\r\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Card &amp;card)\r\n    {\r\n        out &lt;&lt; \/\/ print your card rank and suit here\r\n        return out;\r\n    }\r\n};<\/code><\/pre>\n<p>Second, add a function that returns the value of the Card.  Treat an ace as value 11.  Finally, add a <code>std::array<\/code> of Rank and of Suit (named <code>allRanks<\/code> and <code>allSuits<\/code> respectively) so they can be iterated over.   Because these are part of a struct (not a namespace), make them static so they are only instantiated once (not with each object).<\/p>\n<p>The following should compile:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    \/\/ Print one card\r\n    Card card { Card::rank_5, Card::suit_heart };\r\n    std::cout &lt;&lt; card &lt;&lt; '\\n';\r\n\r\n    \/\/ Print all cards\r\n    for (auto suit : Card::allSuits)\r\n        for (auto rank : Card::allRanks)\r\n            std::cout &lt;&lt; Card { rank, suit } &lt;&lt; ' ';\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>and produce the following output:<\/p>\n<pre>\n5H\r\nAC 2C 3C 4C 5C 6C 7C 8C 9C TC JC QC KC AD 2D 3D 4D 5D 6D 7D 8D 9D TD JD QD KD AH 2H 3H 4H 5H 6H 7H 8H 9H TH JH QH KH AS 2S 3S 4S 5S 6S 7S 8S 9S TS JS QS KS \r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_8'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_8\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nstruct Card\r\n{\r\n    enum Rank\r\n    {\r\n        rank_ace,\r\n        rank_2,\r\n        rank_3,\r\n        rank_4,\r\n        rank_5,\r\n        rank_6,\r\n        rank_7,\r\n        rank_8,\r\n        rank_9,\r\n        rank_10,\r\n        rank_jack,\r\n        rank_queen,\r\n        rank_king,\r\n\r\n        max_ranks\r\n    };\r\n\r\n    enum Suit\r\n    {\r\n        suit_club,\r\n        suit_diamond,\r\n        suit_heart,\r\n        suit_spade,\r\n\r\n        max_suits\r\n    };\r\n\r\n    \/\/ These need to be static so they are only created once per program, not once per Card\r\n    static constexpr std::array allRanks { rank_ace, rank_2, rank_3, rank_4, rank_5, rank_6, rank_7, rank_8, rank_9, rank_10, rank_jack, rank_queen, rank_king };\r\n    static constexpr std::array allSuits { suit_club, suit_diamond, suit_heart, suit_spade };\r\n\r\n    Rank rank{};\r\n    Suit suit{};\r\n\r\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Card &amp;card)\r\n    {\r\n        static constexpr std::array ranks { 'A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K' };\r\n        static constexpr std::array suits { 'C', 'D', 'H', 'S' };\r\n\r\n        out &lt;&lt; ranks[card.rank] &lt;&lt; suits[card.suit];\r\n        return out;\r\n    }\r\n\r\n    int value() const\r\n    {\r\n        static constexpr std::array rankValues { 11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10 };\r\n        return rankValues[rank];\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    \/\/ Print one card\r\n    Card card { Card::rank_5, Card::suit_heart };\r\n    std::cout &lt;&lt; card &lt;&lt; '\\n';\r\n\r\n    \/\/ Print all cards\r\n    for (auto suit : Card::allSuits)\r\n        for (auto rank : Card::allRanks)\r\n            std::cout &lt;&lt; Card { rank, suit } &lt;&lt; ' ';\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #4<\/p>\n<p>Next, let&#8217;s create our deck of cards.  Create a class named <code>Deck<\/code> that contains a <code>std::array<\/code> of Cards.  You can assume a deck is 52 Cards.<\/p>\n<p>The Deck should have three functions:<\/p>\n<p>First, the default constructor should initialize the array of cards.  You can use a ranged-for loop similar to the one in the main() function of the prior example to traverse through all the suits and ranks.<\/p>\n<p>Second, add a <code>dealCard()<\/code> function that returns the next card in the Deck by value.  Since <code>std::array<\/code> is a fixed-size array, think about how you will keep track of where the next card is.  This function should assert out if it is called when the Deck has gone through all the cards.<\/p>\n<p>Third, write a <code>shuffle()<\/code> member function that shuffles the deck.  To make this easy, we will enlist the help of <code>std::shuffle<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt; \/\/ for std::shuffle\r\n#include \"Random.h\"  \/\/ for Random::mt\r\n\r\n    \/\/ Put this line in your shuffle function to shuffle m_cards using the Random::mt Mersenne Twister\r\n    \/\/ This will rearrange all the Cards in the deck randomly\r\n    std::shuffle(m_cards.begin(), m_cards.end(), Random::mt);<\/code><\/pre>\n<p>The <code>shuffle()<\/code> function should also reset however you are tracking where the next card is back to the start of the deck.<\/p>\n<p>The following program should run:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    Deck deck{};\r\n    std::cout &lt;&lt; deck.dealCard() &lt;&lt; ' ' &lt;&lt; deck.dealCard() &lt;&lt; ' ' &lt;&lt; deck.dealCard() &lt;&lt; '\\n';\r\n\r\n    deck.shuffle();\r\n    std::cout &lt;&lt; deck.dealCard() &lt;&lt; ' ' &lt;&lt; deck.dealCard() &lt;&lt; ' ' &lt;&lt; deck.dealCard() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>and produce the following output (the last 3 cards should be randomized):<\/p>\n<pre>\nAC 2C 3C\r\n2H 7H 9C\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_9'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_9\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt; \/\/ for std::shuffle\r\n#include &lt;array&gt;\r\n#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n#include \"Random.h\"\r\n\r\nstruct Card\r\n{\r\n    enum Rank\r\n    {\r\n        rank_ace,\r\n        rank_2,\r\n        rank_3,\r\n        rank_4,\r\n        rank_5,\r\n        rank_6,\r\n        rank_7,\r\n        rank_8,\r\n        rank_9,\r\n        rank_10,\r\n        rank_jack,\r\n        rank_queen,\r\n        rank_king,\r\n\r\n        max_ranks\r\n    };\r\n\r\n    enum Suit\r\n    {\r\n        suit_club,\r\n        suit_diamond,\r\n        suit_heart,\r\n        suit_spade,\r\n\r\n        max_suits\r\n    };\r\n\r\n    static constexpr std::array allRanks { rank_ace, rank_2, rank_3, rank_4, rank_5, rank_6, rank_7, rank_8, rank_9, rank_10, rank_jack, rank_queen, rank_king };\r\n    static constexpr std::array allSuits { suit_club, suit_diamond, suit_heart, suit_spade };\r\n\r\n    Rank rank{};\r\n    Suit suit{};\r\n\r\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Card &amp;card)\r\n    {\r\n        static constexpr std::array ranks { 'A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K' };\r\n        static constexpr std::array suits { 'C', 'D', 'H', 'S' };\r\n\r\n        out &lt;&lt; ranks[card.rank] &lt;&lt; suits[card.suit];\r\n        return out;\r\n    }\r\n\r\n    int value() const\r\n    {\r\n        static constexpr std::array rankValues { 11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10 };\r\n        return rankValues[rank];\r\n    }\r\n};\r\n\r\nclass Deck\r\n{\r\nprivate:\r\n    std::array&lt;Card, 52&gt; m_cards {};\r\n    std::size_t m_nextCardIndex { 0 };\r\n\r\npublic:\r\n    Deck()\r\n    {\r\n        std::size_t count { 0 };\r\n        for (auto suit: Card::allSuits)\r\n            for (auto rank: Card::allRanks)\r\n                m_cards[count++] = Card{rank, suit};\r\n    }\r\n\r\n    void shuffle()\r\n    {\r\n        std::shuffle(m_cards.begin(), m_cards.end(), Random::mt);\r\n        m_nextCardIndex = 0;\r\n    }\r\n\r\n    Card dealCard()\r\n    {\r\n        assert(m_nextCardIndex != 52 &amp;&amp; \"Deck::dealCard ran out of cards\");\r\n        return m_cards[m_nextCardIndex++];\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Deck deck{};\r\n    std::cout &lt;&lt; deck.dealCard() &lt;&lt; ' ' &lt;&lt; deck.dealCard() &lt;&lt; ' ' &lt;&lt; deck.dealCard() &lt;&lt; '\\n';\r\n\r\n    deck.shuffle();\r\n    std::cout &lt;&lt; deck.dealCard() &lt;&lt; ' ' &lt;&lt; deck.dealCard() &lt;&lt; ' ' &lt;&lt; deck.dealCard() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #4<\/p>\n<p>Alright, now let&#8217;s use our Card and Deck to implement a simplified version of Blackjack!  If you&#8217;re not already familiar with Blackjack, the Wikipedia article for <a href=\"https:\/\/en.wikipedia.org\/wiki\/Blackjack\">Blackjack<\/a> has a summary.<\/p>\n<p>Here are the rules for our version of Blackjack:<\/p>\n<ul>\n<li>The dealer gets one card to start (in real life, the dealer gets two, but one is face down so it doesn&#8217;t matter at this point).\n<\/li>\n<li>The player gets two cards to start.\n<\/li>\n<li>The player goes first.\n<\/li>\n<li>A player can repeatedly &#8220;hit&#8221; or &#8220;stand&#8221;.\n<\/li>\n<li>If the player &#8220;stands&#8221;, their turn is over, and their score is calculated based on the cards they have been dealt.\n<\/li>\n<li>If the player &#8220;hits&#8221;, they get another card and the value of that card is added to their total score.\n<\/li>\n<li>An ace normally counts as a 1 or an 11 (whichever is better for the total score).  For simplicity, we&#8217;ll count it as an 11 here.\n<\/li>\n<li>If the player goes over a score of 21, they bust and lose immediately.\n<\/li>\n<li>When the player is done, it is the dealer&#8217;s turn.\n<\/li>\n<li>The dealer repeatedly draws until they reach a score of 17 or more, at which point they must stop drawing.\n<\/li>\n<li>If the dealer goes over a score of 21, they bust and the player wins immediately.\n<\/li>\n<li>Otherwise, if the player has a higher score than the dealer, the player wins.  Otherwise, the player loses (we&#8217;ll consider ties as dealer wins for simplicity).\n<\/li>\n<\/ul>\n<p>In our simplified version of Blackjack, we&#8217;re not going to keep track of which specific cards the player and the dealer have been dealt.  We&#8217;ll only track the sum of the values of the cards they have been dealt for the player and dealer.  This keeps things simpler.<\/p>\n<p>Start with the code you wrote in the prior quiz (or use our reference solution).<\/p>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #1<\/p>\n<p>Create a struct named <code>Player<\/code> that will represent a participant in our game (either the dealer or the player).  Since in this game we only care about a player&#8217;s score, this struct only needs one member.<\/p>\n<p>Write a function that will (eventually) play a round of Blackjack.  For now, this function should draw one randomized card for the dealer and two randomized cards for the player.  It should return a bool value indicating who has the greater score.<\/p>\n<p>The code should output the following:<\/p>\n<pre>\nThe dealer is showing: 10\r\nYou have score: 13\r\nYou win!\r\n<\/pre>\n<pre>\nThe dealer is showing: 10\r\nYou have score: 8\r\nYou lose!\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_10'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_10\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt; \/\/ for std::shuffle\r\n#include &lt;array&gt;\r\n#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n#include \"Random.h\"\r\n\r\nstruct Card\r\n{\r\n    enum Rank\r\n    {\r\n        rank_ace,\r\n        rank_2,\r\n        rank_3,\r\n        rank_4,\r\n        rank_5,\r\n        rank_6,\r\n        rank_7,\r\n        rank_8,\r\n        rank_9,\r\n        rank_10,\r\n        rank_jack,\r\n        rank_queen,\r\n        rank_king,\r\n\r\n        max_ranks\r\n    };\r\n\r\n    enum Suit\r\n    {\r\n        suit_club,\r\n        suit_diamond,\r\n        suit_heart,\r\n        suit_spade,\r\n\r\n        max_suits\r\n    };\r\n\r\n    static constexpr std::array allRanks { rank_ace, rank_2, rank_3, rank_4, rank_5, rank_6, rank_7, rank_8, rank_9, rank_10, rank_jack, rank_queen, rank_king };\r\n    static constexpr std::array allSuits { suit_club, suit_diamond, suit_heart, suit_spade };\r\n\r\n    Rank rank{};\r\n    Suit suit{};\r\n\r\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Card &amp;card)\r\n    {\r\n        static constexpr std::array ranks { 'A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K' };\r\n        static constexpr std::array suits { 'C', 'D', 'H', 'S' };\r\n\r\n        out &lt;&lt; ranks[card.rank] &lt;&lt; suits[card.suit];\r\n        return out;\r\n    }\r\n\r\n    int value() const\r\n    {\r\n        static constexpr std::array rankValues { 11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10 };\r\n        return rankValues[rank];\r\n    }\r\n};\r\n\r\nclass Deck\r\n{\r\nprivate:\r\n    std::array&lt;Card, 52&gt; m_cards {};\r\n    std::size_t m_nextCardIndex { 0 };\r\n\r\npublic:\r\n    Deck()\r\n    {\r\n        std::size_t count { 0 };\r\n        for (auto suit: Card::allSuits)\r\n            for (auto rank: Card::allRanks)\r\n                m_cards[count++] = Card{rank, suit};\r\n    }\r\n\r\n    void shuffle()\r\n    {\r\n        std::shuffle(m_cards.begin(), m_cards.end(), Random::mt);\r\n        m_nextCardIndex = 0;\r\n    }\r\n\r\n    Card dealCard()\r\n    {\r\n        assert(m_nextCardIndex != 52 &amp;&amp; \"Deck::dealCard ran out of cards\");\r\n        return m_cards[m_nextCardIndex++];\r\n    }\r\n};\r\n\r\nstruct Player\r\n{\r\n    int score{};\r\n};\r\n\r\nbool playBlackjack()\r\n{\r\n    Deck deck{};\r\n    deck.shuffle();\r\n\r\n    Player dealer{ deck.dealCard().value() };\r\n\r\n    std::cout &lt;&lt; \"The dealer is showing: \" &lt;&lt; dealer.score &lt;&lt; '\\n';\r\n\r\n    Player player { deck.dealCard().value() + deck.dealCard().value() };\r\n\r\n    std::cout &lt;&lt; \"You have score: \" &lt;&lt; player.score &lt;&lt; '\\n';\r\n\r\n    return (player.score &gt; dealer.score);\r\n}\r\n\r\nint main()\r\n{\r\n    if (playBlackjack())\r\n    {\r\n        std::cout &lt;&lt; \"You win!\\n\";\r\n    }\r\n    else\r\n    {\r\n        std::cout &lt;&lt; \"You lose!\\n\";\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #2<\/p>\n<p>Add a <code>Settings<\/code> namespace that contains two constants: the value above which the player busts, and the value where the dealer must stop drawing cards.<\/p>\n<p>Add the logic that handles the dealer&#8217;s turn.  The dealer will draw cards until they hit 17, then they must stop.  If they bust, the player wins.<\/p>\n<p>Here is some sample output:<\/p>\n<pre>\nThe dealer is showing: 8\r\nYou have score: 9\r\nThe dealer flips a 4D.  They now have: 12\r\nThe dealer flips a JS.  They now have: 22\r\nThe dealer went bust!\r\nYou win!\r\n<\/pre>\n<pre>\nThe dealer is showing: 6\r\nYou have score: 13\r\nThe dealer flips a 3D.  They now have: 9\r\nThe dealer flips a 3H.  They now have: 12\r\nThe dealer flips a 9S.  They now have: 21\r\nYou lose!\r\n<\/pre>\n<pre>\nThe dealer is showing: 7\r\nYou have score: 21\r\nThe dealer flips a JC.  They now have: 17\r\nYou win!\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_11'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_11\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt; \/\/ for std::shuffle\r\n#include &lt;array&gt;\r\n#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n#include \"Random.h\"\r\n\r\nstruct Card\r\n{\r\n    enum Rank\r\n    {\r\n        rank_ace,\r\n        rank_2,\r\n        rank_3,\r\n        rank_4,\r\n        rank_5,\r\n        rank_6,\r\n        rank_7,\r\n        rank_8,\r\n        rank_9,\r\n        rank_10,\r\n        rank_jack,\r\n        rank_queen,\r\n        rank_king,\r\n\r\n        max_ranks\r\n    };\r\n\r\n    enum Suit\r\n    {\r\n        suit_club,\r\n        suit_diamond,\r\n        suit_heart,\r\n        suit_spade,\r\n\r\n        max_suits\r\n    };\r\n\r\n    static constexpr std::array allRanks { rank_ace, rank_2, rank_3, rank_4, rank_5, rank_6, rank_7, rank_8, rank_9, rank_10, rank_jack, rank_queen, rank_king };\r\n    static constexpr std::array allSuits { suit_club, suit_diamond, suit_heart, suit_spade };\r\n\r\n    Rank rank{};\r\n    Suit suit{};\r\n\r\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Card &amp;card)\r\n    {\r\n        static constexpr std::array ranks { 'A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K' };\r\n        static constexpr std::array suits { 'C', 'D', 'H', 'S' };\r\n\r\n        out &lt;&lt; ranks[card.rank] &lt;&lt; suits[card.suit];\r\n        return out;\r\n    }\r\n\r\n    int value() const\r\n    {\r\n        static constexpr std::array rankValues { 11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10 };\r\n        return rankValues[rank];\r\n    }\r\n};\r\n\r\nclass Deck\r\n{\r\nprivate:\r\n    std::array&lt;Card, 52&gt; m_cards {};\r\n    std::size_t m_nextCardIndex { 0 };\r\n\r\npublic:\r\n    Deck()\r\n    {\r\n        std::size_t count { 0 };\r\n        for (auto suit: Card::allSuits)\r\n            for (auto rank: Card::allRanks)\r\n                m_cards[count++] = Card{rank, suit};\r\n    }\r\n\r\n    void shuffle()\r\n    {\r\n        std::shuffle(m_cards.begin(), m_cards.end(), Random::mt);\r\n        m_nextCardIndex = 0;\r\n    }\r\n\r\n    Card dealCard()\r\n    {\r\n        assert(m_nextCardIndex != 52 &amp;&amp; \"Deck::dealCard ran out of cards\");\r\n        return m_cards[m_nextCardIndex++];\r\n    }\r\n\r\n};\r\n\r\nstruct Player\r\n{\r\n    int score{};\r\n};\r\n\r\nnamespace Settings\r\n{\r\n    \/\/ Maximum score before losing.\r\n    constexpr int bust{ 21 };\r\n\r\n    \/\/ Minium score that the dealer has to have.\r\n    constexpr int dealerStopsAt{ 17 };\r\n}\r\n\r\n\/\/ Returns true if the dealer went bust. False otherwise.\r\nbool dealerTurn(Deck&amp; deck, Player&amp; dealer)\r\n{\r\n    while (dealer.score &lt; Settings::dealerStopsAt)\r\n    {\r\n        Card card { deck.dealCard() };\r\n        dealer.score += card.value();\r\n        std::cout &lt;&lt; \"The dealer flips a \" &lt;&lt; card &lt;&lt; \".  They now have: \" &lt;&lt; dealer.score &lt;&lt; '\\n';\r\n    }\r\n\r\n    if (dealer.score &gt; Settings::bust)\r\n    {\r\n        std::cout &lt;&lt; \"The dealer went bust!\\n\";\r\n        return true;\r\n    }\r\n    \r\n    return false;\r\n}\r\n\r\nbool playBlackjack()\r\n{\r\n    Deck deck{};\r\n    deck.shuffle();\r\n\r\n    Player dealer{ deck.dealCard().value() };\r\n\r\n    std::cout &lt;&lt; \"The dealer is showing: \" &lt;&lt; dealer.score &lt;&lt; '\\n';\r\n\r\n    Player player { deck.dealCard().value() + deck.dealCard().value() };\r\n\r\n    std::cout &lt;&lt; \"You have score: \" &lt;&lt; player.score &lt;&lt; '\\n';\r\n\r\n    if (dealerTurn(deck, dealer))\r\n        return true;\r\n\r\n    return (player.score &gt; dealer.score);\r\n}\r\n\r\nint main()\r\n{\r\n    if (playBlackjack())\r\n    {\r\n        std::cout &lt;&lt; \"You win!\\n\";\r\n    }\r\n    else\r\n    {\r\n        std::cout &lt;&lt; \"You lose!\\n\";\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #3<\/p>\n<p>Finally, add logic for the player&#8217;s turn.  This will complete the game.<\/p>\n<p>Here is some sample output:<\/p>\n<pre>\nThe dealer is showing: 2\r\nYou have score: 14\r\n(h) to hit, or (s) to stand: h\r\nYou were dealt KH.  You now have: 24\r\nYou went bust!\r\nYou lose!\r\n<\/pre>\n<pre>\nThe dealer is showing: 10\r\nYou have score: 9\r\n(h) to hit, or (s) to stand: h\r\nYou were dealt TH.  You now have: 19\r\n(h) to hit, or (s) to stand: s\r\nThe dealer flips a 3D.  They now have: 13\r\nThe dealer flips a 7H.  They now have: 20\r\nYou lose!\r\n<\/pre>\n<pre>\nThe dealer is showing: 7\r\nYou have score: 12\r\n(h) to hit, or (s) to stand: h\r\nYou were dealt 7S.  You now have: 19\r\n(h) to hit, or (s) to stand: h\r\nYou were dealt 2D.  You now have: 21\r\n(h) to hit, or (s) to stand: s\r\nThe dealer flips a 6H.  They now have: 13\r\nThe dealer flips a QC.  They now have: 23\r\nThe dealer went bust!\r\nYou win!\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_12'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_12\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt; \/\/ for std::shuffle\r\n#include &lt;array&gt;\r\n#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n#include \"Random.h\"\r\n\r\nstruct Card\r\n{\r\n    enum Rank\r\n    {\r\n        rank_ace,\r\n        rank_2,\r\n        rank_3,\r\n        rank_4,\r\n        rank_5,\r\n        rank_6,\r\n        rank_7,\r\n        rank_8,\r\n        rank_9,\r\n        rank_10,\r\n        rank_jack,\r\n        rank_queen,\r\n        rank_king,\r\n\r\n        max_ranks\r\n    };\r\n\r\n    enum Suit\r\n    {\r\n        suit_club,\r\n        suit_diamond,\r\n        suit_heart,\r\n        suit_spade,\r\n\r\n        max_suits\r\n    };\r\n\r\n    static constexpr std::array allRanks { rank_ace, rank_2, rank_3, rank_4, rank_5, rank_6, rank_7, rank_8, rank_9, rank_10, rank_jack, rank_queen, rank_king };\r\n    static constexpr std::array allSuits { suit_club, suit_diamond, suit_heart, suit_spade };\r\n\r\n    Rank rank{};\r\n    Suit suit{};\r\n\r\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Card &amp;card)\r\n    {\r\n        static constexpr std::array ranks { 'A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K' };\r\n        static constexpr std::array suits { 'C', 'D', 'H', 'S' };\r\n\r\n        out &lt;&lt; ranks[card.rank] &lt;&lt; suits[card.suit];\r\n        return out;\r\n    }\r\n\r\n    int value() const\r\n    {\r\n        static constexpr std::array rankValues { 11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10 };\r\n        return rankValues[rank];\r\n    }\r\n};\r\n\r\nclass Deck\r\n{\r\nprivate:\r\n    std::array&lt;Card, 52&gt; m_cards {};\r\n    std::size_t m_nextCardIndex { 0 };\r\n\r\npublic:\r\n    Deck()\r\n    {\r\n        std::size_t count { 0 };\r\n        for (auto suit: Card::allSuits)\r\n            for (auto rank: Card::allRanks)\r\n                m_cards[count++] = Card{rank, suit};\r\n    }\r\n\r\n    void shuffle()\r\n    {\r\n        std::shuffle(m_cards.begin(), m_cards.end(), Random::mt);\r\n        m_nextCardIndex = 0;\r\n    }\r\n\r\n    Card dealCard()\r\n    {\r\n        assert(m_nextCardIndex != 52 &amp;&amp; \"Deck::dealCard ran out of cards\");\r\n        return m_cards[m_nextCardIndex++];\r\n    }\r\n\r\n};\r\n\r\nstruct Player\r\n{\r\n    int score{};\r\n};\r\n\r\nnamespace Settings\r\n{\r\n    \/\/ Maximum score before losing.\r\n    constexpr int bust{ 21 };\r\n\r\n    \/\/ Minium score that the dealer has to have.\r\n    constexpr int dealerStopsAt{ 17 };\r\n}\r\n\r\nbool playerWantsHit()\r\n{\r\n    while (true)\r\n    {\r\n        std::cout &lt;&lt; \"(h) to hit, or (s) to stand: \";\r\n\r\n        char ch{};\r\n        std::cin &gt;&gt; ch;\r\n\r\n        switch (ch)\r\n        {\r\n            case 'h':\r\n                return true;\r\n            case 's':\r\n                return false;\r\n        }\r\n    }\r\n}\r\n\r\n\/\/ Returns true if the player went bust. False otherwise.\r\nbool playerTurn(Deck&amp; deck, Player&amp; player)\r\n{\r\n    while (player.score &lt; Settings::bust &amp;&amp; playerWantsHit())\r\n    {\r\n        Card card { deck.dealCard() };\r\n        player.score += card.value();\r\n\r\n        std::cout &lt;&lt; \"You were dealt \" &lt;&lt; card  &lt;&lt; \". You now have: \" &lt;&lt; player.score &lt;&lt; '\\n';\r\n    }\r\n\r\n    if (player.score &gt; Settings::bust)\r\n    {\r\n        std::cout &lt;&lt; \"You went bust!\\n\";\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n\/\/ Returns true if the dealer went bust. False otherwise.\r\nbool dealerTurn(Deck&amp; deck, Player&amp; dealer)\r\n{\r\n    while (dealer.score &lt; Settings::dealerStopsAt)\r\n    {\r\n        Card card { deck.dealCard() };\r\n        dealer.score += card.value();\r\n        std::cout &lt;&lt; \"The dealer flips a \" &lt;&lt; card &lt;&lt; \".  They now have: \" &lt;&lt; dealer.score &lt;&lt; '\\n';\r\n    }\r\n\r\n    if (dealer.score &gt; Settings::bust)\r\n    {\r\n        std::cout &lt;&lt; \"The dealer went bust!\\n\";\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nbool playBlackjack()\r\n{\r\n    Deck deck{};\r\n    deck.shuffle();\r\n\r\n    Player dealer{ deck.dealCard().value() };\r\n\r\n    std::cout &lt;&lt; \"The dealer is showing: \" &lt;&lt; dealer.score &lt;&lt; '\\n';\r\n\r\n    Player player { deck.dealCard().value() + deck.dealCard().value() };\r\n\r\n    std::cout &lt;&lt; \"You have score: \" &lt;&lt; player.score &lt;&lt; '\\n';\r\n\r\n    if (playerTurn(deck, player))\r\n        return false;\r\n\r\n    if (dealerTurn(deck, dealer))\r\n        return true;\r\n\r\n    return (player.score &gt; dealer.score);\r\n}\r\n\r\nint main()\r\n{\r\n    if (playBlackjack())\r\n    {\r\n        std::cout &lt;&lt; \"You win!\\n\";\r\n    }\r\n    else\r\n    {\r\n        std::cout &lt;&lt; \"You lose!\\n\";\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #5<\/p>\n<p>a) Describe how you could modify the above program to handle the case where aces can be equal to 1 or 11.<\/p>\n<p>It&#8217;s important to note that we&#8217;re only keeping track of the sum of the cards, not which specific cards the user has.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_13'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_13\" style=\"display:none\">\n<p>One way would be to keep track of how many aces the player and the dealer got dealt (In the <code>Player<\/code> struct, as an integer).  If either the player or dealer go over 21 and their ace counter is greater than zero, you can reduce their score by 10 (convert an ace from 11 points to 1 point) and decrement the ace counter.  This can be done as many times as needed until the ace counter reaches zero.\n<\/div>\n<p>b) In actual blackjack, if the player and dealer have the same score (and the player has not gone bust), the result is a tie and neither wins.  Describe how you&#8217;d modify the above program to account for this.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_14'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_14\" style=\"display:none\">\n<p>Our version of <code>playBlackjack()<\/code> currently returns a bool indicating whether the player won or not.  We&#8217;ll need to update this function to return three possibilities: Dealer win, Player win, tie.  The best way to do this would be to define an enumeration for these three options, and have the function return the appropriate enumerator.\n<\/div>\n<p>c) Extra credit: implement the above two ideas into your blackjack game.  Note that you will need to show the dealer&#8217;s initial card and the player&#8217;s initial two cards so they know whether they have an ace or not.<\/p>\n<p>Here&#8217;s a sample output:<\/p>\n<pre>\nThe dealer is showing JH (10)\r\nYou are showing AH 7D (18)\r\n(h) to hit, or (s) to stand: h\r\nYou were dealt JD.  You now have: 18\r\n(h) to hit, or (s) to stand: s\r\nThe dealer flips a 6C.  They now have: 16\r\nThe dealer flips a AD.  They now have: 17\r\nYou win!\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_15'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_15\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt; \/\/ for std::shuffle\r\n#include &lt;array&gt;\r\n#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n#include \"Random.h\"\r\n\r\nnamespace Settings\r\n{\r\n    \/\/ Maximum score before losing.\r\n    constexpr int bust{ 21 };\r\n\r\n    \/\/ Minium score that the dealer has to have.\r\n    constexpr int dealerStopsAt{ 17 };\r\n}\r\n\r\nstruct Card\r\n{\r\n    enum Rank\r\n    {\r\n        rank_ace,\r\n        rank_2,\r\n        rank_3,\r\n        rank_4,\r\n        rank_5,\r\n        rank_6,\r\n        rank_7,\r\n        rank_8,\r\n        rank_9,\r\n        rank_10,\r\n        rank_jack,\r\n        rank_queen,\r\n        rank_king,\r\n\r\n        max_ranks\r\n    };\r\n\r\n    enum Suit\r\n    {\r\n        suit_club,\r\n        suit_diamond,\r\n        suit_heart,\r\n        suit_spade,\r\n\r\n        max_suits\r\n    };\r\n\r\n    static constexpr std::array allRanks { rank_ace, rank_2, rank_3, rank_4, rank_5, rank_6, rank_7, rank_8, rank_9, rank_10, rank_jack, rank_queen, rank_king };\r\n    static constexpr std::array allSuits { suit_club, suit_diamond, suit_heart, suit_spade };\r\n\r\n    Rank rank{};\r\n    Suit suit{};\r\n\r\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Card &amp;card)\r\n    {\r\n        static constexpr std::array ranks { 'A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K' };\r\n        static constexpr std::array suits { 'C', 'D', 'H', 'S' };\r\n\r\n        out &lt;&lt; ranks[card.rank] &lt;&lt; suits[card.suit];\r\n        return out;\r\n    }\r\n\r\n    int value() const\r\n    {\r\n        static constexpr std::array rankValues { 11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10 };\r\n        return rankValues[rank];\r\n    }\r\n};\r\n\r\nclass Deck\r\n{\r\nprivate:\r\n    std::array&lt;Card, 52&gt; m_cards {};\r\n    std::size_t m_nextCardIndex { 0 };\r\n\r\npublic:\r\n    Deck()\r\n    {\r\n        std::size_t count { 0 };\r\n        for (auto suit: Card::allSuits)\r\n            for (auto rank: Card::allRanks)\r\n                m_cards[count++] = Card{rank, suit};\r\n    }\r\n\r\n    void shuffle()\r\n    {\r\n        std::shuffle(m_cards.begin(), m_cards.end(), Random::mt);\r\n        m_nextCardIndex = 0;\r\n    }\r\n\r\n    Card dealCard()\r\n    {\r\n        assert(m_nextCardIndex != 52 &amp;&amp; \"Deck::dealCard ran out of cards\");\r\n        return m_cards[m_nextCardIndex++];\r\n    }\r\n\r\n};\r\n\r\nclass Player\r\n{\r\nprivate:\r\n    int m_score{ };\r\n    int m_ace11Count { 0 }; \/\/ how many aces worth 11 points the player has\r\n\r\npublic:\r\n    \/\/ We'll use a function to add the card to the player's score\r\n    \/\/ Since we now need to count aces\r\n    void addToScore(Card card)\r\n    {\r\n        m_score += card.value();\r\n        if (card.rank == Card::rank_ace)\r\n            ++m_ace11Count; \/\/ aces start at 11 points\r\n        consumeAces();\r\n    }\r\n\r\n    \/\/ Decrease aceCount by 1 and \r\n    void consumeAces()\r\n    {\r\n        \/\/ If the player would bust, see if we can switch aces from 11 points to 1\r\n        while (m_score &gt; Settings::bust &amp;&amp; m_ace11Count &gt; 0)\r\n        {\r\n            m_score -= 10;\r\n            --m_ace11Count;\r\n        }\r\n    }\r\n\r\n    int score() { return m_score; }\r\n};\r\n\r\nbool playerWantsHit()\r\n{\r\n    while (true)\r\n    {\r\n        std::cout &lt;&lt; \"(h) to hit, or (s) to stand: \";\r\n\r\n        char ch{};\r\n        std::cin &gt;&gt; ch;\r\n\r\n        switch (ch)\r\n        {\r\n            case 'h':\r\n                return true;\r\n            case 's':\r\n                return false;\r\n        }\r\n    }\r\n}\r\n\r\n\/\/ Returns true if the player went bust. False otherwise.\r\nbool playerTurn(Deck&amp; deck, Player&amp; player)\r\n{\r\n    while (player.score() &lt; Settings::bust &amp;&amp; playerWantsHit())\r\n    {\r\n        Card card { deck.dealCard() };\r\n        player.addToScore(card);\r\n\r\n        std::cout &lt;&lt; \"You were dealt \" &lt;&lt; card  &lt;&lt; \". You now have: \" &lt;&lt; player.score() &lt;&lt; '\\n';\r\n    }\r\n\r\n    if (player.score() &gt; Settings::bust)\r\n    {\r\n        std::cout &lt;&lt; \"You went bust!\\n\";\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n\r\n\/\/ Returns true if the dealer went bust. False otherwise.\r\nbool dealerTurn(Deck&amp; deck, Player&amp; dealer)\r\n{\r\n    while (dealer.score() &lt; Settings::dealerStopsAt)\r\n    {\r\n        Card card { deck.dealCard() };\r\n        dealer.addToScore(card);\r\n\r\n        std::cout &lt;&lt; \"The dealer flips a \" &lt;&lt; card &lt;&lt; \".  They now have: \" &lt;&lt; dealer.score() &lt;&lt; '\\n';\r\n    }\r\n\r\n    if (dealer.score() &gt; Settings::bust)\r\n    {\r\n        std::cout &lt;&lt; \"The dealer went bust!\\n\";\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nenum class GameResult\r\n{\r\n    playerWon,\r\n    dealerWon,\r\n    tie\r\n};\r\n\r\nGameResult playBlackjack()\r\n{\r\n    Deck deck{};\r\n    deck.shuffle();\r\n\r\n    Player dealer{};\r\n    Card card1 { deck.dealCard() };\r\n    dealer.addToScore(card1);\r\n    std::cout &lt;&lt; \"The dealer is showing \" &lt;&lt; card1 &lt;&lt; \" (\" &lt;&lt; dealer.score() &lt;&lt; \")\\n\";\r\n\r\n    Player player{};\r\n    Card card2 { deck.dealCard() };\r\n    Card card3 { deck.dealCard() };\r\n    player.addToScore(card2);\r\n    player.addToScore(card3);\r\n    std::cout &lt;&lt; \"You are showing \" &lt;&lt; card2 &lt;&lt; ' ' &lt;&lt; card3 &lt;&lt; \" (\" &lt;&lt; player.score() &lt;&lt; \")\\n\";\r\n\r\n    if (playerTurn(deck, player)) \/\/ if player busted\r\n        return GameResult::dealerWon;\r\n\r\n    if (dealerTurn(deck, dealer)) \/\/ if dealer busted\r\n        return GameResult::playerWon;\r\n\r\n    if (player.score() == dealer.score())\r\n        return GameResult::tie;\r\n\r\n    return (player.score() &gt; dealer.score() ? GameResult::playerWon : GameResult::dealerWon);\r\n}\r\n\r\nint main()\r\n{\r\n    switch (playBlackjack())\r\n    {\r\n    case GameResult::playerWon:\r\n        std::cout &lt;&lt; \"You win!\\n\";\r\n        return 0;\r\n    case GameResult::dealerWon:\r\n        std::cout &lt;&lt; \"You lose!\\n\";\r\n        return 0;\r\n    case GameResult::tie:\r\n        std::cout &lt;&lt; \"It's a tie.\\n\";\r\n        return 0;\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/sorting-an-array-using-selection-sort\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">18.1<\/span>Sorting an array using selection sort\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/multidimensional-stdarray\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.13<\/span>Multidimensional std::array\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Chapter Review Fixed-size arrays (or fixed-length arrays) require that the length of the array be known at the point of instantiation, and that length cannot be changed afterward. C-style arrays and std::array are both fixed-size arrays. Dynamic arrays can be resized at runtime. std::vector is a dynamic array. The length &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/2809"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=2809"}],"version-history":[{"count":118,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/2809\/revisions"}],"predecessor-version":[{"id":18090,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/2809\/revisions\/18090"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=2809"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=2809"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=2809"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}