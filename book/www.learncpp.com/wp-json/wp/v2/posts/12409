{"id":12409,"date":"2022-01-18T10:17:25","date_gmt":"2022-01-18T18:17:25","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=12409"},"modified":"2025-02-24T00:11:06","modified_gmt":"2025-02-24T08:11:06","slug":"introduction-to-program-defined-user-defined-types","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-program-defined-user-defined-types\/","title":{"rendered":"13.1 &#8212; Introduction to program-defined (user-defined) types"},"content":{"rendered":"<p>Because fundamental types are defined as part of the core C++ language, they are available for immediate use.  For example, if we want to define a variable with a type of <code>int<\/code> or <code>double<\/code>, we can just do so:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int x; \/\/ define variable of fundamental type 'int'\r\ndouble d; \/\/ define variable of fundamental type 'double'<\/code><\/pre>\n<p>This is also true for the compound types that are simple extensions of fundamental types (including functions, pointers, references, and arrays):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void fcn(int) {}; \/\/ define a function of type void(int)\r\nint* ptr; \/\/ define variable of compound type 'pointer to int'\r\nint&amp; ref { x }; \/\/ define variable of compound type 'reference to int' (initialized with x)\r\nint arr[5]; \/\/ define an array of 5 integers of type int[5] (we'll cover this in a future chapter)<\/code><\/pre>\n<p>This works because the C++ language already knows what the type names (and symbols) for these types mean -- we do not need to provide or import any definitions.<\/p>\n<p>However, consider the case of a type alias (introduced in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/typedefs-and-type-aliases\/\">10.7 -- Typedefs and type aliases<\/a>), which allows us to define a new name for an existing type.  Because a type alias introduces a new identifier into the program, a type alias must be defined before it can be used:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nusing Length = int; \/\/ define a type alias with identifier 'Length'\r\n\r\nint main()\r\n{\r\n    Length x { 5 }; \/\/ we can use 'length' here since we defined it above\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>If we were to omit the definition of <code>Length<\/code>, the compiler wouldn&#8217;t know what a <code>Length<\/code> is, and would complain when we try to define a variable using that type.  The definition for <code>Length<\/code> doesn&#8217;t create an object -- it just tells the compiler what a <code>Length<\/code> is so it can be used later.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">What are user-defined \/ program-defined types?<\/p>\n<p>Back in the introduction to the previous chapter (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-compound-data-types\/\">12.1 -- Introduction to compound data types<\/a>), we introduced the challenge of wanting to store a fraction, which has a numerator and denominator that are conceptually linked together.  In that lesson, we discussed some of the challenges with using two separate integers to store a fraction&#8217;s numerator and denominator independently.<\/p>\n<p>If C++ had a built-in fraction type, that would have been perfect -- but it doesn&#8217;t.  And there are hundreds of other potentially useful types that C++ doesn&#8217;t include because it&#8217;s just not possible to anticipate everything that someone might need (let alone implement and test those things).<\/p>\n<p>Instead, C++ solves such problems in a different way: by allowing the creation of entirely new, custom types that we can use in our programs!  Such types are called <strong>user-defined types<\/strong>.  However, as we will discuss later in this lesson, we&#8217;ll prefer the term <strong>program-defined types<\/strong> for any such types that we create for use in our own programs.<\/p>\n<p>C++ has two different categories of compound types that can be used to create program-defined types:<\/p>\n<ul>\n<li>Enumerated types (including unscoped and scoped enumerations)\n<\/li>\n<li>Class types (including structs, classes, and unions).\n<\/li>\n<\/ul>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Defining program-defined types<\/p>\n<p>Just like type aliases, program-defined types must also be defined and given a name before they can be used.  The definition for a program-defined type is called a <strong>type definition<\/strong>.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>A program-defined type must have a name and a definition before it can be used.  The other compound types require neither.<\/p>\n<p>Functions aren&#8217;t considered user-defined types (even though they require a name and a definition before they can be used) because it is the function itself being given a name and a definition, not the function&#8217;s type.  Functions that we define ourselves are called user-defined functions instead.\n<\/p><\/div>\n<p>Although we haven&#8217;t covered what a struct is yet, here&#8217;s an example showing the definition of custom Fraction type and an instantiation of an object using that type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Define a program-defined type named Fraction so the compiler understands what a Fraction is\r\n\/\/ (we'll explain what a struct is and how to use them later in this chapter)\r\n\/\/ This only defines what a Fraction type looks like, it doesn't create one\r\nstruct Fraction\r\n{\r\n\tint numerator {};\r\n\tint denominator {};\r\n};\r\n\r\n\/\/ Now we can make use of our Fraction type\r\nint main()\r\n{\r\n\tFraction f { 3, 4 }; \/\/ this actually instantiates a Fraction object named f\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In this example, we&#8217;re using the <code>struct<\/code> keyword to define a new program-defined type named <code>Fraction<\/code> (in the global scope, so it can be used anywhere in the rest of the file).  This doesn&#8217;t allocate any memory -- it just tells the compiler what a <code>Fraction<\/code> looks like, so we can allocate objects of a <code>Fraction<\/code> type later.  Then, inside <code>main()<\/code>, we instantiate (and initialize) a variable of type <code>Fraction<\/code> named <code>f<\/code>.<\/p>\n<p>Program-defined type definitions must end in a semicolon.  Failure to include the semicolon at the end of a type definition is a common programmer error, and one that can be hard to debug because the compiler may error on the line <em>after<\/em> the type definition.<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Don&#8217;t forget to end your type definitions with a semicolon.\n<\/p><\/div>\n<p>We&#8217;ll show more examples of defining and using program-defined types in the next lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/unscoped-enumerations\/\">13.2 -- Unscoped enumerations<\/a>), and we cover structs starting in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-structs-members-and-member-selection\/\">13.7 -- Introduction to structs, members, and member selection<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Naming program-defined types<\/p>\n<p>By convention, program-defined types are named starting with a capital letter and don&#8217;t use a suffix (e.g. <code>Fraction<\/code>, not <code>fraction<\/code>, <code>fraction_t<\/code>, or <code>Fraction_t<\/code>).<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Name your program-defined types starting with a capital letter and do not use a suffix.\n<\/p><\/div>\n<p>New programmers sometimes find variable definitions such as the following confusing because of the similarity between the type name and variable name:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">Fraction fraction {}; \/\/ Instantiates a variable named fraction of type Fraction<\/code><\/pre>\n<p>This is no different than any other variable definition: the type (<code>Fraction<\/code>) comes first (and because Fraction is capitalized, we know it&#8217;s a program-defined type), then the variable name (<code>fraction<\/code>), and then an optional initializer.  Because C++ is case-sensitive, there is no naming conflict here!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using program-defined types throughout a multi-file program<\/p>\n<p>Every code file that uses a program-defined type needs to see the full type definition before it is used.  A forward declaration is not sufficient.  This is required so that the compiler knows how much memory to allocate for objects of that type.<\/p>\n<p>To propagate type definitions into the code files that need them, program-defined types are typically defined in header files, and then #included into any code file that requires that type definition.  These header files are typically given the same name as the program-defined type (e.g. a program-defined type named Fraction would be defined in Fraction.h)<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>A program-defined type used in only one code file should be defined in that code file as close to the first point of use as possible.<\/p>\n<p>A program-defined type used in multiple code files should be defined in a header file with the same name as the program-defined type and then #included into each code file as needed.\n<\/p><\/div>\n<p>Here&#8217;s an example of what our Fraction type would look like if we moved it to a header file (named Fraction.h) so that it could be included into multiple code files:<\/p>\n<p>Fraction.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef FRACTION_H\r\n#define FRACTION_H\r\n\r\n\/\/ Define a new type named Fraction\r\n\/\/ This only defines what a Fraction looks like, it doesn't create one\r\n\/\/ Note that this is a full definition, not a forward declaration\r\nstruct Fraction\r\n{\r\n\tint numerator {};\r\n\tint denominator {};\r\n};\r\n\r\n#endif<\/code><\/pre>\n<p>Fraction.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"Fraction.h\" \/\/ include our Fraction definition in this code file\r\n\r\n\/\/ Now we can make use of our Fraction type\r\nint main()\r\n{\r\n\tFraction f{ 3, 4 }; \/\/ this actually creates a Fraction object named f\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Type definitions are partially exempt from the one-definition rule (ODR)<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/forward-declarations\/#ODR\">2.7 -- Forward declarations and definitions<\/a>, we discussed how the one-definition rule requires that each function and global variable only have one definition per program.  To use a given function or global variable in a file that does not contain the definition, we need a forward declaration (which we typically propagate via a header file).  This works because declarations are enough to satisfy the compiler when it comes to functions and non-constexpr variables, and the linker can then connect everything up.<\/p>\n<p>However, using forward declarations in a similar manner doesn&#8217;t work for types, because the compiler typically needs to see the full definition to use a given type.  We must be able to propagate the full type definition to each code file that needs it.<\/p>\n<p>To allow for this, types are partially exempt from the one-definition rule: a given type is allowed to be defined in multiple code files.<\/p>\n<p>You&#8217;ve already exercised this capability (likely without realizing it): if your program has two code files that both <code>#include &lt;iostream&gt;<\/code>, you&#8217;re importing all of the input\/output type definitions into both files.<\/p>\n<p>There are two caveats that are worth knowing about.  First, you can still only have one type definition per code file (this usually isn&#8217;t a problem since header guards will prevent this).  Second, all of the type definitions for a given type must be identical, otherwise undefined behavior will result.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Nomenclature: user-defined types vs program-defined types<\/p>\n<p>The term &#8220;user-defined type&#8221; sometimes comes up in casual conversation, as well as being mentioned (but not defined) in the C++ language standard.  In casual conversation, the term tends to mean &#8220;a type defined within your own programs&#8221; (such as the Fraction type example above).<\/p>\n<p>The C++ language standard uses the term &#8220;user-defined type&#8221; in a non-conventional manner.  In the language standard, a &#8220;user-defined type&#8221; is any class type or enumerated type that is defined by you, the standard library, or the implementation (e.g. types defined by the compiler to support language extensions).  Perhaps counter-intuitively, this means <code>std::string<\/code> (a class type defined in the standard library) is considered to be a user-defined type!<\/p>\n<p>To provide additional differentiation, the C++20 language standard helpfully defines the term \u201cprogram-defined type\u201d to mean class types and enumerated types that are not defined as part of the standard library, implementation, or core language.  In other words, &#8220;program-defined types&#8221; only include class types and enum types that are defined by us (or a third-party library).<\/p>\n<p>Consequently, when talking only about class types and enum types that we&#8217;re defining for use in our own programs, we&#8217;ll prefer the term &#8220;program-defined&#8221;, as it has a more precise definition.<\/p>\n<div class=\"cpp-table-wrapper\">\n<table class=\"cpp-table\">\n<tr>\n<th> Type <\/th>\n<th> Meaning <\/th>\n<th> Examples <\/th>\n<\/tr>\n<tr>\n<td> Fundamental     <\/td>\n<td> A basic type built into the core C++ language <\/td>\n<td> int, std::nullptr_t <\/td>\n<\/tr>\n<tr>\n<td> Compound        <\/td>\n<td> A type defined in terms of other types <\/td>\n<td> int&#038;, double*, std::string, Fraction <\/td>\n<\/tr>\n<tr>\n<td> User-defined    <\/td>\n<td> A class type or enumerated type<br \/>(Includes those defined in the standard library or implementation)<br \/>(In casual use, typically used to mean program-defined types) <\/td>\n<td> std::string, Fraction <\/td>\n<\/tr>\n<tr>\n<td> Program-defined <\/td>\n<td> A class type or enumerated type<br \/>(Excludes those defined in standard library or implementation) <\/td>\n<td> Fraction <\/td>\n<\/tr>\n<\/table>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/unscoped-enumerations\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.2<\/span>Unscoped enumerations\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-12-summary-and-quiz\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.x<\/span>Chapter 12 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Because fundamental types are defined as part of the core C++ language, they are available for immediate use. For example, if we want to define a variable with a type of int or double, we can just do so: int x; \/\/ define variable of fundamental type &#8216;int&#8217; double d; &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12409"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=12409"}],"version-history":[{"count":29,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12409\/revisions"}],"predecessor-version":[{"id":18223,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12409\/revisions\/18223"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=12409"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=12409"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=12409"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}