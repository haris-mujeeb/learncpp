{"id":7887,"date":"2019-02-01T09:49:32","date_gmt":"2019-02-01T17:49:32","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=7887"},"modified":"2025-03-06T16:21:29","modified_gmt":"2025-03-07T00:21:29","slug":"variable-assignment-and-initialization","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/variable-assignment-and-initialization\/","title":{"rendered":"1.4 &#8212; Variable assignment and initialization"},"content":{"rendered":"<p>In the previous lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-objects-and-variables\/\">1.3 -- Introduction to objects and variables<\/a>), we covered how to define a variable that we can use to store values.  In this lesson, we&#8217;ll explore how to actually put values into variables.<\/p>\n<p>As a reminder, here&#8217;s a short program that first allocates a single integer variable named <code>x<\/code>, then allocates two more integer variables named <code>y<\/code> and <code>z<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int x;    \/\/ define an integer variable named x (preferred)\r\n    int y, z; \/\/ define two integer variables, named y and z\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>As a reminder, it is preferred to define one variable per line.  We&#8217;ll come back to cases where we define multiple variables later in this lesson.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Variable assignment<\/p>\n<p>After a variable has been defined, you can give it a value (in a separate statement) using the <code>=<\/code> operator.  This process is called <strong>assignment<\/strong>, and the <code>=<\/code> operator is called the <strong>assignment operator<\/strong>.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int width; \/\/ define an integer variable named width\r\nwidth = 5; \/\/ assignment of value 5 into variable width\r\n\r\n\/\/ variable width now has value 5<\/code><\/pre>\n<p>By default, assignment copies the value on the right-hand side of the <em>= operator<\/em> to the variable on the left-hand side of the operator.  This is called <strong>copy-assignment<\/strong>.<\/p>\n<p>Once a variable has been given a value, the value of that variable can be printed via <code>std::cout<\/code> and the <code>&lt;&lt;<\/code> operator.<\/p>\n<p>Assignment can be used whenever we want to change the value held by a variable.  Here&#8217;s an example where we use assignment twice:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tint width; \/\/ define a variable named width\r\n\twidth = 5; \/\/ copy assignment of value 5 into variable width\r\n\r\n\tstd::cout &lt;&lt; width; \/\/ prints 5\r\n\r\n\twidth = 7; \/\/ change value stored in variable width to 7\r\n\r\n\tstd::cout &lt;&lt; width; \/\/ prints 7\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n57\r\n<\/pre>\n<p>When this program is run, execution begins at the top of the <code>main<\/code> function and proceeds sequentially.  First, memory for variable <code>width<\/code> is allocated.  We then assign <code>width<\/code> the value <code>5<\/code>.  When we output the value of <code>width<\/code>, it prints <code>5<\/code> to the console.  When we then assign value <code>7<\/code> to <code>width<\/code>, any prior value (in this case <code>5<\/code>) is overwritten.  Thus when we output <code>width<\/code> again, this time it prints <code>7<\/code>.<\/p>\n<p>Normal variables can only hold one value at a time.<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>One of the most common mistakes that new programmers make is to confuse the assignment operator (<code>=<\/code>) with the equality operator (<code>==<\/code>).  Assignment (<code>=<\/code>) is used to assign a value to a variable.  Equality (<code>==<\/code>) is used to test whether two operands are equal in value.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Variable initialization<\/p>\n<p>One downside of assignment is that assigning a value to a just-defined object requires two statements: one to define the variable, and another to assign the value.<\/p>\n<p>These two steps can be combined.  When an object is defined, you can optionally provide an initial value for the object.  The process of specifying an initial value for an object is called <strong>initialization<\/strong>, and the syntax used to initialize an object is called an <strong>initializer<\/strong>.  Informally, the initial value is often called an &#8220;initializer&#8221; as well.<\/p>\n<p>For example, the following statement both defines a variable named <code>width<\/code> (of type <code>int<\/code>) and initializes it with the value <code>5<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int width { 5 };    \/\/ define variable width and initialize with initial value 5\r\n    std::cout &lt;&lt; width; \/\/ prints 5\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above initialization of variable <code>width<\/code>, <code>{ 5 }<\/code> is the initializer, and <code>5<\/code> is the initial value.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Initialization provides an initial value for a variable.  Think &#8220;initial-ization&#8221;.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Different forms of initialization<\/p>\n<p>Unlike assignment (which is generally straightforward), initialization in C++ is surprisingly complex.  So we&#8217;ll present a simplified view here to get started.<\/p>\n<p>There are 5 common forms of initialization in C++:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int a;         \/\/ default-initialization (no initializer)\r\n\r\n\/\/ Traditional initialization forms:\r\nint b = 5;     \/\/ copy-initialization (initial value after equals sign)\r\nint c ( 6 );   \/\/ direct-initialization (initial value in parenthesis)\r\n\r\n\/\/ Modern initialization forms (preferred):\r\nint d { 7 };   \/\/ direct-list-initialization (initial value in braces)\r\nint e {};      \/\/ value-initialization (empty braces)<\/code><\/pre>\n<p>You may see the above forms written with different spacing (e.g. <code>int b=5;<\/code> <code>int c(6);<\/code>, <code>int d{7};<\/code>, <code>int e{};<\/code>).  Whether you use extra spaces for readability or not is a matter of personal preference.<\/p>\n<p>As of C++17, copy-initialization, direct-initialization, and direct-list-initialization behave identically in most cases.  We&#8217;ll cover the most relevant case where they differ below.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover the rest of the differences between copy-initialization, direct-initialization, and list-initialization in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-initialization-and-copy-elision\/\">14.15 -- Class initialization and copy elision<\/a>.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Other forms of initialization include:<\/p>\n<ul>\n<li>Aggregate initialization (see <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/struct-aggregate-initialization\/\">13.8 -- Struct aggregate initialization<\/a>).\n<\/li>\n<li>Copy-list-initialization (discussed below).\n<\/li>\n<li>Reference initialization (see <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/lvalue-references\/\">12.3 --  Lvalue references<\/a>).\n<\/li>\n<li>Static-initialization, constant-initialization, and dynamic-initialization (see <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/why-non-const-global-variables-are-evil\/\">7.8 -- Why (non-const) global variables are evil<\/a>).\n<\/li>\n<li>Zero-initialization (discussed below).\n<\/li>\n<\/ul>\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Default-initialization<\/p>\n<p>When no initializer is provided (such as for variable <code>a<\/code> above), this is called <strong>default-initialization<\/strong>.  In many cases, default-initialization performs no initialization, and leaves the variable with an indeterminate value (a value that is not predictable, sometimes called a &#8220;garbage value&#8221;).<\/p>\n<p>We&#8217;ll discuss this case further in lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/uninitialized-variables-and-undefined-behavior\/\">1.6 -- Uninitialized variables and undefined behavior<\/a>).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Copy-initialization<\/p>\n<p>When an initial value is provided after an equals sign, this is called <strong>copy-initialization<\/strong>.  This form of initialization was inherited from the C language.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int width = 5; \/\/ copy-initialization of value 5 into variable width<\/code><\/pre>\n<p>Much like copy-assignment, this copies the value on the right-hand side of the equals into the variable being created on the left-hand side.  In the above snippet, variable <code>width<\/code> will be initialized with value <code>5<\/code>.<\/p>\n<p>Copy-initialization had fallen out of favor in modern C++ due to being less efficient than other forms of initialization for some complex types.  However, C++17 remedied the bulk of these issues, and copy-initialization is now finding new advocates.  You will also find it used in older code (especially code ported from C), or by developers who simply think it looks more natural and is easier to read.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Copy-initialization is also used whenever values are implicitly copied, such as when passing arguments to a function by value, returning from a function by value, or catching exceptions by value.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Direct-initialization<\/p>\n<p>When an initial value is provided inside parenthesis, this is called <strong>direct-initialization<\/strong>.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int width ( 5 ); \/\/ direct initialization of value 5 into variable width<\/code><\/pre>\n<p>Direct-initialization was initially introduced to allow for more efficient initialization of complex objects (those with class types, which we&#8217;ll cover in a future chapter).  Just like copy-initialization, direct-initialization had fallen out of favor in modern C++, largely due to being superseded by direct-list-initialization.  However, direct-list-initialization has a few quirks of its own, and so direct-initialization is once again finding use in certain cases.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Direct-initialization is also used when values are explicitly cast to another type (e.g. via <code>static_cast<\/code>).\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">List-initialization<\/p>\n<p>The modern way to initialize objects in C++ is to use a form of initialization that makes use of curly braces.  This is called <strong>list-initialization<\/strong> (or <strong>uniform initialization<\/strong> or <strong>brace initialization<\/strong>).<\/p>\n<p>List-initialization comes in two forms:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int width { 5 };    \/\/ direct-list-initialization of initial value 5 into variable width (preferred)\r\nint height = { 6 }; \/\/ copy-list-initialization of initial value 6 into variable height (rarely used)<\/code><\/pre>\n<p>Prior to C++11, some types of initialization required using copy-initialization, and other types of initialization required using direct-initialization.  Copy-initialization can be hard to differentiate from copy-assignment (because both use an <code>=<\/code>).  And direct-initialization can be difficult to differentiate from function-related operations (because both use parentheses).<\/p>\n<p>List-initialization was introduced to provide a initialization syntax that works in almost all cases, behaves consistently, and has an unambiguous syntax that makes it easy to tell where we&#8217;re initializing an object.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>When we see curly braces, we know we&#8217;re list-initializing an object.\n<\/p><\/div>\n<p>Additionally, list-initialization also provides a way to initialize objects with a list of values rather than a single value (which is why it is called &#8220;list-initialization&#8221;).  We show an example of this in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdvector-and-list-constructors\/\">16.2 -- Introduction to std::vector and list constructors<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">List-initialization disallows narrowing conversions<\/p>\n<p>One of the primary benefits of list-initialization for new C++ programmers is that &#8220;narrowing conversions&#8221; are disallowed.  This means that if you try to list-initialize a variable using a value that the variable can not safely hold, the compiler is required to produce a diagnostic (compilation error or warning) to notify you.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    \/\/ An integer can only hold non-fractional values.\r\n    \/\/ Initializing an int with fractional value 4.5 requires the compiler to convert 4.5 to a value an int can hold.\r\n    \/\/ Such a conversion is a narrowing conversion, since the fractional part of the value will be lost.\r\n\r\n    int w1 { 4.5 }; \/\/ compile error: list-init does not allow narrowing conversion\r\n\r\n    int w2 = 4.5;   \/\/ compiles: w2 copy-initialized to value 4\r\n    int w3 (4.5);   \/\/ compiles: w3 direct-initialized to value 4\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>On line 7 of the above program, we&#8217;re using a value (<code>4.5<\/code>) with a fractional component (<code>.5<\/code>) to list-initialize an integer variable (which can only hold non-fractional values).  Because this is a narrowing conversion, the compiler is required to generate a diagnostic in such cases.<\/p>\n<p>Copy-initialization (line 9) and direct-initialization (line 10) both silently drop the <code>.5<\/code> and initialize the variable with the value <code>4<\/code> (which probably isn&#8217;t what we want).  Your compiler may warn you about this (since losing data is rarely desired), but it also may not.<\/p>\n<p>Note that this restriction on narrowing conversions only applies to the list-initialization, not to any subsequent assignments to the variable:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int w1 { 4.5 }; \/\/ compile error: list-init does not allow narrowing conversion of 4.5 to 4\r\n\r\n    w1 = 4.5;       \/\/ okay: copy-assignment allows narrowing conversion of 4.5 to 4\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Value-initialization and zero-initialization<\/p>\n<p>When a variable is initialized using an empty set of braces, a special form of list-initialization called <strong>value-initialization<\/strong> takes place.  In most cases, value-initialization will implicitly initialize the variable to zero (or whatever value is closest to zero for a given type).  In cases where zeroing occurs, this is called <strong>zero-initialization<\/strong>.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int width {}; \/\/ value-initialization \/ zero-initialization to value 0<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>For class types, value-initialization (and default-initialization) may instead initialize the object to predefined default values, which may be non-zero.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">List-initialization is the preferred form of initialization in modern C++<\/p>\n<p>List-initialization (including value-initialization) is generally preferred over the other initialization forms because it works in most cases (and is therefore most consistent), it disallows narrowing conversions (which we normally don&#8217;t want), and it supports initialization with a list of values (something we&#8217;ll cover in a future lesson).<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Prefer direct-list-initialization or value-initialization to initialize your variables.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>Bjarne Stroustrup (creator of C++) and Herb Sutter (C++ expert) also recommend <a href=\"https:\/\/isocpp.github.io\/CppCoreGuidelines\/CppCoreGuidelines#Res-list\">using list-initialization<\/a> to initialize your variables.<\/p>\n<p>In modern C++, there are some cases where list-initialization does not work as expected.  We cover one such case in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdvector-and-list-constructors\/\">16.2 -- Introduction to std::vector and list constructors<\/a>.  Because of such quirks, some experienced developers now advocate for using a mix of copy, direct, and list-initialization, depending on the circumstance.  Once you are familiar enough with the language to understand the nuances of each initialization type and the reasoning behind such recommendations, you can evaluate on your own whether you find these arguments persuasive.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Q: When should I initialize with { 0 } vs {}?<\/p>\n<p>Use direct-list-initialization when you&#8217;re actually using the initial value:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int x { 0 };    \/\/ direct-list-initialization with initial value 0\r\nstd::cout &lt;&lt; x; \/\/ we're using that 0 value here<\/code><\/pre>\n<p>Use value-initialization when the object&#8217;s value is temporary and will be replaced:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int x {};      \/\/ value initialization\r\nstd::cin &gt;&gt; x; \/\/ we're immediately replacing that value so an explicit 0 would be meaningless<\/code><\/pre>\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Initialize your variables<\/p>\n<p>Initialize your variables upon creation.  You may eventually find cases where you want to ignore this advice for a specific reason (e.g. a performance critical section of code that uses a lot of variables), and that&#8217;s okay, as long as the choice is made deliberately.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>For more discussion on this topic, Bjarne Stroustrup (creator of C++) and Herb Sutter (C++ expert) make this recommendation themselves <a href=\"https:\/\/github.com\/isocpp\/CppCoreGuidelines\/blob\/master\/CppCoreGuidelines.md#es20-always-initialize-an-object\">here<\/a>.\n<\/div>\n<p>We explore what happens if you try to use a variable that doesn&#8217;t have a well-defined value in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/uninitialized-variables-and-undefined-behavior\/\">1.6 -- Uninitialized variables and undefined behavior<\/a>.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Initialize your variables upon creation.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Instantiation<\/p>\n<p>The term <strong>instantiation<\/strong> is a fancy word that means a variable has been created (allocated) and initialized (this includes default initialization).  An instantiated object is sometimes called an <strong>instance<\/strong>.  Most often, this term is applied to class type objects, but it is occasionally applied to objects of other types as well.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Initializing multiple variables<\/p>\n<p>In the last section, we noted that it is possible to define multiple variables <em>of the same type<\/em> in a single statement by separating the names with a comma:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int a, b; \/\/ create variables a and b, but do not initialize them<\/code><\/pre>\n<p>We also noted that best practice is to avoid this syntax altogether.  However, since you may encounter other code that uses this style, it&#8217;s still useful to talk a little bit more about it, if for no other reason than to reinforce some of the reasons you should be avoiding it.<\/p>\n<p>You can initialize multiple variables defined on the same line:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int a = 5, b = 6;          \/\/ copy-initialization\r\nint c ( 7 ), d ( 8 );      \/\/ direct-initialization\r\nint e { 9 }, f { 10 };     \/\/ direct-list-initialization\r\nint i {}, j {};            \/\/ value-initialization<\/code><\/pre>\n<p>Unfortunately, there&#8217;s a common pitfall here that can occur when the programmer mistakenly tries to initialize both variables by using one initialization statement:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int a, b = 5;     \/\/ wrong: a is not initialized to 5!\r\nint a = 5, b = 5; \/\/ correct: a and b are initialized to 5<\/code><\/pre>\n<p>In the top statement, variable <code>a<\/code> will be left uninitialized, and the compiler may or may not complain.  If it doesn&#8217;t, this is a great way to have your program intermittently crash or produce sporadic results.  We&#8217;ll talk more about what happens if you use uninitialized variables shortly.<\/p>\n<p>The best way to remember that this is wrong is to note that each variable can only be initialized by its own initializer:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int a = 4, b = 5; \/\/ correct: a and b both have initializers\r\nint a, b = 5;     \/\/ wrong: a doesn't have its own initializer<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Unused initialized variables warnings<\/p>\n<p>Modern compilers will typically generate warnings if a variable is initialized but not used (since this is rarely desirable).  And if &#8220;treat warnings as errors&#8221; is enabled, these warnings will be promoted to errors and cause the compilation to fail.<\/p>\n<p>Consider the following innocent looking program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int x { 5 }; \/\/ variable x defined\r\n\r\n    \/\/ but not used anywhere\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When compiling this with GCC and &#8220;treat warnings as errors&#8221; on, the following error is generated:<\/p>\n<pre>\nprog.cc: In function 'int main()':\r\nprog.cc:3:9: error: unused variable 'x' [-Werror=unused-variable]\r\n<\/pre>\n<p>and the program fails to compile.<\/p>\n<p>There are a few easy ways to fix this.<\/p>\n<ol start=\"1\">\n<li>If the variable really is unused and you don&#8217;t need it, then the easiest option is to remove the definition of <code>x<\/code> (or comment it out).  After all, if it&#8217;s not used, then removing it won&#8217;t affect anything.\n<\/li>\n<li>Another option is to simply use the variable somewhere:\n<\/li>\n<\/ol>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 5 };\r\n\r\n    std::cout &lt;&lt; x; \/\/ variable now used somewhere\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>But this requires some effort to write code that uses it, and has the downside of potentially changing your program&#8217;s behavior.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The <code>[[maybe_unused]]<\/code> attribute <span class=\"cpp-section-pill cpp-section-standard\">C++17<\/span><\/p>\n<p>In some cases, neither of the above options are desirable.  Consider the case where we have a set of math\/physics values that we use in many different programs:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    \/\/ Here's some math\/physics values that we copy-pasted from elsewhere\r\n    double pi { 3.14159 };\r\n    double gravity { 9.8 };\r\n    double phi { 1.61803 };\r\n\r\n    std::cout &lt;&lt; pi &lt;&lt; '\\n';  \/\/ pi is used\r\n    std::cout &lt;&lt; phi &lt;&lt; '\\n'; \/\/ phi is used\r\n\r\n    \/\/ The compiler will likely complain about gravity being defined but unused\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>If we use these values a lot, we probably have these saved somewhere and copy\/paste\/import them all together.<\/p>\n<p>However, in any program where we don&#8217;t use <em>all<\/em> of these values, the compiler will likely complain about each variable that isn&#8217;t actually used.  In the above example, we could easily just remove the definition of <code>gravity<\/code>.  But what if there were 20 or 30 variables instead of 3?  And what if we use them in multiple places?  Going through the list of variables to remove\/comment out the unused ones takes time and energy.  And later if we need one that we&#8217;ve previously removed, we&#8217;ll have to spend more time and energy to go back and re-add\/uncomment it.<\/p>\n<p>To address such cases, C++17 introduced the <code>[[maybe_unused]]<\/code> attribute, which allows us to tell the compiler that we&#8217;re okay with a variable being unused.  The compiler will not generate unused variable warnings for such variables.<\/p>\n<p>The following program should generate no warnings\/errors:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    [[maybe_unused]] double pi { 3.14159 };  \/\/ Don't complain if pi is unused\r\n    [[maybe_unused]] double gravity { 9.8 }; \/\/ Don't complain if gravity is unused\r\n    [[maybe_unused]] double phi { 1.61803 }; \/\/ Don't complain if phi is unused\r\n\r\n    std::cout &lt;&lt; pi &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; phi &lt;&lt; '\\n';\r\n\r\n    \/\/ The compiler will no longer warn about gravity not being used\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Additionally, the compiler will likely optimize these variables out of the program, so they have no performance impact.<\/p>\n<p>The <code>[[maybe_unused]]<\/code> attribute should only be applied selectively to variables that have a specific and legitimate reason for being unused (e.g. because you need a list of named values, but which specific values are actually used in a given program may vary).  Otherwise, unused variables should be removed from the program.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>In future lessons, we&#8217;ll often define variables we don&#8217;t use again, in order to demonstrate the syntax for certain concepts.  Making use of <code>[[maybe_unused]]<\/code> allows us to do so without compilation warnings\/errors.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>What is the difference between initialization and assignment?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>Initialization gives a variable an initial value at the point when it is created.  Assignment gives a variable a value at some point after the variable is created.\n<\/p><\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>What form of initialization should you prefer when you want to initialize a variable with a specific value?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p>Direct-list-initialization (aka. direct brace initialization).\n<\/p><\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #3<\/p>\n<p>What are default-initialization and value-initialization?  What is the behavior of each?  Which should you prefer?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<p>Default-initialization is when a variable initialization has no initializer (e.g. <code>int x;<\/code>).  In most cases, the variable is left with an indeterminate value.<\/p>\n<p>Value-initialization is when a variable initialization has an empty brace initializer (e.g. <code>int x{};<\/code>).  In most cases this will perform zero-initialization.<\/p>\n<p>You should prefer value-initialization, as it initializes the variable to a consistent value.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-iostream-cout-cin-and-endl\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">1.5<\/span>Introduction to iostream: cout, cin, and endl\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-objects-and-variables\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">1.3<\/span>Introduction to objects and variables\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the previous lesson (), we covered how to define a variable that we can use to store values. In this lesson, we&#8217;ll explore how to actually put values into variables. As a reminder, here&#8217;s a short program that first allocates a single integer variable named x, then allocates two &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/7887"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=7887"}],"version-history":[{"count":69,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/7887\/revisions"}],"predecessor-version":[{"id":18243,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/7887\/revisions\/18243"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=7887"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=7887"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=7887"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}