{"id":11246,"date":"2021-06-17T17:43:47","date_gmt":"2021-06-18T01:43:47","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=11246"},"modified":"2024-12-11T22:05:08","modified_gmt":"2024-12-12T06:05:08","slug":"function-overload-differentiation","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/function-overload-differentiation\/","title":{"rendered":"11.2 &#8212; Function overload differentiation"},"content":{"rendered":"<p>In the prior lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-function-overloading\/\">11.1 -- Introduction to function overloading<\/a>), we introduced the concept of function overloading, which allows us to create multiple functions with the same name, so long as each identically named function has different parameter types (or the functions can be otherwise differentiated).<\/p>\n<p>In this lesson, we&#8217;ll take a closer look at how overloaded functions are differentiated.  Overloaded functions that are not properly differentiated will cause the compiler to issue a compile error.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">How overloaded functions are differentiated<\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<th>Function property<\/th>\n<th>Used for differentiation<\/th>\n<th>Notes<\/th>\n<\/tr>\n<tr>\n<td>Number of parameters<\/td>\n<td>Yes<\/td>\n<td><\/td>\n<\/tr>\n<tr>\n<td>Type of parameters<\/td>\n<td>Yes<\/td>\n<td>Excludes typedefs, type aliases, and const qualifier on value parameters.  Includes ellipses.<\/td>\n<\/tr>\n<tr>\n<td>Return type<\/td>\n<td>No<\/td>\n<td><\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>Note that a function&#8217;s return type is not used to differentiate overloaded functions.  We&#8217;ll discuss this more in a bit.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>For member functions, additional function-level qualifiers are also considered:<\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<th>Function-level qualifier<\/th>\n<th>Used for overloading<\/th>\n<\/tr>\n<tr>\n<td>const or volatile<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Ref-qualifiers<\/td>\n<td>Yes<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>As an example, a const member function can be differentiated from an otherwise identical non-const member function (even if they share the same set of parameters).\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover ellipses in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/ellipsis-and-why-to-avoid-them\/\">20.5 -- Ellipsis (and why to avoid them)<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Overloading based on number of parameters<\/p>\n<p>An overloaded function is differentiated so long as each overloaded function has a different number of parameters.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int add(int x, int y)\r\n{\r\n    return x + y;\r\n}\r\n\r\nint add(int x, int y, int z)\r\n{\r\n    return x + y + z;\r\n}<\/code><\/pre>\n<p>The compiler can easily tell that a function call with two integer parameters should go to <code>add(int, int)<\/code> and a function call with three integer parameters should go to <code>add(int, int, int)<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Overloading based on type of parameters<\/p>\n<p>A function can also be differentiated so long as each overloaded function&#8217;s list of parameter types is distinct.  For example, all of the following overloads are differentiated:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int add(int x, int y); \/\/ integer version\r\ndouble add(double x, double y); \/\/ floating point version\r\ndouble add(int x, double y); \/\/ mixed version\r\ndouble add(double x, int y); \/\/ mixed version<\/code><\/pre>\n<p>Because type aliases (or typedefs) are not distinct types, overloaded functions using type aliases are not distinct from overloads using the aliased type.  For example, all of the following overloads are not differentiated (and will result in a compile error):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">typedef int Height; \/\/ typedef\r\nusing Age = int; \/\/ type alias\r\n\r\nvoid print(int value);\r\nvoid print(Age value); \/\/ not differentiated from print(int)\r\nvoid print(Height value); \/\/ not differentiated from print(int)<\/code><\/pre>\n<p>For parameters passed by value, the const qualifier is also not considered.  Therefore, the following functions are not considered to be differentiated:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void print(int);\r\nvoid print(const int); \/\/ not differentiated from print(int)<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>We haven&#8217;t covered ellipsis yet, but ellipsis parameters are considered to be a unique type of parameter:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void foo(int x, int y);\r\nvoid foo(int x, ...); \/\/ differentiated from foo(int, int)<\/code><\/pre>\n<p>Thus a call to <code>foo(4, 5)<\/code> will match to <code>foo(int, int)<\/code>, not <code>foo(int, ...)<\/code>.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The return type of a function is not considered for differentiation<\/p>\n<p>A function&#8217;s return type is not considered when differentiating overloaded functions.<\/p>\n<p>Consider the case where you want to write a function that returns a random number, but you need a version that will return an int, and another version that will return a double.  You might be tempted to do this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int getRandomValue();\r\ndouble getRandomValue();<\/code><\/pre>\n<p>On Visual Studio 2019, this results in the following compiler error:<\/p>\n<pre>\r\nerror C2556: 'double getRandomValue(void)': overloaded function differs only by return type from 'int getRandomValue(void)'\r\n<\/pre>\n<p>This makes sense.  If you were the compiler, and you saw this statement:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">getRandomValue();<\/code><\/pre>\n<p>Which of the two overloaded functions would you call?  It&#8217;s not clear.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>This was an intentional choice, as it ensures the behavior of a function call can be determined independently from the rest of the expression, making understanding complex expressions much simpler.  Put another way, we can always determine which version of a function will be called based solely on the arguments in the function call.  If return values were used for differentiation, then we wouldn&#8217;t have an easy syntactic way to tell which overload of a function was being called -- we&#8217;d also have to understand how the return value was being used, which requires a lot more analysis.\n<\/p><\/div>\n<p>The best way to address this is to give the functions different names:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int getRandomInt();\r\ndouble getRandomDouble();<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Type signature<\/p>\n<p>A function&#8217;s <strong>type signature<\/strong> (generally called a <strong>signature<\/strong>) is defined as the parts of the function header that are used for differentiation of the function.  In C++, this includes the function name, number of parameters, parameter type, and function-level qualifiers.  It notably does <em>not<\/em> include the return type.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Name mangling<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>When the compiler compiles a function, it performs <strong>name mangling<\/strong>, which means the compiled name of the function is altered (&#8220;mangled&#8221;) based on various criteria, such as the number and type of parameters, so that the linker has unique names to work with.<\/p>\n<p>For example, a function with prototype <code>int fcn()<\/code> might compile to mangled name <code>__fcn_v<\/code>, whereas <code>int fcn(int)<\/code> might compile to mangled name <code>__fcn_i<\/code>.  So while in the source code, the two overloaded functions share the name <code>fcn()<\/code>, in compiled code, the mangled names are unique (<code>__fcn_v<\/code> vs <code>__fcn_i<\/code>).<\/p>\n<p>There is no standardization on how names should be mangled, so different compilers will produce different mangled names.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-overload-resolution-and-ambiguous-matches\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">11.3<\/span>Function overload resolution and ambiguous matches\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-function-overloading\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">11.1<\/span>Introduction to function overloading\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the prior lesson (), we introduced the concept of function overloading, which allows us to create multiple functions with the same name, so long as each identically named function has different parameter types (or the functions can be otherwise differentiated). In this lesson, we&#8217;ll take a closer look at &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/11246"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=11246"}],"version-history":[{"count":16,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/11246\/revisions"}],"predecessor-version":[{"id":17981,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/11246\/revisions\/17981"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=11246"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=11246"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=11246"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}