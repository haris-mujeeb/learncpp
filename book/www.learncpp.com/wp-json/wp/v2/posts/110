{"id":110,"date":"2007-07-24T18:06:35","date_gmt":"2007-07-25T02:06:35","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/73-passing-arguments-by-reference\/"},"modified":"2024-12-06T09:52:30","modified_gmt":"2024-12-06T17:52:30","slug":"pass-by-lvalue-reference","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/pass-by-lvalue-reference\/","title":{"rendered":"12.5 &#8212; Pass by lvalue reference"},"content":{"rendered":"<p>In the previous lessons, we introduced lvalue references (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/lvalue-references\/\">12.3 --  Lvalue references<\/a>) and lvalue references to const (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/lvalue-references-to-const\/\">12.4 -- Lvalue references to const<\/a>).  In isolation, these may not have seemed very useful -- why create an alias to a variable when you can just use the variable itself?<\/p>\n<p>In this lesson, we&#8217;ll finally provide some insight into what makes references useful.  And then starting later in this chapter, you&#8217;ll see references used regularly.<\/p>\n<p>First, some context.  Back in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-function-parameters-and-arguments\/\">2.4 -- Introduction to function parameters and arguments<\/a> we discussed <code>pass by value<\/code>, where an argument passed to a function is copied into the function&#8217;s parameter:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printValue(int y)\r\n{\r\n    std::cout &lt;&lt; y &lt;&lt; '\\n';\r\n} \/\/ y is destroyed here\r\n\r\nint main()\r\n{\r\n    int x { 2 };\r\n\r\n    printValue(x); \/\/ x is passed by value (copied) into parameter y (inexpensive)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above program, when <code>printValue(x)<\/code> is called, the value of <code>x<\/code> (<code>2<\/code>) is <em>copied<\/em> into parameter <code>y<\/code>.  Then, at the end of the function, object <code>y<\/code> is destroyed.<\/p>\n<p>This means that when we called the function, we made a copy of our argument&#8217;s value, only to use it briefly and then destroy it!  Fortunately, because fundamental types are cheap to copy, this isn&#8217;t a problem.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Some objects are expensive to copy<\/p>\n<p>Most of the types provided by the standard library (such as <code>std::string<\/code>) are class types.  Class types are usually expensive to copy.  Whenever possible, we want to avoid making unnecessary copies of objects that are expensive to copy, especially when we will destroy those copies almost immediately.<\/p>\n<p>Consider the following program illustrating this point:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nvoid printValue(std::string y)\r\n{\r\n    std::cout &lt;&lt; y &lt;&lt; '\\n';\r\n} \/\/ y is destroyed here\r\n\r\nint main()\r\n{\r\n    std::string x { \"Hello, world!\" }; \/\/ x is a std::string\r\n\r\n    printValue(x); \/\/ x is passed by value (copied) into parameter y (expensive)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints<\/p>\n<pre>\r\nHello, world!\r\n<\/pre>\n<p>While this program behaves like we expect, it&#8217;s also inefficient.  Identically to the prior example, when <code>printValue()<\/code> is called, argument <code>x<\/code> is copied into <code>printValue()<\/code> parameter <code>y<\/code>.  However, in this example, the argument is a <code>std::string<\/code> instead of an <code>int<\/code>, and <code>std::string<\/code> is a class type that is expensive to copy.  And this expensive copy is made every time <code>printValue()<\/code> is called!<\/p>\n<p>We can do better.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Pass by reference<\/p>\n<p>One way to avoid making an expensive copy of an argument when calling a function is to use <code>pass by reference<\/code> instead of <code>pass by value<\/code>.  When using <strong>pass by reference<\/strong>, we declare a function parameter as a reference type (or const reference type) rather than as a normal type.  When the function is called, each reference parameter is bound to the appropriate argument.  Because the reference acts as an alias for the argument, no copy of the argument is made.<\/p>\n<p>Here&#8217;s the same example as above, using pass by reference instead of pass by value:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nvoid printValue(std::string&amp; y) \/\/ type changed to std::string&amp;\r\n{\r\n    std::cout &lt;&lt; y &lt;&lt; '\\n';\r\n} \/\/ y is destroyed here\r\n\r\nint main()\r\n{\r\n    std::string x { \"Hello, world!\" };\r\n\r\n    printValue(x); \/\/ x is now passed by reference into reference parameter y (inexpensive)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program is identical to the prior one, except the type of parameter <code>y<\/code> has been changed from <code>std::string<\/code> to <code>std::string&amp;<\/code> (an lvalue reference).  Now, when <code>printValue(x)<\/code> is called, lvalue reference parameter <code>y<\/code> is bound to argument <code>x<\/code>.  Binding a reference is always inexpensive, and no copy of <code>x<\/code> needs to be made.  Because a reference acts as an alias for the object being referenced, when <code>printValue()<\/code> uses reference <code>y<\/code>, it&#8217;s accessing the actual argument <code>x<\/code> (rather than a copy of <code>x<\/code>).<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Pass by reference allows us to pass arguments to a function without making copies of those arguments each time the function is called.\n<\/p><\/div>\n<p>The following program demonstrates that a value parameter is a separate object from the argument, while a reference parameter is treated as if it were the argument:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printAddresses(int val, int&amp; ref)\r\n{\r\n    std::cout &lt;&lt; \"The address of the value parameter is: \" &lt;&lt; &amp;val &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"The address of the reference parameter is: \" &lt;&lt; &amp;ref &lt;&lt; '\\n';   \r\n}\r\n\r\nint main()\r\n{\r\n    int x { 5 };\r\n    std::cout &lt;&lt; \"The address of x is: \" &lt;&lt; &amp;x &lt;&lt; '\\n';\r\n    printAddresses(x, x);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>One run of this program produced the following output:<\/p>\n<pre>\nThe address of x is: 0x7ffd16574de0\r\nThe address of the value parameter is: 0x7ffd16574de4\r\nThe address of the reference parameter is: 0x7ffd16574de0\r\n<\/pre>\n<p>We can see that the argument has a different address than the value parameter, meaning the value parameter is a different object.  Since they have separate memory addresses, in order for the value parameter to have the same value as the argument, the argument&#8217;s value must be copied into memory held by the value parameter.<\/p>\n<p>On the other hand, we can see that taking the address of the reference parameter yields an address identical to that of the argument.  This means that the reference parameter is being treated as if it were the same object as the argument.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Pass by reference allows us to change the value of an argument<\/p>\n<p>When an object is passed by value, the function parameter receives a copy of the argument.  This means that any changes to the value of the parameter are made to the copy of the argument, not the argument itself:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid addOne(int y) \/\/ y is a copy of x\r\n{\r\n    ++y; \/\/ this modifies the copy of x, not the actual object x\r\n}\r\n\r\nint main()\r\n{\r\n    int x { 5 };\r\n\r\n    std::cout &lt;&lt; \"value = \" &lt;&lt; x &lt;&lt; '\\n';\r\n\r\n    addOne(x);\r\n\r\n    std::cout &lt;&lt; \"value = \" &lt;&lt; x &lt;&lt; '\\n'; \/\/ x has not been modified\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above program, because value parameter <code>y<\/code> is a copy of <code>x<\/code>, when we increment <code>y<\/code>, this only affects <code>y<\/code>.  This program outputs:<\/p>\n<pre>\nvalue = 5\r\nvalue = 5\r\n<\/pre>\n<p>However, since a reference acts identically to the object being referenced, when using pass by reference, any changes made to the reference parameter <em>will<\/em> affect the argument:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid addOne(int&amp; y) \/\/ y is bound to the actual object x\r\n{\r\n    ++y; \/\/ this modifies the actual object x\r\n}\r\n\r\nint main()\r\n{\r\n    int x { 5 };\r\n\r\n    std::cout &lt;&lt; \"value = \" &lt;&lt; x &lt;&lt; '\\n';\r\n\r\n    addOne(x);\r\n\r\n    std::cout &lt;&lt; \"value = \" &lt;&lt; x &lt;&lt; '\\n'; \/\/ x has been modified\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program outputs:<\/p>\n<pre>\nvalue = 5\r\nvalue = 6\r\n<\/pre>\n<p>In the above example, <code>x<\/code> initially has value <code>5<\/code>.  When <code>addOne(x)<\/code> is called, reference parameter <code>y<\/code> is bound to argument <code>x<\/code>.  When the <code>addOne()<\/code> function increments reference <code>y<\/code>, it&#8217;s actually incrementing argument <code>x<\/code> from <code>5<\/code> to <code>6<\/code> (not a copy of <code>x<\/code>).  This changed value persists even after <code>addOne()<\/code> has finished executing.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Passing values by reference to non-const allows us to write functions that modify the value of arguments passed in.\n<\/p><\/div>\n<p>The ability for functions to modify the value of arguments passed in can be useful.  Imagine you&#8217;ve written a function that determines whether a monster has successfully attacked the player.  If so, the monster should do some amount of damage to the player&#8217;s health.  If you pass your player object by reference, the function can directly modify the health of the actual player object that was passed in.  If you pass the player object by value, you could only modify the health of a copy of the player object, which isn&#8217;t as useful.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Pass by reference can only accept modifiable lvalue arguments<\/p>\n<p>Because a reference to a non-const value can only bind to a modifiable lvalue (essentially a non-const variable), this means that pass by reference only works with arguments that are modifiable lvalues.  In practical terms, this significantly limits the usefulness of pass by reference to non-const, as it means we can not pass const variables or literals.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printValue(int&amp; y) \/\/ y only accepts modifiable lvalues\r\n{\r\n    std::cout &lt;&lt; y &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    int x { 5 };\r\n    printValue(x); \/\/ ok: x is a modifiable lvalue\r\n\r\n    const int z { 5 };\r\n    printValue(z); \/\/ error: z is a non-modifiable lvalue\r\n\r\n    printValue(5); \/\/ error: 5 is an rvalue\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Fortunately, there&#8217;s an easy way around this, which we will discuss next lesson.  We&#8217;ll also take a look at when to pass by value vs. pass by reference.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pass-by-const-lvalue-reference\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.6<\/span>Pass by const lvalue reference\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/lvalue-references-to-const\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.4<\/span>Lvalue references to const\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the previous lessons, we introduced lvalue references () and lvalue references to const (). In isolation, these may not have seemed very useful &#8212; why create an alias to a variable when you can just use the variable itself? In this lesson, we&#8217;ll finally provide some insight into what &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/110"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=110"}],"version-history":[{"count":63,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/110\/revisions"}],"predecessor-version":[{"id":17966,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/110\/revisions\/17966"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=110"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=110"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=110"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}