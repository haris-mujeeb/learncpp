{"id":9386,"date":"2020-01-03T10:37:51","date_gmt":"2020-01-03T18:37:51","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=9386"},"modified":"2025-01-30T15:34:01","modified_gmt":"2025-01-30T23:34:01","slug":"internal-linkage","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/internal-linkage\/","title":{"rendered":"7.6 &#8212; Internal linkage"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/local-variables\/\">7.3 -- Local variables<\/a>, we said, &#8220;An identifier\u2019s linkage determines whether other declarations of that name refer to the same object or not&#8221;, and we discussed how local variables have <code>no linkage<\/code>.<\/p>\n<p>Global variables and function identifiers can have either <code>internal linkage<\/code> or <code>external linkage<\/code>.  We&#8217;ll cover the internal linkage case in this lesson, and the external linkage case in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/external-linkage-and-variable-forward-declarations\/\">7.7 -- External linkage and variable forward declarations<\/a>.<\/p>\n<p>An identifier with <strong>internal linkage<\/strong> can be seen and used within a single translation unit, but it is not accessible from other translation units.  This means that if two source files have identically named identifiers with internal linkage, those identifiers will be treated as independent (and do not result in an ODR violation for having duplicate definitions).<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Identifiers with internal linkage may not be visible to the linker at all.  Alternatively, they may be visible to the linker, but marked for use in a specific translation unit only.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover translation units in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-the-preprocessor\/\">2.10 -- Introduction to the preprocessor<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Global variables with internal linkage<\/p>\n<p>Global variables with internal linkage are sometimes called <strong>internal variables<\/strong>.  <\/p>\n<p>To make a non-constant global variable internal, we use the <code>static<\/code> keyword.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstatic int g_x{}; \/\/ non-constant globals have external linkage by default, but can be given internal linkage via the static keyword\r\n\r\nconst int g_y{ 1 }; \/\/ const globals have internal linkage by default\r\nconstexpr int g_z{ 2 }; \/\/ constexpr globals have internal linkage by default\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; g_x &lt;&lt; ' ' &lt;&lt; g_y &lt;&lt; ' ' &lt;&lt; g_z &lt;&lt; '\\n';\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Const and constexpr global variables have internal linkage by default (and thus don&#8217;t need the <code>static<\/code> keyword -- if it is used, it will be ignored).<\/p>\n<p>Here&#8217;s an example of multiple files using internal variables:<\/p>\n<p>a.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">[[maybe_unused]] constexpr int g_x { 2 }; \/\/ this internal g_x is only accessible within a.cpp<\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstatic int g_x { 3 }; \/\/ this separate internal g_x is only accessible within main.cpp\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; g_x &lt;&lt; '\\n'; \/\/ uses main.cpp's g_x, prints 3\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\r\n3\r\n<\/pre>\n<p>Because <code>g_x<\/code> is internal to each file, <code>main.cpp<\/code> has no idea that <code>a.cpp<\/code> also has a variable named <code>g_x<\/code> (and vice versa).<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>The use of the <code>static<\/code> keyword above is an example of a <strong>storage class specifier<\/strong>, which sets both the name&#8217;s linkage and its storage duration.  The most commonly used <code>storage class specifiers<\/code> are <code>static<\/code>, <code>extern<\/code>, and <code>mutable<\/code>.  The term <code>storage class specifier<\/code> is mostly used in technical documentations.\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>The C++11 standard (appendix C) provides the rationale for why const variables have internal linkage by default: &#8220;Because const objects can be used as compile-time values in C++, this feature urges programmers to provide explicit initializer values for each const. This feature allows the user to put const objects in header files that are included in many compilation units.&#8221;<\/p>\n<p>The designers of C++ intended two things:<\/p>\n<ul>\n<li>Const objects should be usable in constant expressions.  In order to be usable in a constant expression, the compiler must have seen a definition (not a declaration) so it be evaluated at compile-time.\n<\/li>\n<li>Const objects should be able to be propagated via header files.\n<\/li>\n<\/ul>\n<p>Objects with external linkage can only be defined in a single translation unit without violating the ODR -- other translation units must access those objects via a forward declaration.  If const objects had external linkage by default, they would only be usable in constant expressions in the single translation unit containing the definition, and they could not be effectively propagated via header files, as #including the header into more than one source file would result in an ODR violation.<\/p>\n<p>Objects with internal linkage can have a definition in each translation unit where they are needed without violating the ODR.  This allows const objects to be placed in a header file and #included into as many translation units as desired without violating the ODR.  And since each translation unit has a definition rather than a declaration, this ensures that those constants can be used in constant expressions within the translation unit.<\/p>\n<p>Inline variables (which can have external linkage without causing ODR violations) weren&#8217;t introduced until C++17.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Functions with internal linkage<\/p>\n<p>As noted above, function identifiers also have linkage.  Functions default to external linkage (which we&#8217;ll cover in the next lesson), but can be set to internal linkage via the <code>static<\/code> keyword:<\/p>\n<p>add.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ This function is declared as static, and can now be used only within this file\r\n\/\/ Attempts to access it from another file via a function forward declaration will fail\r\n[[maybe_unused]] static int add(int x, int y)\r\n{\r\n    return x + y;\r\n}<\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y); \/\/ forward declaration for function add\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; add(3, 4) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program won&#8217;t link, because function <code>add<\/code> is not accessible outside of <code>add.cpp<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The one-definition rule and internal linkage<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/forward-declarations\/\">2.7 -- Forward declarations and definitions<\/a>, we noted that the one-definition rule says that an object or function can&#8217;t have more than one definition, either within a file or a program.<\/p>\n<p>However, it&#8217;s worth noting that internal objects (and functions) that are defined in different files are considered to be independent entities (even if their names and types are identical), so there is no violation of the one-definition rule.  Each internal object only has one definition.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><code>static<\/code> vs unnamed namespaces<\/p>\n<p>In modern C++, use of the <code>static<\/code> keyword for giving identifiers internal linkage is falling out of favor.  Unnamed namespaces can give internal linkage to a wider range of identifiers (e.g. type identifiers), and they are better suited for giving many identifiers internal linkage.<\/p>\n<p>We cover unnamed namespaces in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/unnamed-and-inline-namespaces\/\">7.14 -- Unnamed and inline namespaces<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Why bother giving identifiers internal linkage?<\/p>\n<p>There are typically two reasons to give identifiers internal linkage:<\/p>\n<ul>\n<li>There is an identifier we want to make sure isn&#8217;t accessible to other files.  This could be a global variable we don&#8217;t want messed with, or a helper function we don&#8217;t want to be called.\n<\/li>\n<li>To be pedantic about avoiding naming collisions.  Because identifiers with internal linkage aren&#8217;t exposed to the linker, they can only collide with names in the same translation unit, not across the entire program.\n<\/li>\n<\/ul>\n<p>Many modern development guides recommend giving every variable and function that isn&#8217;t meant to be used from another file internal linkage.  If you have the discipline, this is a good recommendation.<\/p>\n<p>For now, we&#8217;ll recommend a lighter-touch approach as a minimum: give internal linkage to any identifier that you have an explicit reason to disallow access from other files.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Give identifiers internal linkage when you have an explicit reason to disallow access from other files.<\/p>\n<p>Consider giving all identifiers you don&#8217;t want accessible to other files internal linkage (use an unnamed namespace for this).\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quick Summary<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Internal global variables definitions:\r\nstatic int g_x;          \/\/ defines non-initialized internal global variable (zero initialized by default)\r\nstatic int g_x{ 1 };     \/\/ defines initialized internal global variable\r\n\r\nconst int g_y { 2 };     \/\/ defines initialized internal global const variable\r\nconstexpr int g_y { 3 }; \/\/ defines initialized internal global constexpr variable\r\n\r\n\/\/ Internal function definitions:\r\nstatic int foo() {};     \/\/ defines internal function<\/code><\/pre>\n<p>We provide a comprehensive summary in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/scope-duration-and-linkage-summary\/\">7.12 -- Scope, duration, and linkage summary<\/a>.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/external-linkage-and-variable-forward-declarations\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.7<\/span>External linkage and variable forward declarations\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/variable-shadowing-name-hiding\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.5<\/span>Variable shadowing (name hiding)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we said, &#8220;An identifier\u2019s linkage determines whether other declarations of that name refer to the same object or not&#8221;, and we discussed how local variables have no linkage. Global variables and function identifiers can have either internal linkage or external linkage. We&#8217;ll cover the internal linkage case &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9386"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=9386"}],"version-history":[{"count":26,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9386\/revisions"}],"predecessor-version":[{"id":18150,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9386\/revisions\/18150"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=9386"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=9386"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=9386"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}