{"id":3831,"date":"2016-03-25T18:01:43","date_gmt":"2016-03-26T02:01:43","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=3831"},"modified":"2024-08-17T21:21:19","modified_gmt":"2024-08-18T04:21:19","slug":"chapter-14-summary-and-quiz","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-14-summary-and-quiz\/","title":{"rendered":"14.x &#8212; Chapter 14 summary and quiz"},"content":{"rendered":"<p>In this chapter, we explored the meat of C++ -- classes!  This is the most important chapter in the tutorial series, as it sets the stage for much of what&#8217;s left to come.<\/p>\n<p class=\"cpp-section\">Chapter Review<\/p>\n<p>In <strong>procedural programming<\/strong>, the focus is on creating &#8220;procedures&#8221; (which in C++ are called functions) that implement our program logic.  We pass data objects to these functions, those functions perform operations on the data, and then potentially return a result to be used by the caller.<\/p>\n<p>With <strong>Object-oriented programming<\/strong> (often abbreviated as OOP), the focus is on creating program-defined data types that contain both properties and a set of well-defined behaviors.<\/p>\n<p>A <strong>class invariant<\/strong> is a condition that must be true throughout the lifetime of an object in order for the object to remain in a valid state. An object that has a violated class invariant is said to be in an <strong>invalid state<\/strong>, and unexpected or undefined behavior may result from further use of that object.<\/p>\n<p>A <strong>class<\/strong> is a program-defined compound type that bundles both data and functions that work on that data.<\/p>\n<p>Functions that belong to a class type are called <strong>member functions<\/strong>.  The object that a member function is called on is often called the <strong>implicit object<\/strong>.  Functions that are not member functions are called <strong>non-member functions<\/strong> to distinguish them from member functions.  If your class type has no data members, prefer using a namespace instead.<\/p>\n<p>A <strong>const member function<\/strong> is a member function that guarantees it will not modify the object or call any non-const member functions (as they may modify the object).  A member function that does not (and will not ever) modify the state of the object should be made const, so that it can be called on both non-const and const objects.<\/p>\n<p>Each member of a class type has a property called an <strong>access level<\/strong> that determines who can access that member.  The access level system is sometimes informally called <strong>access controls<\/strong>.  Access levels are defined on a per-class basis, not on a per-object basis.<\/p>\n<p><strong>Public members<\/strong> are members of a class type that do not have any restrictions on how they can be accessed. Public members can be accessed by anyone (as long as they are in scope).  This includes other members of the same class.  Public members can also be accessed by <strong>the public<\/strong>, which is what we call code that exists outside the members of a given class type.  Examples of the public include non-member functions, as well as the members of other class types.<\/p>\n<p>By default, all members of a struct are public members.<\/p>\n<p><strong>Private members<\/strong> are members of a class type that can only be accessed by other members of the same class.<\/p>\n<p>By default, the members of a class are private.  A class with private members is no longer an aggregate, and therefore can no longer use aggregate initialization.  Consider naming your private members starting with an \u201cm_\u201d prefix to help distinguish them from the names of local variables, function parameters, and member functions.<\/p>\n<p>We can explicitly set the access level of our members by using an <strong>access specifier<\/strong>.  Structs should generally avoid using access specifiers so all members default to public.<\/p>\n<p>An <strong>access function<\/strong> is a trivial public member function whose job is to retrieve or change the value of a private member variable.  Access functions come in two flavors: getters and setters. <strong>Getters<\/strong> (also sometimes called <strong>accessors<\/strong>) are public member functions that return the value of a private member variable.  <strong>Setters<\/strong> (also sometimes called <strong>mutators<\/strong>) are public member functions that set the value of a private member variable.<\/p>\n<p>The <strong>interface<\/strong> of a class type defines how a user of the class type will interact with objects of the class type. Because only public members can be accessed from outside of the class type, the public members of a class type form its interface. For this reason, an interface composed of public members is sometimes called a <strong>public interface<\/strong>.<\/p>\n<p>The <strong>implementation<\/strong> of a class type consists of the code that actually makes the class behave as intended. This includes both the member variables that store data, and the bodies of the member functions that contain the program logic and manipulate the member variables.<\/p>\n<p>In programming, <strong>data hiding<\/strong> (also called <strong>information hiding<\/strong> or <strong>data abstraction<\/strong>) is a technique used to enforce the separation of interface and implementation by hiding the implementation of a program-defined data type from users.<\/p>\n<p>The term <strong>encapsulation<\/strong> is also sometimes used to refer to data hiding. However, this term is also used to refer to the bundling of data and functions together (without regard for access controls), so its use can be ambiguous.<\/p>\n<p>When defining a class, prefer to declare your public members first and your private members last. This spotlights the public interface and de-emphasizes implementation details.<\/p>\n<p>A <strong>constructor<\/strong> is a special member function that is used to initialize class type objects.  A matching constructor must be found in order to create a non-aggregate class type object.<\/p>\n<p>A <strong>Member initializer list<\/strong> allows you to initialize your member variables from within a constructor.  Member variables in a member initializer list should be listed in order that they are defined in the class.  Prefer using the member initializer list to initialize your members over assigning values in the body of the constructor.<\/p>\n<p>A constructor that takes no parameters (or has all default parameters) is called a <strong>default constructor<\/strong>.  The default constructor is used if no initialization values are provided by the user.  If a non-aggregate class type object has no user-declared constructors, the compiler will generate a default constructor (so that the class can be value or default initialized). This constructor is called an <strong>implicit default constructor<\/strong>.<\/p>\n<p>Constructors are allowed to delegate initialization to another constructor from the same class type. This process is sometimes called <strong>constructor chaining<\/strong> and such constructors are called <strong>delegating constructors<\/strong>.  Constructors can delegate or initialize, but not both.<\/p>\n<p>A <strong>temporary object<\/strong> (sometimes called an <strong>anonymous object<\/strong> or an <strong>unnamed object<\/strong>) is an object that has no name and exists only for the duration of a single expression.<\/p>\n<p>A <strong>copy constructor<\/strong> is a constructor that is used to initialize an object with an existing object of the same type.  If you do not provide a copy constructor for your classes, C++ will create a public <strong>implicit copy constructor<\/strong> for you that does memberwise initialization.<\/p>\n<p>The <strong>as-if rule<\/strong> says that the compiler can modify a program however it likes in order to produce more optimized code, so long as those modifications do not affect a program\u2019s &#8220;observable behavior&#8221;.  One exception to the as-if rule is copy elision.  <strong>Copy elision<\/strong> is a compiler optimization technique that allows the compiler to remove unnecessary copying of objects.  When the compiler optimizes away a call to the copy constructor, we say the constructor has been <strong>elided<\/strong>.<\/p>\n<p>A function that we&#8217;ve written to convert a value to or from a program-defined type is called a <strong>user-defined conversion<\/strong>.  A constructor that can be used to perform an implicit conversion is called a <strong>converting constructor<\/strong>. By default, all constructors are converting constructors.<\/p>\n<p>We can use the <strong>explicit<\/strong> keyword to tell the compiler that a constructor should not be used as a converting constructor.  Such a constructor can not be used to do copy initialization or copy list initialization, nor can it be used to do implicit conversions.<\/p>\n<p>Make any constructor that accepts a single argument explicit by default. If an implicit conversion between types is both semantically equivalent and performant (such as a conversion from <code>std::string<\/code> to <code>std::string_view<\/code>), you can consider making the constructor non-explicit.  Do not make copy or move constructors explicit, as these do not perform conversions.<\/p>\n<p>Member functions (including constructors) may be constexpr.  As of C++14, constexpr member functions are not implicitly const.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>The blackjack quiz that used to be part of this lesson has been moved to lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-17-summary-and-quiz\/\">17.x -- Chapter 17 summary and quiz<\/a>.\n<\/p><\/div>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>a) Write a class named <code>Point2d<\/code>.  <code>Point2d<\/code> should contain two member variables of type <code>double<\/code>: <code>m_x<\/code>, and <code>m_y<\/code>, both defaulted to <code>0.0<\/code>.<\/p>\n<p>Provide a constructor and a <code>print()<\/code> function.<\/p>\n<p>The following program should run:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    Point2d first{};\r\n    Point2d second{ 3.0, 4.0 };\r\n\r\n    \/\/ Point2d third{ 4.0 }; \/\/ should error if uncommented \r\n\r\n    first.print();\r\n    second.print();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This should print:<\/p>\n<pre>\nPoint2d(0, 0)\r\nPoint2d(3, 4)\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Point2d\r\n{\r\nprivate:\r\n\tdouble m_x{ 0.0 };\r\n\tdouble m_y{ 0.0 };\r\n\r\npublic:\r\n\tPoint2d() = default;\r\n\r\n\tPoint2d(double x, double y)\r\n\t\t: m_x{ x }, m_y{ y }\r\n\t{\r\n\t}\r\n\r\n\tvoid print() const\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Point2d(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \")\\n\";\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n    Point2d first{};\r\n    Point2d second{ 3.0, 4.0 };\r\n\r\n    \/\/ Point2d third{ 4.0 }; \/\/ should error if uncommented \r\n\r\n    first.print();\r\n    second.print();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>b) Now add a member function named <code>distanceTo()<\/code> that takes another <code>Point2d<\/code> as a parameter, and calculates the distance between them.  Given two points (x1, y1) and (x2, y2), the distance between them can be calculated using the formula <code>std::sqrt((x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2))<\/code>.  The <code>std::sqrt<\/code> function lives in header <code>cmath<\/code>.<\/p>\n<p>The following program should run:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cmath&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    Point2d first{};\r\n    Point2d second{ 3.0, 4.0 };\r\n\r\n    first.print();\r\n    second.print();\r\n\r\n    std::cout &lt;&lt; \"Distance between two points: \" &lt;&lt; first.distanceTo(second) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This should print:<\/p>\n<pre>\nPoint2d(0, 0)\r\nPoint2d(3, 4)\r\nDistance between two points: 5\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cmath&gt;\r\n#include &lt;iostream&gt;\r\n\r\nclass Point2d\r\n{\r\nprivate:\r\n\tdouble m_x{ 0.0 };\r\n\tdouble m_y{ 0.0 };\r\n\r\npublic:\r\n\tPoint2d() = default;\r\n\r\n\tPoint2d(double x, double y)\r\n\t\t: m_x{ x }, m_y{ y }\r\n\t{\r\n\t}\r\n\r\n\tvoid print() const\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Point2d(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \")\\n\";\r\n\t}\r\n\r\n\tdouble distanceTo(const Point2d&amp; other) const\r\n\t{\r\n\t\treturn std::sqrt(\r\n            (m_x - other.m_x)*(m_x - other.m_x) +\r\n            (m_y - other.m_y)*(m_y - other.m_y)\r\n            );\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n    Point2d first{};\r\n    Point2d second{ 3.0, 4.0 };\r\n\r\n    first.print();\r\n    second.print();\r\n\r\n    std::cout &lt;&lt; \"Distance between two points: \" &lt;&lt; first.distanceTo(second) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/passing-and-returning-structs\/\">13.10 -- Passing and returning structs<\/a>, we wrote a short program using a <code>Fraction<\/code> struct.  The reference solution looks like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Fraction\r\n{\r\n    int numerator{ 0 };\r\n    int denominator{ 1 };\r\n};\r\n\r\nFraction getFraction()\r\n{\r\n    Fraction temp{};\r\n    std::cout &lt;&lt; \"Enter a value for numerator: \";\r\n    std::cin &gt;&gt; temp.numerator;\r\n    std::cout &lt;&lt; \"Enter a value for denominator: \";\r\n    std::cin &gt;&gt; temp.denominator;\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return temp;\r\n}\r\n\r\nFraction multiply(const Fraction&amp; f1, const Fraction&amp; f2)\r\n{\r\n    return { f1.numerator * f2.numerator, f1.denominator * f2.denominator };\r\n}\r\n\r\nvoid printFraction(const Fraction&amp; f)\r\n{\r\n    std::cout &lt;&lt; f.numerator &lt;&lt; '\/' &lt;&lt; f.denominator &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    Fraction f1{ getFraction() };\r\n    Fraction f2{ getFraction() };\r\n\r\n    std::cout &lt;&lt; \"Your fractions multiplied together: \";\r\n\r\n    printFraction(multiply(f1, f2));\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Convert <code>Fraction<\/code> from a struct to a class.  Convert all of the functions to (non-static) member functions.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>Note: This quiz does not comply with best practices for when you should use a non-member or member function.  The goal is to test whether you understand how to convert non-member functions to member functions.\n<\/p><\/div>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Fraction\r\n{\r\nprivate:\r\n    int m_numerator{ 0 };\r\n    int m_denominator{ 1 };\r\n\r\npublic:\r\n    explicit Fraction(int numerator=0, int denominator=1)\r\n        : m_numerator { numerator }, m_denominator { denominator}\r\n    {\r\n    }\r\n\r\n    void getFraction()\r\n    {\r\n        std::cout &lt;&lt; \"Enter a value for numerator: \";\r\n        std::cin &gt;&gt; m_numerator; \/\/ this is a member function, so we can access members directly\r\n        std::cout &lt;&lt; \"Enter a value for denominator: \";\r\n        std::cin &gt;&gt; m_denominator;\r\n        std::cout &lt;&lt; '\\n';\r\n    }\r\n\r\n    Fraction multiply(const Fraction&amp; f) const\r\n    {\r\n        return Fraction{ m_numerator * f.m_numerator, m_denominator * f.m_denominator };\r\n    }\r\n\r\n    void printFraction() const\r\n    {\r\n        std::cout &lt;&lt; m_numerator &lt;&lt; '\/' &lt;&lt; m_denominator &lt;&lt; '\\n';\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Fraction f1{};\r\n    f1.getFraction();\r\n    \r\n    Fraction f2{};\r\n    f2.getFraction();\r\n\r\n    std::cout &lt;&lt; \"Your fractions multiplied together: \";\r\n\r\n    f1.multiply(f2).printFraction();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #3<\/p>\n<p>In the prior quiz solution, why was the Fraction constructor made <code>explicit<\/code>?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<p>Making the constructor explicit prevents it from being used to create a <code>Fraction<\/code> via an implicit conversion with a single value.  This helps prevent nonsense like <code>f1.multiply(true)<\/code>.<\/p>\n<p><code>f1.multiply(true)<\/code> requires that <code>true<\/code> be implicitly converted to a <code>Fraction<\/code>. Normally the compiler would use <code>Fraction(int numerator=0, int denominator=1)<\/code> for this, but if we make that constructor explicit, it is not eligible to be used for implicit conversions.  Since the compiler will then be unable to find a way to convert <code>true<\/code> into a <code>Fraction<\/code>, it will emit a compilation error.\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #4<\/p>\n<p>In the prior quiz question, why might it be better to leave <code>getFraction()<\/code> and <code>print()<\/code> as non-members?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\n<p>With the non-member version of <code>getFraction()<\/code>, we can define and initialize a Fraction in a single step.  The member version requires two steps, as we must first create an object and then call the member function on it.  It also prints application-specific text prompts for the user to follow.<\/p>\n<p>By moving <code>print()<\/code> to be a non-member (and using access functions to access the members), we remove the function from the interface of the class, making the core functionality of the class less cluttered.  It also means that if the implementation of the class is ever changed, we don&#8217;t need to consider whether <code>print()<\/code> needs to be updated, so long as the interface isn&#8217;t changed (since we know it can&#8217;t access any data members directly).\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/the-hidden-this-pointer-and-member-function-chaining\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">15.1<\/span>The hidden &#8220;this&#8221; pointer and member function chaining\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-aggregates-and-classes\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.17<\/span>Constexpr aggregates and classes\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In this chapter, we explored the meat of C++ &#8212; classes! This is the most important chapter in the tutorial series, as it sets the stage for much of what&#8217;s left to come. Chapter Review In , the focus is on creating &#8220;procedures&#8221; (which in C++ are called functions) that &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/3831"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=3831"}],"version-history":[{"count":103,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/3831\/revisions"}],"predecessor-version":[{"id":17484,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/3831\/revisions\/17484"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=3831"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=3831"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=3831"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}