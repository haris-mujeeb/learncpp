{"id":1473,"date":"2015-03-23T15:59:36","date_gmt":"2015-03-23T23:59:36","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=1473"},"modified":"2025-01-29T18:02:41","modified_gmt":"2025-01-30T02:02:41","slug":"why-non-const-global-variables-are-evil","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/why-non-const-global-variables-are-evil\/","title":{"rendered":"7.8 &#8212; Why (non-const) global variables are evil"},"content":{"rendered":"<p>If you were to ask a veteran programmer for <em>one<\/em> piece of advice on good programming practices, after some thought, the most likely answer would be, &#8220;Avoid global variables!&#8221;.  And with good reason: global variables are one of the most historically abused concepts in the language.  Although they may seem harmless in small academic programs, they are often problematic in larger ones.<\/p>\n<p>New programmers are often tempted to use lots of global variables, because they are easy to work with, especially when many calls to different functions are involved (passing data through function parameters is a pain).  However, this is generally a bad idea.  Many developers believe non-const global variables should be avoided completely!<\/p>\n<p>But before we go into why, we should make a clarification.  When developers tell you that global variables are evil, they&#8217;re usually not talking about <em>all<\/em> global variables.  They&#8217;re mostly talking about non-const global variables.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Why (non-const) global variables are evil<\/p>\n<p>By far the biggest reason non-const global variables are dangerous is because their values can be changed by <em>any<\/em> function that is called, and there is no easy way for the programmer to know that this will happen.  Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint g_mode; \/\/ declare global variable (will be zero-initialized by default)\r\n\r\nvoid doSomething()\r\n{\r\n    g_mode = 2; \/\/ set the global g_mode variable to 2\r\n}\r\n\r\nint main()\r\n{\r\n    g_mode = 1; \/\/ note: this sets the global g_mode variable to 1.  It does not declare a local g_mode variable!\r\n\r\n    doSomething();\r\n\r\n    \/\/ Programmer still expects g_mode to be 1\r\n    \/\/ But doSomething changed it to 2!\r\n\r\n    if (g_mode == 1)\r\n    {\r\n        std::cout &lt;&lt; \"No threat detected.\\n\";\r\n    }\r\n    else\r\n    {\r\n        std::cout &lt;&lt; \"Launching nuclear missiles...\\n\";\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Note that the programmer set variable <code>g_mode<\/code> to <em>1<\/em>, and then called <code>doSomething()<\/code>.  Unless the programmer had explicit knowledge that <code>doSomething()<\/code> was going to change the value of <code>g_mode<\/code>, he or she was probably not expecting <code>doSomething()<\/code> to change the value!  Consequently, the rest of <code>main()<\/code> doesn&#8217;t work like the programmer expects (and the world is obliterated).<\/p>\n<p>In short, global variables make the program&#8217;s state unpredictable.  Every function call becomes potentially dangerous, and the programmer has no easy way of knowing which ones are dangerous and which ones aren&#8217;t!  Local variables are much safer because other functions can not affect them directly.<\/p>\n<p>There are plenty of other good reasons not to use non-const globals.<\/p>\n<p>With global variables, it&#8217;s not uncommon to find a piece of code that looks like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void someFunction()\r\n{\r\n    \/\/ useful code\r\n\r\n    if (g_mode == 4)\r\n    {\r\n        \/\/ do something good\r\n    }\r\n}<\/code><\/pre>\n<p>After debugging, you determine that your program isn&#8217;t working correctly because <code>g_mode<\/code> has value <code>3<\/code>, not <em>4<\/em>.  How do you fix it?  Now you need to find all of the places <code>g_mode<\/code> could possibly be set to <code>3<\/code>, and trace through how it got set in the first place.  It&#8217;s possible this may be in a totally unrelated piece of code!<\/p>\n<p>One of the key reasons to declare local variables as close to where they are used as possible is because doing so minimizes the amount of code you need to look through to understand what the variable does.  Global variables are at the opposite end of the spectrum -- because they can be accessed anywhere, you might have to look through the entire program to understand their usage.  In small programs, this might not be an issue.  In large ones, it will be.<\/p>\n<p>For example, you might find <code>g_mode<\/code> is referenced 442 times in your program.  Unless <code>g_mode<\/code> is well documented, you&#8217;ll potentially have to look through every use of <code>g_mode<\/code> to understand how it&#8217;s being used in different cases, what its valid values are, and what its overall function is.<\/p>\n<p>Global variables also make your program less modular and less flexible.  A function that utilizes nothing but its parameters and has no side effects is perfectly modular.  Modularity helps both in understanding what a program does, as well as with reusability.  Global variables reduce modularity significantly.<\/p>\n<p>In particular, avoid using global variables for important &#8220;decision-point&#8221; variables (e.g. variables you&#8217;d use in a conditional statement, like variable <code>g_mode<\/code> in the example above).  Your program isn&#8217;t likely to break if a global variable holding an informational value changes (e.g. like the user&#8217;s name).  It is much more likely to break if you change a global variable that impacts <em>how<\/em> your program actually functions.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Use local variables instead of global variables whenever possible.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The initialization order problem of global variables<\/p>\n<p>Initialization of static variables (which includes global variables) happens as part of program startup, before execution of the <code>main<\/code> function.  This proceeds in two phases.<\/p>\n<p>The first phase is called <strong>static initialization<\/strong>.  Static initialization proceeds in two phases:<\/p>\n<ul>\n<li>Global variables with constexpr initializers (including literals) are initialized to those values.  This is called <strong>constant initialization<\/strong>.\n<\/li>\n<li>Global variables without initializers are zero-initialized.  Zero-initialization is considered to be a form of static-initialization since <code>0<\/code> is a constexpr value.\n<\/li>\n<\/ul>\n<p>The second phase is called <strong>dynamic initialization<\/strong>.  This phase is more complex and nuanced, but the gist of it is that global variables with non-constexpr initializers are initialized.<\/p>\n<p>Here&#8217;s an example of a non-constexpr initializer:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int init()\r\n{\r\n    return 5;\r\n}\r\n\r\nint g_something{ init() }; \/\/ non-constexpr initialization<\/code><\/pre>\n<p>Within a single file, for each phase, global variables are generally initialized in order of definition (there are a few exceptions to this rule for the dynamic initialization phase).  Given this, you need to be careful not to have variables dependent on the initialization value of other variables that won&#8217;t be initialized until later.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint initX();  \/\/ forward declaration\r\nint initY();  \/\/ forward declaration\r\n\r\nint g_x{ initX() }; \/\/ g_x is initialized first\r\nint g_y{ initY() };\r\n\r\nint initX()\r\n{\r\n    return g_y; \/\/ g_y isn't initialized when this is called\r\n}\r\n\r\nint initY()\r\n{\r\n    return 5;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; g_x &lt;&lt; ' ' &lt;&lt; g_y &lt;&lt; '\\n';\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\n0 5\r\n<\/pre>\n<p>Much more of a problem, the order in which static objects are initialized across different translation units is ambiguous.<\/p>\n<p>Given two files, <em>a.cpp<\/em> and <em>b.cpp<\/em>, either could have its global variables initialized first.  If some variable with static duration in <em>a.cpp<\/em> is initialized with a static duration variable defined in <em>b.cpp<\/em>, there&#8217;s a 50% chance that the variable in <em>b.cpp<\/em> won&#8217;t be initialized yet.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Nomenclature<\/p>\n<p>The ambiguity in the order that objects with static storage duration in different translation units are initialized is often called the <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/language\/siof\">static initialization order fiasco<\/a>.\n<\/div>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Avoid initializing objects with static duration using other objects with static duration from a different translation unit.<\/p>\n<p>Dynamic initialization of global variables is also susceptible to initialization order issues and should be avoided whenever possible.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">So what are very good reasons to use non-const global variables?<\/p>\n<p>There aren&#8217;t many.  In most cases, using local variables and passing them as arguments to other functions is preferable.  But in some cases, judicious use of non-const global variables <em>can<\/em> actually reduce program complexity, and in these rare cases, their use may be better than the alternatives.<\/p>\n<p>A good example is a log file, where you can dump error or debug information.  It probably makes sense to define this as a global, because you&#8217;re likely to only have one such log in a program and it will likely be used everywhere in your program.  Another good example would be a random number generator (we show an example of this in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/global-random-numbers-random-h\/\">8.15 -- Global random numbers (Random.h)<\/a>).<\/p>\n<p>For what it&#8217;s worth, the std::cout and std::cin objects are implemented as global variables (inside the <em>std<\/em> namespace).<\/p>\n<p>As a rule of thumb, any use of a global variable should meet at least the following two criteria: There should only ever be one of the thing the variable represents in your program, and its use should be ubiquitous throughout your program.<\/p>\n<p>Many new programmers make the mistake of thinking that something can be implemented as a global because only one is needed <em>right now<\/em>.  For example, you might think that because you&#8217;re implementing a single player game, you only need one player.  But what happens later when you want to add a multiplayer mode (versus or hotseat)?<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Protecting yourself from global destruction<\/p>\n<p>If you do find a good use for a non-const global variable, a few useful bits of advice will minimize the amount of trouble you can get into.  This advice isn&#8217;t only for non-const global variables, but can help with all global variables.<\/p>\n<p>First, prefix all non-namespaced global variables with &#8220;g&#8221; or &#8220;g_&#8221;, or better yet, put them in a namespace (discussed in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/user-defined-namespaces-and-the-scope-resolution-operator\/\">7.2 -- User-defined namespaces and the scope resolution operator<\/a>), to reduce the chance of naming collisions.<\/p>\n<p>For example, instead of:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nconstexpr double gravity { 9.8 }; \/\/ risk of collision with some other global variable named gravity\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; gravity &lt;&lt; '\\n'; \/\/ unclear if this is a local or global variable from the name\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Do this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nnamespace constants\r\n{\r\n    constexpr double gravity { 9.8 }; \/\/ will not collide with other global variables named gravity\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; constants::gravity &lt;&lt; '\\n'; \/\/ clear this is a global variable (since namespaces are global)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Second, instead of allowing direct access to the global variable, it&#8217;s a better practice to &#8220;encapsulate&#8221; the variable.  Make sure the variable can only be accessed from within the file it&#8217;s declared in, e.g. by making the variable static or const, then provide external global &#8220;access functions&#8221; to work with the variable.  These functions can ensure proper usage is maintained (e.g. do input validation, range checking, etc&#8230;).  Also, if you ever decide to change the underlying implementation (e.g. move from one database to another), you only have to update the access functions instead of every piece of code that uses the global variable directly.<\/p>\n<p>For example, instead of this:<\/p>\n<p>constants.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">namespace constants\r\n{\r\n    extern const double gravity { 9.8 }; \/\/ has external linkage, can be accessed by other files\r\n}<\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nnamespace constants\r\n{\r\n    extern const double gravity; \/\/ forward declaration\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; constants::gravity &lt;&lt; '\\n'; \/\/ direct access to global variable\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Do this:<\/p>\n<p>contants.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">namespace constants\r\n{\r\n    constexpr double gravity { 9.8 }; \/\/ has internal linkage, is accessible only within this file\r\n}\r\n\r\ndouble getGravity() \/\/ has external linkage, can be accessed by other files\r\n{\r\n    \/\/ We could add logic here if needed later\r\n    \/\/ or change the implementation transparently to the callers\r\n    return constants::gravity;\r\n} <\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ndouble getGravity(); \/\/ forward declaration\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; getGravity() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">A reminder<\/p>\n<p>Global <code>const<\/code> variables have internal linkage by default, <code>gravity<\/code> doesn&#8217;t need to be <code>static<\/code>.\n<\/div>\n<p>Third, when writing an otherwise standalone function that uses the global variable, don&#8217;t use the variable directly in your function body.  Pass it in as an argument instead.  That way, if your function ever needs to use a different value for some circumstance, you can simply vary the argument.  This helps maintain modularity.<\/p>\n<p>Instead of:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nnamespace constants\r\n{\r\n    constexpr double gravity { 9.8 };\r\n}\r\n\r\n\/\/ This function is only useful for calculating your instant velocity based on the global gravity\r\ndouble instantVelocity(int time)\r\n{\r\n    return constants::gravity * time;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; instantVelocity(5) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n\r\n}<\/code><\/pre>\n<p>Do this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nnamespace constants\r\n{\r\n    constexpr double gravity { 9.8 };\r\n}\r\n\r\n\/\/ This function can calculate the instant velocity for any gravity value (more useful)\r\ndouble instantVelocity(int time, double gravity)\r\n{\r\n    return gravity * time;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; instantVelocity(5, constants::gravity) &lt;&lt; '\\n'; \/\/ pass our constant to the function as a parameter\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A C++ joke<\/p>\n<p>What&#8217;s the best naming prefix for a global variable?<\/p>\n<p>Answer: \/\/<\/p>\n<p>This joke is worth all the comments.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/inline-functions-and-variables\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.9<\/span>Inline functions and variables\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/external-linkage-and-variable-forward-declarations\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.7<\/span>External linkage and variable forward declarations\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>If you were to ask a veteran programmer for one piece of advice on good programming practices, after some thought, the most likely answer would be, &#8220;Avoid global variables!&#8221;. And with good reason: global variables are one of the most historically abused concepts in the language. Although they may seem &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1473"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=1473"}],"version-history":[{"count":48,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1473\/revisions"}],"predecessor-version":[{"id":18144,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1473\/revisions\/18144"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=1473"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=1473"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=1473"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}