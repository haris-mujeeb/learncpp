{"id":9401,"date":"2020-01-03T11:01:29","date_gmt":"2020-01-03T19:01:29","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=9401"},"modified":"2024-07-18T22:38:14","modified_gmt":"2024-07-19T05:38:14","slug":"variable-shadowing-name-hiding","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/variable-shadowing-name-hiding\/","title":{"rendered":"7.5 &#8212; Variable shadowing (name hiding)"},"content":{"rendered":"<p>Each block defines its own scope region.  So what happens when we have a variable inside a nested block that has the same name as a variable in an outer block?  When this happens, the nested variable &#8220;hides&#8221; the outer variable in areas where they are both in scope.  This is called <strong>name hiding<\/strong> or <strong>shadowing<\/strong>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Shadowing of local variables<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{ \/\/ outer block\r\n    int apples { 5 }; \/\/ here's the outer block apples\r\n\r\n    { \/\/ nested block\r\n        \/\/ apples refers to outer block apples here\r\n        std::cout &lt;&lt; apples &lt;&lt; '\\n'; \/\/ print value of outer block apples\r\n\r\n        int apples{ 0 }; \/\/ define apples in the scope of the nested block\r\n\r\n        \/\/ apples now refers to the nested block apples\r\n        \/\/ the outer block apples is temporarily hidden\r\n\r\n        apples = 10; \/\/ this assigns value 10 to nested block apples, not outer block apples\r\n\r\n        std::cout &lt;&lt; apples &lt;&lt; '\\n'; \/\/ print value of nested block apples\r\n    } \/\/ nested block apples destroyed\r\n\r\n\r\n    std::cout &lt;&lt; apples &lt;&lt; '\\n'; \/\/ prints value of outer block apples\r\n\r\n    return 0;\r\n} \/\/ outer block apples destroyed<\/code><\/pre>\n<p>If you run this program, it prints:<\/p>\n<pre>\r\n5\r\n10\r\n5\r\n<\/pre>\n<p>In the above program, we first declare a variable named <code>apples<\/code> in the outer block.  This variable is visible within the inner block, which we can see by printing its value (<code>5<\/code>).  Then we declare a different variable (also named <code>apples<\/code>) in the nested block.  From this point to the end of the block, the name <code>apples<\/code> refers to the nested block <code>apples<\/code>, not the outer block <code>apples<\/code>.<\/p>\n<p>Thus, when we assign value <code>10<\/code> to <code>apples<\/code>, we&#8217;re assigning it to the nested block <code>apples<\/code>.  After printing this value (<code>10<\/code>), the nested block ends and nested block <code>apples<\/code> is destroyed.  The existence and value of outer block <code>apples<\/code> is not affected, and we prove this by printing the value of outer block <code>apples<\/code> (<code>5<\/code>).<\/p>\n<p>Note that if the nested block <code>apples<\/code> had not been defined, the name <code>apples<\/code> in the nested block would still refer to the outer block <code>apples<\/code>, so the assignment of value <code>10<\/code> to <code>apples<\/code> would have applied to the outer block <code>apples<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{ \/\/ outer block\r\n    int apples{5}; \/\/ here's the outer block apples\r\n\r\n    { \/\/ nested block\r\n        \/\/ apples refers to outer block apples here\r\n        std::cout &lt;&lt; apples &lt;&lt; '\\n'; \/\/ print value of outer block apples\r\n\r\n        \/\/ no inner block apples defined in this example\r\n\r\n        apples = 10; \/\/ this applies to outer block apples\r\n\r\n        std::cout &lt;&lt; apples &lt;&lt; '\\n'; \/\/ print value of outer block apples\r\n    } \/\/ outer block apples retains its value even after we leave the nested block\r\n\r\n    std::cout &lt;&lt; apples &lt;&lt; '\\n'; \/\/ prints value of outer block apples\r\n\r\n    return 0;\r\n} \/\/ outer block apples destroyed<\/code><\/pre>\n<p>The above program prints:<\/p>\n<pre>\r\n5\r\n10\r\n10\r\n<\/pre>\n<p>When inside the nested block, there&#8217;s no way to directly access the shadowed variable from the outer block.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Shadowing of global variables<\/p>\n<p>Similar to how variables in a nested block can shadow variables in an outer block, local variables with the same name as a global variable will shadow the global variable wherever the local variable is in scope:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\nint value { 5 }; \/\/ global variable\r\n\r\nvoid foo()\r\n{\r\n    std::cout &lt;&lt; \"global variable value: \" &lt;&lt; value &lt;&lt; '\\n'; \/\/ value is not shadowed here, so this refers to the global value\r\n}\r\n\r\nint main()\r\n{\r\n    int value { 7 }; \/\/ hides the global variable value (wherever local variable value is in scope)\r\n\r\n    ++value; \/\/ increments local value, not global value\r\n\r\n    std::cout &lt;&lt; \"local variable value: \" &lt;&lt; value &lt;&lt; '\\n';\r\n\r\n    foo();\r\n\r\n    return 0;\r\n} \/\/ local value is destroyed<\/code><\/pre>\n<p>This code prints:<\/p>\n<pre>\r\nlocal variable value: 8\r\nglobal variable value: 5\r\n<\/pre>\n<p>However, because global variables are part of the global namespace, we can use the scope operator (::) with no prefix to tell the compiler we mean the global variable instead of the local variable.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\nint value { 5 }; \/\/ global variable\r\n\r\nint main()\r\n{\r\n    int value { 7 }; \/\/ hides the global variable value\r\n    ++value; \/\/ increments local value, not global value\r\n\r\n    --(::value); \/\/ decrements global value, not local value (parenthesis added for readability)\r\n\r\n    std::cout &lt;&lt; \"local variable value: \" &lt;&lt; value &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"global variable value: \" &lt;&lt; ::value &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n} \/\/ local value is destroyed<\/code><\/pre>\n<p>This code prints:<\/p>\n<pre>\r\nlocal variable value: 8\r\nglobal variable value: 4\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Avoid variable shadowing<\/p>\n<p>Shadowing of local variables should generally be avoided, as it can lead to inadvertent errors where the wrong variable is used or modified.  Some compilers will issue a warning when a variable is shadowed.<\/p>\n<p>For the same reason that we recommend avoiding shadowing local variables, we recommend avoiding shadowing global variables as well.  This is trivially avoidable if all of your global names use a &#8220;g_&#8221; prefix.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Avoid variable shadowing.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightyellowbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For gcc users<\/p>\n<p>GCC and Clang support the flag <code>-Wshadow<\/code> that will generate warnings if a variable is shadowed.  There are several subvariants of this flag (<code>-Wshadow=global<\/code>, <code>-Wshadow=local<\/code>, and <code>-Wshadow=compatible-local<\/code>.  Consult the <a href=\"https:\/\/gcc.gnu.org\/onlinedocs\/gcc\/Warning-Options.html\">GCC documentation<\/a> for an explanation of the differences.<\/p>\n<p>Visual Studio has such warnings enabled by default.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/internal-linkage\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.6<\/span>Internal linkage\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-global-variables\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.4<\/span>Introduction to global variables\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Each block defines its own scope region. So what happens when we have a variable inside a nested block that has the same name as a variable in an outer block? When this happens, the nested variable &#8220;hides&#8221; the outer variable in areas where they are both in scope. This &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9401"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=9401"}],"version-history":[{"count":11,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9401\/revisions"}],"predecessor-version":[{"id":17347,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/9401\/revisions\/17347"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=9401"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=9401"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=9401"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}