{"id":10330,"date":"2020-08-16T15:28:52","date_gmt":"2020-08-16T23:28:52","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=10330"},"modified":"2024-08-15T09:19:00","modified_gmt":"2024-08-15T16:19:00","slug":"stdmove_if_noexcept","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/stdmove_if_noexcept\/","title":{"rendered":"27.10 &#8212; std::move_if_noexcept"},"content":{"rendered":"<p>(h\/t to reader Koe for providing the first draft of this lesson!)<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdmove\/\">22.4 -- std::move<\/a>, we covered <code>std::move<\/code>, which casts its lvalue argument to an rvalue so that we can invoke move semantics.  And in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/exception-specifications-and-noexcept\/\">27.9 -- Exception specifications and noexcept<\/a>, we covered the <code>noexcept<\/code> exception specifier and operator.  This lesson builds on both concepts.<\/p>\n<p>We also covered the <code>strong exception guarantee<\/code>, which guarantees that if a function is interrupted by an exception, no memory will be leaked and the program state will not be changed.  In particular, all constructors should uphold the strong exception guarantee, so that the rest of the program won&#8217;t be left in an altered state if construction of an object fails.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The move constructors exception problem<\/p>\n<p>Consider the case where we are copying some object, and the copy fails for some reason (e.g. the machine is out of memory).  In such a case, the object being copied is not harmed in any way, because the source object doesn&#8217;t need to be modified to create a copy.  We can discard the failed copy, and move on.  The <code>strong exception guarantee<\/code> is upheld.<\/p>\n<p>Now consider the case where we are instead moving an object.  A move operation transfers ownership of a given resource from the source to the destination object.  If the move operation is interrupted by an exception after the transfer of ownership occurs, then our source object will be left in a modified state.  This isn&#8217;t a problem if the source object is a temporary object and going to be discarded after the move anyway -- but for non-temporary objects, we&#8217;ve now damaged the source object.  To comply with the <code>strong exception guarantee<\/code>, we&#8217;d need to move the resource back to the source object, but if the move failed the first time, there&#8217;s no guarantee the move back will succeed either.<\/p>\n<p>How can we give move constructors the <code>strong exception guarantee<\/code>? It is simple enough to avoid throwing exceptions in the body of a move constructor, but a move constructor may invoke other constructors that are <code>potentially throwing<\/code>. Take for example the move constructor for <code>std::pair<\/code>, which must try to move each subobject in the source pair into the new pair object.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Example move constructor definition for std::pair\r\n\/\/ Take in an 'old' pair, and then move construct the new pair's 'first' and 'second' subobjects from the 'old' ones\r\ntemplate &lt;typename T1, typename T2&gt;\r\npair&lt;T1,T2&gt;::pair(pair&amp;&amp; old)\r\n  : first(std::move(old.first)),\r\n    second(std::move(old.second))\r\n{}<\/code><\/pre>\n<p>Now lets use two classes, <code>MoveClass<\/code> and <code>CopyClass<\/code>, which we will <code>pair<\/code> together to demonstrate the <code>strong exception guarantee<\/code> problem with move constructors:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;utility&gt; \/\/ For std::pair, std::make_pair, std::move, std::move_if_noexcept\r\n#include &lt;stdexcept&gt; \/\/ std::runtime_error\r\n\r\nclass MoveClass\r\n{\r\nprivate:\r\n  int* m_resource{};\r\n\r\npublic:\r\n  MoveClass() = default;\r\n\r\n  MoveClass(int resource)\r\n    : m_resource{ new int{ resource } }\r\n  {}\r\n\r\n  \/\/ Copy constructor\r\n  MoveClass(const MoveClass&amp; that)\r\n  {\r\n    \/\/ deep copy\r\n    if (that.m_resource != nullptr)\r\n    {\r\n      m_resource = new int{ *that.m_resource };\r\n    }\r\n  }\r\n\r\n  \/\/ Move constructor\r\n  MoveClass(MoveClass&amp;&amp; that) noexcept\r\n    : m_resource{ that.m_resource }\r\n  {\r\n    that.m_resource = nullptr;\r\n  }\r\n\r\n  ~MoveClass()\r\n  {\r\n    std::cout &lt;&lt; \"destroying \" &lt;&lt; *this &lt;&lt; '\\n';\r\n\r\n    delete m_resource;\r\n  }\r\n\r\n  friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MoveClass&amp; moveClass)\r\n  {\r\n    out &lt;&lt; \"MoveClass(\";\r\n\r\n    if (moveClass.m_resource == nullptr)\r\n    {\r\n      out &lt;&lt; \"empty\";\r\n    }\r\n    else\r\n    {\r\n      out &lt;&lt; *moveClass.m_resource;\r\n    }\r\n\r\n    out &lt;&lt; ')';\r\n    \r\n    return out;\r\n  }\r\n};\r\n\r\n\r\nclass CopyClass\r\n{\r\npublic:\r\n  bool m_throw{};\r\n\r\n  CopyClass() = default;\r\n\r\n  \/\/ Copy constructor throws an exception when copying from\r\n  \/\/ a CopyClass object where its m_throw is 'true'\r\n  CopyClass(const CopyClass&amp; that)\r\n    : m_throw{ that.m_throw }\r\n  {\r\n    if (m_throw)\r\n    {\r\n      throw std::runtime_error{ \"abort!\" };\r\n    }\r\n  }\r\n};\r\n\r\nint main()\r\n{\r\n  \/\/ We can make a std::pair without any problems:\r\n  std::pair my_pair{ MoveClass{ 13 }, CopyClass{} };\r\n\r\n  std::cout &lt;&lt; \"my_pair.first: \" &lt;&lt; my_pair.first &lt;&lt; '\\n';\r\n\r\n  \/\/ But the problem arises when we try to move that pair into another pair.\r\n  try\r\n  {\r\n    my_pair.second.m_throw = true; \/\/ To trigger copy constructor exception\r\n\r\n    \/\/ The following line will throw an exception\r\n    std::pair moved_pair{ std::move(my_pair) }; \/\/ We'll comment out this line later\r\n    \/\/ std::pair moved_pair{ std::move_if_noexcept(my_pair) }; \/\/ We'll uncomment this later\r\n\r\n    std::cout &lt;&lt; \"moved pair exists\\n\"; \/\/ Never prints\r\n  }\r\n  catch (const std::exception&amp; ex)\r\n  {\r\n      std::cerr &lt;&lt; \"Error found: \" &lt;&lt; ex.what() &lt;&lt; '\\n';\r\n  }\r\n\r\n  std::cout &lt;&lt; \"my_pair.first: \" &lt;&lt; my_pair.first &lt;&lt; '\\n';\r\n\r\n  return 0;\r\n}<\/code><\/pre>\n<p>The above program prints:<\/p>\n<pre>\r\ndestroying MoveClass(empty)\r\nmy_pair.first: MoveClass(13)\r\ndestroying MoveClass(13)\r\nError found: abort!\r\nmy_pair.first: MoveClass(empty)\r\ndestroying MoveClass(empty)\r\n<\/pre>\n<p>Let&#8217;s explore what happened. The first printed line shows the temporary <code>MoveClass<\/code> object used to initialize <code>my_pair<\/code> gets destroyed as soon as the <code>my_pair<\/code> instantiation statement has been executed. It is <code>empty<\/code> since the <code>MoveClass<\/code> subobject in <code>my_pair<\/code> was move constructed from it, demonstrated by the next line which shows <code>my_pair.first<\/code> contains the <code>MoveClass<\/code> object with value <code>13<\/code>.<\/p>\n<p>It gets interesting in the third line. We created <code>moved_pair<\/code> by copy constructing its <code>CopyClass<\/code> subobject (it doesn&#8217;t have a move constructor), but that copy construction threw an exception since we changed the Boolean flag. Construction of <code>moved_pair<\/code> was aborted by the exception, and its already-constructed members were destroyed. In this case, the <code>MoveClass<\/code> member was destroyed, printing <code>destroying MoveClass(13) variable<\/code>. Next we see the <code>Error found: abort!<\/code> message printed by <code>main()<\/code>.<\/p>\n<p>When we try to print <code>my_pair.first<\/code> again, it shows the <code>MoveClass<\/code> member is empty. Since <code>moved_pair<\/code> was initialized with <code>std::move<\/code>, the <code>MoveClass<\/code> member (which has a move constructor) got move constructed and <code>my_pair.first<\/code> was nulled.<\/p>\n<p>Finally, <code>my_pair<\/code> was destroyed at the end of main().<\/p>\n<p>To summarize the above results: the move constructor of <code>std::pair<\/code> used the throwing copy constructor of <code>CopyClass<\/code>.  This copy constructor threw an exception, causing the creation of <code>moved_pair<\/code> to abort, and <code>my_pair.first<\/code> to be permanently damaged.  The <code>strong exception guarantee<\/code> was not preserved.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">std::move_if_noexcept to the rescue<\/p>\n<p>Note that the above problem could have been avoided if <code>std::pair<\/code> had tried to do a copy instead of a move.  In that case, <code>moved_pair<\/code> would have failed to construct, but <code>my_pair<\/code> would not have been altered.<\/p>\n<p>But copying instead of moving has a performance cost that we don&#8217;t want to pay for all objects -- ideally we want to do a move if we can do so safely, and a copy otherwise.<\/p>\n<p>Fortunately, C++ has two mechanisms that, when used in combination, let us do exactly that.  First, because <code>noexcept<\/code> functions are no-throw\/no-fail, they implicitly meet the criteria for the <code>strong exception guarantee<\/code>.  Thus, a <code>noexcept<\/code> move constructor is guaranteed to succeed.<\/p>\n<p>Second, we can use the standard library function <code>std::move_if_noexcept()<\/code> to determine whether a move or a copy should be performed.  <code>std::move_if_noexcept<\/code> is a counterpart to <code>std::move<\/code>, and is used in the same way.<\/p>\n<p>If the compiler can tell that an object passed as an argument to <code>std::move_if_noexcept<\/code> won&#8217;t throw an exception when it is move constructed (or if the object is move-only and has no copy constructor), then <code>std::move_if_noexcept<\/code> will perform identically to <code>std::move()<\/code> (and return the object converted to an r-value).  Otherwise, <code>std::move_if_noexcept<\/code> will return a normal l-value reference to the object.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p><code>std::move_if_noexcept<\/code> will return a movable r-value if the object has a noexcept move constructor, otherwise it will return a copyable l-value.  We can use the <code>noexcept<\/code> specifier in conjunction with <code>std::move_if_noexcept<\/code> to use move semantics only when a strong exception guarantee exists (and use copy semantics otherwise).\n<\/div>\n<p>Let&#8217;s update the code in the previous example as follows:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/std::pair moved_pair{std::move(my_pair)}; \/\/ comment out this line now\r\nstd::pair moved_pair{std::move_if_noexcept(my_pair)}; \/\/ and uncomment this line<\/code><\/pre>\n<p>Running the program again prints:<\/p>\n<pre>\r\ndestroying MoveClass(empty)\r\nmy_pair.first: MoveClass(13)\r\ndestroying MoveClass(13)\r\nError found: abort!\r\nmy_pair.first: MoveClass(13)\r\ndestroying MoveClass(13)\r\n<\/pre>\n<p>As you can see, after the exception was thrown, the subobject <code>my_pair.first<\/code> still points to the value <code>13<\/code>.<\/p>\n<p>The move constructor of <code>std::pair<\/code> isn&#8217;t <code>noexcept<\/code> (as of C++20), so <code>std::move_if_noexcept<\/code> returns <code>my_pair<\/code> as an l-value reference.  This causes <code>moved_pair<\/code> to be created via the copy constructor (rather than the move constructor).  The copy constructor can throw safely, because it doesn&#8217;t modify the source object.<\/p>\n<p>The standard library uses <code>std::move_if_noexcept<\/code> often to optimize for functions that are <code>noexcept<\/code>.  For example, <code>std::vector::resize<\/code> will use move semantics if the element type has a <code>noexcept<\/code> move constructor, and copy semantics otherwise.  This means <code>std::vector<\/code> will generally operate faster with objects that have a <code>noexcept<\/code> move constructor.<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>If a type has both potentially throwing move semantics and deleted copy semantics (the copy constructor and copy assignment operator are unavailable), then <code>std::move_if_noexcept<\/code> will waive the strong guarantee and invoke move semantics. This conditional waiving of the strong guarantee is ubiquitous in the standard library container classes, since they use std::move_if_noexcept often.\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-27-summary-and-quiz\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">27.x<\/span>Chapter 27 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/exception-specifications-and-noexcept\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">27.9<\/span>Exception specifications and noexcept\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>(h\/t to reader Koe for providing the first draft of this lesson!) In lesson , we covered std::move, which casts its lvalue argument to an rvalue so that we can invoke move semantics. And in lesson , we covered the noexcept exception specifier and operator. This lesson builds on both &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/10330"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=10330"}],"version-history":[{"count":16,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/10330\/revisions"}],"predecessor-version":[{"id":17472,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/10330\/revisions\/17472"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=10330"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=10330"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=10330"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}