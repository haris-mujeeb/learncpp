{"id":16806,"date":"2024-03-19T11:44:06","date_gmt":"2024-03-19T18:44:06","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=16806"},"modified":"2025-02-08T20:44:07","modified_gmt":"2025-02-09T04:44:07","slug":"stdoptional","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/stdoptional\/","title":{"rendered":"12.15 &#8212; std::optional"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/detecting-and-handling-errors\/\">9.4 -- Detecting and handling errors<\/a>, we discussed cases where a function encounters an error that it cannot reasonably handle itself.  For example, consider a function that calculates and returns a value:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int doIntDivision(int x, int y)\r\n{\r\n    return x \/ y;\r\n}<\/code><\/pre>\n<p>If the caller passes in a value that is semantically invalid (such as <code>y<\/code> = <code>0<\/code>), this function cannot calculate a value to return (as division by 0 is mathematically undefined).  What do we do in that case?  Because functions that calculate results should have no side effects, this function cannot reasonably resolve the error itself.  In such cases, the typical thing to do is have the function detect the error, but then pass the error back to the caller to deal with in some program-appropriate way.<\/p>\n<p>In the previously linked lesson, we covered two different ways to have a function return an error back to the caller:<\/p>\n<ul>\n<li>Have a void-returning function return a bool instead (indicating success or failure).\n<\/li>\n<li>Have a value-returning function return a sentinel value (a special value that does not occur in the set of possible values the function can otherwise return) to indicate an error.\n<\/li>\n<\/ul>\n<p>As an example of the latter, the <code>reciprocal()<\/code> function that follows returns value <code>0.0<\/code> (which can never otherwise occur) if the user passes in a semantically invalid argument for <code>x<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ The reciprocal of x is 1\/x, returns 0.0 if x=0\r\ndouble reciprocal(double x)\r\n{\r\n    if (x == 0.0) \/\/ if x is semantically invalid\r\n       return 0.0; \/\/ return 0.0 as a sentinel to indicate an error occurred\r\n\r\n    return 1.0 \/ x;\r\n}\r\n\r\nvoid testReciprocal(double d)\r\n{\r\n     double result { reciprocal(d) };\r\n     std::cout &lt;&lt; \"The reciprocal of \" &lt;&lt; d &lt;&lt; \" is \";\r\n     if (result != 0.0)\r\n         std::cout &lt;&lt; result &lt;&lt; '\\n';\r\n     else\r\n         std::cout &lt;&lt; \"undefined\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    testReciprocal(5.0);\r\n    testReciprocal(-4.0);\r\n    testReciprocal(0.0);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>While this is a fairly attractive solution, there are a number of potential downsides:<\/p>\n<ul>\n<li>The programmer must know which sentinel value the function is using to indicate an error (and this value may differ for each function returning an error using this method).\n<\/li>\n<li>A different version of the same function may use a different sentinel value.\n<\/li>\n<li>This method does not work for functions where all possible sentinel values are valid return values.\n<\/li>\n<\/ul>\n<p>Consider our <code>doIntDivision()<\/code> function above.  What value could it return if the user passes in <code>0<\/code> for <code>y<\/code>?  We can&#8217;t use <code>0<\/code>, because <code>0<\/code> divided by anything yields <code>0<\/code> as a valid result.  In fact, there are no values that we could return that cannot occur naturally.<\/p>\n<p>So what are we to do?<\/p>\n<p>First, we could pick some (hopefully) uncommon return value as our sentinel and use it to indicate an error:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;limits&gt; \/\/ for std::numeric_limits\r\n\r\n\/\/ returns std::numeric_limits&lt;int&gt;::lowest() on failure\r\nint doIntDivision(int x, int y)\r\n{\r\n    if (y == 0)\r\n        return std::numeric_limits&lt;int&gt;::lowest();\r\n    return x \/ y;\r\n}<\/code><\/pre>\n<p><code>std::numeric_limits&lt;T&gt;::lowest()<\/code> is a function that returns the most negative value for type <code>T<\/code>.  It is the counterpart to the <code>std::numeric_limits&lt;T&gt;::max()<\/code> function (which returns the largest positive value for type <code>T<\/code>) that we introduced in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdcin-and-handling-invalid-input\/\">9.5 -- std::cin and handling invalid input<\/a>.<\/p>\n<p>In the example above, if <code>doIntDivision()<\/code> cannot proceed, we return <code>std::numeric_limits&lt;int&gt;::lowest()<\/code>, which returns the most negative int value back to the caller to indicate that the function failed.<\/p>\n<p>While this mostly works, it has two downsides:<\/p>\n<ul>\n<li>Every time we call this function, we need to test the return value for equality with <code>std::numeric_limits&lt;int&gt;::lowest()<\/code> to see if it failed.  That&#8217;s verbose and ugly.\n<\/li>\n<li>It is an example of a <a href=\"https:\/\/en.wikipedia.org\/wiki\/Semipredicate_problem\">semipredicate problem<\/a>: if the user calls <code>doIntDivision(std::numeric_limits&lt;int&gt;::lowest(), 1)<\/code>, the returned result <code>std::numeric_limits&lt;int&gt;::lowest()<\/code> will be ambiguous as to whether the function succeeded or failed.  That may or may not be a problem depending on how the function is actually used, but it&#8217;s another thing we have to worry about and another potential way that errors can creep into our program.\n<\/li>\n<\/ul>\n<p>Second, we could abandon using return values to return errors and use some other mechanism (e.g. exceptions).  However, exceptions have their own complications and performance costs, and may not be appropriate or desired.  That&#8217;s probably overkill for something like this.<\/p>\n<p>Third, we could abandon returning a single value and return two values instead: one (of type <code>bool<\/code>) that indicates whether the function succeeded, and the other (of the desired return type) that holds the actual return value (if the function succeeded) or an indeterminate value (if the function failed).  This is probably the best option of the bunch.<\/p>\n<p>Prior to C++17, choosing this latter option required you to implement it yourself.  And while C++ provides multiple ways to do so, any roll-your-own approach will inevitably lead to inconsistencies and errors.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Returning a <code>std::optional<\/code><\/p>\n<p>C++17 introduces <code>std::optional<\/code>, which is a class template type that implements an optional value.  That is, a <code>std::optional&lt;T&gt;<\/code> can either have a value of type <code>T<\/code>, or not.  We can use this to implement the third option above:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;optional&gt; \/\/ for std::optional (C++17)\r\n\r\n\/\/ Our function now optionally returns an int value\r\nstd::optional&lt;int&gt; doIntDivision(int x, int y)\r\n{\r\n    if (y == 0)\r\n        return {}; \/\/ or return std::nullopt\r\n    return x \/ y;\r\n}\r\n\r\nint main()\r\n{\r\n    std::optional&lt;int&gt; result1 { doIntDivision(20, 5) };\r\n    if (result1) \/\/ if the function returned a value\r\n        std::cout &lt;&lt; \"Result 1: \" &lt;&lt; *result1 &lt;&lt; '\\n'; \/\/ get the value\r\n    else\r\n        std::cout &lt;&lt; \"Result 1: failed\\n\";\r\n\r\n    std::optional&lt;int&gt; result2 { doIntDivision(5, 0) };\r\n\r\n    if (result2)\r\n        std::cout &lt;&lt; \"Result 2: \" &lt;&lt; *result2 &lt;&lt; '\\n';\r\n    else\r\n        std::cout &lt;&lt; \"Result 2: failed\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nResult 1: 4\r\nResult 2: failed\r\n<\/pre>\n<p>Using <code>std::optional<\/code> is quite easy.  We can construct a <code>std::optional&lt;T&gt;<\/code> either with or without a value:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::optional&lt;int&gt; o1 { 5 };            \/\/ initialize with a value\r\nstd::optional&lt;int&gt; o2 {};               \/\/ initialize with no value\r\nstd::optional&lt;int&gt; o3 { std::nullopt }; \/\/ initialize with no value<\/code><\/pre>\n<p>To see if a <code>std::optional<\/code> has a value, we can choose one of the following:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">if (o1.has_value()) \/\/ call has_value() to check if o1 has a value\r\nif (o2)             \/\/ use implicit conversion to bool to check if o2 has a value<\/code><\/pre>\n<p>To get the value from a <code>std::optional<\/code>, we can choose one of the following:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::cout &lt;&lt; *o1;             \/\/ dereference to get value stored in o1 (undefined behavior if o1 does not have a value)\r\nstd::cout &lt;&lt; o2.value();      \/\/ call value() to get value stored in o2 (throws std::bad_optional_access exception if o2 does not have a value)\r\nstd::cout &lt;&lt; o3.value_or(42); \/\/ call value_or() to get value stored in o3 (or value `42` if o3 doesn't have a value)<\/code><\/pre>\n<p>Note that <code>std::optional<\/code> has a usage syntax that is essentially identical to a pointer:<\/p>\n<div class=\"cpp-table-wrapper\">\n<table class=\"cpp-table\">\n<tr>\n<th> Behavior <\/th>\n<th> Pointer <\/th>\n<th> <code>std::optional<\/code> <\/th>\n<\/tr>\n<tr>\n<td> Hold no value <\/td>\n<td> initialize\/assign <code>{}<\/code> or <code>std::nullptr<\/code> <\/td>\n<td> initialize\/assign <code>{}<\/code> or <code>std::nullopt<\/code> <\/td>\n<\/tr>\n<tr>\n<td> Hold a value <\/td>\n<td> initialize\/assign an address <\/td>\n<td> initialize\/assign a value <\/td>\n<\/tr>\n<tr>\n<td> Check if has value <\/td>\n<td> implicit conversion to bool <\/td>\n<td> implicit conversion to bool or <code>has_value()<\/code> <\/td>\n<\/tr>\n<tr>\n<td> Get value <\/td>\n<td> dereference <\/td>\n<td> dereference or <code>value()<\/code> <\/td>\n<\/tr>\n<\/table>\n<\/div>\n<p>However, semantically, a pointer and a <code>std::optional<\/code> are quite different.<\/p>\n<ul>\n<li>A pointer has reference semantics, meaning it references some other object, and assignment copies the pointer, not the object.  If we return a pointer by address, the pointer is copied back to the caller, not the object being pointed to.  This means we can&#8217;t return a local object by address, as we&#8217;ll copy that object&#8217;s address back to the caller, and then the object will be destroyed, leaving the returned pointer dangling.\n<\/li>\n<li>A <code>std::optional<\/code> has value semantics, meaning it actually contains its value, and assignment copies the value.  If we return a <code>std::optional<\/code> by value, the <code>std::optional<\/code> (including the contained value) is copied back to the caller.  This means we can return a value from the function back to the caller using <code>std::optional<\/code>.\n<\/li>\n<\/ul>\n<p>With this in mind, let&#8217;s look at how our example works.  Our <code>doIntDivision()<\/code> now returns a <code>std::optional&lt;int&gt;<\/code> instead of an <code>int<\/code>.  Inside the function body, if we detect an error, we return <code>{}<\/code>, which implicitly returns a <code>std::optional<\/code> containing no value.  If we have a value, we return that value, which implicit returns a <code>std::optional<\/code> containing that value.<\/p>\n<p>Within <code>main()<\/code>, we use an implicit conversion to bool to check if our returned <code>std::optional<\/code> has a value or not.  If it does, we dereference the <code>std::optional<\/code> object to get the value.  If it doesn&#8217;t, then we execute our error condition.  That&#8217;s it!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Pros and cons of returning a <code>std::optional<\/code><\/p>\n<p>Returning a <code>std::optional<\/code> is nice for a number of reasons:<\/p>\n<ul>\n<li>Using <code>std::optional<\/code> effectively documents that a function may return a value or not.\n<\/li>\n<li>We don&#8217;t have to remember which value is being returned as a sentinel.\n<\/li>\n<li>The syntax for using <code>std::optional<\/code> is convenient and intuitive.\n<\/li>\n<\/ul>\n<p>Returning a <code>std::optional<\/code> does come with a few downsides:<\/p>\n<ul>\n<li>We have to make sure the <code>std::optional<\/code> contains a value before getting the value.  If we dereference a <code>std::optional<\/code> that does not contain a value, we get undefined behavior.\n<\/li>\n<li><code>std::optional<\/code> does not provide a way to pass back information about why the function failed.\n<\/li>\n<\/ul>\n<p>Unless your function needs to return additional information about why it failed (either to better understand the failure, or to differentiate different kinds of failure), <code>std::optional<\/code> is an excellent choice for functions that may return a value or fail.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Return a <code>std::optional<\/code> (instead of a sentinel value) for functions that may fail, unless your function needs to return additional information about why it failed.\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p><code>std::expected<\/code> (introduced in C++23) is designed to handle the case where a function can return either an expected value or an unexpected error code.  See the <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/utility\/expected\">std::expected reference<\/a> for more information.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using <code>std::optional<\/code> as an optional function parameter<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pass-by-address-part-2\/\">12.11 -- Pass by address (part 2)<\/a>, we discussed how pass by address can be used to allow a function to accept an &#8220;optional&#8221; argument (that is, the caller can either pass in <code>nullptr<\/code> to represent &#8220;no argument&#8221; or an object).  However, one downside of this approach is that a non-nullptr argument must be an lvalue (so that its address can be passed to the function).<\/p>\n<p>Perhaps unsurprisingly (given the name), <code>std::optional<\/code> is an alternative way for a function to accept an optional argument (that is used as an in-parameter only).  Instead of this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printIDNumber(const int *id=nullptr)\r\n{\r\n    if (id)\r\n        std::cout &lt;&lt; \"Your ID number is \" &lt;&lt; *id &lt;&lt; \".\\n\";\r\n    else\r\n        std::cout &lt;&lt; \"Your ID number is not known.\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    printIDNumber(); \/\/ we don't know the user's ID yet\r\n\r\n    int userid { 34 };\r\n    printIDNumber(&amp;userid); \/\/ we know the user's ID now\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>You can do this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;optional&gt;\r\n\r\nvoid printIDNumber(std::optional&lt;const int&gt; id = std::nullopt)\r\n{\r\n    if (id)\r\n        std::cout &lt;&lt; \"Your ID number is \" &lt;&lt; *id &lt;&lt; \".\\n\";\r\n    else\r\n        std::cout &lt;&lt; \"Your ID number is not known.\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    printIDNumber(); \/\/ we don't know the user's ID yet\r\n\r\n    int userid { 34 };\r\n    printIDNumber(userid); \/\/ we know the user's ID now\r\n\r\n    printIDNumber(62); \/\/ we can also pass an rvalue\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>There are two advantages to this approach:<\/p>\n<ol start=\"1\">\n<li>It effectively documents that the parameter is optional.\n<\/li>\n<li>We can pass in an rvalue (since <code>std::optional<\/code> will make a copy).\n<\/li>\n<\/ol>\n<p>However, because <code>std::optional<\/code> makes a copy of its argument, this becomes problematic when <code>T<\/code> is an expensive-to-copy type (like <code>std::string<\/code>).  With normal function parameters, we worked around this by making the parameter a <code>const lvalue reference<\/code>, so that a copy would not be made.  Unfortunately, as of C++23 <code>std::optional<\/code> does not support references.<\/p>\n<p>Therefore, we recommend using <code>std::optional&lt;T&gt;<\/code> as an optional parameter only when <code>T<\/code> would normally be passed by value.  Otherwise, use <code>const T*<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Although <code>std::optional<\/code> doesn&#8217;t support references directly, you can use <code>std::reference_wrapper<\/code> (which we cover in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/arrays-of-references-via-stdreference_wrapper\/\">17.5 -- Arrays of references via std::reference_wrapper<\/a>) to mimic a reference.  Let&#8217;s take a look at what the above program looks like using a <code>std::string<\/code> id and <code>std::reference_wrapper<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;functional&gt;  \/\/ for std::reference_wrapper\r\n#include &lt;iostream&gt;\r\n#include &lt;optional&gt;\r\n#include &lt;string&gt;\r\n\r\nstruct Employee\r\n{\r\n    std::string name{}; \/\/ expensive to copy\r\n    int id;\r\n};\r\n\r\nvoid printEmployeeID(std::optional&lt;std::reference_wrapper&lt;Employee&gt;&gt; e=std::nullopt)\r\n{\r\n    if (e)\r\n        std::cout &lt;&lt; \"Your ID number is \" &lt;&lt; e-&gt;get().id &lt;&lt; \".\\n\";\r\n    else\r\n        std::cout &lt;&lt; \"Your ID number is not known.\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    printEmployeeID(); \/\/ we don't know the Employee yet\r\n\r\n    Employee e { \"James\", 34 };\r\n    printEmployeeID(e); \/\/ we know the Employee's ID now\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>And for comparison, the pointer version:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nstruct Employee\r\n{\r\n    std::string name{}; \/\/ expensive to copy\r\n    int id;\r\n};\r\n\r\nvoid printEmployeeID(const Employee* e=nullptr)\r\n{\r\n    if (e)\r\n        std::cout &lt;&lt; \"Your ID number is \" &lt;&lt; e-&gt;id &lt;&lt; \".\\n\";\r\n    else\r\n        std::cout &lt;&lt; \"Your ID number is not known.\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    printEmployeeID(); \/\/ we don't know the Employee yet\r\n\r\n    Employee e { \"James\", 34 };\r\n    printEmployeeID(&amp;e); \/\/ we know the Employee's ID now\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>These two programs are nearly identical.  We&#8217;d argue the former isn&#8217;t more readable or maintainable than the latter, and isn&#8217;t worth introducing two additional types into your program for.\n<\/p><\/div>\n<p>In many cases, function overloading provides a superior solution:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nstruct Employee\r\n{\r\n    std::string name{}; \/\/ expensive to copy\r\n    int id;\r\n};\r\n\r\nvoid printEmployeeID()\r\n{\r\n    std::cout &lt;&lt; \"Your ID number is not known.\\n\";\r\n}\r\n\r\nvoid printEmployeeID(const Employee&amp; e)\r\n{\r\n    std::cout &lt;&lt; \"Your ID number is \" &lt;&lt; e.id &lt;&lt; \".\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    printEmployeeID(); \/\/ we don't know the Employee yet\r\n\r\n    Employee e { \"James\", 34 };\r\n    printEmployeeID(e); \/\/ we know the Employee's ID now\r\n\r\n    printEmployeeID( { \"Dave\", 62 } ); \/\/ we can even pass rvalues\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Prefer <code>std::optional<\/code> for optional return types.<\/p>\n<p>Prefer function overloading for optional function parameters (when possible).  Otherwise, use <code>std::optional&lt;T&gt;<\/code> for optional arguments when <code>T<\/code> would normally be passed by value.  Favor <code>const T*<\/code> when <code>T<\/code> is expensive to copy.\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-12-summary-and-quiz\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.x<\/span>Chapter 12 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/type-deduction-with-pointers-references-and-const\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.14<\/span>Type deduction with pointers, references, and const\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we discussed cases where a function encounters an error that it cannot reasonably handle itself. For example, consider a function that calculates and returns a value: int doIntDivision(int x, int y) { return x \/ y; } If the caller passes in a value that is semantically &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/16806"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=16806"}],"version-history":[{"count":16,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/16806\/revisions"}],"predecessor-version":[{"id":18177,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/16806\/revisions\/18177"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=16806"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=16806"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=16806"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}