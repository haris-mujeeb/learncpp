{"id":14967,"date":"2023-07-31T11:22:42","date_gmt":"2023-07-31T18:22:42","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=14967"},"modified":"2024-12-09T21:06:39","modified_gmt":"2024-12-10T05:06:39","slug":"in-and-out-parameters","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/in-and-out-parameters\/","title":{"rendered":"12.13 &#8212; In and out parameters"},"content":{"rendered":"<p>A function and its caller communicate with each other via two mechanisms: parameters and return values.  When a function is called, the caller provides arguments, which the function receives via its parameters.  These arguments can be passed by value, reference, or address.<\/p>\n<p>Typically, we&#8217;ll pass arguments by value or by const reference.  But there are times when we may need to do otherwise.<\/p>\n<p class=\"cpp-section\">In parameters<\/p>\n<p>In most cases, a function parameter is used only to receive an input from the caller.  Parameters that are used only for receiving input from the caller are sometimes called <strong>in parameters<\/strong>.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid print(int x) \/\/ x is an in parameter\r\n{\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n';\r\n}\r\n\r\nvoid print(const std::string&amp; s) \/\/ s is an in parameter\r\n{\r\n    std::cout &lt;&lt; s &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    print(5);\r\n    std::string s { \"Hello, world!\" };\r\n    print(s);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In-parameters are typically passed by value or by const reference.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Out parameters<\/p>\n<p>A function argument passed by non-const reference (or by pointer-to-non-const) allows the function to modify the value of an object passed as an argument.  This provides a way for a function to return data back to the caller in cases where using a return value is not sufficient for some reason.<\/p>\n<p>A function parameter that is used only for the purpose of returning information back to the caller is called an <strong>out parameter<\/strong>.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cmath&gt;    \/\/ for std::sin() and std::cos()\r\n#include &lt;iostream&gt;\r\n\r\n\/\/ sinOut and cosOut are out parameters\r\nvoid getSinCos(double degrees, double&amp; sinOut, double&amp; cosOut)\r\n{\r\n    \/\/ sin() and cos() take radians, not degrees, so we need to convert\r\n    constexpr double pi { 3.14159265358979323846 }; \/\/ the value of pi\r\n    double radians = degrees * pi \/ 180.0;\r\n    sinOut = std::sin(radians);\r\n    cosOut = std::cos(radians);\r\n}\r\n \r\nint main()\r\n{\r\n    double sin { 0.0 };\r\n    double cos { 0.0 };\r\n \r\n    double degrees{};\r\n    std::cout &lt;&lt; \"Enter the number of degrees: \";\r\n    std::cin &gt;&gt; degrees;\r\n\r\n    \/\/ getSinCos will return the sin and cos in variables sin and cos\r\n    getSinCos(degrees, sin, cos);\r\n \r\n    std::cout &lt;&lt; \"The sin is \" &lt;&lt; sin &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"The cos is \" &lt;&lt; cos &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This function has one parameter <code>degrees<\/code> (whose argument is passed by value) as input, and \u201creturns\u201d two parameters (by reference) as output. <\/p>\n<p>We\u2019ve named these out parameters with the suffix &#8220;out&#8221; to denote that they\u2019re out parameters. This helps remind the caller that the initial value passed to these parameters doesn\u2019t matter, and that we should expect them to be overwritten. By convention, output parameters are typically the rightmost parameters.<\/p>\n<p>Let\u2019s explore how this works in more detail. First, the main function creates local variables <code>sin<\/code> and <code>cos<\/code>. Those are passed into function <code>getSinCos()<\/code> by reference (rather than by value). This means function <code>getSinCos()<\/code> has access to the actual <code>sin<\/code> and <code>cos<\/code> variables in <code>main()<\/code>, not just copies.  <code>getSinCos()<\/code> accordingly assigns new values to <code>sin<\/code> and <code>cos<\/code> (through references <code>sinOut<\/code> and <code>cosOut<\/code> respectively), which overwrites the old values in <code>sin<\/code> and <code>cos<\/code>. Function <code>main()<\/code> then prints these updated values.<\/p>\n<p>If <code>sin<\/code> and <code>cos<\/code> had been passed by value instead of reference, <code>getSinCos()<\/code> would have changed copies of <code>sin<\/code> and <code>cos<\/code>, leading to any changes being discarded at the end of the function. But because <code>sin<\/code> and <code>cos<\/code> were passed by reference, any changes made to <code>sin<\/code> or <code>cos<\/code> (through the references) are persisted beyond the function.  We can therefore use this mechanism to return values back to the caller.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p><a href=\"https:\/\/stackoverflow.com\/a\/9779765\">This answer on StackOverflow<\/a> is an interesting read that explains why non-const lvalue references are not allowed to bind to rvalues\/temporary objects (due to implicit type conversion producing unexpected behavior when combined with out-parameters).\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Out parameters have an unnatural usage syntax<\/p>\n<p>Out-parameters, while functional, have a few downsides.<\/p>\n<p>First, the caller must instantiate (and initialize) objects and pass them as arguments, even if it doesn\u2019t intend to use them.  These objects must be able to be assigned to, which means they can&#8217;t be made const.<\/p>\n<p>Second, because the caller must pass in objects, these values can&#8217;t be used as temporaries, or easily used in a single expression.<\/p>\n<p>The following example shows both of these downsides:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint getByValue()\r\n{\r\n    return 5;\r\n}\r\n\r\nvoid getByReference(int&amp; x)\r\n{\r\n    x = 5;\r\n}\r\n\r\nint main()\r\n{\r\n    \/\/ return by value\r\n    [[maybe_unused]] int x{ getByValue() }; \/\/ can use to initialize object\r\n    std::cout &lt;&lt; getByValue() &lt;&lt; '\\n';      \/\/ can use temporary return value in expression\r\n\r\n    \/\/ return by out parameter\r\n    int y{};                \/\/ must first allocate an assignable object\r\n    getByReference(y);      \/\/ then pass to function to assign the desired value\r\n    std::cout &lt;&lt; y &lt;&lt; '\\n'; \/\/ and only then can we use that value\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>As you can see, the syntax for using out-parameters is a bit unnatural.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Out-parameters by reference don&#8217;t make it obvious the arguments will be modified<\/p>\n<p>When we assign a function&#8217;s return value to an object, it is clear that the value of the object is being modified:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">x = getByValue(); \/\/ obvious that x is being modified<\/code><\/pre>\n<p>This is good, as it makes it clear that we should expect the value of <code>x<\/code> to change.<\/p>\n<p>However, let&#8217;s take a look at the function call to <code>getSinCos()<\/code> in the example above again:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    getSinCos(degrees, sin, cos);<\/code><\/pre>\n<p>It is not clear from this function call that <code>degrees<\/code> is an in parameter, but <code>sin<\/code> and <code>cos<\/code> are out-parameters.  If the caller does not realize that <code>sin<\/code> and <code>cos<\/code> will be modified, a semantic error will likely result.<\/p>\n<p>Using pass by address instead of pass by reference can in some case help make out-parameters more obvious by requiring the caller to pass in the address of objects as arguments. <\/p>\n<p>Consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void foo1(int x);  \/\/ pass by value\r\nvoid foo2(int&amp; x); \/\/ pass by reference\r\nvoid foo3(int* x); \/\/ pass by address\r\n\r\nint main()\r\n{\r\n    int i{};\r\n \r\n    foo1(i);  \/\/ can't modify i\r\n    foo2(i);  \/\/ can modify i (not obvious)\r\n    foo3(&amp;i); \/\/ can modify i\r\n\r\n    int *ptr { &amp;i };\r\n    foo3(ptr); \/\/ can modify i (not obvious)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Notice that in the call to <code>foo3(&amp;i)<\/code>, we have to pass in <code>&amp;i<\/code> rather than <code>i<\/code>, which helps make it clearer that we should expect <code>i<\/code> to be modified.<\/p>\n<p>However, this is not fool-proof, as <code>foo3(ptr)<\/code> allows <code>foo3()<\/code> to modify <code>i<\/code> and does not require the caller to take the address-of <code>ptr<\/code>.<\/p>\n<p>The caller may also think they can pass in <code>nullptr<\/code> or a null pointer as a valid argument when this is disallowed.  And the function is now required to do null pointer checking and handling, which adds more complexity.  This need for added null pointer handling often causes more issues than just sticking with pass by reference.<\/p>\n<p>For all of these reasons, out-parameters should be avoided unless no other good options exist.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Avoid out-parameters (except in the rare case where no better options exist).<\/p>\n<p>Prefer pass by reference for non-optional out-parameters.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">In\/out parameters<\/p>\n<p>In rare cases, a function will actually use the value of an out-parameter before overwriting its value.  Such a parameter is called an <strong>in-out parameter<\/strong>.  In-out-parameters work identically to out-parameters and have all the same challenges.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">When to pass by non-const reference<\/p>\n<p>If you&#8217;re going to pass by reference in order to avoid making a copy of the argument, you should almost always pass by const reference.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>In the following examples, we will use <code>Foo<\/code> to represent some type that we care about.  For now, you can imagine <code>Foo<\/code> as a type alias for a type of your choice (e.g. <code>std::string<\/code>).\n<\/div>\n<p>However, there are two primary cases where pass by non-const reference may be the better choice.<\/p>\n<p>First, use pass by non-const reference when a parameter is an in-out-parameter.  Since we&#8217;re already passing in the object we need back out, it&#8217;s often more straightforward and performant to just modify that object.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void someFcn(Foo&amp; inout)\r\n{\r\n    \/\/ modify inout\r\n}\r\n\r\nint main()\r\n{\r\n    Foo foo{};\r\n    someFcn(foo); \/\/ foo modified after this call, may not be obvious\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Giving the function a good name can help:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void modifyFoo(Foo&amp; inout)\r\n{\r\n    \/\/ modify inout\r\n}\r\n\r\nint main()\r\n{\r\n    Foo foo{};\r\n    modifyFoo(foo); \/\/ foo modified after this call, slightly more obvious\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The alternative is to pass the object by value or const reference instead (as per usual) and return a new object by value, which the caller can then assign back to the original object:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">Foo someFcn(const Foo&amp; in)\r\n{\r\n    Foo foo { in }; \/\/ copy here\r\n    \/\/ modify foo\r\n    return foo;\r\n}\r\n\r\nint main()\r\n{\r\n    Foo foo{};\r\n    foo = someFcn(foo); \/\/ makes it obvious foo is modified, but another copy made here\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This has the benefit of using a more conventional return syntax, but requires making 2 extra copies (sometimes the compiler can optimize one of these copies away).<\/p>\n<p>Second, use pass by non-const reference when a function would otherwise return an object by value to the caller, but making a copy of that object is <em>extremely<\/em> expensive.  Especially if the function is called many times in a performance-critical section of code.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void generateExpensiveFoo(Foo&amp; out)\r\n{\r\n    \/\/ modify out\r\n}\r\n\r\nint main()\r\n{\r\n    Foo foo{};\r\n    generateExpensiveFoo(foo); \/\/ foo modified after this call\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>The most common example of the above is when a function needs to fill a large C-style array or <code>std::array<\/code> with data, and the array has an expensive-to-copy element type.  We discuss arrays in a future chapter.\n<\/div>\n<p>That said, objects are rarely so expensive to copy that resorting to non-conventional methods of returning those objects is worthwhile.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/type-deduction-with-pointers-references-and-const\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.14<\/span>Type deduction with pointers, references, and const\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/return-by-reference-and-return-by-address\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.12<\/span>Return by reference and return by address\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>A function and its caller communicate with each other via two mechanisms: parameters and return values. When a function is called, the caller provides arguments, which the function receives via its parameters. These arguments can be passed by value, reference, or address. Typically, we&#8217;ll pass arguments by value or by &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/14967"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=14967"}],"version-history":[{"count":22,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/14967\/revisions"}],"predecessor-version":[{"id":17970,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/14967\/revisions\/17970"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=14967"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=14967"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=14967"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}