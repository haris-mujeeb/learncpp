{"id":2094,"date":"2015-07-30T13:02:56","date_gmt":"2015-07-30T21:02:56","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=2094"},"modified":"2024-09-25T10:21:21","modified_gmt":"2024-09-25T17:21:21","slug":"type-deduction-for-objects-using-the-auto-keyword","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/type-deduction-for-objects-using-the-auto-keyword\/","title":{"rendered":"10.8 &#8212; Type deduction for objects using the auto keyword"},"content":{"rendered":"<p>There&#8217;s a subtle redundancy lurking in this simple variable definition:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">double d{ 5.0 };<\/code><\/pre>\n<p>In C++, we are required to provide an explicit type for all objects.  Thus, we&#8217;ve specified that variable <code>d<\/code> is of type double.<\/p>\n<p>However, the literal value <code>5.0<\/code> used to initialize <code>d<\/code> also has type double (implicitly determined via the format of the literal).<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We discuss how literal types are determined in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/literals\/\">5.2 -- Literals<\/a>.\n<\/p><\/div>\n<p>In cases where we want a variable and its initializer to have the same type, we&#8217;re effectively providing the same type information twice.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Type deduction for initialized variables<\/p>\n<p><strong>Type deduction<\/strong> (also sometimes called <strong>type inference<\/strong>) is a feature that allows the compiler to deduce the type of an object from the object&#8217;s initializer.  When defining a variable, type deduction can be invoked by using the <code>auto<\/code> keyword can be used in place of the variable&#8217;s type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    auto d { 5.0 }; \/\/ 5.0 is a double literal, so d will be deduced as a double\r\n    auto i { 1 + 2 }; \/\/ 1 + 2 evaluates to an int, so i will be deduced as an int\r\n    auto x { i }; \/\/ i is an int, so x will be deduced as an int\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the first case, because <code>5.0<\/code> is a double literal, the compiler will deduce that variable <code>d<\/code> should be of type <code>double<\/code>.  In the second case, the expression <code>1 + 2<\/code> yields an int result, so variable <code>i<\/code> will be of type <code>int<\/code>.  In the third case, <code>i<\/code> was previously deduced to be of type <code>int<\/code>, so <code>x<\/code> will also be deduced to be of type <code>int<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Prior to C++17, <code>auto d{ 5.0 };<\/code> would deduce <code>d<\/code> to be of type <code>std::initializer_list&lt;double&gt;<\/code> rather than <code>double<\/code>.  This was fixed in C++17, and many compilers (such as gcc and Clang) have back-ported this change to previous language standards.<\/p>\n<p>If you are using C++14 or older, and the above example doesn&#8217;t compile on your compiler, use copy initialization with <code>auto<\/code> instead (<code>auto d = 5.0<\/code>).\n<\/div>\n<p>Because function calls are valid expressions, we can even use type deduction when our initializer is a non-void function call:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int add(int x, int y)\r\n{\r\n    return x + y;\r\n}\r\n\r\nint main()\r\n{\r\n    auto sum { add(5, 6) }; \/\/ add() returns an int, so sum's type will be deduced as an int\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The <code>add()<\/code> function returns an <code>int<\/code> value, so the compiler will deduce that variable <code>sum<\/code> should have type <code>int<\/code>.<\/p>\n<p>Literal suffixes can be used in combination with type deduction to specify a particular type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    auto a { 1.23f }; \/\/ f suffix causes a to be deduced to float\r\n    auto b { 5u };    \/\/ u suffix causes b to be deduced to unsigned int\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Variables using type deduction may also use other specifiers\/qualifiers, such as <code>const<\/code> or <code>constexpr<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int a { 5 };            \/\/ a is an int\r\n\r\n    const auto b { 5 };     \/\/ b is a const int\r\n    constexpr auto c { 5 }; \/\/ c is a constexpr int\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Type deduction must have something to deduce from<\/p>\n<p>Type deduction will not work for objects that either do not have initializers or have empty initializers.  It also will not work when the initializer has type <code>void<\/code> (or any other incomplete type).  Thus, the following is not valid:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid foo()\r\n{\r\n}\r\n\r\nint main()\r\n{\r\n    auto a;           \/\/ The compiler is unable to deduce the type of a\r\n    auto b { };       \/\/ The compiler is unable to deduce the type of b\r\n    auto c { foo() }; \/\/ Invalid: c can't have type incomplete type void\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>Although using type deduction for fundamental data types only saves a few (if any) keystrokes, in future lessons we will see examples where the types get complex and lengthy (and in some cases, can be hard to figure out).  In those cases, using <code>auto<\/code> can save a lot of typing (and typos).<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>The type deduction rules for pointers and references are a bit more complex.  We discuss these in <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/type-deduction-with-pointers-references-and-const\/\">12.14 -- Type deduction with pointers, references, and const<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Type deduction drops <code>const<\/code> from the deduced type<\/p>\n<p>In most cases, type deduction will drop the <code>const<\/code> from deduced types.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    const int a { 5 }; \/\/ a has type const int\r\n    auto b { a };      \/\/ b has type int (const dropped)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, <code>a<\/code> has type <code>const int<\/code>, but when deducing a type for variable <code>b<\/code> using <code>a<\/code> as the initializer, type deduction deduces the type as <code>int<\/code>, not <code>const int<\/code>.<\/p>\n<p>If you want a deduced type to be const, you must supply the <code>const<\/code> yourself as part of the definition:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    const int a { 5 };  \/\/ a has type const int\r\n    const auto b { a }; \/\/ b has type const int (const dropped but reapplied)\r\n\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this example, the type deduced from <code>a<\/code> will be <code>int<\/code> (the <code>const<\/code> is dropped), but because we&#8217;ve re-added a <code>const<\/code> qualifier during the definition of variable <code>b<\/code>, variable <code>b<\/code> will have type <code>const int<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Type deduction for string literals<\/p>\n<p>For historical reasons, string literals in C++ have a strange type.  Therefore, the following probably won&#8217;t work as expected:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">auto s { \"Hello, world\" }; \/\/ s will be type const char*, not std::string<\/code><\/pre>\n<p>If you want the type deduced from a string literal to be <code>std::string<\/code> or <code>std::string_view<\/code>, you&#8217;ll need to use the <code>s<\/code> or <code>sv<\/code> literal suffixes (introduced in lessons <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdstring\/\">5.7 -- Introduction to std::string<\/a> and <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdstring_view\/\">5.8 -- Introduction to std::string_view<\/a>):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nint main()\r\n{\r\n    using namespace std::literals; \/\/ easiest way to access the s and sv suffixes\r\n\r\n    auto s1 { \"goo\"s };  \/\/ \"goo\"s is a std::string literal, so s1 will be deduced as a std::string\r\n    auto s2 { \"moo\"sv }; \/\/ \"moo\"sv is a std::string_view literal, so s2 will be deduced as a std::string_view\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>But in such cases, it may be better to not use type deduction.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Type deduction and constexpr<\/p>\n<p>Because <code>constexpr<\/code> is not part of the type system, it cannot be deduced as part of type deduction.  However, a <code>constexpr<\/code> variable is implicitly const, and this const will be dropped during type deduction (and can be readded if desired):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    constexpr double a { 3.4 };  \/\/ a has type const double (constexpr not part of type, const is implicit)\r\n\r\n    auto b { a };                \/\/ b has type double (const dropped)\r\n    const auto c { a };          \/\/ c has type const double (const dropped but reapplied)\r\n    constexpr auto d { a };      \/\/ d has type const double (const dropped but implicitly reapplied by constexpr)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Type deduction benefits and downsides<\/p>\n<p>Type deduction is not only convenient, but also has a number of other benefits.<\/p>\n<p>First, if two or more variables are defined on sequential lines, the names of the variables will be lined up, helping to increase readability:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ harder to read\r\nint a { 5 };\r\ndouble b { 6.7 };\r\n\r\n\/\/ easier to read\r\nauto c { 5 };\r\nauto d { 6.7 };<\/code><\/pre>\n<p>Second, type deduction only works on variables that have initializers, so if you are in the habit of using type deduction, it can help avoid unintentionally uninitialized variables:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int x; \/\/ oops, we forgot to initialize x, but the compiler may not complain\r\nauto y; \/\/ the compiler will error out because it can't deduce a type for y<\/code><\/pre>\n<p>Third, you are guaranteed that there will be no unintended performance-impacting conversions:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::string_view getString();   \/\/ some function that returns a std::string_view\r\n\r\nstd::string s1 { getString() }; \/\/ bad: expensive conversion from std::string_view to std::string (assuming you didn't want this)\r\nauto s2 { getString() };        \/\/ good: no conversion required<\/code><\/pre>\n<p>Type deduction also has a few downsides.<\/p>\n<p>First, type deduction obscures an object&#8217;s type information in the code.  Although a good IDE should be able to show you the deduced type (e.g. when hovering a variable), it&#8217;s still a bit easier to make type-based mistakes when using type deduction.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">auto y { 5 }; \/\/ oops, we wanted a double here but we accidentally provided an int literal<\/code><\/pre>\n<p>In the above code, if we&#8217;d explicitly specified <code>y<\/code> as type double, <code>y<\/code> would have been a double even though we accidentally provided an int literal initializer.  With type deduction, <code>y<\/code> will be deduced to be of type int.<\/p>\n<p>Here&#8217;s another example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n     auto x { 3 };\r\n     auto y { 2 };\r\n\r\n     std::cout &lt;&lt; x \/ y &lt;&lt; '\\n'; \/\/ oops, we wanted floating point division here\r\n\r\n     return 0;\r\n}<\/code><\/pre>\n<p>In this example, it&#8217;s less clear that we&#8217;re getting an integer division rather than a floating-point division.<\/p>\n<p>Similar cases occur when a variable is <code>unsigned<\/code>.  Since we don&#8217;t want to mix signed and unsigned values, explicitly knowing that a variable has an unsigned type is generally something that shouldn&#8217;t be obscured.<\/p>\n<p>Second, if the type of an initializer changes, the type of a variable using type deduction will also change, perhaps unexpectedly.  Consider:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">auto sum { add(5, 6) + gravity };<\/code><\/pre>\n<p>If the return type of <code>add<\/code> changes from int to double, or <code>gravity<\/code> changes from int to double, <code>sum<\/code> will also change type from int to double.<\/p>\n<p>Overall, the modern consensus is that type deduction is generally safe to use for objects, and that doing so can help make your code more readable by de-emphasizing type information so the logic of your code stands out better.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Use type deduction for your variables when the type of the object doesn&#8217;t matter.<\/p>\n<p>Favor an explicit type when you require a specific type that differs from the type of the initializer, or when your object is used in a context where making the type obvious is useful.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>In future lessons, we&#8217;ll continue to use explicit types instead of type deduction when we feel showing the type information is helpful to understanding a concept or example.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/type-deduction-for-functions\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">10.9<\/span>Type deduction for functions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/typedefs-and-type-aliases\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">10.7<\/span>Typedefs and type aliases\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>There&#8217;s a subtle redundancy lurking in this simple variable definition: double d{ 5.0 }; In C++, we are required to provide an explicit type for all objects. Thus, we&#8217;ve specified that variable d is of type double. However, the literal value 5.0 used to initialize d also has type double &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/2094"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=2094"}],"version-history":[{"count":54,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/2094\/revisions"}],"predecessor-version":[{"id":17661,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/2094\/revisions\/17661"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=2094"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=2094"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=2094"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}