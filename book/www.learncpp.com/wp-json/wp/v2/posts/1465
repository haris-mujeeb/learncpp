{"id":1465,"date":"2015-03-23T11:32:22","date_gmt":"2015-03-23T19:32:22","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=1465"},"modified":"2024-06-09T21:18:47","modified_gmt":"2024-06-10T04:18:47","slug":"local-variables","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/local-variables\/","title":{"rendered":"7.3 &#8212; Local variables"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-local-scope\/\">2.5 -- Introduction to local scope<\/a>, we introduced <code>local variables<\/code>, which are variables that are defined inside a function (including function parameters).<\/p>\n<p>It turns out that C++ actually doesn\u2019t have a single attribute that defines a variable as being a local variable. Instead, local variables have several different properties that differentiate how these variables behave from other kinds of (non-local) variables. We\u2019ll explore these properties in this and upcoming lessons.<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-local-scope\/\">2.5 -- Introduction to local scope<\/a>, we also introduced the concept of scope.  An identifier&#8217;s <code>scope<\/code> determines where an identifier can be accessed within the source code.  When an identifier can be accessed, we say it is <code>in scope<\/code>. When an identifier can not be accessed, we say it is <code>out of scope<\/code>. Scope is a compile-time property, and trying to use an identifier when it is out of scope will result in a compile error.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Local variables have block scope<\/p>\n<p>Local variables have <strong>block scope<\/strong>, which means they are <em>in scope<\/em> from their point of definition to the end of the block they are defined within.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>Please review lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/compound-statements-blocks\/\">7.1 -- Compound statements (blocks)<\/a> if you need a refresher on blocks.\n<\/p><\/div>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int i { 5 }; \/\/ i enters scope here\r\n    double d { 4.0 }; \/\/ d enters scope here\r\n\r\n    return 0;\r\n} \/\/ d and i go out of scope here<\/code><\/pre>\n<p>Although function parameters are not defined inside the function body, for typical functions they can be considered to be part of the scope of the function body block.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int max(int x, int y) \/\/ x and y enter scope here\r\n{\r\n    \/\/ assign the greater of x or y to max\r\n    int max{ (x &gt; y) ? x : y }; \/\/ max enters scope here\r\n\r\n    return max;\r\n} \/\/ max, y, and x leave scope here<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">All variable names within a scope must be unique<\/p>\n<p>Variable names must be unique within a given scope, otherwise any reference to the name will be ambiguous.  Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void someFunction(int x)\r\n{\r\n    int x{}; \/\/ compilation failure due to name collision with function parameter\r\n}\r\n\r\nint main()\r\n{\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The above program doesn&#8217;t compile because the variable <code>x<\/code> defined inside the function body and the function parameter <code>x<\/code> have the same name and both are in the same block scope.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Local variables have automatic storage duration<\/p>\n<p>A variable&#8217;s <strong>storage duration<\/strong> (usually just called <strong>duration<\/strong>) determines what rules govern when and how a variable will be created (instantiated) and destroyed.  In most cases, a variable&#8217;s storage duration directly determines its <code>lifetime<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We discuss what a lifetime is in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-local-scope\/\">2.5 -- Introduction to local scope<\/a>.\n<\/p><\/div>\n<p>For example, local variables have <strong>automatic storage duration<\/strong>, which means they are created at the point of definition and destroyed at the end of the block they are defined in.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int i { 5 }; \/\/ i created and initialized here\r\n    double d { 4.0 }; \/\/ d created and initialized here\r\n\r\n    return 0;\r\n} \/\/ d and i are destroyed here<\/code><\/pre>\n<p>For this reason, local variables are sometimes called <strong>automatic variables<\/strong>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Local variables in nested blocks<\/p>\n<p>Local variables can be defined inside nested blocks.  This works identically to local variables in function body blocks:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main() \/\/ outer block\r\n{\r\n    int x { 5 }; \/\/ x enters scope and is created here\r\n\r\n    { \/\/ nested block\r\n        int y { 7 }; \/\/ y enters scope and is created here\r\n    } \/\/ y goes out of scope and is destroyed here\r\n\r\n    \/\/ y can not be used here because it is out of scope in this block\r\n\r\n    return 0;\r\n} \/\/ x goes out of scope and is destroyed here<\/code><\/pre>\n<p>In the above example, variable <code>y<\/code> is defined inside a nested block.  Its scope is limited from its point of definition to the end of the nested block, and its lifetime is the same.  Because the scope of variable <code>y<\/code> is limited to the inner block in which it is defined, it&#8217;s not accessible anywhere in the outer block.<\/p>\n<p>Note that nested blocks are considered part of the scope of the outer block in which they are defined.  Consequently, variables defined in the outer block <em>can<\/em> be seen inside a nested block:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{ \/\/ outer block\r\n\r\n    int x { 5 }; \/\/ x enters scope and is created here\r\n\r\n    { \/\/ nested block\r\n        int y { 7 }; \/\/ y enters scope and is created here\r\n\r\n        \/\/ x and y are both in scope here\r\n        std::cout &lt;&lt; x &lt;&lt; \" + \" &lt;&lt; y &lt;&lt; \" = \" &lt;&lt; x + y &lt;&lt; '\\n';\r\n    } \/\/ y goes out of scope and is destroyed here\r\n\r\n    \/\/ y can not be used here because it is out of scope in this block\r\n\r\n    return 0;\r\n} \/\/ x goes out of scope and is destroyed here<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Local variables have no linkage<\/p>\n<p>Identifiers have another property named <em>linkage<\/em>.  An identifier&#8217;s <strong>linkage<\/strong> determines whether a declaration of that same identifier in a different scope refers to the same object (or function).<\/p>\n<p>Local variables have no linkage.  Each declaration of an identifier with no linkage refers to a unique object or function.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int x { 2 }; \/\/ local variable, no linkage\r\n\r\n    {\r\n        int x { 3 }; \/\/ this declaration of x refers to a different object than the previous x\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Scope and linkage may seem somewhat similar.  However, scope determines where declaration of a single identifier can be seen and used in the code.  Linkage determines whether multiple declarations of the same identifier refer to the same object or not.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We discuss what happens when variables with the same name appear in nested blocks in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/variable-shadowing-name-hiding\/\">7.5 -- Variable shadowing (name hiding)<\/a>.\n<\/p><\/div>\n<p>Linkage isn&#8217;t very interesting in the context of local variables, but we&#8217;ll talk about it more in the next few lessons.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Variables should be defined in the most limited scope<\/p>\n<p>If a variable is only used within a nested block, it should be defined inside that nested block:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    \/\/ do not define y here\r\n\r\n    {\r\n        \/\/ y is only used inside this block, so define it here\r\n        int y { 5 };\r\n        std::cout &lt;&lt; y &lt;&lt; '\\n';\r\n    }\r\n\r\n    \/\/ otherwise y could still be used here, where it's not needed\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>By limiting the scope of a variable, you reduce the complexity of the program because the number of active variables is reduced.  Further, it makes it easier to see where variables are used (or aren&#8217;t used).  A variable defined inside a block can only be used within that block (or nested blocks).  This can make the program easier to understand.<\/p>\n<p>If a variable is needed in an outer block, it needs to be declared in the outer block:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int y { 5 }; \/\/ we're declaring y here because we need it in this outer block later\r\n\r\n    {\r\n        int x{};\r\n        std::cin &gt;&gt; x;\r\n\r\n        \/\/ if we declared y here, immediately before its actual first use...\r\n        if (x == 4)\r\n            y = 4;\r\n    } \/\/ ... it would be destroyed here\r\n\r\n    std::cout &lt;&lt; y; \/\/ and we need y to exist here\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The above example shows one of the rare cases where you may need to declare a variable well before its first use.<\/p>\n<p>New developers sometimes wonder whether it&#8217;s worth creating a nested block just to intentionally limit a variable&#8217;s scope (and force it to go out of scope \/ be destroyed early).  Doing so makes that variable simpler, but the overall function becomes longer and more complex as a result.  The tradeoff generally isn&#8217;t worth it.  If creating a nested block seems useful to intentionally limit the scope of a chunk of code, that code might be better to put in a separate function instead.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Define variables in the most limited existing scope.  Avoid creating new blocks whose only purpose is to limit the scope of variables.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #1<\/p>\n<p>Write a program that asks the user to enter two integers, one named <code>smaller<\/code>, the other named <code>larger<\/code>.  If the user enters a smaller value for the second integer, use a block and a temporary variable to swap the smaller and larger values.  Then print the values of the <code>smaller<\/code> and <code>larger<\/code> variables.  Add comments to your code indicating where each variable dies. Note: When you print the values, <code>smaller<\/code> should hold the smaller input and <code>larger<\/code> the larger input, no matter which order they were entered in.<\/p>\n<p>The program output should match the following:<\/p>\n<pre>\r\nEnter an integer: 4\r\nEnter a larger integer: 2\r\nSwapping the values\r\nThe smaller value is 2\r\nThe larger value is 4\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter an integer: \";\r\n    int smaller{};\r\n    std::cin &gt;&gt; smaller;\r\n\r\n    std::cout &lt;&lt; \"Enter a larger integer: \";\r\n    int larger{};\r\n    std::cin &gt;&gt; larger;\r\n\r\n    \/\/ if user did it wrong\r\n    if (smaller &gt; larger)\r\n    {\r\n        \/\/ swap values of smaller and larger\r\n        std::cout &lt;&lt; \"Swapping the values\\n\";\r\n\r\n        int temp{ larger };\r\n        larger = smaller;\r\n        smaller = temp;\r\n    } \/\/ temp dies here\r\n\r\n    std::cout &lt;&lt; \"The smaller value is: \" &lt;&lt; smaller &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"The larger value is: \" &lt;&lt; larger &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n} \/\/ smaller and larger die here<\/code><\/pre>\n<p>In the future, you can use <code>std::swap()<\/code> from the <code>&lt;utility&gt;<\/code> header to swap the values of two variables. For example<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int temp{ larger };\r\nlarger = smaller;\r\nsmaller = temp;\r\n\r\n\/\/ is the same as\r\nstd::swap(larger, smaller);<\/code><\/pre>\n<\/div>\n<\/div>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #2<\/p>\n<p>What&#8217;s the difference between a variable&#8217;s scope, duration, and lifetime?  By default, what kind of scope and duration do local variables have (and what do those mean)?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p>A variable&#8217;s scope determines where the variable is accessible within the source code.  Duration defines the rules that govern when a variable is created and destroyed.  A variable&#8217;s lifetime is the actual time between its creation and destruction.<\/p>\n<p>Local variables have block scope, which means they can be accessed from their point of definition to the end of the block they are defined within.<\/p>\n<p>Local variables have automatic duration, which means they are created at the point of definition, and destroyed at the end of the block in which they are defined.\n<\/p><\/div>\n<\/p>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-global-variables\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.4<\/span>Introduction to global variables\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/user-defined-namespaces-and-the-scope-resolution-operator\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.2<\/span>User-defined namespaces and the scope resolution operator\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we introduced local variables, which are variables that are defined inside a function (including function parameters). It turns out that C++ actually doesn\u2019t have a single attribute that defines a variable as being a local variable. Instead, local variables have several different properties that differentiate how these &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1465"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=1465"}],"version-history":[{"count":50,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1465\/revisions"}],"predecessor-version":[{"id":17175,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/1465\/revisions\/17175"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=1465"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=1465"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=1465"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}