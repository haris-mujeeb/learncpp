{"id":190,"date":"2008-03-04T16:09:23","date_gmt":"2008-03-05T00:09:23","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/132-input\/"},"modified":"2024-12-23T21:39:44","modified_gmt":"2024-12-24T05:39:44","slug":"input-with-istream","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/input-with-istream\/","title":{"rendered":"28.2 &#8212; Input with istream"},"content":{"rendered":"<p>The iostream library is fairly complex -- so we will not be able to cover it in its entirety in these tutorials.  However, we will show you the most commonly used functionality.  In this section, we will look at various aspects of the input class (istream).<\/p>\n<p><strong>The extraction operator<\/strong><\/p>\n<p>As seen in many lessons now, we can use the extraction operator (>>) to read information from an input stream.  C++ has predefined extraction operations for all of the built-in data types, and you&#8217;ve already seen how you can <a href=\"http:\/\/www.learncpp.com\/cpp-tutorial\/93-overloading-the-io-operators\/\">overload the extraction operator<\/a> for your own classes.<\/p>\n<p>When reading strings, one common problem with the extraction operator is how to keep the input from overflowing your buffer.  Given the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">char buf[10]{};\r\nstd::cin &gt;&gt; buf;<\/code><\/pre>\n<p>what happens if the user enters 18 characters?  The buffer overflows, and bad stuff happens.  Generally speaking, it&#8217;s a bad idea to make any assumption about how many characters your user will enter.<\/p>\n<p>One way to handle this problem is through use of manipulators.  A <strong>manipulator<\/strong> is an object that is used to modify a stream when applied with the extraction (>>) or insertion (<<) operators.  One manipulator you have already worked with is \"std::endl\", which both prints a newline character and flushes any buffered output.\n\nC++ provides a manipulator known as <strong>setw<\/strong> (in the iomanip header) that can be used to limit the number of characters read in from a stream.  To use setw(), simply provide the maximum number of characters to read as a parameter, and insert it into your input statement like such:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iomanip&gt;\r\nchar buf[10]{};\r\nstd::cin &gt;&gt; std::setw(10) &gt;&gt; buf;<\/code><\/pre>\n<p>This program will now only read the first 9 characters out of the stream (leaving room for a terminator).  Any remaining characters will be left in the stream until the next extraction.<\/p>\n<p><strong>Extraction and whitespace<\/strong><\/p>\n<p>As a reminder, the extraction operator skips whitespace (blanks, tabs, and newlines).<\/p>\n<p>Take a look at the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    char ch{};\r\n    while (std::cin &gt;&gt; ch)\r\n        std::cout &lt;&lt; ch;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When the user inputs the following:<\/p>\n<pre>\r\nHello my name is Alex\r\n<\/pre>\n<p>The extraction operator skips the spaces and the newline.  Consequently, the output is:<\/p>\n<pre>\r\nHellomynameisAlex\r\n<\/pre>\n<p>Oftentimes, you&#8217;ll want to get user input but not discard whitespace.  To do this, the istream class provides many functions that can be used for this purpose.<\/p>\n<p>One of the most useful is the <strong>get()<\/strong> function, which simply gets a character from the input stream.  Here&#8217;s the same program as above using get():<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    char ch{};\r\n    while (std::cin.get(ch))\r\n        std::cout &lt;&lt; ch;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Now when we use the input:<\/p>\n<pre>\r\nHello my name is Alex\r\n<\/pre>\n<p>The output is:<\/p>\n<pre>\r\nHello my name is Alex\r\n<\/pre>\n<p>get() also has a string version that takes a maximum number of characters to read:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    char strBuf[11]{};\r\n    std::cin.get(strBuf, 11);\r\n    std::cout &lt;&lt; strBuf &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>If we input:<\/p>\n<pre>\r\nHello my name is Alex\r\n<\/pre>\n<p>The output is:<\/p>\n<pre>\r\nHello my n\r\n<\/pre>\n<p>Note that we only read the first 10 characters (we had to leave one character for a terminator).  The remaining characters were left in the input stream.<\/p>\n<p>One important thing to note about get() is that it does not read in a newline character!  This can cause some unexpected results:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    char strBuf[11]{};\r\n    \/\/ Read up to 10 characters\r\n    std::cin.get(strBuf, 11);\r\n    std::cout &lt;&lt; strBuf &lt;&lt; '\\n';\r\n\r\n    \/\/ Read up to 10 more characters\r\n    std::cin.get(strBuf, 11);\r\n    std::cout &lt;&lt; strBuf &lt;&lt; '\\n';\r\n    return 0;\r\n}<\/code><\/pre>\n<p>If the user enters:<\/p>\n<pre>\r\nHello!\r\n<\/pre>\n<p>The program will print:<\/p>\n<pre>\r\nHello!\r\n<\/pre>\n<p>and then terminate!  Why didn&#8217;t it ask for 10 more characters?  The answer is because the first get() read up to the newline and then stopped.  The second get() saw there was still input in the cin stream and tried to read it.  But the first character was the newline, so it stopped immediately.<\/p>\n<p>Consequently, there is another function called <strong>getline()<\/strong> that works similarly to get(), but will extract (and discard) the delimiter.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    char strBuf[11]{};\r\n    \/\/ Read up to 10 characters\r\n    std::cin.getline(strBuf, 11);\r\n    std::cout &lt;&lt; strBuf &lt;&lt; '\\n';\r\n\r\n    \/\/ Read up to 10 more characters\r\n    std::cin.getline(strBuf, 11);\r\n    std::cout &lt;&lt; strBuf &lt;&lt; '\\n';\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This code will perform as you expect, even if the user enters a string with a newline in it.<\/p>\n<p>If you need to know how many character were extracted by the last call of getline(), use <strong>gcount()<\/strong>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    char strBuf[100]{};\r\n    std::cin.getline(strBuf, 100);\r\n    std::cout &lt;&lt; strBuf &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; std::cin.gcount() &lt;&lt; \" characters were read\" &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>gcount() includes any extracted and discarded delimiters.<\/p>\n<p><strong>A special version of getline() for std::string<\/strong><\/p>\n<p>There is a special version of getline() that lives outside the istream class that is used for reading in variables of type std::string.  This special version is not a member of either ostream or istream, and is included in the string header.  Here is an example of its use:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::string strBuf{};\r\n    std::getline(std::cin, strBuf);\r\n    std::cout &lt;&lt; strBuf &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><strong>A few more useful istream functions<\/strong><\/p>\n<p>There are a few more useful input functions that you might want to make use of:<\/p>\n<p><strong>ignore()<\/strong> discards the first character in the stream.<br \/>\n<strong>ignore(int nCount)<\/strong> discards the first nCount characters.<br \/>\n<strong>peek()<\/strong> allows you to read a character from the stream without removing it from the stream.<br \/>\n<strong>unget()<\/strong> returns the last character read back into the stream so it can be read again by the next call.<br \/>\n<strong>putback(char ch)<\/strong> allows you to put a character of your choice back into the stream to be read by the next call.<\/p>\n<p>istream contains many other functions and variants of the above mentioned functions that may be useful, depending on what you need to do.  You can find these on a reference site such as <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/io\/basic_istream\">https:\/\/en.cppreference.com\/w\/cpp\/io\/basic_istream<\/a>.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/output-with-ostream-and-ios\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">28.3<\/span>Output with ostream and ios\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/input-and-output-io-streams\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">28.1<\/span>Input and output (I\/O) streams\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>The iostream library is fairly complex &#8212; so we will not be able to cover it in its entirety in these tutorials. However, we will show you the most commonly used functionality. In this section, we will look at various aspects of the input class (istream). The extraction operator As &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/190"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=190"}],"version-history":[{"count":23,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/190\/revisions"}],"predecessor-version":[{"id":18012,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/190\/revisions\/18012"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=190"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=190"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=190"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}