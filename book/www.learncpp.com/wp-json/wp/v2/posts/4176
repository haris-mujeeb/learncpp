{"id":4176,"date":"2016-06-05T10:51:00","date_gmt":"2016-06-05T18:51:00","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=4176"},"modified":"2024-07-22T14:42:30","modified_gmt":"2024-07-22T21:42:30","slug":"overloading-the-assignment-operator","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-the-assignment-operator\/","title":{"rendered":"21.12 &#8212; Overloading the assignment operator"},"content":{"rendered":"<p>The <strong>copy assignment operator<\/strong> (operator=) is used to copy values from one object to another <em>already existing object<\/em>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>As of C++11, C++ also supports &#8220;Move assignment&#8221;.  We discuss move assignment in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/move-constructors-and-move-assignment\/\">22.3 -- Move constructors and move assignment<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Copy assignment vs Copy constructor<\/p>\n<p>The purpose of the copy constructor and the copy assignment operator are almost equivalent -- both copy one object to another.  However, the copy constructor initializes new objects, whereas the assignment operator replaces the contents of existing objects.<\/p>\n<p>The difference between the copy constructor and the copy assignment operator causes a lot of confusion for new programmers, but it&#8217;s really not all that difficult.  Summarizing:<\/p>\n<ul>\n<li>If a new object has to be created before the copying can occur, the copy constructor is used (note: this includes passing or returning objects by value).\n<li>If a new object does not have to be created before the copying can occur, the assignment operator is used.\n<\/ul>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Overloading the assignment operator<\/p>\n<p>Overloading the copy assignment operator (operator=) is fairly straightforward, with one specific caveat that we&#8217;ll get to.  The copy assignment operator must be overloaded as a member function.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n\r\nclass Fraction\r\n{\r\nprivate:\r\n\tint m_numerator { 0 };\r\n\tint m_denominator { 1 };\r\n\r\npublic:\r\n\t\/\/ Default constructor\r\n\tFraction(int numerator = 0, int denominator = 1 )\r\n\t\t: m_numerator { numerator }, m_denominator { denominator }\r\n\t{\r\n\t\tassert(denominator != 0);\r\n\t}\r\n\r\n\t\/\/ Copy constructor\r\n\tFraction(const Fraction&amp; copy)\r\n\t\t: m_numerator { copy.m_numerator }, m_denominator { copy.m_denominator }\r\n\t{\r\n\t\t\/\/ no need to check for a denominator of 0 here since copy must already be a valid Fraction\r\n\t\tstd::cout &lt;&lt; \"Copy constructor called\\n\"; \/\/ just to prove it works\r\n\t}\r\n\r\n\t\/\/ Overloaded assignment\r\n\tFraction&amp; operator= (const Fraction&amp; fraction);\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1);\r\n        \r\n};\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)\r\n{\r\n\tout &lt;&lt; f1.m_numerator &lt;&lt; '\/' &lt;&lt; f1.m_denominator;\r\n\treturn out;\r\n}\r\n\r\n\/\/ A simplistic implementation of operator= (see better implementation below)\r\nFraction&amp; Fraction::operator= (const Fraction&amp; fraction)\r\n{\r\n    \/\/ do the copy\r\n    m_numerator = fraction.m_numerator;\r\n    m_denominator = fraction.m_denominator;\r\n\r\n    \/\/ return the existing object so we can chain this operator\r\n    return *this;\r\n}\r\n\r\nint main()\r\n{\r\n    Fraction fiveThirds { 5, 3 };\r\n    Fraction f;\r\n    f = fiveThirds; \/\/ calls overloaded assignment\r\n    std::cout &lt;&lt; f;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\n5\/3\r\n<\/pre>\n<p>This should all be pretty straightforward by now.  Our overloaded operator= returns *this, so that we can chain multiple assignments together:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    Fraction f1 { 5, 3 };\r\n    Fraction f2 { 7, 2 };\r\n    Fraction f3 { 9, 5 };\r\n\r\n    f1 = f2 = f3; \/\/ chained assignment\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Issues due to self-assignment<\/p>\n<p>Here&#8217;s where things start to get a little more interesting.  C++ allows self-assignment:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    Fraction f1 { 5, 3 };\r\n    f1 = f1; \/\/ self assignment\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This will call f1.operator=(f1), and under the simplistic implementation above, all of the members will be assigned to themselves.  In this particular example, the self-assignment causes each member to be assigned to itself, which has no overall impact, other than wasting time.  In most cases, a self-assignment doesn&#8217;t need to do anything at all!<\/p>\n<p>However, in cases where an assignment operator needs to dynamically assign memory, self-assignment can actually be dangerous:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt; \/\/ for std::max and std::copy_n\r\n#include &lt;iostream&gt;\r\n\r\nclass MyString\r\n{\r\nprivate:\r\n\tchar* m_data {};\r\n\tint m_length {};\r\n\r\npublic:\r\n\tMyString(const char* data = nullptr, int length = 0 )\r\n\t\t: m_length { std::max(length, 0) }\r\n\t{\r\n\t\tif (length)\r\n\t\t{\r\n\t\t\tm_data = new char[static_cast&lt;std::size_t&gt;(length)];\r\n\t\t\tstd::copy_n(data, length, m_data); \/\/ copy length elements of data into m_data\r\n\t\t}\r\n\t}\r\n\t~MyString()\r\n\t{\r\n\t\tdelete[] m_data;\r\n\t}\r\n\r\n\tMyString(const MyString&amp;) = default; \/\/ some compilers (gcc) warn if you have pointer members but no declared copy constructor\r\n\r\n\t\/\/ Overloaded assignment\r\n\tMyString&amp; operator= (const MyString&amp; str);\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyString&amp; s);\r\n};\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyString&amp; s)\r\n{\r\n\tout &lt;&lt; s.m_data;\r\n\treturn out;\r\n}\r\n\r\n\/\/ A simplistic implementation of operator= (do not use)\r\nMyString&amp; MyString::operator= (const MyString&amp; str)\r\n{\r\n\t\/\/ if data exists in the current string, delete it\r\n\tif (m_data) delete[] m_data;\r\n\r\n\tm_length = str.m_length;\r\n\tm_data = nullptr;\r\n\r\n\t\/\/ allocate a new array of the appropriate length\r\n\tif (m_length)\r\n\t\tm_data = new char[static_cast&lt;std::size_t&gt;(str.m_length)];\r\n\r\n\tstd::copy_n(str.m_data, m_length, m_data); \/\/ copies m_length elements of str.m_data into m_data\r\n\r\n\t\/\/ return the existing object so we can chain this operator\r\n\treturn *this;\r\n}\r\n\r\nint main()\r\n{\r\n\tMyString alex(\"Alex\", 5); \/\/ Meet Alex\r\n\tMyString employee;\r\n\temployee = alex; \/\/ Alex is our newest employee\r\n\tstd::cout &lt;&lt; employee; \/\/ Say your name, employee\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>First, run the program as it is.  You&#8217;ll see that the program prints &#8220;Alex&#8221; as it should.<\/p>\n<p>Now run the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    MyString alex { \"Alex\", 5 }; \/\/ Meet Alex\r\n    alex = alex; \/\/ Alex is himself\r\n    std::cout &lt;&lt; alex; \/\/ Say your name, Alex\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>You&#8217;ll probably get garbage output.  What happened?<\/p>\n<p>Consider what happens in the overloaded operator= when the implicit object AND the passed in parameter (str) are both variable alex.  In this case, m_data is the same as str.m_data.  The first thing that happens is that the function checks to see if the implicit object already has a string.  If so, it needs to delete it, so we don&#8217;t end up with a memory leak.  In this case, m_data is allocated, so the function deletes m_data.  But because str is the same as *this, the string that we wanted to copy has been deleted and m_data (and str.m_data) are dangling.<\/p>\n<p>Later on, we allocate new memory to m_data (and str.m_data).  So when we subsequently copy the data from str.m_data into m_data, we&#8217;re copying garbage, because str.m_data was never initialized.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Detecting and handling self-assignment<\/p>\n<p>Fortunately, we can detect when self-assignment occurs.  Here&#8217;s an updated implementation of our overloaded operator= for the MyString class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">MyString&amp; MyString::operator= (const MyString&amp; str)\r\n{\r\n\t\/\/ self-assignment check\r\n\tif (this == &amp;str)\r\n\t\treturn *this;\r\n\r\n\t\/\/ if data exists in the current string, delete it\r\n\tif (m_data) delete[] m_data;\r\n\r\n\tm_length = str.m_length;\r\n\tm_data = nullptr;\r\n\r\n\t\/\/ allocate a new array of the appropriate length\r\n\tif (m_length)\r\n\t\tm_data = new char[static_cast&lt;std::size_t&gt;(str.m_length)];\r\n\r\n\tstd::copy_n(str.m_data, m_length, m_data); \/\/ copies m_length elements of str.m_data into m_data\r\n\r\n\t\/\/ return the existing object so we can chain this operator\r\n\treturn *this;\r\n}<\/code><\/pre>\n<p>By checking if the address of our implicit object is the same as the address of the object being passed in as a parameter, we can have our assignment operator just return immediately without doing any other work.<\/p>\n<p>Because this is just a pointer comparison, it should be fast, and does not require operator== to be overloaded.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">When not to handle self-assignment<\/p>\n<p>Typically the self-assignment check is skipped for copy constructors.  Because the object being copy constructed is newly created, the only case where the newly created object can be equal to the object being copied is when you try to initialize a newly defined object with itself:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">someClass c { c };<\/code><\/pre>\n<p>In such cases, your compiler should warn you that <code>c<\/code> is an uninitialized variable.<\/p>\n<p>Second, the self-assignment check may be omitted in classes that can naturally handle self-assignment.  Consider this Fraction class assignment operator that has a self-assignment guard:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ A better implementation of operator=\r\nFraction&amp; Fraction::operator= (const Fraction&amp; fraction)\r\n{\r\n    \/\/ self-assignment guard\r\n    if (this == &amp;fraction)\r\n        return *this;\r\n\r\n    \/\/ do the copy\r\n    m_numerator = fraction.m_numerator; \/\/ can handle self-assignment\r\n    m_denominator = fraction.m_denominator; \/\/ can handle self-assignment\r\n\r\n    \/\/ return the existing object so we can chain this operator\r\n    return *this;\r\n}<\/code><\/pre>\n<p>If the self-assignment guard did not exist, this function would still operate correctly during a self-assignment (because all of the operations done by the function can handle self-assignment properly).<\/p>\n<p>Because self-assignment is a rare event, some prominent C++ gurus recommend omitting the self-assignment guard even in classes that would benefit from it.  We do not recommend this, as we believe it&#8217;s a better practice to code defensively and then selectively optimize later.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The copy and swap idiom<\/p>\n<p>A better way to handle self-assignment issues is via what&#8217;s called the copy and swap idiom.  There&#8217;s a great writeup of how this idiom works <a href=\"https:\/\/stackoverflow.com\/questions\/3279543\/what-is-the-copy-and-swap-idiom\">on Stack Overflow<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The implicit copy assignment operator<\/p>\n<p>Unlike other operators, the compiler will provide an implicit public copy assignment operator for your class if you do not provide a user-defined one.  This assignment operator does memberwise assignment (which is essentially the same as the memberwise initialization that default copy constructors do).<\/p>\n<p>Just like other constructors and operators, you can prevent assignments from being made by making your copy assignment operator private or using the delete keyword:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n\r\nclass Fraction\r\n{\r\nprivate:\r\n\tint m_numerator { 0 };\r\n\tint m_denominator { 1 };\r\n\r\npublic:\r\n    \/\/ Default constructor\r\n    Fraction(int numerator = 0, int denominator = 1)\r\n        : m_numerator { numerator }, m_denominator { denominator }\r\n    {\r\n        assert(denominator != 0);\r\n    }\r\n\r\n\t\/\/ Copy constructor\r\n\tFraction(const Fraction &amp;copy) = delete;\r\n\r\n\t\/\/ Overloaded assignment\r\n\tFraction&amp; operator= (const Fraction&amp; fraction) = delete; \/\/ no copies through assignment!\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1);\r\n        \r\n};\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)\r\n{\r\n\tout &lt;&lt; f1.m_numerator &lt;&lt; '\/' &lt;&lt; f1.m_denominator;\r\n\treturn out;\r\n}\r\n\r\nint main()\r\n{\r\n    Fraction fiveThirds { 5, 3 };\r\n    Fraction f;\r\n    f = fiveThirds; \/\/ compile error, operator= has been deleted\r\n    std::cout &lt;&lt; f;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Note that if your class has const members, the compiler will instead define the implicit <code>operator=<\/code> as deleted.  This is because const members can&#8217;t be assigned, so the compiler will assume your class should not be assignable.<\/p>\n<p>If you want a class with const members to be assignable (for all members that aren&#8217;t const), you will need to explicitly overload <code>operator=<\/code> and manually assign each non-const member.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/shallow-vs-deep-copying\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.13<\/span>Shallow vs. deep copying\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-typecasts\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.11<\/span>Overloading typecasts\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>The copy assignment operator (operator=) is used to copy values from one object to another already existing object. Related content As of C++11, C++ also supports &#8220;Move assignment&#8221;. We discuss move assignment in lesson . Copy assignment vs Copy constructor The purpose of the copy constructor and the copy assignment &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4176"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=4176"}],"version-history":[{"count":34,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4176\/revisions"}],"predecessor-version":[{"id":17379,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4176\/revisions\/17379"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=4176"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=4176"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=4176"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}