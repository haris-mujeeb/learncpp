{"id":12830,"date":"2022-04-08T13:50:59","date_gmt":"2022-04-08T20:50:59","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=12830"},"modified":"2025-01-04T23:26:42","modified_gmt":"2025-01-05T07:26:42","slug":"chapter-12-summary-and-quiz","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-12-summary-and-quiz\/","title":{"rendered":"12.x &#8212; Chapter 12 summary and quiz"},"content":{"rendered":"<p class=\"cpp-section\">Quick review<\/p>\n<p><strong>Compound data types<\/strong> (also called <strong>composite data type<\/strong>) are data types that can be constructed from fundamental data types (or other compound data types).<\/p>\n<p>The <strong>value category<\/strong> of an expression indicates whether an expression resolves to a value, a function, or an object of some kind.<\/p>\n<p>An <strong>lvalue<\/strong> is an expression that evaluates to a function or an object that has an identity.  An object or function with an <strong>identity<\/strong> has an identifier or an identifiable memory address.  Lvalues come in two subtypes: <strong>modifiable lvalues<\/strong> are lvalues that can be modified, and <strong>non-modifiable lvalues<\/strong> are lvalues whose values can&#8217;t be modified (typically because they are const or constexpr).<\/p>\n<p>An <strong>rvalue<\/strong> is an expression that is not an l-value.  This includes literals (except string literals) and the return values of functions or operators (when returned by value).<\/p>\n<p>A <strong>reference<\/strong> is an alias for an existing object.  Once a reference has been defined, any operation on the reference is applied to the object being referenced.  C++ contains two types of references: lvalue references and rvalue references.  An <strong>lvalue reference<\/strong> (commonly just called a <strong>reference<\/strong>) acts as an alias for an existing lvalue (such as a variable).  An <strong>lvalue reference variable<\/strong> is a variable that acts as a reference to an lvalue (usually another variable).<\/p>\n<p>When a reference is initialized with an object (or function), we say it is <strong>bound<\/strong> to that object (or function). The object (or function) being referenced is sometimes called the <strong>referent<\/strong>.<\/p>\n<p>Lvalue references can\u2019t be bound to non-modifiable lvalues or rvalues (otherwise you\u2019d be able to change those values through the reference, which would be a violation of their const-ness). For this reason, lvalue references are occasionally called <strong>lvalue references to non-const<\/strong> (sometimes shortened to <strong>non-const reference<\/strong>).<\/p>\n<p>Once initialized, a reference in C++ cannot be <strong>reseated<\/strong>, meaning it can not be changed to reference another object.<\/p>\n<p>When an object being referenced is destroyed before a reference to it, the reference is left referencing an object that no longer exists. Such a reference is called a <strong>dangling reference<\/strong>. Accessing a dangling reference leads to undefined behavior.<\/p>\n<p>By using the <code>const<\/code> keyword when declaring an lvalue reference, we tell an lvalue reference to treat the object it is referencing as const. Such a reference is called an <strong>lvalue reference to a const value<\/strong> (sometimes called a <strong>reference to const<\/strong> or a <strong>const reference<\/strong>).  Const references can bind to modifiable lvalues, non-modifiable lvalues, and rvalues.<\/p>\n<p>A <strong>temporary object<\/strong> (also sometimes called an <strong>unnamed object<\/strong> or <strong>anonymous object<\/strong>) is an object that is created for temporary use (and then destroyed) within a single expression.<\/p>\n<p>When using <strong>pass by reference<\/strong>, we declare a function parameter as a reference (or const reference) rather than as a normal variable. When the function is called, each reference parameter is bound to the appropriate argument. Because the reference acts as an alias for the argument, no copy of the argument is made.<\/p>\n<p>The <strong>address-of operator<\/strong> (&#038;) returns the memory address of its operand.   The <strong>dereference operator<\/strong> (*) returns the value at a given memory address as an lvalue.<\/p>\n<p>A <strong>pointer<\/strong> is an object that holds a <em>memory address<\/em> (typically of another variable) as its value.  This allows us to store the address of some other object to use later.  Like normal variables, pointers are not initialized by default. A pointer that has not been initialized is sometimes called a <strong>wild pointer<\/strong>.  A <strong>dangling pointer<\/strong> is a pointer that is holding the address of an object that is no longer valid (e.g. because it has been destroyed).<\/p>\n<p>Besides a memory address, there is one additional value that a pointer can hold: a null value.  A <strong>null value<\/strong> (often shortened to <strong>null<\/strong>) is a special value that means something has no value.  When a pointer is holding a null value, it means the pointer is not pointing at anything.  Such a pointer is called a <strong>null pointer<\/strong>.  The <strong>nullptr<\/strong> keyword represents a null pointer literal.  We can use <code>nullptr<\/code> to explicitly initialize or assign a pointer a null value.<\/p>\n<p>A pointer should either hold the address of a valid object, or be set to <code>nullptr<\/code>. That way we only need to test pointers for null, and can assume any non-null pointer is valid. <\/p>\n<p>A <strong>pointer to a const value<\/strong> (sometimes called a <strong>pointer to const<\/strong> for short) is a (non-const) pointer that points to a constant value.<\/p>\n<p>A <strong>const pointer<\/strong> is a pointer whose address can not be changed after initialization.<\/p>\n<p>A <strong>const pointer to a const value<\/strong> can not have its address changed, nor can the value it is pointing to be changed through the pointer.<\/p>\n<p>With <strong>pass by address<\/strong>, instead of providing an object as an argument, the caller provides an object\u2019s address (via a pointer). This pointer (holding the address of the object) is copied into a pointer parameter of the called function (which now also holds the address of the object). The function can then dereference that pointer to access the object whose address was passed.<\/p>\n<p><strong>Return by reference<\/strong> returns a reference that is bound to the object being returned, which avoids making a copy of the return value.  Using return by reference has one major caveat: the programmer must be sure that the object being referenced outlives the function returning the reference. Otherwise, the reference being returned will be left dangling (referencing an object that has been destroyed), and use of that reference will result in undefined behavior.  If a parameter is passed into a function by reference, it\u2019s safe to return that parameter by reference.<\/p>\n<p>If a function returns a reference, and that reference is used to initialize or assign to a non-reference variable, the return value will be copied (as if it had been returned by value).<\/p>\n<p>Type deduction for variables (via the <code>auto<\/code> keyword) will drop any reference or top-level const qualifiers from the deduced type.  These can be reapplied as part of the variable declaration if desired.<\/p>\n<p><strong>Return by address<\/strong> works almost identically to return by reference, except a pointer to an object is returned instead of a reference to an object.<\/p>\n<p><p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p><p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p><\/p>\n<p>For each of the following expressions on the right side of operator &lt;&lt;, indicate whether the expression is an lvalue or rvalue:<\/p>\n<p>a)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::cout &lt;&lt; 5;<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\nLiterals are rvalues, so <code>5<\/code> is an rvalue<\/div>\n<p>b)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int x { 5 };\r\nstd::cout &lt;&lt; x;<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\nThe expression <code>x<\/code> identifies variable <code>x<\/code>, so this expression is an lvalue.<\/div>\n<p>c)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int x { 5 };\r\nstd::cout &lt;&lt; x + 1;<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\nThe expression <code>x + 1<\/code> calculates a temporary value, so this expression is an rvalue.<\/div>\n<p>d)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int foo() { return 5; }\r\nstd::cout &lt;&lt; foo();<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\nThe return value of a function (when returned by value) is an rvalue.<\/div>\n<p>e)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int&amp; max(int &amp;x, int &amp;y) { return x &gt; y ? x : y; }\r\nint x { 5 };\r\nint y { 6 };\r\nstd::cout &lt;&lt; max(x, y);<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\nmax() returns an lvalue reference, which is an lvalue<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>What is the output of this program?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tint x{ 4 };\r\n\tint y{ 6 };\r\n\r\n\tint&amp; ref{ x };\r\n\t++ref;\r\n\tref = y;\r\n\t++ref;\r\n\r\n\tstd::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y;\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_5'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_5\" style=\"display:none\">\n<pre>\n7 6\r\n<\/pre>\n<p>Remember, references cannot be reseated, so <code>ref = y<\/code> does not make <code>ref<\/code> a reference to <code>y<\/code>.  It is equivalent to <code>x = y<\/code>.<\/p>\n<p>With comments explaining:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tint x{ 4 };\r\n\tint y{ 6 };\r\n\r\n\tint&amp; ref{ x }; \/\/ ref is now an alias for `x`\r\n\t++ref;   \/\/ x is now 5\r\n\tref = y; \/\/ x is now 6\r\n\t++ref;   \/\/ x is now 7\r\n\r\n\tstd::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y; \/\/ prints 7 6\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #3<\/p>\n<p>Name two reasons why we prefer to pass arguments by const reference instead of by non-const reference whenever possible.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_6'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_6\" style=\"display:none\">\n<ol start=\"1\">\n<li>A non-const reference parameter can be used to modify the value of the argument.  If we do not need this ability, it&#8217;s better to pass by const reference so that we don&#8217;t accidentally modify the argument.\n<\/li>\n<li>A non-const reference parameter can only accept a modifiable lvalue as an argument.  A const reference-parameter can accept a modifiable lvalue, a non-modifiable lvalue, or an rvalue as an argument.\n<\/li>\n<\/ol>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #4<\/p>\n<p>What is the difference between a const pointer and a pointer-to-const?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_7'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_7\" style=\"display:none\">\n<p>A const pointer is a pointer whose address can not be changed (it cannot be re-pointed at some other object).  However, the value of the object being pointed to can be changed.<br \/>\nA pointer-to-const is a pointer that is pointing at an object whose value can&#8217;t be changed through the pointer.  However, the pointer can be re-pointed at another object.\n<\/p><\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #5<\/p>\n<p>Write a function named <code>sort2<\/code> which allows the caller to pass 2 int variables as arguments.  When the function returns, the first argument should hold the lesser of the two values, and the second argument should hold the greater of the two values.<\/p>\n<p>Hint: The <code>std::swap()<\/code> function (in the &lt;algorithm&gt; header) can be used to swap the values of two variables.  e.g. <code>std::swap(x, y)<\/code> swaps the values of the variables <code>x<\/code> and <code>y<\/code>.<\/p>\n<p>The following code should run and print the values noted in the comments:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 7 };\r\n    int y { 5 };\r\n\r\n    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\\n'; \/\/ should print 7 5\r\n\r\n    sort2(x, y); \/\/ make sure sort works when values need to be swapped\r\n    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\\n'; \/\/ should print 5 7\r\n\r\n    sort2(x, y); \/\/ make sure sort works when values don't need to be swapped\r\n    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\\n'; \/\/ should print 5 7\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_8'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_8\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt; \/\/ for std::swap\r\n#include &lt;iostream&gt;\r\n\r\nvoid sort2(int&amp; lesser, int&amp; greater)\r\n{\r\n    \/\/ If the values are not sorted, we need to swap them so they are\r\n    if (lesser &gt; greater)\r\n        std::swap(lesser, greater);\r\n\r\n    \/\/ If we wrote our own swap instead, we could do so like this:\r\n    \/\/ int swap { lesser };\r\n    \/\/ lesser = greater;\r\n    \/\/ greater = swap;\r\n\r\n}\r\n\r\nint main()\r\n{\r\n    int x { 7 };\r\n    int y { 5 };\r\n\r\n    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\\n';\r\n\r\n    sort2(x, y); \/\/ make sure sort works when values need to be swapped\r\n    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\\n';\r\n\r\n    sort2(x, y); \/\/ make sure sort works when values don't need to be swapped\r\n    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-program-defined-user-defined-types\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.1<\/span>Introduction to program-defined (user-defined) types\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdoptional\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.15<\/span>std::optional\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Quick review (also called ) are data types that can be constructed from fundamental data types (or other compound data types). The of an expression indicates whether an expression resolves to a value, a function, or an object of some kind. An is an expression that evaluates to a function &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12830"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=12830"}],"version-history":[{"count":14,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12830\/revisions"}],"predecessor-version":[{"id":18085,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12830\/revisions\/18085"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=12830"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=12830"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=12830"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}