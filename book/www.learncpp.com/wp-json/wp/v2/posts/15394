{"id":15394,"date":"2023-09-11T14:28:02","date_gmt":"2023-09-11T21:28:02","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15394"},"modified":"2024-03-21T15:34:34","modified_gmt":"2024-03-21T22:34:34","slug":"passing-stdvector","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/passing-stdvector\/","title":{"rendered":"16.4 &#8212; Passing std::vector"},"content":{"rendered":"<p>An object of type <code>std::vector<\/code> can be passed to a function just like any other object.  That means if we pass a <code>std::vector<\/code> by value, an expensive copy will be made.  Therefore, we typically pass <code>std::vector<\/code> by (const) reference to avoid such copies.<\/p>\n<p>With a <code>std::vector<\/code>, the element type is part of the type information of the object.  Therefore, when we use a <code>std::vector<\/code> as a function parameter, we have to explicitly specify the element type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nvoid passByRef(const std::vector&lt;int&gt;&amp; arr) \/\/ we must explicitly specify &lt;int&gt; here\r\n{\r\n    std::cout &lt;&lt; arr[0] &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector primes{ 2, 3, 5, 7, 11 };\r\n    passByRef(primes);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Passing <code>std::vector<\/code> of different element types<\/p>\n<p>Because our <code>passByRef()<\/code> function expects a <code>std::vector&lt;int&gt;<\/code>, we are unable to pass vectors with different element types:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nvoid passByRef(const std::vector&lt;int&gt;&amp; arr)\r\n{\r\n    std::cout &lt;&lt; arr[0] &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector primes{ 2, 3, 5, 7, 11 };\r\n    passByRef(primes);  \/\/ ok: this is a std::vector&lt;int&gt;\r\n\r\n    std::vector dbl{ 1.1, 2.2, 3.3 };\r\n    passByRef(dbl); \/\/ compile error: std::vector&lt;double&gt; is not convertible to std::vector&lt;int&gt;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In C++17 or newer, you might try to use CTAD to solve this problem:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nvoid passByRef(const std::vector&amp; arr) \/\/ compile error: CTAD can't be used to infer function parameters\r\n{\r\n    std::cout &lt;&lt; arr[0] &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector primes{ 2, 3, 5, 7, 11 }; \/\/ okay: use CTAD to infer std::vector&lt;int&gt;\r\n    passByRef(primes);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Although CTAD will work to deduce an vector&#8217;s element type from initializers when it is defined, CTAD doesn&#8217;t (currently) work with function parameters.<\/p>\n<p>We&#8217;ve seen this kind of problem before, where we have overloaded functions that only differ by the parameter type.  This is a great place to make use of function templates!  We can create a function template that parameterizes the element type, and then C++ will use that function template to instantiate functions with actual types.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover function templates in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-templates\/\">11.6 -- Function templates<\/a>.\n<\/p><\/div>\n<p>We can create a function template that uses the same template parameter declaration:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nvoid passByRef(const std::vector&lt;T&gt;&amp; arr)\r\n{\r\n    std::cout &lt;&lt; arr[0] &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector primes{ 2, 3, 5, 7, 11 };\r\n    passByRef(primes); \/\/ ok: compiler will instantiate passByRef(const std::vector&lt;int&gt;&amp;)\r\n\r\n    std::vector dbl{ 1.1, 2.2, 3.3 };\r\n    passByRef(dbl);    \/\/ ok: compiler will instantiate passByRef(const std::vector&lt;double&gt;&amp;)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, we&#8217;ve created a single function template named <code>passByRef()<\/code> that has a parameter of type <code>const std::vector&lt;T&gt;&amp;<\/code>.   <code>T<\/code> is defined in the template parameter declaration on the previous line: <code>template &lt;typename T<\/code>.  <code>T<\/code> is a standard type template parameter that allows the caller to specify the element type.<\/p>\n<p>Therefore, when we call <code>passByRef(primes)<\/code> from <code>main()<\/code> (where <code>primes<\/code> is defined as a <code>std::vector&lt;int&gt;<\/code>), the compiler will instantiate and call <code>void passByRef(const std::vector&lt;int&gt;&amp; arr)<\/code>.<\/p>\n<p>When we call <code>passByRef(dbl)<\/code> from <code>main()<\/code> (where <code>dbl<\/code> is defined as a <code>std::vector&lt;double&gt;<\/code>), the compiler will instantiate and call <code>void passByRef(const std::vector&lt;double&gt;&amp; arr)<\/code>.<\/p>\n<p>Thus, we&#8217;ve created a single function template that can instantiate functions to handle <code>std::vector<\/code> arguments of any element type and length!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Passing a <code>std::vector<\/code> using a generic template or abbreviated function template<\/p>\n<p>We can also create a function template that will accept any type of object:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nvoid passByRef(const T&amp; arr) \/\/ will accept any type of object that has an overloaded operator[]\r\n{\r\n    std::cout &lt;&lt; arr[0] &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector primes{ 2, 3, 5, 7, 11 };\r\n    passByRef(primes); \/\/ ok: compiler will instantiate passByRef(const std::vector&lt;int&gt;&amp;)\r\n\r\n    std::vector dbl{ 1.1, 2.2, 3.3 };\r\n    passByRef(dbl);    \/\/ ok: compiler will instantiate passByRef(const std::vector&lt;double&gt;&amp;)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In C++20, we can use an abbreviated function template (via an <code>auto<\/code> parameter) to do the same thing:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nvoid passByRef(const auto&amp; arr) \/\/ abbreviated function template\r\n{\r\n    std::cout &lt;&lt; arr[0] &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector primes{ 2, 3, 5, 7, 11 };\r\n    passByRef(primes); \/\/ ok: compiler will instantiate passByRef(const std::vector&lt;int&gt;&amp;)\r\n\r\n    std::vector dbl{ 1.1, 2.2, 3.3 };\r\n    passByRef(dbl);    \/\/ ok: compiler will instantiate passByRef(const std::vector&lt;double&gt;&amp;)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Both of these will accept an argument of <em>any<\/em> type that will compile.  This can be desirable when writing functions that we might want to operate on more than just a <code>std::vector<\/code>.  For example, the above functions will also work on a <code>std::array<\/code>, a <code>std::string<\/code>, or some other type we may not have even considered.<\/p>\n<p>The potential downside of this method is that it may lead to bugs if the function is passed an object of a type that compiles but doesn&#8217;t make sense semantically.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Asserting on array length<\/p>\n<p>Consider the following template function, which is similar to the one presented above:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nvoid printElement3(const std::vector&lt;T&gt;&amp; arr)\r\n{\r\n    std::cout &lt;&lt; arr[3] &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector arr{ 9, 7, 5, 3, 1 };\r\n    printElement3(arr);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>While <code>printElement3(arr)<\/code> works fine in this case, there&#8217;s a potential bug waiting for a unwary programmer in this program.  See it?<\/p>\n<p>The above program prints the value of the array element with index 3.  This is fine as long as the array has a valid element with index 3.  However, the compiler will happily let you pass in arrays where index 3 is out of bounds.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nvoid printElement3(const std::vector&lt;T&gt;&amp; arr)\r\n{\r\n    std::cout &lt;&lt; arr[3] &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector arr{ 9, 7 }; \/\/ a 2-element array (valid indexes 0 and 1)\r\n    printElement3(arr);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This leads to undefined behavior.<\/p>\n<p>One option here is to assert on <code>arr.size()<\/code>, which will catch such errors when run in a debug build configuration.  Because <code>std::vector::size()<\/code> is a non-constexpr function, we can only do a runtime assert here.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>A better option is to avoid using <code>std::vector<\/code>in cases where you need to assert on array length.  Using a type that supports <code>constexpr<\/code> arrays (e.g. <code>std::array<\/code>) is probably a better choice, as you can <code>static_assert<\/code> on the length of a constexpr array.  We cover this in future lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/passing-and-returning-stdarray\/\">17.3 -- Passing and returning std::array<\/a>.\n<\/div>\n<p>The best option is to avoid writing functions that rely on the user passing in a vector with a minimum length in the first place.<\/p>\n<p><p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p><p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p><\/p>\n<p>Write a function that takes two parameters: a <code>std::vector<\/code> and an index.  If the index is out of bounds, print an error.  If the index is in bounds, print the value of the element.<\/p>\n<p>The following sample program should compile:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\n\/\/ Write your printElement function here\r\n\r\nint main()\r\n{\r\n    std::vector v1 { 0, 1, 2, 3, 4 };\r\n    printElement(v1, 2);\r\n    printElement(v1, 5);\r\n\r\n    std::vector v2 { 1.1, 2.2, 3.3 };\r\n    printElement(v2, 0);\r\n    printElement(v2, -1);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>and produce the following result:<\/p>\n<pre>\nThe element has value 2\r\nInvalid index\r\nThe element has value 1.1\r\nInvalid index\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\n\/\/ index needs to be an int, not a std::size_t, otherwise we won't be able to detect if the user passes in a negative index\r\ntemplate &lt;typename T&gt;\r\nvoid printElement(const std::vector&lt;T&gt;&amp; arr, int index)\r\n{\r\n    if (index &lt; 0 || index &gt;= static_cast&lt;int&gt;(arr.size())) \/\/ In C++20, could use std::ssize(arr) to avoid the cast\r\n        std::cout &lt;&lt; \"Invalid index\\n\";\r\n    else\r\n        std::cout &lt;&lt; \"The element has value \" &lt;&lt; arr[static_cast&lt;std::size_t&gt;(index)] &lt;&lt; '\\n';  \r\n}\r\n\r\nint main()\r\n{\r\n    std::vector v1 { 0, 1, 2, 3, 4 };\r\n    printElement(v1, 2);\r\n    printElement(v1, 5);\r\n\r\n    std::vector v2 { 1.1, 2.2, 3.3 };\r\n    printElement(v2, 0);\r\n    printElement(v2, -1);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/returning-stdvector-and-an-introduction-to-move-semantics\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">16.5<\/span>Returning std::vector, and an introduction to move semantics\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdvector-and-the-unsigned-length-and-subscript-problem\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">16.3<\/span>std::vector and the unsigned length and subscript problem\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>An object of type std::vector can be passed to a function just like any other object. That means if we pass a std::vector by value, an expensive copy will be made. Therefore, we typically pass std::vector by (const) reference to avoid such copies. With a std::vector, the element type is &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15394"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15394"}],"version-history":[{"count":12,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15394\/revisions"}],"predecessor-version":[{"id":16828,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15394\/revisions\/16828"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15394"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15394"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15394"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}