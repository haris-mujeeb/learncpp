{"id":143,"date":"2007-10-08T15:09:49","date_gmt":"2007-10-08T23:09:49","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/95-overloading-operators-and\/"},"modified":"2023-11-25T16:59:34","modified_gmt":"2023-11-26T00:59:34","slug":"overloading-unary-operators","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-unary-operators\/","title":{"rendered":"21.6 &#8212; Overloading unary operators +, -, and !"},"content":{"rendered":"<p><strong>Overloading unary operators<\/strong><\/p>\n<p>Unlike the operators you&#8217;ve seen so far, the positive (+), negative (-) and logical not (!) operators all are unary operators, which means they only operate on one operand.  Because they only operate on the object they are applied to, typically unary operator overloads are implemented as member functions.  All three operators are implemented in an identical manner.<\/p>\n<p>Let&#8217;s take a look at how we&#8217;d implement operator- on the Cents class we used in a previous example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Cents\r\n{\r\nprivate:\r\n    int m_cents {};\r\n \r\npublic:\r\n    Cents(int cents): m_cents{cents} {}\r\n \r\n    \/\/ Overload -Cents as a member function\r\n    Cents operator-() const;\r\n\r\n    int getCents() const { return m_cents; }\r\n};\r\n \r\n\/\/ note: this function is a member function!\r\nCents Cents::operator-() const\r\n{\r\n    return -m_cents; \/\/ since return type is a Cents, this does an implicit conversion from int to Cents using the Cents(int) constructor\r\n}\r\n\r\nint main()\r\n{\r\n    const Cents nickle{ 5 };\r\n    std::cout &lt;&lt; \"A nickle of debt is worth \" &lt;&lt; (-nickle).getCents() &lt;&lt; \" cents\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This should be straightforward.  Our overloaded negative operator (-) is a unary operator implemented as a member function, so it takes no parameters (it operates on the *this object).  It returns a Cents object that is the negation of the original Cents value.  Because operator- does not modify the Cents object, we can (and should) make it a const function (so it can be called on const Cents objects).<\/p>\n<p>Note that there&#8217;s no confusion between the negative operator- and the minus operator- since they have a different number of parameters.<\/p>\n<p>Here&#8217;s another example.  The ! operator is the logical negation operator -- if an expression evaluates to &#8220;true&#8221;, operator! will return false, and vice-versa.  We commonly see this applied to boolean variables to test whether they are true or not:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">if (!isHappy)\r\n    std::cout &lt;&lt; \"I am not happy!\\n\";\r\nelse\r\n    std::cout &lt;&lt; \"I am so happy!\\n\";<\/code><\/pre>\n<p>For integers, 0 evaluates to false, and anything else to true, so operator! as applied to integers will return true for an integer value of 0 and false otherwise.<\/p>\n<p>Extending the concept, we can say that operator! should evaluate to true if the state of the object is &#8220;false&#8221;, &#8220;zero&#8221;, or whatever the default initialization state is.<\/p>\n<p>The following example shows an overload of both operator- and operator! for a user-defined Point class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Point\r\n{\r\nprivate:\r\n    double m_x {};\r\n    double m_y {};\r\n    double m_z {};\r\n \r\npublic:\r\n    Point(double x=0.0, double y=0.0, double z=0.0):\r\n        m_x{x}, m_y{y}, m_z{z}\r\n    {\r\n    }\r\n \r\n    \/\/ Convert a Point into its negative equivalent\r\n    Point operator- () const;\r\n\r\n    \/\/ Return true if the point is set at the origin\r\n    bool operator! () const;\r\n \r\n    double getX() const { return m_x; }\r\n    double getY() const { return m_y; }\r\n    double getZ() const { return m_z; }\r\n};\r\n\r\n\/\/ Convert a Point into its negative equivalent \r\nPoint Point::operator- () const\r\n{\r\n    return { -m_x, -m_y, -m_z };\r\n}\r\n\r\n\/\/ Return true if the point is set at the origin, false otherwise\r\nbool Point::operator! () const\r\n{\r\n    return (m_x == 0.0 &amp;&amp; m_y == 0.0 &amp;&amp; m_z == 0.0);\r\n}\r\n\r\nint main()\r\n{\r\n    Point point{}; \/\/ use default constructor to set to (0.0, 0.0, 0.0)\r\n\r\n    if (!point)\r\n        std::cout &lt;&lt; \"point is set at the origin.\\n\";\r\n    else\r\n        std::cout &lt;&lt; \"point is not set at the origin.\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The overloaded operator! for this class returns the Boolean value &#8220;true&#8221; if the Point is set to the default value at coordinate (0.0, 0.0, 0.0).  Thus, the above code produces the result:<\/p>\n<pre>\r\npoint is set at the origin.\r\n<\/pre>\n<p><strong>Quiz time<\/strong><\/p>\n<ol start=\"1\">\n<li>Implement overloaded unary <code>operator+<\/code> for the Point class.  Unary <code>operator+<\/code> just returns its operand (it does not make negative values positive).\n<\/li>\n<\/ol>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>Here&#8217;s the obvious solution:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">Point Point::operator+ () const\r\n{\r\n    return { m_x, m_y, m_z };\r\n}<\/code><\/pre>\n<p>But because the Point we&#8217;re returning is exactly the same one we&#8217;re operating on, the following also works:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">Point Point::operator+ () const\r\n{\r\n    return *this;\r\n}<\/code><\/pre>\n<p>Note that we&#8217;re returning a copy by value rather than a const reference here.  This is because users of this function will probably expect the returned object to be modifiable.<\/p>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-the-comparison-operators\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.7<\/span>Overloading the comparison operators\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-operators-using-member-functions\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.5<\/span>Overloading operators using member functions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Overloading unary operators Unlike the operators you&#8217;ve seen so far, the positive (+), negative (-) and logical not (!) operators all are unary operators, which means they only operate on one operand. Because they only operate on the object they are applied to, typically unary operator overloads are implemented as &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/143"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=143"}],"version-history":[{"count":25,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/143\/revisions"}],"predecessor-version":[{"id":16137,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/143\/revisions\/16137"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=143"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=143"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=143"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}