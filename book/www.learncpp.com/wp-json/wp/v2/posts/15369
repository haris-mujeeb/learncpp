{"id":15369,"date":"2023-09-11T13:05:39","date_gmt":"2023-09-11T20:05:39","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15369"},"modified":"2024-04-30T21:18:02","modified_gmt":"2024-05-01T04:18:02","slug":"friend-classes-and-friend-member-functions","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/friend-classes-and-friend-member-functions\/","title":{"rendered":"15.9 &#8212; Friend classes and friend member functions"},"content":{"rendered":"<p class=\"cpp-section\">Friend classes<\/p>\n<p>A <strong>friend class<\/strong> is a class that can access the private and protected members of another class.<\/p>\n<p>Here is an example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Storage\r\n{\r\nprivate:\r\n    int m_nValue {};\r\n    double m_dValue {};\r\npublic:\r\n    Storage(int nValue, double dValue)\r\n       : m_nValue { nValue }, m_dValue { dValue }\r\n    { }\r\n\r\n    \/\/ Make the Display class a friend of Storage\r\n    friend class Display;\r\n};\r\n\r\nclass Display\r\n{\r\nprivate:\r\n    bool m_displayIntFirst {};\r\n\r\npublic:\r\n    Display(bool displayIntFirst)\r\n         : m_displayIntFirst { displayIntFirst }\r\n    {\r\n    }\r\n\r\n    \/\/ Because Display is a friend of Storage, Display members can access the private members of Storage\r\n    void displayStorage(const Storage&amp; storage)\r\n    {\r\n        if (m_displayIntFirst)\r\n            std::cout &lt;&lt; storage.m_nValue &lt;&lt; ' ' &lt;&lt; storage.m_dValue &lt;&lt; '\\n';\r\n        else \/\/ display double first\r\n            std::cout &lt;&lt; storage.m_dValue &lt;&lt; ' ' &lt;&lt; storage.m_nValue &lt;&lt; '\\n';\r\n    }\r\n\r\n    void setDisplayIntFirst(bool b)\r\n    {\r\n         m_displayIntFirst = b;\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Storage storage { 5, 6.7 };\r\n    Display display { false };\r\n\r\n    display.displayStorage(storage);\r\n\r\n    display.setDisplayIntFirst(true);\r\n    display.displayStorage(storage);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because the <code>Display<\/code> class is a friend of <code>Storage<\/code>, <code>Display<\/code> members can access the private members of any <code>Storage<\/code> object they have access to.<\/p>\n<p>This program produces the following result:<\/p>\n<pre>\n6.7 5\r\n5 6.7\r\n<\/pre>\n<p>A few additional notes on friend classes.<\/p>\n<p>First, even though <code>Display<\/code> is a friend of <code>Storage<\/code>, <code>Display<\/code> has no access to the <code>*this<\/code> pointer of <code>Storage<\/code> objects (because <code>*this<\/code> is actually a function parameter).<\/p>\n<p>Second, friendship is not reciprocal.  Just because <code>Display<\/code> is a friend of <code>Storage<\/code> does not mean <code>Storage<\/code> is also a friend of <code>Display<\/code>.  If you want two classes to be friends of each other, both must declare the other as a friend.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>Sorry if this one hits a little close to home!\n<\/p><\/div>\n<p>Class friendship is also not transitive.  If class A is a friend of B, and B is a friend of C, that does not mean A is a friend of C.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Nor is friendship inherited.  If class A makes B a friend, classes derived from B are not friends of A.\n<\/p><\/div>\n<p>A friend class declaration acts as a forward declaration for the class being friended.  This means we do not need to forward declare the class being friended before friending it.  In the example above, <code>friend class Display<\/code> acts as both a forward declaration of <code>Display<\/code> and a friend declaration.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Friend member functions<\/p>\n<p>Instead of making an entire class a friend, you can make a single member function a friend.  This is done similarly to making a non-member function a friend, except the name of the member function is used instead.<\/p>\n<p>However, in actuality, this can be a little trickier than expected.  Let&#8217;s convert the previous example to make <code>Display::displayStorage<\/code> a friend member function.  You might try something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Display; \/\/ forward declaration for class Display\r\n\r\nclass Storage\r\n{\r\nprivate:\r\n\tint m_nValue {};\r\n\tdouble m_dValue {};\r\npublic:\r\n\tStorage(int nValue, double dValue)\r\n\t\t: m_nValue { nValue }, m_dValue { dValue }\r\n\t{\r\n\t}\r\n\r\n\t\/\/ Make the Display::displayStorage member function a friend of the Storage class\r\n\tfriend void Display::displayStorage(const Storage&amp; storage); \/\/ error: Storage hasn't seen the full definition of class Display\r\n};\r\n\r\nclass Display\r\n{\r\nprivate:\r\n\tbool m_displayIntFirst {};\r\n\r\npublic:\r\n\tDisplay(bool displayIntFirst)\r\n\t\t: m_displayIntFirst { displayIntFirst }\r\n\t{\r\n\t}\r\n\r\n\tvoid displayStorage(const Storage&amp; storage)\r\n\t{\r\n\t\tif (m_displayIntFirst)\r\n\t\t\tstd::cout &lt;&lt; storage.m_nValue &lt;&lt; ' ' &lt;&lt; storage.m_dValue &lt;&lt; '\\n';\r\n\t\telse \/\/ display double first\r\n\t\t\tstd::cout &lt;&lt; storage.m_dValue &lt;&lt; ' ' &lt;&lt; storage.m_nValue &lt;&lt; '\\n';\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n    Storage storage { 5, 6.7 };\r\n    Display display { false };\r\n    display.displayStorage(storage);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, it turns out this won&#8217;t work.  In order to make a single member function a friend, the compiler has to have seen the full definition for the class of the friend member function (not just a forward declaration).  Since class <code>Storage<\/code> hasn&#8217;t seen the full definition for class <code>Display<\/code> yet, the compiler will error at the point where we try to make the member function a friend.<\/p>\n<p>Fortunately, this is easily resolved by moving the definition of class <code>Display<\/code> before the definition of class <code>Storage<\/code> (either in the same file, or by moving the definition of <code>Display<\/code> to a header file and #including it before <code>Storage<\/code> is defined).<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Display\r\n{\r\nprivate:\r\n\tbool m_displayIntFirst {};\r\n\r\npublic:\r\n\tDisplay(bool displayIntFirst)\r\n\t\t: m_displayIntFirst { displayIntFirst }\r\n\t{\r\n\t}\r\n\r\n\tvoid displayStorage(const Storage&amp; storage) \/\/ compile error: compiler doesn't know what a Storage is\r\n\t{\r\n\t\tif (m_displayIntFirst)\r\n\t\t\tstd::cout &lt;&lt; storage.m_nValue &lt;&lt; ' ' &lt;&lt; storage.m_dValue &lt;&lt; '\\n';\r\n\t\telse \/\/ display double first\r\n\t\t\tstd::cout &lt;&lt; storage.m_dValue &lt;&lt; ' ' &lt;&lt; storage.m_nValue &lt;&lt; '\\n';\r\n\t}\r\n};\r\n\r\nclass Storage\r\n{\r\nprivate:\r\n\tint m_nValue {};\r\n\tdouble m_dValue {};\r\npublic:\r\n\tStorage(int nValue, double dValue)\r\n\t\t: m_nValue { nValue }, m_dValue { dValue }\r\n\t{\r\n\t}\r\n\r\n\t\/\/ Make the Display::displayStorage member function a friend of the Storage class\r\n\tfriend void Display::displayStorage(const Storage&amp; storage); \/\/ okay now\r\n};\r\n\r\nint main()\r\n{\r\n    Storage storage { 5, 6.7 };\r\n    Display display { false };\r\n    display.displayStorage(storage);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, we now have another problem.  Because member function <code>Display::displayStorage()<\/code> uses <code>Storage<\/code> as a reference parameter, and we just moved the definition of <code>Storage<\/code> below the definition of <code>Display<\/code>, the compiler will complain it doesn&#8217;t know what a <code>Storage<\/code> is.  We can&#8217;t fix this one by rearranging the definition order, because then we&#8217;ll undo our previous fix.<\/p>\n<p>Fortunately, this is also fixable in a couple of simple steps.  First, we can add <code>class Storage<\/code> as a forward declaration so the compiler will be okay with a reference to <code>Storage<\/code> before it has seen the full definition of the class.  <\/p>\n<p>Second, we can move the definition of <code>Display::displayStorage()<\/code> out of the class, after the full definition of <code>Storage<\/code> class.<\/p>\n<p>Here&#8217;s what this looks like:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Storage; \/\/ forward declaration for class Storage\r\n\r\nclass Display\r\n{\r\nprivate:\r\n\tbool m_displayIntFirst {};\r\n\r\npublic:\r\n\tDisplay(bool displayIntFirst)\r\n\t\t: m_displayIntFirst { displayIntFirst }\r\n\t{\r\n\t}\r\n\r\n\tvoid displayStorage(const Storage&amp; storage); \/\/ forward declaration for Storage needed for reference here\r\n};\r\n\r\nclass Storage \/\/ full definition of Storage class\r\n{\r\nprivate:\r\n\tint m_nValue {};\r\n\tdouble m_dValue {};\r\npublic:\r\n\tStorage(int nValue, double dValue)\r\n\t\t: m_nValue { nValue }, m_dValue { dValue }\r\n\t{\r\n\t}\r\n\r\n\t\/\/ Make the Display::displayStorage member function a friend of the Storage class\r\n\t\/\/ Requires seeing the full definition of class Display (as displayStorage is a member)\r\n\tfriend void Display::displayStorage(const Storage&amp; storage);\r\n};\r\n\r\n\/\/ Now we can define Display::displayStorage\r\n\/\/ Requires seeing the full definition of class Storage (as we access Storage members)\r\nvoid Display::displayStorage(const Storage&amp; storage)\r\n{\r\n\tif (m_displayIntFirst)\r\n\t\tstd::cout &lt;&lt; storage.m_nValue &lt;&lt; ' ' &lt;&lt; storage.m_dValue &lt;&lt; '\\n';\r\n\telse \/\/ display double first\r\n\t\tstd::cout &lt;&lt; storage.m_dValue &lt;&lt; ' ' &lt;&lt; storage.m_nValue &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    Storage storage { 5, 6.7 };\r\n    Display display { false };\r\n    display.displayStorage(storage);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Now everything will compile properly: the forward declaration of <code>class Storage<\/code> is enough to satisfy the declaration of <code>Display::displayStorage()<\/code> inside the <code>Display<\/code> class.  The full definition of <code>Display<\/code> satisfies declaring <code>Display::displayStorage()<\/code> as a friend of <code>Storage<\/code>.  And the full definition of class <code>Storage<\/code> is enough to satisfy the definition of member function <code>Display::displayStorage()<\/code>.<\/p>\n<p>If that&#8217;s a bit confusing, see the comments in the program above.  The key points are that a class forward declaration satisfies references to the class.  However, accessing members of a class requires that the compiler have seen the full class definition.<\/p>\n<p>If this seems like a pain -- it is.  Fortunately, this dance is only necessary because we&#8217;re trying to do everything in a single file.  A better solution is to put each class definition in a separate header file, with the member function definitions in corresponding .cpp files.  That way, all of the class definitions would be available in the .cpp files, and no rearranging of classes or functions is necessary!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>In geometry, a point is a position in space.  We can define a point in 3d-space as the set of coordinates x, y, and z.  For example, <code>Point { 2.0, 1.0, 0.0 }<\/code> would be the point at coordinate space x=2.0, y=1.0, and z=0.0.<\/p>\n<p>In physics, a vector is a quantity that has a magnitude (length) and a direction (but no position).  We can define a vector in 3d-space as an x, y, and z value representing the direction of the vector along the x, y, and z axis (the length can be derived from these).  For example, <code>Vector { 2.0, 0.0, 0.0 }<\/code> would be a vector representing a direction along the positive x-axis (only), with length 2.0.<\/p>\n<p>A <code>Vector<\/code> can be applied to a <code>Point<\/code> to move the <code>Point<\/code> to a new position.  This is done by adding the vector&#8217;s direction to the point&#8217;s position to yield a new position.  For example, <code>Point { 2.0, 1.0, 0.0 }<\/code> + <code>Vector { 2.0, 0.0, 0.0 }<\/code> would yield <code>Point { 4.0, 1.0, 0.0 }<\/code>.<\/p>\n<p>Such points and vectors are often used in computer graphics (with points representing the vertices of a shape, and vectors represent movement of the shape).<\/p>\n<p>Given the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Vector3d\r\n{\r\nprivate:\r\n\tdouble m_x{};\r\n\tdouble m_y{};\r\n\tdouble m_z{};\r\n\r\npublic:\r\n\tVector3d(double x, double y, double z)\r\n\t\t: m_x{x}, m_y{y}, m_z{z}\r\n\t{\r\n\t}\r\n\r\n\tvoid print() const\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Vector(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \", \" &lt;&lt; m_z &lt;&lt; \")\\n\";\r\n\t}\r\n};\r\n\r\nclass Point3d\r\n{\r\nprivate:\r\n\tdouble m_x{};\r\n\tdouble m_y{};\r\n\tdouble m_z{};\r\n\r\npublic:\r\n\tPoint3d(double x, double y, double z)\r\n\t\t: m_x{x}, m_y{y}, m_z{z}\r\n\t{ }\r\n\r\n\tvoid print() const\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Point(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \", \" &lt;&lt; m_z &lt;&lt; \")\\n\";\r\n\t}\r\n\r\n\tvoid moveByVector(const Vector3d&amp; v)\r\n\t{\r\n\t\t\/\/ implement this function as a friend of class Vector3d\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tPoint3d p { 1.0, 2.0, 3.0 };\r\n\tVector3d v { 2.0, 2.0, -3.0 };\r\n\r\n\tp.print();\r\n\tp.moveByVector(v);\r\n\tp.print();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #1<\/p>\n<p>Make <code>Point3d<\/code> a friend class of <code>Vector3d<\/code>, and implement function <code>Point3d::moveByVector()<\/code>.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Vector3d\r\n{\r\nprivate:\r\n\tdouble m_x{};\r\n\tdouble m_y{};\r\n\tdouble m_z{};\r\n\r\npublic:\r\n\tVector3d(double x, double y, double z)\r\n\t\t: m_x{x}, m_y{y}, m_z{z}\r\n\t{\r\n\r\n\t}\r\n\r\n\tvoid print() const\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Vector(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \", \" &lt;&lt; m_z &lt;&lt; \")\\n\";\r\n\t}\r\n\r\n\tfriend class Point3d; \/\/ Point3d is now a friend of class Vector3d\r\n};\r\n\r\n\r\nclass Point3d\r\n{\r\nprivate:\r\n\tdouble m_x{};\r\n\tdouble m_y{};\r\n\tdouble m_z{};\r\n\r\npublic:\r\n\tPoint3d(double x, double y, double z)\r\n\t\t: m_x{x}, m_y{y}, m_z{z}\r\n\t{\r\n\r\n\t}\r\n\r\n\tvoid print() const\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Point(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \", \" &lt;&lt; m_z &lt;&lt; \")\\n\";\r\n\t}\r\n\r\n\r\n\tvoid moveByVector(const Vector3d&amp; v)\r\n\t{\r\n\t\tm_x += v.m_x;\r\n\t\tm_y += v.m_y;\r\n\t\tm_z += v.m_z;\r\n\t}\r\n};\r\n\r\n\r\nint main()\r\n{\r\n\tPoint3d p { 1.0, 2.0, 3.0 };\r\n\tVector3d v { 2.0, 2.0, -3.0 };\r\n\r\n\tp.print();\r\n\tp.moveByVector(v);\r\n\tp.print();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #2<\/p>\n<p>Instead of making class <code>Point3d<\/code> a friend of class <code>Vector3d<\/code>, make member function <code>Point3d::moveByVector<\/code> a friend of class <code>Vector3d<\/code>.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Vector3d; \/\/ first, we need to tell the compiler that a class named Vector3d exists\r\n\r\nclass Point3d\r\n{\r\nprivate:\r\n\tdouble m_x{};\r\n\tdouble m_y{};\r\n\tdouble m_z{};\r\n\r\npublic:\r\n\tPoint3d(double x, double y, double z)\r\n\t\t: m_x{x}, m_y{y}, m_z{z}\r\n\t{\r\n\r\n\t}\r\n\r\n\tvoid print() const\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Point(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \", \" &lt;&lt; m_z &lt;&lt; \")\\n\";\r\n\t}\r\n\r\n\tvoid moveByVector(const Vector3d&amp; v); \/\/ so we can use Vector3d here\r\n       \/\/ note: we can't define this function here, because Vector3d hasn't been defined yet (just forward declared)\r\n};\r\n\r\nclass Vector3d\r\n{\r\nprivate:\r\n\tdouble m_x{};\r\n\tdouble m_y{};\r\n\tdouble m_z{};\r\n\r\npublic:\r\n\tVector3d(double x, double y, double z)\r\n\t\t: m_x{x}, m_y{y}, m_z{z}\r\n\t{\r\n\r\n\t}\r\n\r\n\tvoid print() const\r\n\t{\r\n\t\tstd::cout &lt;&lt; \"Vector(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \", \" &lt;&lt; m_z &lt;&lt; \")\\n\";\r\n\t}\r\n\r\n\tfriend void Point3d::moveByVector(const Vector3d&amp; v); \/\/ Point3d::moveByVector() is now a friend of class Vector3d\r\n};\r\n\r\n\/\/ Now that Vector3d has been defined, we can define the function Point3d::moveByVector()\r\nvoid Point3d::moveByVector(const Vector3d&amp; v)\r\n{\r\n\tm_x += v.m_x;\r\n\tm_y += v.m_y;\r\n\tm_z += v.m_z;\r\n}\r\n\r\nint main()\r\n{\r\n\tPoint3d p { 1.0, 2.0, 3.0 };\r\n\tVector3d v { 2.0, 2.0, -3.0 };\r\n\r\n\tp.print();\r\n\tp.moveByVector(v);\r\n\tp.print();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #3<\/p>\n<p>Reimplement the solution to the prior step using 5 separate files: Point3d.h, Point3d.cpp, Vector3d.h, Vector3d.cpp, and main.cpp.<\/p>\n<p>Thanks to reader Shiva for the suggestion and solution.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<p>Point3d.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Header file that defines the Point3d class\r\n\r\n#ifndef POINT3D_H\r\n#define POINT3D_H\r\n\r\nclass Vector3d; \/\/ forward declaration for class Vector3d for function moveByVector()\r\n\r\nclass Point3d\r\n{\r\n    private:\r\n        double m_x{};\r\n        double m_y{};\r\n        double m_z{};\r\n\r\n    public:\r\n        Point3d(double x, double y, double z);\r\n\r\n        void print() const;\r\n        void moveByVector(const Vector3d&amp; v); \/\/ forward declaration above needed for this line\r\n};\r\n\r\n#endif<\/code><\/pre>\n<p>Point3d.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Member functions of the Point3d class defined here\r\n\r\n#include \"Point3d.h\" \/\/ Point3d class defined here\r\n#include \"Vector3d.h\" \/\/ for the parameter of the function moveByVector()\r\n\r\n#include &lt;iostream&gt;\r\n\r\nPoint3d::Point3d(double x, double y, double z)\r\n  : m_x{x}, m_y{y}, m_z{z}\r\n{}\r\n\r\nvoid Point3d::moveByVector(const Vector3d&amp; v)\r\n{\r\n    \/\/ Add the vector components to the corresponding point coordinates\r\n    m_x += v.m_x;\r\n    m_y += v.m_y;\r\n    m_z += v.m_z;\r\n}\r\n\r\nvoid Point3d::print() const\r\n{\r\n    std::cout &lt;&lt; \"Point(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \", \" &lt;&lt; m_z &lt;&lt; \")\\n\";\r\n}<\/code><\/pre>\n<p>Vector3d.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Header file that defines the Vector3d class\r\n\r\n#ifndef VECTOR3D_H\r\n#define VECTOR3D_H\r\n\r\n#include \"Point3d.h\" \/\/ for declaring Point3d::moveByVector() as a friend\r\n\r\nclass Vector3d\r\n{\r\n    private:\r\n        double m_x{};\r\n        double m_y{};\r\n        double m_z{};\r\n\r\n    public:\r\n        Vector3d(double x, double y, double z);\r\n\r\n        void print() const;\r\n        friend void Point3d::moveByVector(const Vector3d&amp; v);\r\n};\r\n\r\n#endif<\/code><\/pre>\n<p>Vector3d.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Member functions of the Vector3d class defined here\r\n\r\n#include \"Vector3d.h\" \/\/ Vector3d class defined in this file\r\n\r\n#include &lt;iostream&gt;\r\n\r\nVector3d::Vector3d(double x, double y, double z)\r\n  : m_x{x}, m_y{y}, m_z{z}\r\n{}\r\n\r\nvoid Vector3d::print() const\r\n{\r\n    std::cout &lt;&lt; \"Vector(\" &lt;&lt; m_x &lt;&lt; \" , \" &lt;&lt; m_y &lt;&lt; \" , \" &lt;&lt; m_z &lt;&lt; \")\\n\";\r\n}<\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"Vector3d.h\"\r\n#include \"Point3d.h\"\r\n\r\nint main()\r\n{\r\n    Point3d p { 1.0, 2.0, 3.0 };\r\n    Vector3d v { 2.0, 2.0, -3.0 };\r\n\r\n    p.print();\r\n    p.moveByVector(v);\r\n    p.print();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/ref-qualifiers\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">15.10<\/span>Ref qualifiers\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/friend-non-member-functions\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">15.8<\/span>Friend non-member functions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Friend classes A friend class is a class that can access the private and protected members of another class. Here is an example: #include &lt;iostream&gt; class Storage { private: int m_nValue {}; double m_dValue {}; public: Storage(int nValue, double dValue) : m_nValue { nValue }, m_dValue { dValue } { &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15369"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15369"}],"version-history":[{"count":8,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15369\/revisions"}],"predecessor-version":[{"id":16998,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15369\/revisions\/16998"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15369"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15369"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15369"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}