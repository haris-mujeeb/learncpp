{"id":111,"date":"2007-07-25T16:14:13","date_gmt":"2007-07-26T00:14:13","guid":{"rendered":"http:\/\/www.learncpp.com\/uncategorized\/74-passing-arguments-by-address\/"},"modified":"2025-02-13T13:38:07","modified_gmt":"2025-02-13T21:38:07","slug":"pass-by-address","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/pass-by-address\/","title":{"rendered":"12.10 &#8212; Pass by address"},"content":{"rendered":"<p>In prior lessons, we&#8217;ve covered two different ways to pass an argument to a function: pass by value (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-function-parameters-and-arguments\/\">2.4 -- Introduction to function parameters and arguments<\/a>) and pass by reference (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pass-by-lvalue-reference\/\">12.5 -- Pass by lvalue reference<\/a>). <\/p>\n<p>Here&#8217;s a sample program that shows a <code>std::string<\/code> object being passed by value and by reference:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nvoid printByValue(std::string val) \/\/ The function parameter is a copy of str\r\n{\r\n    std::cout &lt;&lt; val &lt;&lt; '\\n'; \/\/ print the value via the copy\r\n}\r\n\r\nvoid printByReference(const std::string&amp; ref) \/\/ The function parameter is a reference that binds to str\r\n{\r\n    std::cout &lt;&lt; ref &lt;&lt; '\\n'; \/\/ print the value via the reference\r\n}\r\n\r\nint main()\r\n{\r\n    std::string str{ \"Hello, world!\" };\r\n    \r\n    printByValue(str); \/\/ pass str by value, makes a copy of str\r\n    printByReference(str); \/\/ pass str by reference, does not make a copy of str\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When we pass argument <code>str<\/code> by value, the function parameter <code>val<\/code> receives a copy of the argument.  Because the parameter is a copy of the argument, any changes to the <code>val<\/code> are made to the copy, not the original argument.<\/p>\n<p>When we pass argument <code>str<\/code> by reference, the reference parameter <code>ref<\/code> is bound to the actual argument.  This avoids making a copy of the argument.  Because our reference parameter is const, we are not allowed to change <code>ref<\/code>.  But if <code>ref<\/code> were non-const, any changes we made to <code>ref<\/code> would change <code>str<\/code>.<\/p>\n<p>In both cases, the caller is providing the actual object (<code>str<\/code>) to be passed as an argument to the function call.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Pass by address<\/p>\n<p>C++ provides a third way to pass values to a function, called pass by address.  With <strong>pass by address<\/strong>, instead of providing an object as an argument, the caller provides an object&#8217;s <em>address<\/em> (via a pointer).  This pointer (holding the address of the object) is copied into a pointer parameter of the called function (which now also holds the address of the object).  The function can then dereference that pointer to access the object whose address was passed.<\/p>\n<p>Here&#8217;s a version of the above program that adds a pass by address variant:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nvoid printByValue(std::string val) \/\/ The function parameter is a copy of str\r\n{\r\n    std::cout &lt;&lt; val &lt;&lt; '\\n'; \/\/ print the value via the copy\r\n}\r\n\r\nvoid printByReference(const std::string&amp; ref) \/\/ The function parameter is a reference that binds to str\r\n{\r\n    std::cout &lt;&lt; ref &lt;&lt; '\\n'; \/\/ print the value via the reference\r\n}\r\n\r\nvoid printByAddress(const std::string* ptr) \/\/ The function parameter is a pointer that holds the address of str\r\n{\r\n    std::cout &lt;&lt; *ptr &lt;&lt; '\\n'; \/\/ print the value via the dereferenced pointer\r\n}\r\n\r\nint main()\r\n{\r\n    std::string str{ \"Hello, world!\" };\r\n    \r\n    printByValue(str); \/\/ pass str by value, makes a copy of str\r\n    printByReference(str); \/\/ pass str by reference, does not make a copy of str\r\n    printByAddress(&amp;str); \/\/ pass str by address, does not make a copy of str\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Note how similar all three of these versions are.  Let&#8217;s explore the pass by address version in more detail.<\/p>\n<p>First, because we want our <code>printByAddress()<\/code> function to use pass by address, we&#8217;ve made our function parameter a pointer named <code>ptr<\/code>.  Since <code>printByAddress()<\/code> will use <code>ptr<\/code> in a read-only manner, <code>ptr<\/code> is a pointer to a const value. <\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void printByAddress(const std::string* ptr)\r\n{\r\n    std::cout &lt;&lt; *ptr &lt;&lt; '\\n'; \/\/ print the value via the dereferenced pointer\r\n}<\/code><\/pre>\n<p>Inside the <code>printByAddress()<\/code> function, we dereference <code>ptr<\/code> parameter to access the value of the object being pointed to.<\/p>\n<p>Second, when the function is called, we can&#8217;t just pass in the <code>str<\/code> object -- we need to pass in the address of <code>str<\/code>.  The easiest way to do that is to use the address-of operator (&#038;) to get a pointer holding the address of <code>str<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">printByAddress(&amp;str); \/\/ use address-of operator (&amp;) to get pointer holding address of str<\/code><\/pre>\n<p>When this call is executed, <code>&amp;str<\/code> will create a pointer holding the address of <code>str<\/code>.  This address is then copied into function parameter <code>ptr<\/code> as part of the function call.  Because <code>ptr<\/code> now holds the address of <code>str<\/code>, when the function dereferences <code>ptr<\/code>, it will get the value of <code>str<\/code>, which the function prints to the console.<\/p>\n<p>That&#8217;s it.<\/p>\n<p>Although we use the address-of operator in the above example to get the address of <code>str<\/code>, if we already had a pointer variable holding the address of <code>str<\/code>, we could use that instead:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    std::string str{ \"Hello, world!\" };\r\n    \r\n    printByValue(str); \/\/ pass str by value, makes a copy of str\r\n    printByReference(str); \/\/ pass str by reference, does not make a copy of str\r\n    printByAddress(&amp;str); \/\/ pass str by address, does not make a copy of str\r\n\r\n    std::string* ptr { &amp;str }; \/\/ define a pointer variable holding the address of str\r\n    printByAddress(ptr); \/\/ pass str by address, does not make a copy of str    \r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Nomenclature<\/p>\n<p>When we pass the address of a variable as an argument using <code>operator&amp;<\/code>, we say the variable is passed by address.<\/p>\n<p>When we have a pointer variable holding the address of an object, and we pass the pointer as an argument to a parameter of the same type, we say the object is passed by address, and the pointer is passed by value.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Pass by address does not make a copy of the object being pointed to<\/p>\n<p>Consider the following statements:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::string str{ \"Hello, world!\" };\r\nprintByAddress(&amp;str); \/\/ use address-of operator (&amp;) to get pointer holding address of str<\/code><\/pre>\n<p>As we noted in <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pass-by-lvalue-reference\/\">12.5 -- Pass by lvalue reference<\/a>, copying a <code>std::string<\/code> is expensive, so that&#8217;s something we want to avoid.  When we pass a <code>std::string<\/code> by address, we&#8217;re not copying the actual <code>std::string<\/code> object -- we&#8217;re just copying the pointer (holding the address of the object) from the caller to the called function.  Since an address is typically only 4 or 8 bytes, a pointer is only 4 or 8 bytes, so copying a pointer is always fast.<\/p>\n<p>Thus, just like pass by reference, pass by address is fast, and avoids making a copy of the argument object.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Pass by address allows the function to modify the argument&#8217;s value<\/p>\n<p>When we pass an object by address, the function receives the address of the passed object, which it can access via dereferencing.  Because this is the address of the actual argument object being passed (not a copy of the object), if the function parameter is a pointer to non-const, the function can modify the argument via the pointer parameter:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid changeValue(int* ptr) \/\/ note: ptr is a pointer to non-const in this example\r\n{\r\n    *ptr = 6; \/\/ change the value to 6\r\n}\r\n\r\nint main()\r\n{\r\n    int x{ 5 };\r\n\r\n    std::cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; '\\n';\r\n\r\n    changeValue(&amp;x); \/\/ we're passing the address of x to the function\r\n\r\n    std::cout &lt;&lt; \"x = \" &lt;&lt; x &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nx = 5\r\nx = 6\r\n<\/pre>\n<p>As you can see, the argument is modified and this modification persists even after <code>changeValue()<\/code> has finished running.<\/p>\n<p>If a function is not supposed to modify the object being passed in, the function parameter should be made a pointer-to-const:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void changeValue(const int* ptr) \/\/ note: ptr is now a pointer to a const\r\n{\r\n    *ptr = 6; \/\/ error: can not change const value\r\n}<\/code><\/pre>\n<p>For many of the same reasons we typically don&#8217;t <code>const<\/code> regular (non-pointer, non-reference) function parameters (discussed in <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constant-variables-named-constants\/\">5.1 -- Constant variables (named constants)<\/a>), we also typically don&#8217;t <code>const<\/code> pointer function parameters.  Let&#8217;s make two assertions:<\/p>\n<ul>\n<li>A <code>const<\/code> keyword used to make a pointer function parameter a const pointer provides little value (since it has no impact on the caller, and mostly serves as documentation that the pointer won&#8217;t change).\n<\/li>\n<li>A <code>const<\/code> keyword used to differentiate a pointer-to-const from a pointer-to-non-const that can modify the object passed in is significant (as the caller needs to know if the function could change the value of the argument).\n<\/li>\n<\/ul>\n<p>If we only use non-const pointer function parameters, then all uses of <code>const<\/code> are significant.  As soon as we start using <code>const<\/code> for const pointer function parameters, then it becomes more difficult to determine whether a given use of <code>const<\/code> is significant or not.  More importantly, it also makes it harder to notice pointer-to-non-const parameters.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void foo(const char* source, char* dest, int count);             \/\/ Using non-const pointers, all consts are significant.\r\nvoid foo(const char* const source, char* const dest, int count); \/\/ Using const pointers, `dest` being a pointer-to-non-const may go unnoticed amongst the sea of spurious consts.<\/code><\/pre>\n<p>In the former case, it&#8217;s easy to see that <code>source<\/code> is a pointer-to-const and <code>dest<\/code> is a pointer-to-non-const.  In the latter case, it&#8217;s much harder to see that <code>dest<\/code> is a const-pointer-to-non-const, whose pointed-to object can be modified by the function!<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Prefer pointer-to-const function parameters over pointer-to-non-const function parameters, unless the function needs to modify the object passed in.<br \/>\nDo not make function parameters const pointers unless there is some specific reason to do so.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Null checking<\/p>\n<p>Now consider this fairly innocent looking program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid print(int* ptr)\r\n{\r\n\tstd::cout &lt;&lt; *ptr &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n\tint x{ 5 };\r\n\tprint(&amp;x);\r\n\r\n\tint* myPtr {};\r\n\tprint(myPtr);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>When this program is run, it will print the value <code>5<\/code> and then most likely crash.<\/p>\n<p>In the call to <code>print(myPtr)<\/code>, <code>myPtr<\/code> is a null pointer, so function parameter <code>ptr<\/code> will also be a null pointer.  When this null pointer is dereferenced in the body of the function, undefined behavior results.<\/p>\n<p>When passing a parameter by address, care should be taken to ensure the pointer is not a null pointer before you dereference the value.  One way to do that is to use a conditional statement:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid print(int* ptr)\r\n{\r\n    if (ptr) \/\/ if ptr is not a null pointer\r\n    {\r\n        std::cout &lt;&lt; *ptr &lt;&lt; '\\n';\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n\tint x{ 5 };\r\n\t\r\n\tprint(&amp;x);\r\n\tprint(nullptr);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In the above program, we&#8217;re testing <code>ptr<\/code> to ensure it is not null before we dereference it.  While this is fine for such a simple function, in more complicated functions this can result in redundant logic (testing if ptr is not null multiple times) or nesting of the primary logic of the function (if contained in a block).<\/p>\n<p>In most cases, it is more effective to do the opposite: test whether the function parameter is null as a precondition (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/assert-and-static_assert\/\">9.6 -- Assert and static_assert<\/a>) and handle the negative case immediately:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid print(int* ptr)\r\n{\r\n    if (!ptr) \/\/ if ptr is a null pointer, early return back to the caller\r\n        return;\r\n\r\n    \/\/ if we reached this point, we can assume ptr is valid\r\n    \/\/ so no more testing or nesting required\r\n\r\n    std::cout &lt;&lt; *ptr &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n\tint x{ 5 };\r\n\t\r\n\tprint(&amp;x);\r\n\tprint(nullptr);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>If a null pointer should never be passed to the function, an <code>assert<\/code> (which we covered in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/assert-and-static_assert\/\">9.6 -- Assert and static_assert<\/a>) can be used instead (or also) (as asserts are intended to document things that should never happen):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;cassert&gt;\r\n\r\nvoid print(const int* ptr) \/\/ now a pointer to a const int\r\n{\r\n\tassert(ptr); \/\/ fail the program in debug mode if a null pointer is passed (since this should never happen)\r\n\r\n\t\/\/ (optionally) handle this as an error case in production mode so we don't crash if it does happen\r\n\tif (!ptr)\r\n\t\treturn;\r\n\r\n\tstd::cout &lt;&lt; *ptr &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n\tint x{ 5 };\r\n\t\r\n\tprint(&amp;x);\r\n\tprint(nullptr);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Prefer pass by (const) reference<\/p>\n<p>Note that function <code>print()<\/code> in the example above doesn&#8217;t handle null values very well -- it effectively just aborts the function.  Given this, why allow a user to pass in a null value at all?  Pass by reference has the same benefits as pass by address without the risk of inadvertently dereferencing a null pointer.<\/p>\n<p>Pass by const reference has a few other advantages over pass by address.<\/p>\n<p>First, because an object being passed by address must have an address, only lvalues can be passed by address (as rvalues don&#8217;t have addresses).  Pass by const reference is more flexible, as it can accept lvalues and rvalues:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printByValue(int val) \/\/ The function parameter is a copy of the argument\r\n{\r\n    std::cout &lt;&lt; val &lt;&lt; '\\n'; \/\/ print the value via the copy\r\n}\r\n\r\nvoid printByReference(const int&amp; ref) \/\/ The function parameter is a reference that binds to the argument\r\n{\r\n    std::cout &lt;&lt; ref &lt;&lt; '\\n'; \/\/ print the value via the reference\r\n}\r\n\r\nvoid printByAddress(const int* ptr) \/\/ The function parameter is a pointer that holds the address of the argument\r\n{\r\n    std::cout &lt;&lt; *ptr &lt;&lt; '\\n'; \/\/ print the value via the dereferenced pointer\r\n}\r\n\r\nint main()\r\n{\r\n    printByValue(5);     \/\/ valid (but makes a copy)\r\n    printByReference(5); \/\/ valid (because the parameter is a const reference)\r\n    printByAddress(&amp;5);  \/\/ error: can't take address of r-value\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Second, the syntax for pass by reference is natural, as we can just pass in literals or objects.  With pass by address, our code ends up littered with ampersands (&#038;) and asterisks (*).<\/p>\n<p>In modern C++, most things that can be done with pass by address are better accomplished through other methods.  Follow this common maxim: &#8220;Pass by reference when you can, pass by address when you must&#8221;.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Prefer pass by reference to pass by address unless you have a specific reason to use pass by address.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pass-by-address-part-2\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.11<\/span>Pass by address (part 2)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pointers-and-const\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.9<\/span>Pointers and const\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In prior lessons, we&#8217;ve covered two different ways to pass an argument to a function: pass by value () and pass by reference (). Here&#8217;s a sample program that shows a std::string object being passed by value and by reference: #include &lt;iostream&gt; #include &lt;string&gt; void printByValue(std::string val) \/\/ The function &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/111"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=111"}],"version-history":[{"count":46,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/111\/revisions"}],"predecessor-version":[{"id":18195,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/111\/revisions\/18195"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=111"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=111"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=111"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}