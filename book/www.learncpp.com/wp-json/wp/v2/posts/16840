{"id":16840,"date":"2024-03-25T14:51:15","date_gmt":"2024-03-25T21:51:15","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=16840"},"modified":"2025-02-13T21:42:48","modified_gmt":"2025-02-14T05:42:48","slug":"converting-an-enumeration-to-and-from-a-string","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/converting-an-enumeration-to-and-from-a-string\/","title":{"rendered":"13.4 &#8212; Converting an enumeration to and from a string"},"content":{"rendered":"<p>In the prior lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/unscoped-enumerator-integral-conversions\/\">13.3 -- Unscoped enumerator integral conversions<\/a>), we showed an example like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nenum Color\r\n{\r\n    black, \/\/ 0\r\n    red,   \/\/ 1\r\n    blue,  \/\/ 2\r\n};\r\n\r\nint main()\r\n{\r\n    Color shirt{ blue };\r\n\r\n    std::cout &lt;&lt; \"Your shirt is \" &lt;&lt; shirt &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nYour shirt is 2\r\n<\/pre>\n<p>Because <code>operator&lt;&lt;<\/code> doesn&#8217;t know how to print a <code>Color<\/code>, the compiler will implicitly convert <code>Color<\/code> into an integral value and print that instead.<\/p>\n<p>Most of the time, printing an enumeration as an integral value (such as <code>2<\/code>) isn&#8217;t what we want.  Instead, we typically want to print the name of whatever the enumerator represents (e.g. <code>blue<\/code>).  C++ doesn&#8217;t come with an out-of-the-box way to do this, so we&#8217;ll have to find a solution ourselves.  Fortunately, that&#8217;s not very difficult.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Getting the name of an enumerator<\/p>\n<p>The typical way to get the name of an enumerator is to write a function that allows us to pass in an enumerator and returns the enumerator&#8217;s name as a string. But that requires some way to determine which string should be returned for a given enumerator.<\/p>\n<p>There are two common ways to do this.<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/switch-statement-basics\/\">8.5 -- Switch statement basics<\/a>, we noted that a switch statement can switch on either an integral value or an enumerated value.  In the following example, we use a switch statement to select an enumerator and return the appropriate color string literal for that enumerator:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nenum Color\r\n{\r\n    black,\r\n    red,\r\n    blue,\r\n};\r\n\r\nconstexpr std::string_view getColorName(Color color)\r\n{\r\n    switch (color)\r\n    {\r\n    case black: return \"black\";\r\n    case red:   return \"red\";\r\n    case blue:  return \"blue\";\r\n    default:    return \"???\";\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    constexpr Color shirt{ blue };\r\n\r\n    std::cout &lt;&lt; \"Your shirt is \" &lt;&lt; getColorName(shirt) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nYour shirt is blue\r\n<\/pre>\n<p>In the above example, we switch on <code>color<\/code>, which holds the enumerator we passed in.  Inside the switch, we have a case-label for each enumerator of <code>Color<\/code>.  Each case returns the name of the appropriate color as a C-style string literal.  This C-style string literal gets implicitly converted into a <code>std::string_view<\/code>, which is returned to the caller.  We also have a default case which returns <code>\"???\"<\/code>, in case the user passes in something we didn&#8217;t expect.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">A reminder<\/p>\n<p>Because C-style string literals exist for the entire program, it&#8217;s okay to return a <code>std::string_view<\/code> that is viewing a C-style string literal.  When the <code>std::string_view<\/code> is copied back to the caller, the C-style string literal being viewed will still exist.\n<\/div>\n<p>The function is constexpr so that we can use the color&#8217;s name in a constant expression.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>Constexpr functions are covered in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-functions\/\">F.1 -- Constexpr functions<\/a>.\n<\/p><\/div>\n<p>While this lets us get the name of an enumerator, if we want to print that name to the console, having to do <code>std::cout &lt;&lt; getColorName(shirt)<\/code> isn&#8217;t quite as nice as <code>std::cout &lt;&lt; shirt<\/code>.  We&#8217;ll teach <code>std::cout<\/code> how to print an enumeration in upcoming lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-overloading-the-i-o-operators\/\">13.5 -- Introduction to overloading the I\/O operators<\/a>.<\/p>\n<p>The second way to solve the program of mapping enumerators to strings is to use an array.  We cover this in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdarray-and-enumerations\/\">17.6 -- std::array and enumerations<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Unscoped enumerator input<\/p>\n<p>Now let&#8217;s take a look at an input case.  In the following example, we define a <code>Pet<\/code> enumeration.  Because <code>Pet<\/code> is a program-defined type, the language doesn&#8217;t know how to input a <code>Pet<\/code> using <code>std::cin<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nenum Pet\r\n{\r\n    cat,   \/\/ 0\r\n    dog,   \/\/ 1\r\n    pig,   \/\/ 2\r\n    whale, \/\/ 3\r\n};\r\n\r\nint main()\r\n{\r\n    Pet pet { pig };\r\n    std::cin &gt;&gt; pet; \/\/ compile error: std::cin doesn't know how to input a Pet\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>One simple way to work around this is to read in an integer, and use <code>static_cast<\/code> to convert the integer to an enumerator of the appropriate enumerated type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nenum Pet\r\n{\r\n    cat,   \/\/ 0\r\n    dog,   \/\/ 1\r\n    pig,   \/\/ 2\r\n    whale, \/\/ 3\r\n};\r\n\r\nconstexpr std::string_view getPetName(Pet pet)\r\n{\r\n    switch (pet)\r\n    {\r\n    case cat:   return \"cat\";\r\n    case dog:   return \"dog\";\r\n    case pig:   return \"pig\";\r\n    case whale: return \"whale\";\r\n    default:    return \"???\";\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter a pet (0=cat, 1=dog, 2=pig, 3=whale): \";\r\n\r\n    int input{};\r\n    std::cin &gt;&gt; input; \/\/ input an integer\r\n\r\n    if (input &lt; 0 || input &gt; 3)\r\n        std::cout &lt;&lt; \"You entered an invalid pet\\n\";\r\n    else\r\n    {\r\n        Pet pet{ static_cast&lt;Pet&gt;(input) }; \/\/ static_cast our integer to a Pet\r\n        std::cout &lt;&lt; \"You entered: \" &lt;&lt; getPetName(pet) &lt;&lt; '\\n';\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>While this works, it&#8217;s a bit awkward.  Also note that we should only <code>static_cast&lt;Pet&gt;(input)<\/code> once we know <code>input<\/code> is in range of the enumerator.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Getting an enumeration from a string<\/p>\n<p>Instead of inputting a number, it would be nicer if the user could type in a string representing an enumerator (e.g. &#8220;pig&#8221;), and we could convert that string into the appropriate <code>Pet<\/code> enumerator.  However, doing this requires us to solve a couple of challenges.<\/p>\n<p>First, we can&#8217;t switch on a string, so we need to use something else to match the string the user passed in.  The simplest approach here is to use a series of if-statements.<\/p>\n<p>Second, what <code>Pet<\/code> enumerator should we return if the user passes in an invalid string?  One option would be to add an enumerator to represent &#8220;none\/invalid&#8221;, and return that.  However, a better option is to use <code>std::optional<\/code> here.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover <code>std::optional<\/code> in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdoptional\/\">12.15 -- std::optional<\/a>.\n<\/div>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;optional&gt; \/\/ for std::optional\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nenum Pet\r\n{\r\n    cat,   \/\/ 0\r\n    dog,   \/\/ 1\r\n    pig,   \/\/ 2\r\n    whale, \/\/ 3\r\n};\r\n\r\nconstexpr std::string_view getPetName(Pet pet)\r\n{\r\n    switch (pet)\r\n    {\r\n    case cat:   return \"cat\";\r\n    case dog:   return \"dog\";\r\n    case pig:   return \"pig\";\r\n    case whale: return \"whale\";\r\n    default:    return \"???\";\r\n    }\r\n}\r\n\r\nconstexpr std::optional&lt;Pet&gt; getPetFromString(std::string_view sv)\r\n{\r\n    \/\/ We can only switch on an integral value (or enum), not a string\r\n    \/\/ so we have to use if-statements here\r\n    if (sv == \"cat\")   return cat;\r\n    if (sv == \"dog\")   return dog;\r\n    if (sv == \"pig\")   return pig;\r\n    if (sv == \"whale\") return whale;\r\n    \r\n    return {};\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter a pet: cat, dog, pig, or whale: \";\r\n    std::string s{};\r\n    std::cin &gt;&gt; s;\r\n        \r\n    std::optional&lt;Pet&gt; pet { getPetFromString(s) };\r\n\r\n    if (!pet)\r\n        std::cout &lt;&lt; \"You entered an invalid pet\\n\";\r\n    else\r\n        std::cout &lt;&lt; \"You entered: \" &lt;&lt; getPetName(*pet) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above solution, we use a series of if-else statements to do string comparisons.  If the user&#8217;s input string matches an enumerator string, we return the appropriate enumerator.  If none of the strings match, we return <code>{}<\/code>, which means &#8220;no value&#8221;.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Note that the above solution only matches lower case letters.  If you want to match any letter case, you can use the following function to convert the user&#8217;s input to lower case:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt; \/\/ for std::transform\r\n#include &lt;cctype&gt;    \/\/ for std::tolower\r\n#include &lt;iterator&gt;  \/\/ for std::back_inserter\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\n\/\/ This function returns a std::string that is the lower-case version of the std::string_view passed in.\r\n\/\/ Only 1:1 character mapping can be performed by this function\r\nstd::string toASCIILowerCase(std::string_view sv)\r\n{\r\n    std::string lower{};\r\n    std::transform(sv.begin(), sv.end(), std::back_inserter(lower),\r\n        [](char c)\r\n        { \r\n            return static_cast&lt;char&gt;(std::tolower(static_cast&lt;unsigned char&gt;(c)));\r\n        });\r\n    return lower;\r\n}<\/code><\/pre>\n<p>This function steps through each character in <code>std::string_view sv<\/code>, converts it to a lower case character using <code>std::tolower()<\/code> (with the help of a lambda), and then appends that lower-case character to <code>lower<\/code>.  <\/p>\n<p>We cover lambdas in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-lambdas-anonymous-functions\/\">20.6 -- Introduction to lambdas (anonymous functions)<\/a>.\n<\/p><\/div>\n<p>Similar to the output case, it would be better if we could just <code>std::cin &gt;&gt; pet<\/code>.  We&#8217;ll cover this in upcoming lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-overloading-the-i-o-operators\/\">13.5 -- Introduction to overloading the I\/O operators<\/a>.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-overloading-the-i-o-operators\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.5<\/span>Introduction to overloading the I\/O operators\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/unscoped-enumerator-integral-conversions\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.3<\/span>Unscoped enumerator integral conversions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the prior lesson (), we showed an example like this: #include &lt;iostream&gt; enum Color { black, \/\/ 0 red, \/\/ 1 blue, \/\/ 2 }; int main() { Color shirt{ blue }; std::cout &lt;&lt; &#8220;Your shirt is &#8221; &lt;&lt; shirt &lt;&lt; &#8216;\\n&#8217;; return 0; } This prints: Your shirt &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/16840"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=16840"}],"version-history":[{"count":9,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/16840\/revisions"}],"predecessor-version":[{"id":18197,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/16840\/revisions\/18197"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=16840"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=16840"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=16840"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}