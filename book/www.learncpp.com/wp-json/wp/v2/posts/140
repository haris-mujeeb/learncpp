{"id":140,"date":"2007-10-04T17:10:19","date_gmt":"2007-10-05T01:10:19","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/94-overloading-the-comparison-operators\/"},"modified":"2024-02-07T09:23:55","modified_gmt":"2024-02-07T17:23:55","slug":"overloading-the-comparison-operators","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-the-comparison-operators\/","title":{"rendered":"21.7 &#8212; Overloading the comparison operators"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/relational-operators-and-floating-point-comparisons\/\">6.7 -- Relational operators and floating point comparisons<\/a>, we discussed the six comparison operators.  Overloading these comparison operators is comparatively simple (see what I did there?), as they follow the same patterns as we&#8217;ve seen in overloading other operators.<\/p>\n<p>Because the comparison operators are all binary operators that do not modify their left operands, we will make our overloaded comparison operators friend functions.<\/p>\n<p>Here&#8217;s an example Car class with an overloaded operator== and operator!=.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Car\r\n{\r\nprivate:\r\n    std::string m_make;\r\n    std::string m_model;\r\n\r\npublic:\r\n    Car(std::string_view make, std::string_view model)\r\n        : m_make{ make }, m_model{ model }\r\n    {\r\n    }\r\n\r\n    friend bool operator== (const Car&amp; c1, const Car&amp; c2);\r\n    friend bool operator!= (const Car&amp; c1, const Car&amp; c2);\r\n};\r\n\r\nbool operator== (const Car&amp; c1, const Car&amp; c2)\r\n{\r\n    return (c1.m_make == c2.m_make &amp;&amp;\r\n            c1.m_model == c2.m_model);\r\n}\r\n\r\nbool operator!= (const Car&amp; c1, const Car&amp; c2)\r\n{\r\n    return (c1.m_make != c2.m_make ||\r\n            c1.m_model != c2.m_model);\r\n}\r\n\r\nint main()\r\n{\r\n    Car corolla{ \"Toyota\", \"Corolla\" };\r\n    Car camry{ \"Toyota\", \"Camry\" };\r\n\r\n    if (corolla == camry)\r\n        std::cout &lt;&lt; \"a Corolla and Camry are the same.\\n\";\r\n\r\n    if (corolla != camry)\r\n        std::cout &lt;&lt; \"a Corolla and Camry are not the same.\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The code here should be straightforward.<\/p>\n<p>What about operator&lt; and operator&gt;?  What would it mean for a Car to be greater or less than another Car?  We typically don&#8217;t think about cars this way.  Since the results of operator&lt; and operator&gt; would not be immediately intuitive, it may be better to leave these operators undefined.  <\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Only define overloaded operators that make intuitive sense for your class.\n<\/p><\/div>\n<p>However, there is one common exception to the above recommendation.  What if we wanted to sort a list of Cars?  In such a case, we might want to overload the comparison operators to return the member (or members) you&#8217;re most likely to want to sort on.  For example, an overloaded operator&lt; for Cars might sort based on make and model alphabetically.<\/p>\n<p>Some of the container classes in the standard library (classes that hold sets of other classes) require an overloaded operator&lt; so they can keep the elements sorted.<\/p>\n<p>Here&#8217;s a different example overloading all 6 logical comparison operators:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Cents\r\n{\r\nprivate:\r\n    int m_cents;\r\n \r\npublic:\r\n    Cents(int cents)\r\n\t: m_cents{ cents }\r\n\t{}\r\n \r\n    friend bool operator== (const Cents&amp; c1, const Cents&amp; c2);\r\n    friend bool operator!= (const Cents&amp; c1, const Cents&amp; c2);\r\n\r\n    friend bool operator&lt; (const Cents&amp; c1, const Cents&amp; c2);\r\n    friend bool operator&gt; (const Cents&amp; c1, const Cents&amp; c2);\r\n\r\n    friend bool operator&lt;= (const Cents&amp; c1, const Cents&amp; c2);\r\n    friend bool operator&gt;= (const Cents&amp; c1, const Cents&amp; c2);\r\n};\r\n\r\nbool operator== (const Cents&amp; c1, const Cents&amp; c2)\r\n{\r\n    return c1.m_cents == c2.m_cents;\r\n}\r\n\r\nbool operator!= (const Cents&amp; c1, const Cents&amp; c2)\r\n{\r\n    return c1.m_cents != c2.m_cents;\r\n}\r\n\r\nbool operator&gt; (const Cents&amp; c1, const Cents&amp; c2)\r\n{\r\n    return c1.m_cents &gt; c2.m_cents;\r\n}\r\n\r\nbool operator&lt; (const Cents&amp; c1, const Cents&amp; c2)\r\n{\r\n    return c1.m_cents &lt; c2.m_cents;\r\n}\r\n\r\nbool operator&lt;= (const Cents&amp; c1, const Cents&amp; c2)\r\n{\r\n    return c1.m_cents &lt;= c2.m_cents;\r\n}\r\n\r\nbool operator&gt;= (const Cents&amp; c1, const Cents&amp; c2)\r\n{\r\n    return c1.m_cents &gt;= c2.m_cents;\r\n}\r\n\r\nint main()\r\n{\r\n    Cents dime{ 10 };\r\n    Cents nickel{ 5 };\r\n \r\n    if (nickel &gt; dime)\r\n        std::cout &lt;&lt; \"a nickel is greater than a dime.\\n\";\r\n    if (nickel &gt;= dime)\r\n        std::cout &lt;&lt; \"a nickel is greater than or equal to a dime.\\n\";\r\n    if (nickel &lt; dime)\r\n        std::cout &lt;&lt; \"a dime is greater than a nickel.\\n\";\r\n    if (nickel &lt;= dime)\r\n        std::cout &lt;&lt; \"a dime is greater than or equal to a nickel.\\n\";\r\n    if (nickel == dime)\r\n        std::cout &lt;&lt; \"a dime is equal to a nickel.\\n\";\r\n    if (nickel != dime)\r\n        std::cout &lt;&lt; \"a dime is not equal to a nickel.\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This is also pretty straightforward.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Minimizing comparative redundancy<\/p>\n<p>In the example above, note how similar the implementation of each of the overloaded comparison operators are.  Overloaded comparison operators tend to have a high degree of redundancy, and the more complex the implementation, the more redundancy there will be.<\/p>\n<p>Fortunately, many of the comparison operators can be implemented using the other comparison operators:<\/p>\n<ul>\n<li>operator!= can be implemented as !(operator==)<\/li>\n<li>operator&gt; can be implemented as operator&lt; with the order of the parameters flipped<\/li>\n<li>operator&gt;= can be implemented as !(operator&lt;)<\/li>\n<li>operator&lt;= can be implemented as !(operator&gt;)<\/li>\n<\/ul>\n<p>This means that we only need to implement logic for operator== and operator&lt;, and then the other four comparison operators can be defined in terms of those two!  Here&#8217;s an updated Cents example illustrating this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Cents\r\n{\r\nprivate:\r\n    int m_cents;\r\n\r\npublic:\r\n    Cents(int cents)\r\n        : m_cents{ cents }\r\n    {}\r\n\r\n    friend bool operator== (const Cents&amp; c1, const Cents&amp; c2) { return c1.m_cents == c2.m_cents; }\r\n    friend bool operator!= (const Cents&amp; c1, const Cents&amp; c2) { return !(operator==(c1, c2)); }\r\n\r\n    friend bool operator&lt; (const Cents&amp; c1, const Cents&amp; c2) { return c1.m_cents &lt; c2.m_cents; }\r\n    friend bool operator&gt; (const Cents&amp; c1, const Cents&amp; c2) { return operator&lt;(c2, c1); }\r\n\r\n    friend bool operator&lt;= (const Cents&amp; c1, const Cents&amp; c2) { return !(operator&gt;(c1, c2)); }\r\n    friend bool operator&gt;= (const Cents&amp; c1, const Cents&amp; c2) { return !(operator&lt;(c1, c2)); }\r\n\r\n};\r\n\r\nint main()\r\n{\r\n    Cents dime{ 10 };\r\n    Cents nickel{ 5 };\r\n\r\n    if (nickel &gt; dime)\r\n        std::cout &lt;&lt; \"a nickel is greater than a dime.\\n\";\r\n    if (nickel &gt;= dime)\r\n        std::cout &lt;&lt; \"a nickel is greater than or equal to a dime.\\n\";\r\n    if (nickel &lt; dime)\r\n        std::cout &lt;&lt; \"a dime is greater than a nickel.\\n\";\r\n    if (nickel &lt;= dime)\r\n        std::cout &lt;&lt; \"a dime is greater than or equal to a nickel.\\n\";\r\n    if (nickel == dime)\r\n        std::cout &lt;&lt; \"a dime is equal to a nickel.\\n\";\r\n    if (nickel != dime)\r\n        std::cout &lt;&lt; \"a dime is not equal to a nickel.\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This way, if we ever need to change something, we only need to update operator== and operator&lt; instead of all six comparison operators!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The spaceship operator &lt;=&gt; <span class=\"cpp-section-pill cpp-section-standard\">C++20<\/span><\/p>\n<p>C++20 introduces the spaceship operator (<code>operator&lt;=&gt;<\/code>), which allows us to reduce the number of comparison functions we need to write down to 2 at most, and sometimes just 1!<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>We intend to add a new lesson on this topic soon.  Until then, consider this something to pique your interest -- but you&#8217;ll have to go off-site to discover more.\n<\/p><\/div>\n<p><strong>Quiz time<\/strong><\/p>\n<ol start=\"1\">\n<li>Add the six comparison operators to the Fraction class so that the following program compiles:\n<\/li>\n<\/ol>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;numeric&gt; \/\/ for std::gcd\r\n\r\nclass Fraction\r\n{\r\nprivate:\r\n\tint m_numerator{};\r\n\tint m_denominator{};\r\n\r\npublic:\r\n\tFraction(int numerator = 0, int denominator = 1) :\r\n\t\tm_numerator{ numerator }, m_denominator{ denominator }\r\n\t{\r\n\t\t\/\/ We put reduce() in the constructor to ensure any new fractions we make get reduced!\r\n\t\t\/\/ Any fractions that are overwritten will need to be re-reduced\r\n\t\treduce();\r\n\t}\r\n\r\n\tvoid reduce()\r\n\t{\r\n\t\tint gcd{ std::gcd(m_numerator, m_denominator) };\r\n\t\tif (gcd)\r\n\t\t{\r\n\t\t\tm_numerator \/= gcd;\r\n\t\t\tm_denominator \/= gcd;\r\n\t\t}\r\n\t}\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1);\r\n};\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)\r\n{\r\n\tout &lt;&lt; f1.m_numerator &lt;&lt; '\/' &lt;&lt; f1.m_denominator;\r\n\treturn out;\r\n}\r\n\r\nint main()\r\n{\r\n\tFraction f1{ 3, 2 };\r\n\tFraction f2{ 5, 8 };\r\n\r\n\tstd::cout &lt;&lt; f1 &lt;&lt; ((f1 == f2) ? \" == \" : \" not == \") &lt;&lt; f2 &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; f1 &lt;&lt; ((f1 != f2) ? \" != \" : \" not != \") &lt;&lt; f2 &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; f1 &lt;&lt; ((f1 &lt; f2) ? \" &lt; \" : \" not &lt; \") &lt;&lt; f2 &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; f1 &lt;&lt; ((f1 &gt; f2) ? \" &gt; \" : \" not &gt; \") &lt;&lt; f2 &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; f1 &lt;&lt; ((f1 &lt;= f2) ? \" &lt;= \" : \" not &lt;= \") &lt;&lt; f2 &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; f1 &lt;&lt; ((f1 &gt;= f2) ? \" &gt;= \" : \" not &gt;= \") &lt;&lt; f2 &lt;&lt; '\\n';\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>If you\u2019re on a pre-C++17 compiler, you can replace std::gcd with this function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cmath&gt;\r\n \r\nint gcd(int a, int b) {\r\n    return (b == 0) ? std::abs(a) : gcd(b, a % b);\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;numeric&gt; \/\/ for std::gcd\r\n\r\nclass Fraction\r\n{\r\nprivate:\r\n\tint m_numerator{};\r\n\tint m_denominator{};\r\n\r\npublic:\r\n\tFraction(int numerator = 0, int denominator = 1) :\r\n\t\tm_numerator{ numerator }, m_denominator{ denominator }\r\n\t{\r\n\t\t\/\/ We put reduce() in the constructor to ensure any new fractions we make get reduced!\r\n\t\t\/\/ Any fractions that are overwritten will need to be re-reduced\r\n\t\treduce();\r\n\t}\r\n\r\n\tvoid reduce()\r\n\t{\r\n\t\tint gcd{ std::gcd(m_numerator, m_denominator) };\r\n\t\tif (gcd)\r\n\t\t{\r\n\t\t\tm_numerator \/= gcd;\r\n\t\t\tm_denominator \/= gcd;\r\n\t\t}\r\n\t}\r\n\r\n\tfriend bool operator== (const Fraction&amp; f1, const Fraction&amp; f2);\r\n\tfriend bool operator!= (const Fraction&amp; f1, const Fraction&amp; f2);\r\n\r\n\tfriend bool operator&lt; (const Fraction&amp; f1, const Fraction&amp; f2);\r\n\tfriend bool operator&gt; (const Fraction&amp; f1, const Fraction&amp; f2);\r\n\r\n\tfriend bool operator&lt;= (const Fraction&amp; f1, const Fraction&amp; f2);\r\n\tfriend bool operator&gt;= (const Fraction&amp; f1, const Fraction&amp; f2);\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1);\r\n};\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Fraction&amp; f1)\r\n{\r\n\tout &lt;&lt; f1.m_numerator &lt;&lt; '\/' &lt;&lt; f1.m_denominator;\r\n\treturn out;\r\n}\r\n\r\nbool operator== (const Fraction&amp; f1, const Fraction&amp; f2)\r\n{\r\n\treturn (f1.m_numerator == f2.m_numerator) &amp;&amp; (f1.m_denominator == f2.m_denominator);\r\n}\r\n\r\nbool operator!= (const Fraction&amp; f1, const Fraction&amp; f2)\r\n{\r\n\treturn !(operator==(f1, f2));\r\n}\r\n\r\nbool operator&lt; (const Fraction&amp; f1, const Fraction&amp; f2)\r\n{\r\n\treturn (f1.m_numerator * f2.m_denominator &lt; f2.m_numerator * f1.m_denominator);\r\n}\r\n\r\nbool operator&gt; (const Fraction&amp; f1, const Fraction&amp; f2)\r\n{\r\n\treturn operator&lt;(f2, f1);\r\n}\r\n\r\nbool operator&lt;= (const Fraction&amp; f1, const Fraction&amp; f2)\r\n{\r\n\treturn !(operator&gt;(f1, f2));\r\n}\r\n\r\nbool operator&gt;= (const Fraction&amp; f1, const Fraction&amp; f2)\r\n{\r\n\treturn !(operator&lt;(f1, f2));\r\n}\r\n\r\nint main()\r\n{\r\n\tFraction f1{ 3, 2 };\r\n\tFraction f2{ 5, 8 };\r\n\r\n\tstd::cout &lt;&lt; f1 &lt;&lt; ((f1 == f2) ? \" == \" : \" not == \") &lt;&lt; f2 &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; f1 &lt;&lt; ((f1 != f2) ? \" != \" : \" not != \") &lt;&lt; f2 &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; f1 &lt;&lt; ((f1 &lt; f2) ? \" &lt; \" : \" not &lt; \") &lt;&lt; f2 &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; f1 &lt;&lt; ((f1 &gt; f2) ? \" &gt; \" : \" not &gt; \") &lt;&lt; f2 &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; f1 &lt;&lt; ((f1 &lt;= f2) ? \" &lt;= \" : \" not &lt;= \") &lt;&lt; f2 &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; f1 &lt;&lt; ((f1 &gt;= f2) ? \" &gt;= \" : \" not &gt;= \") &lt;&lt; f2 &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<ol start=\"2\">\n<li>Add an overloaded operator&lt;&lt; and operator&lt; to the Car class at the top of the lesson so that the following program compiles:\n<\/li>\n<\/ol>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n  std::vector&lt;Car&gt; cars{\r\n    { \"Toyota\", \"Corolla\" },\r\n    { \"Honda\", \"Accord\" },\r\n    { \"Toyota\", \"Camry\" },\r\n    { \"Honda\", \"Civic\" }\r\n  };\r\n\r\n  std::sort(cars.begin(), cars.end()); \/\/ requires an overloaded operator&lt;\r\n\r\n  for (const auto&amp; car : cars)\r\n    std::cout &lt;&lt; car &lt;&lt; '\\n'; \/\/ requires an overloaded operator&lt;&lt;\r\n\r\n  return 0;\r\n}<\/code><\/pre>\n<p>This program should produce the following output:<\/p>\n<pre>\r\n(Honda, Accord)\r\n(Honda, Civic)\r\n(Toyota, Camry)\r\n(Toyota, Corolla)\r\n<\/pre>\n<p>If you need a refresher on std::sort, we talk about it in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/sorting-an-array-using-selection-sort\/\">18.1 -- Sorting an array using selection sort<\/a>.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n#include &lt;vector&gt;\r\n\r\nclass Car\r\n{\r\nprivate:\r\n    std::string m_make;\r\n    std::string m_model;\r\n\r\npublic:\r\n    Car(std::string_view make, std::string_view model)\r\n        : m_make{ make }, m_model{ model }\r\n    {\r\n    }\r\n\r\n    friend bool operator==(const Car&amp; c1, const Car&amp; c2);\r\n    friend bool operator!=(const Car&amp; c1, const Car&amp; c2);\r\n\r\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Car&amp; c)\r\n    {\r\n        out &lt;&lt; '(' &lt;&lt; c.m_make &lt;&lt; \", \" &lt;&lt; c.m_model &lt;&lt; ')';\r\n        return out;\r\n    }\r\n\r\n    \/\/ h\/t to reader Olivier for the initial version of the function\r\n    friend bool operator&lt;(const Car&amp; c1, const Car&amp; c2)\r\n    {\r\n        if (c1.m_make != c2.m_make) \/\/ If the car is not the same make...\r\n            return c1.m_make &lt; c2.m_make; \/\/ ...then compare the make\r\n\r\n        return c1.m_model &lt; c2.m_model; \/\/ otherwise compare the model\r\n    }\r\n};\r\n\r\nbool operator==(const Car&amp; c1, const Car&amp; c2)\r\n{\r\n    return c1.m_make == c2.m_make &amp;&amp; c1.m_model == c2.m_model;\r\n}\r\n\r\nbool operator!= (const Car&amp; c1, const Car&amp; c2)\r\n{\r\n    return !operator==(c1, c2);\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector&lt;Car&gt; cars{\r\n      { \"Toyota\", \"Corolla\" },\r\n      { \"Honda\", \"Accord\" },\r\n      { \"Toyota\", \"Camry\" },\r\n      { \"Honda\", \"Civic\" }\r\n    };\r\n\r\n    std::sort(cars.begin(), cars.end()); \/\/ requires an overloaded Car::operator&lt;\r\n\r\n    for (const auto&amp; car : cars)\r\n        std::cout &lt;&lt; car &lt;&lt; '\\n'; \/\/ requires an overloaded Car::operator&lt;&lt;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-the-increment-and-decrement-operators\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.8<\/span>Overloading the increment and decrement operators\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-unary-operators\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.6<\/span>Overloading unary operators +, -, and !\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we discussed the six comparison operators. Overloading these comparison operators is comparatively simple (see what I did there?), as they follow the same patterns as we&#8217;ve seen in overloading other operators. Because the comparison operators are all binary operators that do not modify their left operands, we &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/140"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=140"}],"version-history":[{"count":40,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/140\/revisions"}],"predecessor-version":[{"id":16640,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/140\/revisions\/16640"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=140"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=140"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=140"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}