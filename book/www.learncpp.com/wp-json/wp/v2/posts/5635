{"id":5635,"date":"2017-03-21T17:44:43","date_gmt":"2017-03-22T01:44:43","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=5635"},"modified":"2024-07-22T14:20:57","modified_gmt":"2024-07-22T21:20:57","slug":"circular-dependency-issues-with-stdshared_ptr-and-stdweak_ptr","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/circular-dependency-issues-with-stdshared_ptr-and-stdweak_ptr\/","title":{"rendered":"22.7 &#8212; Circular dependency issues with std::shared_ptr, and std::weak_ptr"},"content":{"rendered":"<p>In the previous lesson, we saw how std::shared_ptr allowed us to have multiple smart pointers co-owning the same resource.  However, in certain cases, this can become problematic.  Consider the following case, where the shared pointers in two separate objects each point at the other object:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;memory&gt; \/\/ for std::shared_ptr\r\n#include &lt;string&gt;\r\n\r\nclass Person\r\n{\r\n\tstd::string m_name;\r\n\tstd::shared_ptr&lt;Person&gt; m_partner; \/\/ initially created empty\r\n\r\npublic:\r\n\t\t\r\n\tPerson(const std::string &amp;name): m_name(name)\r\n\t{ \r\n\t\tstd::cout &lt;&lt; m_name &lt;&lt; \" created\\n\";\r\n\t}\r\n\t~Person()\r\n\t{\r\n\t\tstd::cout &lt;&lt; m_name &lt;&lt; \" destroyed\\n\";\r\n\t}\r\n\r\n\tfriend bool partnerUp(std::shared_ptr&lt;Person&gt; &amp;p1, std::shared_ptr&lt;Person&gt; &amp;p2)\r\n\t{\r\n\t\tif (!p1 || !p2)\r\n\t\t\treturn false;\r\n\r\n\t\tp1-&gt;m_partner = p2;\r\n\t\tp2-&gt;m_partner = p1;\r\n\r\n\t\tstd::cout &lt;&lt; p1-&gt;m_name &lt;&lt; \" is now partnered with \" &lt;&lt; p2-&gt;m_name &lt;&lt; '\\n';\r\n\r\n\t\treturn true;\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tauto lucy { std::make_shared&lt;Person&gt;(\"Lucy\") }; \/\/ create a Person named \"Lucy\"\r\n\tauto ricky { std::make_shared&lt;Person&gt;(\"Ricky\") }; \/\/ create a Person named \"Ricky\"\r\n\r\n\tpartnerUp(lucy, ricky); \/\/ Make \"Lucy\" point to \"Ricky\" and vice-versa\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In the above example, we dynamically allocate two Persons, &#8220;Lucy&#8221; and &#8220;Ricky&#8221; using make_shared() (to ensure lucy and ricky are destroyed at the end of main()).  Then we partner them up.  This sets the std::shared_ptr inside &#8220;Lucy&#8221; to point at &#8220;Ricky&#8221;, and the std::shared_ptr inside &#8220;Ricky&#8221; to point at &#8220;Lucy&#8221;.  Shared pointers are meant to be shared, so it&#8217;s fine that both the lucy shared pointer and Rick&#8217;s m_partner shared pointer both point at &#8220;Lucy&#8221; (and vice-versa).<\/p>\n<p>However, this program doesn&#8217;t execute as expected:<\/p>\n<pre>\r\nLucy created\r\nRicky created\r\nLucy is now partnered with Ricky\r\n<\/pre>\n<p>And that&#8217;s it.  No deallocations took place.  Uh oh.  What happened?<\/p>\n<p>After partnerUp() is called, there are two shared pointers pointing to &#8220;Ricky&#8221; (ricky, and Lucy&#8217;s m_partner) and two shared pointers pointing to &#8220;Lucy&#8221; (lucy, and Ricky&#8217;s m_partner).<\/p>\n<p>At the end of main(), the ricky shared pointer goes out of scope first.  When that happens, ricky checks if there are any other shared pointers that co-own the Person &#8220;Ricky&#8221;.  There are (Lucy&#8217;s m_partner).  Because of this, it doesn&#8217;t deallocate &#8220;Ricky&#8221; (if it did, then Lucy&#8217;s m_partner would end up as a dangling pointer).  At this point, we now have one shared pointer to &#8220;Ricky&#8221; (Lucy&#8217;s m_partner) and two shared pointers to &#8220;Lucy&#8221; (lucy, and Ricky&#8217;s m_partner).<\/p>\n<p>Next the lucy shared pointer goes out of scope, and the same thing happens.  The shared pointer lucy checks if there are any other shared pointers co-owning the Person &#8220;Lucy&#8221;.  There are (Ricky&#8217;s m_partner), so &#8220;Lucy&#8221; isn&#8217;t deallocated.  At this point, there is one shared pointer to &#8220;Lucy&#8221; (Ricky&#8217;s m_partner) and one shared pointer to &#8220;Ricky&#8221; (Lucy&#8217;s m_partner).<\/p>\n<p>Then the program ends -- and neither Person &#8220;Lucy&#8221; or &#8220;Ricky&#8221; have been deallocated!  Essentially, &#8220;Lucy&#8221; ends up keeping &#8220;Ricky&#8221; from being destroyed, and &#8220;Ricky&#8221; ends up keeping &#8220;Lucy&#8221; from being destroyed.<\/p>\n<p>It turns out that this can happen any time shared pointers form a circular reference.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Circular references<\/p>\n<p>A <strong>Circular reference<\/strong> (also called a <strong>cyclical reference<\/strong> or a <strong>cycle<\/strong>) is a series of references where each object references the next, and the last object references back to the first, causing a referential loop.  The references do not need to be actual C++ references -- they can be pointers, unique IDs, or any other means of identifying specific objects.  <\/p>\n<p>In the context of shared pointers, the references will be pointers.<\/p>\n<p>This is exactly what we see in the case above: &#8220;Lucy&#8221; points at &#8220;Ricky&#8221;, and &#8220;Ricky&#8221; points at &#8220;Lucy&#8221;.  With three pointers, you&#8217;d get the same thing when A points at B, B points at C, and C points at A.  The practical effect of having shared pointers form a cycle is that each object ends up keeping the next object alive -- with the last object keeping the first object alive.  Thus, no objects in the series can be deallocated because they all think some other object still needs it!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A reductive case<\/p>\n<p>It turns out, this cyclical reference issue can even happen with a single std::shared_ptr -- a std::shared_ptr referencing the object that contains it is still a cycle (just a reductive one).  Although it&#8217;s fairly unlikely that this would ever happen in practice, we&#8217;ll show you for additional comprehension:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;memory&gt; \/\/ for std::shared_ptr\r\n\r\nclass Resource\r\n{\r\npublic:\r\n\tstd::shared_ptr&lt;Resource&gt; m_ptr {}; \/\/ initially created empty\r\n\t\r\n\tResource() { std::cout &lt;&lt; \"Resource acquired\\n\"; }\r\n\t~Resource() { std::cout &lt;&lt; \"Resource destroyed\\n\"; }\r\n};\r\n\r\nint main()\r\n{\r\n\tauto ptr1 { std::make_shared&lt;Resource&gt;() };\r\n\r\n\tptr1-&gt;m_ptr = ptr1; \/\/ m_ptr is now sharing the Resource that contains it\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In the above example, when ptr1 goes out of scope, the Resource is not deallocated because the Resource&#8217;s m_ptr is sharing the Resource.  At that point, the only way for the Resource to be released would be to set m_ptr to something else (so nothing is sharing the Resource any longer).  But we can&#8217;t access m_ptr because ptr1 is out of scope, so we no longer have a way to do this.  The Resource has become a memory leak.<\/p>\n<p>Thus, the program prints:<\/p>\n<pre>\r\nResource acquired\r\n<\/pre>\n<p>and that&#8217;s it.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">So what is std::weak_ptr for anyway?<\/p>\n<p>std::weak_ptr was designed to solve the &#8220;cyclical ownership&#8221; problem described above.  A std::weak_ptr is an observer -- it can observe and access the same object as a std::shared_ptr (or other std::weak_ptrs) but it is not considered an owner.  Remember, when a std::shared pointer goes out of scope, it only considers whether other std::shared_ptr are co-owning the object.  std::weak_ptr does not count!<\/p>\n<p>Let&#8217;s solve our Person-al issue using a std::weak_ptr:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;memory&gt; \/\/ for std::shared_ptr and std::weak_ptr\r\n#include &lt;string&gt;\r\n\r\nclass Person\r\n{\r\n\tstd::string m_name;\r\n\tstd::weak_ptr&lt;Person&gt; m_partner; \/\/ note: This is now a std::weak_ptr\r\n\r\npublic:\r\n\t\t\r\n\tPerson(const std::string &amp;name): m_name(name)\r\n\t{ \r\n\t\tstd::cout &lt;&lt; m_name &lt;&lt; \" created\\n\";\r\n\t}\r\n\t~Person()\r\n\t{\r\n\t\tstd::cout &lt;&lt; m_name &lt;&lt; \" destroyed\\n\";\r\n\t}\r\n\r\n\tfriend bool partnerUp(std::shared_ptr&lt;Person&gt; &amp;p1, std::shared_ptr&lt;Person&gt; &amp;p2)\r\n\t{\r\n\t\tif (!p1 || !p2)\r\n\t\t\treturn false;\r\n\r\n\t\tp1-&gt;m_partner = p2;\r\n\t\tp2-&gt;m_partner = p1;\r\n\r\n\t\tstd::cout &lt;&lt; p1-&gt;m_name &lt;&lt; \" is now partnered with \" &lt;&lt; p2-&gt;m_name &lt;&lt; '\\n';\r\n\r\n\t\treturn true;\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tauto lucy { std::make_shared&lt;Person&gt;(\"Lucy\") };\r\n\tauto ricky { std::make_shared&lt;Person&gt;(\"Ricky\") };\r\n\r\n\tpartnerUp(lucy, ricky);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This code behaves properly:<\/p>\n<pre>\r\nLucy created\r\nRicky created\r\nLucy is now partnered with Ricky\r\nRicky destroyed\r\nLucy destroyed\r\n<\/pre>\n<p>Functionally, it works almost identically to the problematic example.  However, now when ricky goes out of scope, it sees that there are no other std::shared_ptr pointing at &#8220;Ricky&#8221; (the std::weak_ptr from &#8220;Lucy&#8221; doesn&#8217;t count).  Therefore, it will deallocate &#8220;Ricky&#8221;.  The same occurs for lucy.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using std::weak_ptr<\/p>\n<p>One downside of std::weak_ptr is that std::weak_ptr are not directly usable (they have no operator->).  To use a std::weak_ptr, you must first convert it into a std::shared_ptr.  Then you can use the std::shared_ptr.  To convert a std::weak_ptr into a std::shared_ptr, you can use the lock() member function.  Here&#8217;s the above example, updated to show this off:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;memory&gt; \/\/ for std::shared_ptr and std::weak_ptr\r\n#include &lt;string&gt;\r\n\r\nclass Person\r\n{\r\n\tstd::string m_name;\r\n\tstd::weak_ptr&lt;Person&gt; m_partner; \/\/ note: This is now a std::weak_ptr\r\n\r\npublic:\r\n\r\n\tPerson(const std::string &amp;name) : m_name(name)\r\n\t{\r\n\t\tstd::cout &lt;&lt; m_name &lt;&lt; \" created\\n\";\r\n\t}\r\n\t~Person()\r\n\t{\r\n\t\tstd::cout &lt;&lt; m_name &lt;&lt; \" destroyed\\n\";\r\n\t}\r\n\r\n\tfriend bool partnerUp(std::shared_ptr&lt;Person&gt; &amp;p1, std::shared_ptr&lt;Person&gt; &amp;p2)\r\n\t{\r\n\t\tif (!p1 || !p2)\r\n\t\t\treturn false;\r\n\r\n\t\tp1-&gt;m_partner = p2;\r\n\t\tp2-&gt;m_partner = p1;\r\n\r\n\t\tstd::cout &lt;&lt; p1-&gt;m_name &lt;&lt; \" is now partnered with \" &lt;&lt; p2-&gt;m_name &lt;&lt; '\\n';\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\tstd::shared_ptr&lt;Person&gt; getPartner() const { return m_partner.lock(); } \/\/ use lock() to convert weak_ptr to shared_ptr\r\n\tconst std::string&amp; getName() const { return m_name; }\r\n};\r\n\r\nint main()\r\n{\r\n\tauto lucy { std::make_shared&lt;Person&gt;(\"Lucy\") };\r\n\tauto ricky { std::make_shared&lt;Person&gt;(\"Ricky\") };\r\n\r\n\tpartnerUp(lucy, ricky);\r\n\r\n\tauto partner = ricky-&gt;getPartner(); \/\/ get shared_ptr to Ricky's partner\r\n\tstd::cout &lt;&lt; ricky-&gt;getName() &lt;&lt; \"'s partner is: \" &lt;&lt; partner-&gt;getName() &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\nLucy created\r\nRicky created\r\nLucy is now partnered with Ricky\r\nRicky's partner is: Lucy\r\nRicky destroyed\r\nLucy destroyed\r\n<\/pre>\n<p>We don&#8217;t have to worry about circular dependencies with std::shared_ptr variable &#8220;partner&#8221; since it&#8217;s just a local variable inside the function.  It will eventually go out of scope at the end of the function and the reference count will be decremented by 1.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Avoiding dangling pointers with std::weak_ptr<\/p>\n<p>Consider the case where a normal &#8220;dumb&#8221; pointer is holding the address of some object, and then that object is destroyed.  Such a pointer is dangling, and dereferencing the pointer will lead to undefined behavior.  And unfortunately, there is no way for us to determine whether a pointer holding a non-null address is dangling or not.  This is a large part of the reason dumb pointers are dangerous.<\/p>\n<p>Because std::weak_ptr won&#8217;t keep an owned resource alive, it&#8217;s similarly possible for a std::weak_ptr to be left pointing to a resource that has been deallocated by a std::shared_ptr.  However, std::weak_ptr has a neat trick up its sleeve -- because it has access to the reference count for an object, it can determine if it is pointing to a valid object or not!  If the reference count is non-zero, the resource is still valid.  If the reference count is zero, then the resource has been destroyed.<\/p>\n<p>The easiest way to test whether a std::weak_ptr is valid is to use the <code>expired()<\/code> member function, which returns <code>true<\/code> if the std::weak_ptr is pointing to an invalid object, and <code>false<\/code> otherwise.<\/p>\n<p>Here&#8217;s a simple example showing this difference in behavior:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ h\/t to reader Waldo for an early version of this example\r\n#include &lt;iostream&gt;\r\n#include &lt;memory&gt;\r\n\r\nclass Resource\r\n{\r\npublic:\r\n\tResource() { std::cerr &lt;&lt; \"Resource acquired\\n\"; }\r\n\t~Resource() { std::cerr &lt;&lt; \"Resource destroyed\\n\"; }\r\n};\r\n\r\n\/\/ Returns a std::weak_ptr to an invalid object\r\nstd::weak_ptr&lt;Resource&gt; getWeakPtr()\r\n{\r\n\tauto ptr{ std::make_shared&lt;Resource&gt;() };\r\n\treturn std::weak_ptr&lt;Resource&gt;{ ptr };\r\n} \/\/ ptr goes out of scope, Resource destroyed\r\n\r\n\/\/ Returns a dumb pointer to an invalid object\r\nResource* getDumbPtr()\r\n{\r\n\tauto ptr{ std::make_unique&lt;Resource&gt;() };\r\n\treturn ptr.get();\r\n} \/\/ ptr goes out of scope, Resource destroyed\r\n\r\nint main()\r\n{\r\n\tauto dumb{ getDumbPtr() };\r\n\tstd::cout &lt;&lt; \"Our dumb ptr is: \" &lt;&lt; ((dumb == nullptr) ? \"nullptr\\n\" : \"non-null\\n\");\r\n\r\n\tauto weak{ getWeakPtr() };\r\n\tstd::cout &lt;&lt; \"Our weak ptr is: \" &lt;&lt; ((weak.expired()) ? \"expired\\n\" : \"valid\\n\");\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nResource acquired\r\nResource destroyed\r\nOur dumb ptr is: non-null\r\nResource acquired\r\nResource destroyed\r\nOur weak ptr is: expired\r\n<\/pre>\n<p>Both <code>getDumbPtr()<\/code> and <code>getWeakPtr()<\/code> use a smart pointer to allocate a Resource -- this smart pointer ensures that the allocated Resource will be destroyed at the end of the function.  When <code>getDumbPtr()<\/code> returns a Resource*, it returns a dangling pointer (because std::unique_ptr destroyed the Resource at the end of the function).  When <code>getWeakPtr()<\/code> returns a std::weak_ptr, that std::weak_ptr is similarly pointing to an invalid object (because std::shared_ptr destroyed the Resource at the end of the function).<\/p>\n<p>Inside main(), we first test whether the returned dumb pointer is <code>nullptr<\/code>.  Because the dumb pointer is still holding the address of the deallocated resource, this test fails.  There is no way for <code>main()<\/code> to tell whether this pointer is dangling or not.  In this case, because it is a dangling pointer, if we were to dereference this pointer, undefined behavior would result.<\/p>\n<p>Next, we test whether <code>weak.expired()<\/code> is <code>true<\/code>.  Because the reference count for the object being pointed to by <code>weak<\/code> is <code>0<\/code> (because the object being pointed to was already destroyed), this resolves to <code>true<\/code>.  The code in <code>main()<\/code> can thus tell that <code>weak<\/code> is pointing to an invalid object, and we can conditionalize our code as appropriate!<\/p>\n<p>Note that if a std::weak_ptr is expired, then we shouldn&#8217;t call <code>lock()<\/code> on it, because the object being pointed to has already been destroyed, so there is no object to share.  If you do call <code>lock()<\/code> on an expired std::weak_ptr, it will return a std::shared_ptr to <code>nullptr<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Conclusion<\/p>\n<p>std::shared_ptr can be used when you need multiple smart pointers that can co-own a resource.  The resource will be deallocated when the last std::shared_ptr goes out of scope.  std::weak_ptr can be used when you want a smart pointer that can see and use a shared resource, but does not participate in the ownership of that resource.<\/p>\n<p><p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p><p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p><\/p>\n<ol start=\"1\">\n<li>Fix the program presented in the section &#8220;A reductive case&#8221; so that the Resource is properly deallocated.  Do not alter the code in <code>main()<\/code>.\n<\/li>\n<\/ol>\n<p>Here is the program again for ease of reference:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;memory&gt; \/\/ for std::shared_ptr\r\n\r\nclass Resource\r\n{\r\npublic:\r\n\tstd::shared_ptr&lt;Resource&gt; m_ptr {}; \/\/ initially created empty\r\n\t\r\n\tResource() { std::cout &lt;&lt; \"Resource acquired\\n\"; }\r\n\t~Resource() { std::cout &lt;&lt; \"Resource destroyed\\n\"; }\r\n};\r\n\r\nint main()\r\n{\r\n\tauto ptr1 { std::make_shared&lt;Resource&gt;() };\r\n\r\n\tptr1-&gt;m_ptr = ptr1; \/\/ m_ptr is now sharing the Resource that contains it\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;memory&gt; \/\/ for std::shared_ptr and std::weak_ptr\r\n\r\nclass Resource\r\n{\r\npublic:\r\n\tstd::weak_ptr&lt;Resource&gt; m_ptr {}; \/\/ use std::weak_ptr so m_ptr doesn't keep the Resource alive\r\n\t\r\n\tResource() { std::cout &lt;&lt; \"Resource acquired\\n\"; }\r\n\t~Resource() { std::cout &lt;&lt; \"Resource destroyed\\n\"; }\r\n};\r\n\r\nint main()\r\n{\r\n\tauto ptr1 { std::make_shared&lt;Resource&gt;() };\r\n\r\n\tptr1-&gt;m_ptr = ptr1; \/\/ m_ptr is now sharing the Resource that contains it\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-22-summary-and-quiz\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">22.x<\/span>Chapter 22 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdshared_ptr\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">22.6<\/span>std::shared_ptr\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the previous lesson, we saw how std::shared_ptr allowed us to have multiple smart pointers co-owning the same resource. However, in certain cases, this can become problematic. Consider the following case, where the shared pointers in two separate objects each point at the other object: #include &lt;iostream&gt; #include &lt;memory&gt; \/\/ &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5635"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=5635"}],"version-history":[{"count":32,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5635\/revisions"}],"predecessor-version":[{"id":17376,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5635\/revisions\/17376"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=5635"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=5635"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=5635"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}