{"id":13201,"date":"2022-06-16T14:19:32","date_gmt":"2022-06-16T21:19:32","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=13201"},"modified":"2025-02-11T19:19:23","modified_gmt":"2025-02-12T03:19:23","slug":"numeral-systems-decimal-binary-hexadecimal-and-octal","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/numeral-systems-decimal-binary-hexadecimal-and-octal\/","title":{"rendered":"5.3 &#8212; Numeral systems (decimal, binary, hexadecimal, and octal)"},"content":{"rendered":"<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>This lesson is optional.<\/p>\n<p>Future lessons reference hexadecimal numbers, so you should at least have a passing familiarity with the concept before proceeding.\n<\/p><\/div>\n<p>In everyday life, we count using <strong>decimal<\/strong> numbers, where each numerical digit can be 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9.  Decimal is also called &#8220;base 10&#8221;, because there are 10 possible digits (0 through 9).  In this system, we count like this: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, &#8230;  By default, numbers in C++ programs are assumed to be decimal.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int x { 12 }; \/\/ 12 is assumed to be a decimal number<\/code><\/pre>\n<p>In <strong>binary<\/strong>, there are only 2 digits: 0 and 1, so it is called &#8220;base 2&#8221;.  In binary, we count like this: 0, 1, 10, 11, 100, 101, 110, 111, &#8230;  To make them easier to read, longer binary numbers are often space-separated into groups of 4 digits (e.g. 1101 0100). <\/p>\n<p>Decimal and binary are two examples of <strong>numeral systems<\/strong>, which is a fancy name for a collection of symbols (e.g. digits) used to represent numbers.  There are 4 main numeral systems available in C++.  In order of popularity, these are: decimal (base 10), binary (base 2), hexadecimal (base 16), and octal (base 8).<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Nomenclature<\/p>\n<p>In both decimal and binary, the numbers <code>0<\/code> and <code>1<\/code> have the same meaning.  In both systems, we call these numbers &#8220;zero&#8221; and &#8220;one&#8221;.<\/p>\n<p>But what about the number <code>10<\/code>?  <code>10<\/code> is the number that occurs after the last single-digit number in the number system.  In decimal, <code>10<\/code> is equal to nine plus one.  We call this number &#8220;ten&#8221;.<\/p>\n<p>In binary, <code>10<\/code> uses the same digits, but is equal to one plus one (the equivalent of two in decimal).  It would be confusing to call binary <code>10<\/code> &#8220;ten&#8221;, because &#8220;ten&#8221; is nine plus one, and this <code>10<\/code> is one plus one.<\/p>\n<p>Because of this, the names &#8220;ten&#8221;, &#8220;eleven&#8221;, &#8220;twelve&#8221;, etc&#8230; are typically reserved for decimal numbers.  In non-decimal number systems, we prefer to call those numbers one-zero, one-one, one-two, etc&#8230;  Binary 101 isn&#8217;t &#8220;one hundred and one&#8221;, it&#8217;s &#8220;one-zero-one&#8221;.\n<\/p><\/div>\n<p class=\"cpp-section\">Octal and hexadecimal literals<\/p>\n<p><strong>Octal<\/strong> is base 8 -- that is, the only digits available are: 0, 1, 2, 3, 4, 5, 6, and 7.  In Octal, we count like this: 0, 1, 2, 3, 4, 5, 6, 7, 10, 11, 12, &#8230; (note: no 8 and 9, so we skip from 7 to 10).<\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<td>Decimal<\/td>\n<td>0<\/td>\n<td>1<\/td>\n<td>2<\/td>\n<td>3<\/td>\n<td>4<\/td>\n<td>5<\/td>\n<td>6<\/td>\n<td>7<\/td>\n<td>8<\/td>\n<td>9<\/td>\n<td>10<\/td>\n<td>11<\/td>\n<\/tr>\n<tr>\n<td>Octal<\/td>\n<td>0<\/td>\n<td>1<\/td>\n<td>2<\/td>\n<td>3<\/td>\n<td>4<\/td>\n<td>5<\/td>\n<td>6<\/td>\n<td>7<\/td>\n<td>10<\/td>\n<td>11<\/td>\n<td>12<\/td>\n<td>13<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>To use an octal literal, prefix your literal with a 0 (zero):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x{ 012 }; \/\/ 0 before the number means this is octal\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n';\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\n10\r\n<\/pre>\n<p>Why 10 instead of 12?  Because numbers are output in decimal by default, and 12 octal = 10 decimal.<\/p>\n<p>Octal is hardly ever used, and we recommend you avoid it.<\/p>\n<p><strong>Hexadecimal<\/strong> is base 16.  In hexadecimal, we count like this: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, 10, 11, 12, &#8230;<\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<td>Decimal<\/td>\n<td>0<\/td>\n<td>1<\/td>\n<td>2<\/td>\n<td>3<\/td>\n<td>4<\/td>\n<td>5<\/td>\n<td>6<\/td>\n<td>7<\/td>\n<td>8<\/td>\n<td>9<\/td>\n<td>10<\/td>\n<td>11<\/td>\n<td>12<\/td>\n<td>13<\/td>\n<td>14<\/td>\n<td>15<\/td>\n<td>16<\/td>\n<td>17<\/td>\n<\/tr>\n<tr>\n<td>Hexadecimal<\/td>\n<td>0<\/td>\n<td>1<\/td>\n<td>2<\/td>\n<td>3<\/td>\n<td>4<\/td>\n<td>5<\/td>\n<td>6<\/td>\n<td>7<\/td>\n<td>8<\/td>\n<td>9<\/td>\n<td>A<\/td>\n<td>B<\/td>\n<td>C<\/td>\n<td>D<\/td>\n<td>E<\/td>\n<td>F<\/td>\n<td>10<\/td>\n<td>11<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>You can also use lower case letters (though upper case is more common).<\/p>\n<p>To use a hexadecimal literal, prefix your literal with <code>0x<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x{ 0xF }; \/\/ 0x before the number means this is hexadecimal\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n';\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\n15\r\n<\/pre>\n<p>You can also use a <code>0X<\/code> prefix, but <code>0x<\/code> is conventional because its easier to read.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Numeral systems tables<\/p>\n<p>Here are the four numeral systems lined up, to make it easier to see how each progresses:<\/p>\n<pre>\nDecimal         0     1     2     3     4     5     6     7     8     9    10    11    12    13    14    15\r\nBinary          0     1    10    11   100   101   110   111  1000  1001  1010  1011  1100  1101  1110  1111\r\nOctal           0     1     2     3     4     5     6     7    10    11    12    13    14    15    16    17\r\nHexadecimal     0     1     2     3     4     5     6     7     8     9     A     B     C     D     E     F\r\n\r\nDecimal        16    17    18    19    20    21    22    23    24    25    26    27    28    29    30    31\r\nBinary      10000 10001 10010 10011 10100 10101 10110 10111 11000 11001 11010 11011 11100 11101 11110 11111\r\nOctal          20    21    22    23    24    25    26    27    30    31    32    33    34    35    36    37\r\nHexadecimal    10    11    12    13    14    15    16    17    18    19    1A    1B    1C    1D    1E    1F\r\n\r\n<\/pre>\n<p>Each of these rows contains the same pattern:  The rightmost digit is incremented from 0 to (base-1).  When the digit reaches (base), it is reset to 0 and the digit to the left is incremented by 1.  If this left digit reaches (base), it is reset to 0 and the digit to the left of that one is incremented by 1.  And so on&#8230;<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using hexadecimal to represent binary<\/p>\n<p>Because there are 16 different values for a hexadecimal digit, we can say that a single hexadecimal digit encompasses 4 bits.  Consequently, a pair of hexadecimal digits can be used to exactly represent a full byte.<\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<td>Hexadecimal<\/td>\n<td>0<\/td>\n<td>1<\/td>\n<td>2<\/td>\n<td>3<\/td>\n<td>4<\/td>\n<td>5<\/td>\n<td>6<\/td>\n<td>7<\/td>\n<td>8<\/td>\n<td>9<\/td>\n<td>A<\/td>\n<td>B<\/td>\n<td>C<\/td>\n<td>D<\/td>\n<td>E<\/td>\n<td>F<\/td>\n<\/tr>\n<tr>\n<td>Binary<\/td>\n<td>0000<\/td>\n<td>0001<\/td>\n<td>0010<\/td>\n<td>0011<\/td>\n<td>0100<\/td>\n<td>0101<\/td>\n<td>0110<\/td>\n<td>0111<\/td>\n<td>1000<\/td>\n<td>1001<\/td>\n<td>1010<\/td>\n<td>1011<\/td>\n<td>1100<\/td>\n<td>1101<\/td>\n<td>1110<\/td>\n<td>1111<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>Consider a 32-bit integer with binary value 0011 1010 0111 1111 1001 1000 0010 0110.  Because of the length and repetition of digits, that&#8217;s not easy to read.  In hexadecimal, this same value would be: 3A7F 9826, which is much more concise.  For this reason, hexadecimal values are often used to represent memory addresses or raw data in memory (whose type isn&#8217;t known).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Binary literals<\/p>\n<p>Prior to C++14, there is no support for binary literals.  However, hexadecimal literals provide us with a useful workaround (that you may still see in existing code bases):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int bin{};    \/\/ assume 16-bit ints\r\n    bin = 0x0001; \/\/ assign binary 0000 0000 0000 0001 to the variable\r\n    bin = 0x0002; \/\/ assign binary 0000 0000 0000 0010 to the variable\r\n    bin = 0x0004; \/\/ assign binary 0000 0000 0000 0100 to the variable\r\n    bin = 0x0008; \/\/ assign binary 0000 0000 0000 1000 to the variable\r\n    bin = 0x0010; \/\/ assign binary 0000 0000 0001 0000 to the variable\r\n    bin = 0x0020; \/\/ assign binary 0000 0000 0010 0000 to the variable\r\n    bin = 0x0040; \/\/ assign binary 0000 0000 0100 0000 to the variable\r\n    bin = 0x0080; \/\/ assign binary 0000 0000 1000 0000 to the variable\r\n    bin = 0x00FF; \/\/ assign binary 0000 0000 1111 1111 to the variable\r\n    bin = 0x00B3; \/\/ assign binary 0000 0000 1011 0011 to the variable\r\n    bin = 0xF770; \/\/ assign binary 1111 0111 0111 0000 to the variable\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In C++14 onward, we can use binary literals by using the 0b prefix:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int bin{};        \/\/ assume 16-bit ints\r\n    bin = 0b1;        \/\/ assign binary 0000 0000 0000 0001 to the variable\r\n    bin = 0b11;       \/\/ assign binary 0000 0000 0000 0011 to the variable\r\n    bin = 0b1010;     \/\/ assign binary 0000 0000 0000 1010 to the variable\r\n    bin = 0b11110000; \/\/ assign binary 0000 0000 1111 0000 to the variable\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Digit separators<\/p>\n<p>Because long literals can be hard to read, C++14 also adds the ability to use a quotation mark (&#8216;) as a digit separator.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int bin { 0b1011'0010 };  \/\/ assign binary 1011 0010 to the variable\r\n    long value { 2'132'673'462 }; \/\/ much easier to read than 2132673462\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Also note that the separator can not occur before the first digit of the value:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    int bin { 0b'1011'0010 };  \/\/ error: ' used before first digit of value<\/code><\/pre>\n<p>Digit separators are purely visual and do not impact the literal value in any way.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Outputting values in decimal, octal, or hexadecimal<\/p>\n<p>By default, C++ outputs values in decimal.  However, you can change the output format via use of the <code>std::dec<\/code>, <code>std::oct<\/code>, and <code>std::hex<\/code> I\/O manipulators:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 12 };\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n'; \/\/ decimal (by default)\r\n    std::cout &lt;&lt; std::hex &lt;&lt; x &lt;&lt; '\\n'; \/\/ hexadecimal\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n'; \/\/ now hexadecimal\r\n    std::cout &lt;&lt; std::oct &lt;&lt; x &lt;&lt; '\\n'; \/\/ octal\r\n    std::cout &lt;&lt; std::dec &lt;&lt; x &lt;&lt; '\\n'; \/\/ return to decimal\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n'; \/\/ decimal\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n12\r\nc\r\nc\r\n14\r\n12\r\n12\r\n<\/pre>\n<p>Note that once applied, the I\/O manipulator remains set for future output until it is changed again.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Outputting values in binary<\/p>\n<p>Outputting values in binary is a little harder, as <code>std::cout<\/code> doesn&#8217;t come with this capability built-in.  Fortunately, the C++ standard library includes a type called <code>std::bitset<\/code> that will do this for us (in the &lt;bitset&gt; header).<\/p>\n<p>To use <code>std::bitset<\/code>, we can define a <code>std::bitset<\/code> variable and tell <code>std::bitset<\/code> how many bits we want to store.  The number of bits must be a compile-time constant.  <code>std::bitset<\/code> can be initialized with an integral value (in any format, including decimal, octal, hex, or binary).<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;bitset&gt; \/\/ for std::bitset\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\t\/\/ std::bitset&lt;8&gt; means we want to store 8 bits\r\n\tstd::bitset&lt;8&gt; bin1{ 0b1100'0101 }; \/\/ binary literal for binary 1100 0101\r\n\tstd::bitset&lt;8&gt; bin2{ 0xC5 }; \/\/ hexadecimal literal for binary 1100 0101\r\n\r\n\tstd::cout &lt;&lt; bin1 &lt;&lt; '\\n' &lt;&lt; bin2 &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; std::bitset&lt;4&gt;{ 0b1010 } &lt;&lt; '\\n'; \/\/ create a temporary std::bitset and print it\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n11000101\r\n11000101\r\n1010\r\n<\/pre>\n<p>In the above code, this line:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::cout &lt;&lt; std::bitset&lt;4&gt;{ 0b1010 } &lt;&lt; '\\n'; \/\/ create a temporary std::bitset and print it<\/code><\/pre>\n<p>creates a temporary (unnamed) <code>std::bitset<\/code> object with 4 bits, initializes it with binary literal <code>0b1010<\/code>, prints the value in binary, and then discards the temporary object.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover std::bitset in more detail in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/bit-flags-and-bit-manipulation-via-stdbitset\/\">O.1 -- Bit flags and bit manipulation via std::bitset<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Outputting values in binary using the Format \/ Print Library <span class=\"cpp-section-pill cpp-section-advanced\">Advanced<\/span><\/p>\n<p>In C++20 and C++23, we have better options for printing binary via the new Format Library (C++20) and Print Library (C++23):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;format&gt; \/\/ C++20\r\n#include &lt;iostream&gt;\r\n#include &lt;print&gt; \/\/ C++23\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; std::format(\"{:b}\\n\", 0b1010);  \/\/ C++20, {:b} formats the argument as binary digits\r\n    std::cout &lt;&lt; std::format(\"{:#b}\\n\", 0b1010); \/\/ C++20, {:#b} formats the argument as 0b-prefixed binary digits\r\n\r\n    std::println(\"{:b} {:#b}\", 0b1010, 0b1010);  \/\/ C++23, format\/print two arguments (same as above) and a newline\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n1010\r\n0b1010\r\n1010 0b1010\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Using the tables above, what is 32 in binary and hexadecimal?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>Binary: 10 0000<br \/>\nHex: 20\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/the-as-if-rule-and-compile-time-optimization\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">5.4<\/span>The as-if rule and compile-time optimization\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/literals\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">5.2<\/span>Literals\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Author&#8217;s note This lesson is optional. Future lessons reference hexadecimal numbers, so you should at least have a passing familiarity with the concept before proceeding. In everyday life, we count using numbers, where each numerical digit can be 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9. Decimal &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/13201"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=13201"}],"version-history":[{"count":23,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/13201\/revisions"}],"predecessor-version":[{"id":18189,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/13201\/revisions\/18189"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=13201"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=13201"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=13201"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}