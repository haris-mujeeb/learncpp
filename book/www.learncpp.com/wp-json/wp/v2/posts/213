{"id":213,"date":"2008-10-04T13:29:37","date_gmt":"2008-10-04T21:29:37","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=213"},"modified":"2025-01-06T14:25:19","modified_gmt":"2025-01-06T22:25:19","slug":"basic-exception-handling","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/basic-exception-handling\/","title":{"rendered":"27.2 &#8212; Basic exception handling"},"content":{"rendered":"<p>In the previous lesson on <a href=\"http:\/\/www.learncpp.com\/cpp-tutorial\/151-the-need-for-exceptions\/\">the need for exceptions<\/a>, we talked about how using return codes causes your control flow and error flow to be intermingled, constraining both.  Exceptions in C++ are implemented using three keywords that work in conjunction with each other: <strong>throw<\/strong>, <strong>try<\/strong>, and <strong>catch<\/strong>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Throwing exceptions<\/p>\n<p>We use signals all the time in real life to note that particular events have occurred.  For example, during American football, if a player has committed a foul, the referee will throw a flag on the ground and whistle the play dead.  A penalty is then assessed and executed.  Once the penalty has been taken care of, play generally resumes as normal.<\/p>\n<p>In C++, a <strong>throw statement<\/strong> is used to signal that an exception or error case has occurred (think of throwing a penalty flag).  Signaling that an exception has occurred is also commonly called <strong>raising<\/strong> an exception.<\/p>\n<p>To use a throw statement, simply use the throw keyword, followed by a value of any data type you wish to use to signal that an error has occurred.  Typically, this value will be an error code, a description of the problem, or a custom exception class.<\/p>\n<p>Here are some examples:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">throw -1; \/\/ throw a literal integer value\r\nthrow ENUM_INVALID_INDEX; \/\/ throw an enum value\r\nthrow \"Can not take square root of negative number\"; \/\/ throw a literal C-style (const char*) string\r\nthrow dX; \/\/ throw a double variable that was previously defined\r\nthrow MyException(\"Fatal Error\"); \/\/ Throw an object of class MyException<\/code><\/pre>\n<p>Each of these statements acts as a signal that some kind of problem that needs to be handled has occurred.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Looking for exceptions<\/p>\n<p>Throwing exceptions is only one part of the exception handling process.  Let&#8217;s go back to our American football analogy: once a referee has thrown a penalty flag, what happens next?  The players notice that a penalty has occurred and stop play.  The normal flow of the football game is disrupted.<\/p>\n<p>In C++, we use the <strong>try<\/strong> keyword to define a block of statements (called a <strong>try block<\/strong>).  The try block acts as an observer, looking for any exceptions that are thrown by any of the statements within the try block.<\/p>\n<p>Here&#8217;s an example of a try block:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">try\r\n{\r\n    \/\/ Statements that may throw exceptions you want to handle go here\r\n    throw -1; \/\/ here's a trivial throw statement\r\n}<\/code><\/pre>\n<p>Note that the try block doesn&#8217;t define HOW we&#8217;re going to handle the exception.  It merely tells the program, &#8220;Hey, if any of the statements inside this try block throws an exception, grab it!&#8221;.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Handling exceptions<\/p>\n<p>Finally, the end of our American football analogy: After the penalty has been called and play has stopped, the referee assesses the penalty and executes it.  In other words, the penalty must be handled before normal play can resume.<\/p>\n<p>Actually handling exceptions is the job of the catch block(s).  The <strong>catch<\/strong> keyword is used to define a block of code (called a <strong>catch block<\/strong>) that handles exceptions for a single data type.<\/p>\n<p>Here&#8217;s an example of a catch block that will catch integer exceptions:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">catch (int x)\r\n{\r\n    \/\/ Handle an exception of type int here\r\n    std::cerr &lt;&lt; \"We caught an int exception with value\" &lt;&lt; x &lt;&lt; '\\n';\r\n}<\/code><\/pre>\n<p>Try blocks and catch blocks work together -- a try block detects any exceptions that are thrown by statements within the try block, and routes them to a catch block with a matching type for handling.  A try block must have at least one catch block immediately following it, but may have multiple catch blocks listed in sequence.<\/p>\n<p>Once an exception has been caught by the try block and routed to a matching catch block for handling, the exception is considered handled.  After the matching catch block executes, execution then resumes as normal, starting with the first statement after the last catch block.<\/p>\n<p>Catch parameters work just like function parameters, with the parameter being available within the subsequent catch block.  Exceptions of fundamental types can be caught by value, but exceptions of non-fundamental types should be caught by const reference to avoid making an unnecessary copy (and, in some cases, to prevent slicing).<\/p>\n<p>Just like with functions, if the parameter is not going to be used in the catch block, the variable name can be omitted:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">catch (double) \/\/ note: no variable name since we don't use it in the catch block below\r\n{\r\n    \/\/ Handle exception of type double here\r\n    std::cerr &lt;&lt; \"We caught an exception of type double\\n\";\r\n}<\/code><\/pre>\n<p>This can help prevent compiler warnings about unused variables.<\/p>\n<p>No type conversion is done for exceptions (so an int exception will not be converted to match a catch block with a double parameter).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Putting throw, try, and catch together<\/p>\n<p>Here&#8217;s a full program that uses throw, try, and multiple catch blocks:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nint main()\r\n{\r\n    try\r\n    {\r\n        \/\/ Statements that may throw exceptions you want to handle go here\r\n        throw -1; \/\/ here's a trivial example\r\n    }\r\n    catch (double) \/\/ no variable name since we don't use the exception itself in the catch block below\r\n    {\r\n        \/\/ Any exceptions of type double thrown within the above try block get sent here\r\n        std::cerr &lt;&lt; \"We caught an exception of type double\\n\";\r\n    }\r\n    catch (int x)\r\n    {\r\n        \/\/ Any exceptions of type int thrown within the above try block get sent here\r\n        std::cerr &lt;&lt; \"We caught an int exception with value: \" &lt;&lt; x &lt;&lt; '\\n';\r\n    }\r\n    catch (const std::string&amp;) \/\/ catch classes by const reference\r\n    {\r\n        \/\/ Any exceptions of type std::string thrown within the above try block get sent here\r\n        std::cerr &lt;&lt; \"We caught an exception of type std::string\\n\";\r\n    }\r\n\r\n    \/\/ Execution continues here after the exception has been handled by any of the above catch blocks\r\n    std::cout &lt;&lt; \"Continuing on our merry way\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>On the authors machine, running the above try\/catch block produces the following result:<\/p>\n<pre>\nWe caught an int exception with value -1\r\nContinuing on our merry way\r\n<\/pre>\n<p>A throw statement was used to raise an exception with the value -1, which is of type int.  The throw statement was then caught by the enclosing try block, and routed to the appropriate catch block that handles exceptions of type int.  This catch block printed the appropriate error message.<\/p>\n<p>Once the exception was handled, the program continued as normal after the catch blocks, printing &#8220;Continuing on our merry way&#8221;.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Recapping exception handling<\/p>\n<p>Exception handling is actually quite simple, and the following two paragraphs cover most of what you need to remember about it:<\/p>\n<p>When an exception is raised (using <strong>throw<\/strong>), the running program finds the nearest enclosing <strong>try<\/strong> block (propagating up the stack if necessary to find an enclosing try block -- we&#8217;ll discuss this in more detail next lesson) to see if any of the <strong>catch<\/strong> handlers attached to the try block can handle that type of exception.  If so, execution jumps to the top of the catch block, the exception is considered handled.<\/p>\n<p>If no appropriate catch handlers exist in the nearest enclosing try block, the program continues to look at subsequent enclosing try blocks for a catch handler.  If no appropriate catch handlers can be found before the end of the program, the program will fail with a runtime exception error.<\/p>\n<p>Note that the program will not perform implicit conversions or promotions when matching exceptions with catch blocks!  For example, a char exception will not match with an int catch block.  An int exception will not match a float catch block. However, casts from a derived class to one of its parent classes will be performed.<\/p>\n<p>That&#8217;s really all there is to it.  The rest of this chapter will be dedicated to showing examples of these principles at work.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Exceptions are handled immediately<\/p>\n<p>Here&#8217;s a short program that demonstrates how exceptions are handled immediately:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    try\r\n    {\r\n        throw 4.5; \/\/ throw exception of type double\r\n        std::cout &lt;&lt; \"This never prints\\n\";\r\n    }\r\n    catch (double x) \/\/ handle exception of type double\r\n    {\r\n        std::cerr &lt;&lt; \"We caught a double of value: \" &lt;&lt; x &lt;&lt; '\\n';\r\n    }\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program is about as simple as it gets.  Here&#8217;s what happens: the throw statement is the first statement that gets executed -- this causes an exception of type double to be raised.  Execution <em>immediately<\/em> moves to the nearest enclosing try block, which is the only try block in this program.  The catch handlers are then checked to see if any handler matches.  Our exception is of type double, so we&#8217;re looking for a catch handler of type double.  We have one, so it executes.<\/p>\n<p>Consequently, the result of this program is as follows:<\/p>\n<pre>\nWe caught a double of value: 4.5\r\n<\/pre>\n<p>Note that &#8220;This never prints&#8221; is never printed, because the exception caused the execution path to jump immediately to the exception handler for doubles.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A more realistic example<\/p>\n<p>Let&#8217;s take a look at an example that&#8217;s not quite so academic:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cmath&gt; \/\/ for sqrt() function\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter a number: \";\r\n    double x {};\r\n    std::cin &gt;&gt; x;\r\n\r\n    try \/\/ Look for exceptions that occur within try block and route to attached catch block(s)\r\n    {\r\n        \/\/ If the user entered a negative number, this is an error condition\r\n        if (x &lt; 0.0)\r\n            throw \"Can not take sqrt of negative number\"; \/\/ throw exception of type const char*\r\n\r\n        \/\/ Otherwise, print the answer\r\n        std::cout &lt;&lt; \"The sqrt of \" &lt;&lt; x &lt;&lt; \" is \" &lt;&lt; std::sqrt(x) &lt;&lt; '\\n';\r\n    }\r\n    catch (const char* exception) \/\/ catch exceptions of type const char*\r\n    {\r\n        std::cerr &lt;&lt; \"Error: \" &lt;&lt; exception &lt;&lt; '\\n';\r\n    }\r\n}<\/code><\/pre>\n<p>In this code, the user is asked to enter a number.  If they enter a positive number, the if statement does not execute, no exception is thrown, and the square root of the number is printed.  Because no exception is thrown in this case, the code inside the catch block never executes.  The result is something like this:<\/p>\n<pre>\nEnter a number: 9\r\nThe sqrt of 9 is 3\r\n<\/pre>\n<p>If the user enters a negative number, we throw an exception of type const char<em>.  Because we&#8217;re within a try block and a matching exception handler is found, control immediately transfers to the const char<\/em> exception handler.  The result is:<\/p>\n<pre>\nEnter a number: -4\r\nError: Can not take sqrt of negative number\r\n<\/pre>\n<p>By now, you should be getting the basic idea behind exceptions.  In the next lesson, we&#8217;ll do quite a few more examples to show how flexible exceptions are.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">What catch blocks typically do<\/p>\n<p>If an exception is routed to a catch block, it is considered &#8220;handled&#8221; even if the catch block is empty.  However, typically you&#8217;ll want your catch blocks to do something useful.  There are four common things that catch blocks do when they catch an exception:<\/p>\n<p>First, catch blocks may print an error (either to the console, or a log file) and then allow the function to proceed.<\/p>\n<p>Second, catch blocks may return a value or error code back to the caller.<\/p>\n<p>Third, a catch block may throw another exception.  Because the catch block is outside of the try block, the newly thrown exception in this case is not handled by the preceding try block -- it&#8217;s handled by the next enclosing try block.<\/p>\n<p>Fourth, a catch block in main() may be used to catch fatal errors and terminate the program in a clean way.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/exceptions-functions-and-stack-unwinding\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">27.3<\/span>Exceptions, functions, and stack unwinding\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/the-need-for-exceptions\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">27.1<\/span>The need for exceptions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the previous lesson on the need for exceptions, we talked about how using return codes causes your control flow and error flow to be intermingled, constraining both. Exceptions in C++ are implemented using three keywords that work in conjunction with each other: throw, try, and catch. Throwing exceptions We &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[12,25,14,16],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/213"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=213"}],"version-history":[{"count":29,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/213\/revisions"}],"predecessor-version":[{"id":18091,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/213\/revisions\/18091"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=213"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=213"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=213"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}