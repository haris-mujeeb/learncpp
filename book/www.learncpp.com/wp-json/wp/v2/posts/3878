{"id":3878,"date":"2016-04-05T11:41:07","date_gmt":"2016-04-05T19:41:07","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=3878"},"modified":"2024-06-12T17:32:53","modified_gmt":"2024-06-13T00:32:53","slug":"header-guards","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/header-guards\/","title":{"rendered":"2.12 &#8212; Header guards"},"content":{"rendered":"<p class=\"cpp-section\">The duplicate definition problem<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/forward-declarations\/\">2.7 -- Forward declarations and definitions<\/a>, we noted that a variable or function identifier can only have one definition (the one definition rule).  Thus, a program that defines a variable identifier more than once will cause a compile error:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int x; \/\/ this is a definition for variable x\r\n    int x; \/\/ compile error: duplicate definition\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Similarly, programs that define a function more than once will also cause a compile error:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint foo() \/\/ this is a definition for function foo\r\n{\r\n    return 5;\r\n}\r\n\r\nint foo() \/\/ compile error: duplicate definition\r\n{\r\n    return 5;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; foo();\r\n    return 0;\r\n}<\/code><\/pre>\n<p>While these programs are easy to fix (remove the duplicate definition), with header files, it&#8217;s quite easy to end up in a situation where a definition in a header file gets included more than once.  This can happen when a header file #includes another header file (which is common).<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>In upcoming examples, we&#8217;ll define some functions inside header files.  You generally shouldn&#8217;t do this.<\/p>\n<p>We are doing so here because it is the most effective way to demonstrate some concepts using functionality we&#8217;ve already covered.\n<\/p><\/div>\n<p>Consider the following academic example:<\/p>\n<p>square.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int getSquareSides()\r\n{\r\n    return 4;\r\n}<\/code><\/pre>\n<p>wave.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"square.h\"<\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"square.h\"\r\n#include \"wave.h\"\r\n\r\nint main()\r\n{\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This seemingly innocent looking program won&#8217;t compile!  Here&#8217;s what&#8217;s happening.  First, <em>main.cpp<\/em> #includes <em>square.h<\/em>, which copies the definition for function <em>getSquareSides<\/em> into <em>main.cpp<\/em>.  Then <em>main.cpp<\/em> #includes <em>wave.h<\/em>, which #includes <em>square.h<\/em> itself.  This copies contents of <em>square.h<\/em> (including the definition for function <em>getSquareSides<\/em>) into <em>wave.h<\/em>, which then gets copied into <em>main.cpp<\/em>.<\/p>\n<p>Thus, after resolving all of the #includes, <em>main.cpp<\/em> ends up looking like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int getSquareSides()  \/\/ from square.h\r\n{\r\n    return 4;\r\n}\r\n\r\nint getSquareSides() \/\/ from wave.h (via square.h)\r\n{\r\n    return 4;\r\n}\r\n\r\nint main()\r\n{\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Duplicate definitions and a compile error.  Each file, individually, is fine.  However, because <em>main.cpp<\/em> ends up #including the content of <em>square.h<\/em> twice, we&#8217;ve run into problems.  If <em>wave.h<\/em> needs <em>getSquareSides()<\/em>, and <em>main.cpp<\/em> needs both <em>wave.h<\/em> and <em>square.h<\/em>, how would you resolve this issue?<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Header guards<\/p>\n<p>The good news is that we can avoid the above problem via a mechanism called a <strong>header guard<\/strong> (also called an <strong>include guard<\/strong>).  Header guards are conditional compilation directives that take the following form:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef SOME_UNIQUE_NAME_HERE\r\n#define SOME_UNIQUE_NAME_HERE\r\n\r\n\/\/ your declarations (and certain types of definitions) here\r\n\r\n#endif<\/code><\/pre>\n<p>When this header is #included, the preprocessor will check whether <em>SOME_UNIQUE_NAME_HERE<\/em> has been previously defined in this translation unit.  If this is the first time we&#8217;re including the header, <em>SOME_UNIQUE_NAME_HERE<\/em> will not have been defined.  Consequently, it #defines <em>SOME_UNIQUE_NAME_HERE<\/em> and includes the contents of the file.  If the header is included again into the same file, <em>SOME_UNIQUE_NAME_HERE<\/em> will already have been defined from the first time the contents of the header were included, and the contents of the header will be ignored (thanks to the #ifndef).<\/p>\n<p>All of your header files should have header guards on them.  <em>SOME_UNIQUE_NAME_HERE<\/em> can be any name you want, but by convention is set to the full filename of the header file, typed in all caps, using underscores for spaces or punctuation.  For example, <em>square.h<\/em> would have the header guard:<\/p>\n<p>square.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef SQUARE_H\r\n#define SQUARE_H\r\n\r\nint getSquareSides()\r\n{\r\n    return 4;\r\n}\r\n\r\n#endif<\/code><\/pre>\n<p>Even the standard library headers use header guards.  If you were to take a look at the iostream header file from Visual Studio, you would see:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef _IOSTREAM_\r\n#define _IOSTREAM_\r\n\r\n\/\/ content here\r\n\r\n#endif<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>In large programs, it&#8217;s possible to have two separate header files (included from different directories) that end up having the same filename (e.g. directoryA\\config.h and directoryB\\config.h).  If only the filename is used for the include guard (e.g. CONFIG_H), these two files may end up using the same guard name.  If that happens, any file that includes (directly or indirectly) both config.h files will not receive the contents of the include file to be included second.  This will probably cause a compilation error.<\/p>\n<p>Because of this possibility for guard name conflicts, many developers recommend using a more complex\/unique name in your header guards.  Some good suggestions are a naming convention of PROJECT_PATH_FILE_H, FILE_LARGE-RANDOM-NUMBER_H, or FILE_CREATION-DATE_H.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Updating our previous example with header guards<\/p>\n<p>Let&#8217;s return to the <em>square.h<\/em> example, using the <em>square.h<\/em> with header guards.  For good form, we&#8217;ll also add header guards to <em>wave.h<\/em>.<\/p>\n<p>square.h<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef SQUARE_H\r\n#define SQUARE_H\r\n\r\nint getSquareSides()\r\n{\r\n    return 4;\r\n}\r\n\r\n#endif<\/code><\/pre>\n<p>wave.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef WAVE_H\r\n#define WAVE_H\r\n\r\n#include \"square.h\"\r\n\r\n#endif<\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"square.h\"\r\n#include \"wave.h\"\r\n\r\nint main()\r\n{\r\n    return 0;\r\n}<\/code><\/pre>\n<p>After the preprocessor resolves all of the #include directives, this program looks like this:<\/p>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Square.h included from main.cpp\r\n#ifndef SQUARE_H \/\/ square.h included from main.cpp\r\n#define SQUARE_H \/\/ SQUARE_H gets defined here\r\n\r\n\/\/ and all this content gets included\r\nint getSquareSides()\r\n{\r\n    return 4;\r\n}\r\n\r\n#endif \/\/ SQUARE_H\r\n\r\n#ifndef WAVE_H \/\/ wave.h included from main.cpp\r\n#define WAVE_H\r\n#ifndef SQUARE_H \/\/ square.h included from wave.h, SQUARE_H is already defined from above\r\n#define SQUARE_H \/\/ so none of this content gets included\r\n\r\nint getSquareSides()\r\n{\r\n    return 4;\r\n}\r\n\r\n#endif \/\/ SQUARE_H\r\n#endif \/\/ WAVE_H\r\n\r\nint main()\r\n{\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Let&#8217;s look at how this evaluates.<\/p>\n<p>First, the preprocessor evaluates <code>#ifndef SQUARE_H<\/code>. <code>SQUARE_H<\/code> has not been defined yet, so the code from the <code>#ifndef<\/code> to the subsequent <code>#endif<\/code> is included for compilation. This code defines <code>SQUARE_H<\/code>, and has the definition for the <code>getSquareSides<\/code> function.<\/p>\n<p>Later, the next <code>#ifndef SQUARE_H<\/code> is evaluated. This time, <code>SQUARE_H<\/code> is defined (because it got defined above), so the code from the <code>#ifndef<\/code> to the subsequent <code>#endif<\/code> is excluded from compilation.<\/p>\n<p>Header guards prevent duplicate inclusions because the first time a guard is encountered, the guard macro isn&#8217;t defined, so the guarded content is included. Past that point, the guard macro is defined, so any subsequent copies of the guarded content are excluded.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Header guards do not prevent a header from being included once into different code files<\/p>\n<p>Note that the goal of header guards is to prevent a code file from receiving more than one copy of a guarded header.  By design, header guards do <em>not<\/em> prevent a given header file from being included (once) into separate code files.  This can also cause unexpected problems.  Consider:<\/p>\n<p>square.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef SQUARE_H\r\n#define SQUARE_H\r\n\r\nint getSquareSides()\r\n{\r\n    return 4;\r\n}\r\n\r\nint getSquarePerimeter(int sideLength); \/\/ forward declaration for getSquarePerimeter\r\n\r\n#endif<\/code><\/pre>\n<p>square.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"square.h\"  \/\/ square.h is included once here\r\n\r\nint getSquarePerimeter(int sideLength)\r\n{\r\n    return sideLength * getSquareSides();\r\n}<\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"square.h\" \/\/ square.h is also included once here\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"a square has \" &lt;&lt; getSquareSides() &lt;&lt; \" sides\\n\";\r\n    std::cout &lt;&lt; \"a square of length 5 has perimeter length \" &lt;&lt; getSquarePerimeter(5) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Note that <em>square.h<\/em> is included from both <em>main.cpp<\/em> and <em>square.cpp<\/em>.  This means the contents of <em>square.h<\/em> will be included once into <em>square.cpp<\/em> and once into <em>main.cpp<\/em>.<\/p>\n<p>Let&#8217;s examine why this happens in more detail.  When <em>square.h<\/em> is included from <em>square.cpp<\/em>, <em>SQUARE_H<\/em> is defined until the end of <em>square.cpp<\/em>.  This define prevents <em>square.h<\/em> from being included into <em>square.cpp<\/em> a second time (which is the point of header guards).  However, once <em>square.cpp<\/em> is finished, <em>SQUARE_H<\/em> is no longer considered defined.  This means that when the preprocessor runs on <em>main.cpp<\/em>, <em>SQUARE_H<\/em> is not initially defined in <em>main.cpp<\/em>.<\/p>\n<p>The end result is that both <em>square.cpp<\/em> and <em>main.cpp<\/em> get a copy of the definition of <em>getSquareSides<\/em>.  This program will compile, but the linker will complain about your program having multiple definitions for identifier <em>getSquareSides<\/em>!<\/p>\n<p>The best way to work around this issue is simply to put the function definition in one of the .cpp files so that the header just contains a forward declaration:<\/p>\n<p>square.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef SQUARE_H\r\n#define SQUARE_H\r\n\r\nint getSquareSides(); \/\/ forward declaration for getSquareSides\r\nint getSquarePerimeter(int sideLength); \/\/ forward declaration for getSquarePerimeter\r\n\r\n#endif<\/code><\/pre>\n<p>square.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"square.h\"\r\n\r\nint getSquareSides() \/\/ actual definition for getSquareSides\r\n{\r\n    return 4;\r\n}\r\n\r\nint getSquarePerimeter(int sideLength)\r\n{\r\n    return sideLength * getSquareSides();\r\n}<\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include \"square.h\" \/\/ square.h is also included once here\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"a square has \" &lt;&lt; getSquareSides() &lt;&lt; \" sides\\n\";\r\n    std::cout &lt;&lt; \"a square of length 5 has perimeter length \" &lt;&lt; getSquarePerimeter(5) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Now when the program is compiled, function <em>getSquareSides<\/em> will have just one definition (via <em>square.cpp<\/em>), so the linker is happy.  File <em>main.cpp<\/em> is able to call this function (even though it lives in <em>square.cpp<\/em>) because it includes <em>square.h<\/em>, which has a forward declaration for the function (the linker will connect the call to <em>getSquareSides<\/em> from <em>main.cpp<\/em> to the definition of <em>getSquareSides<\/em> in <em>square.cpp<\/em>).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Can&#8217;t we just avoid definitions in header files?<\/p>\n<p>We&#8217;ve generally told you not to include function definitions in your headers.  So you may be wondering why you should include header guards if they protect you from something you shouldn&#8217;t do.<\/p>\n<p>There are quite a few cases we&#8217;ll show you in the future where it&#8217;s necessary to put non-function definitions in a header file.  For example, C++ will let you create your own types.  These custom types are typically defined in header files, so the type definitions can be propagated out to the code files that need to use them.  Without a header guard, a code file could end up with multiple (identical) copies of a given type definition, which the compiler will flag as an error.<\/p>\n<p>So even though it&#8217;s not strictly necessary to have header guards at this point in the tutorial series, we&#8217;re establishing good habits now, so you don&#8217;t have to unlearn bad habits later.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">#pragma once<\/p>\n<p>Modern compilers support a simpler, alternate form of header guards using the <code>#pragma<\/code> preprocessor directive:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#pragma once\r\n\r\n\/\/ your code here<\/code><\/pre>\n<p><code>#pragma once<\/code> serves the same purpose as header guards: to avoid a header file from being included multiple times.  With traditional header guards, the developer is responsible for guarding the header (by using preprocessor directives <code>#ifndef<\/code>, <code>#define<\/code>, and <code>#endif<\/code>).  With <code>#pragma once<\/code>, we&#8217;re requesting that the compiler guard the header.  How exactly it does this is an implementation-specific detail.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>There is one known case where <code>#pragma once<\/code> will typically fail.  If a header file is copied so that it exists in multiple places on the file system, if somehow both copies of the header get included, header guards will successfully de-dupe the identical headers, but <code>#pragma once<\/code> won&#8217;t (because the compiler won&#8217;t realize they are actually identical content).\n<\/div>\n<p>For most projects, <code>#pragma once<\/code> works fine, and many developers now prefer it because it is easier and less error-prone.  Many IDEs will also auto-include <code>#pragma once<\/code> at the top of a new header file generated through the IDE.<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>The <code>#pragma<\/code> directive was designed for compiler implementers to use for whatever purposes they desire.  As such, which pragmas are supported and what meaning those pragmas have is completely implementation-specific.  With the exception of <code>#pragma once<\/code>, do not expect a pragma that works on one compiler to be supported by another.\n<\/div>\n<p>Because <code>#pragma once<\/code> is not defined by the C++ standard, it is possible that some compilers may not implement it.  For this reason, some development houses (such as Google) recommend using traditional header guards.  In this tutorial series, we will favor header guards, as they are the most conventional way to guard headers.  However, support for <code>#pragma once<\/code> is fairly ubiquitous at this point, and if you wish to use <code>#pragma once<\/code> instead, that is generally accepted in modern C++.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Summary<\/p>\n<p>Header guards are designed to ensure that the contents of a given header file are not copied more than once into any single file, in order to prevent duplicate definitions.<\/p>\n<p>Duplicate <em>declarations<\/em> are fine -- but even if your header file is composed of all declarations (no definitions) it&#8217;s still a best practice to include header guards.<\/p>\n<p>Note that header guards do <em>not<\/em> prevent the contents of a header file from being copied (once) into separate project files.  This is a good thing, because we often need to reference the contents of a given header from different project files.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #1<\/p>\n<p>Add header guards to this header file:<\/p>\n<p>add.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int add(int x, int y);<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef ADD_H\r\n#define ADD_H\r\n\r\nint add(int x, int y);\r\n\r\n#endif<\/code><\/pre>\n<\/div>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/how-to-design-your-first-programs\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">2.13<\/span>How to design your first programs\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/header-files\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">2.11<\/span>Header files\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we noted that a variable or function identifier can only have one definition (the one definition rule). Thus, a program that defines a variable identifier more than once will cause a compile error: int main() { int x; \/\/ this is a definition for variable x int &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/3878"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=3878"}],"version-history":[{"count":47,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/3878\/revisions"}],"predecessor-version":[{"id":17194,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/3878\/revisions\/17194"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=3878"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=3878"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=3878"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}