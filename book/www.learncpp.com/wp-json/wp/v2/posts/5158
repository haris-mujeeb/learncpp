{"id":5158,"date":"2016-12-19T14:07:28","date_gmt":"2016-12-19T22:07:28","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=5158"},"modified":"2023-09-11T11:01:41","modified_gmt":"2023-09-11T18:01:41","slug":"chapter-26-summary-and-quiz","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-26-summary-and-quiz\/","title":{"rendered":"26.x &#8212; Chapter 26 summary and quiz"},"content":{"rendered":"<p>Templates allow us to write functions or classes using placeholder types, so that we can stencil out identical versions of the function or class using different types.  A function or class that has been instantiated is called a function or class instance.<\/p>\n<p>All template functions or classes must start with a template parameter declaration that tells the compiler that the following function or class is a template function or class.  Within the template parameter declaration, the template type parameters or expression parameters are specified.  Template type parameters are just placeholder types, normally named T, T1, T2, or other single letter names (e.g. S).  Expression parameters are usually integral types, but can be a pointer or reference to a function, class object, or member function.<\/p>\n<p>Splitting up template class definition and member function definitions doesn&#8217;t work like normal classes -- you can&#8217;t put your class definition in a header and member function definitions in a .cpp file.  It&#8217;s usually best to keep all of them in a header file, with the member function definitions underneath the class.<\/p>\n<p>Template specialization can be used when we want to override the default behavior from the templated function or class for a specific type.  If all types are overridden, this is called full specialization.  Classes also support partial specialization, where only some of the templated parameters are specialized.  Functions can not be partially specialized.<\/p>\n<p>Many classes in the C++ standard library use templates, including std::array and std::vector.  Templates are often used for implementing container classes, so a container can be written once and used with any appropriate type.<\/p>\n<p><strong>Quiz time<\/strong><\/p>\n<ol start=\"1\">\n<li>It&#8217;s sometimes useful to define data that travels in pairs.  Write a templated class named Pair1 that allows the user to define one template type that is used for both values in the pair.  The following function should work:\n<\/li>\n<\/ol>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n\tPair1&lt;int&gt; p1 { 5, 8 };\r\n\tstd::cout &lt;&lt; \"Pair: \" &lt;&lt; p1.first() &lt;&lt; ' ' &lt;&lt; p1.second() &lt;&lt; '\\n';\r\n\r\n\tconst Pair1&lt;double&gt; p2 { 2.3, 4.5 };\r\n\tstd::cout &lt;&lt; \"Pair: \" &lt;&lt; p2.first() &lt;&lt; ' ' &lt;&lt; p2.second() &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>and print:<\/p>\n<pre>\r\nPair: 5 8\r\nPair: 2.3 4.5\r\n<\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nclass Pair1\r\n{\r\nprivate:\r\n\tT m_x {};\r\n\tT m_y {};\r\n\r\npublic:\r\n\tPair1(const T&amp; x, const T&amp; y)\r\n\t\t: m_x{ x }, m_y{ y }\r\n\t{\r\n\t}\r\n\r\n\tT&amp; first() { return m_x; }\r\n\tT&amp; second() { return m_y; }\r\n\tconst T&amp; first() const { return m_x; }\r\n\tconst T&amp; second() const { return m_y; }\r\n};\r\n\r\nint main()\r\n{\r\n\tPair1&lt;int&gt; p1 { 5, 8 };\r\n\tstd::cout &lt;&lt; \"Pair: \" &lt;&lt; p1.first() &lt;&lt; ' ' &lt;&lt; p1.second() &lt;&lt; '\\n';\r\n\r\n\tconst Pair1&lt;double&gt; p2 { 2.3, 4.5 };\r\n\tstd::cout &lt;&lt; \"Pair: \" &lt;&lt; p2.first() &lt;&lt; ' ' &lt;&lt; p2.second() &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<ol start=\"2\">\n<li>Write a Pair class that allows you to specify separate types for each of the two values in the pair.\n<\/li>\n<\/ol>\n<p>Note: We&#8217;re naming this class differently from the previous one because C++ does not currently allow you to &#8220;overload&#8221; classes that differ only in the number or type of template parameters.<\/p>\n<p>The following program should work:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n\tPair&lt;int, double&gt; p1 { 5, 6.7 };\r\n\tstd::cout &lt;&lt; \"Pair: \" &lt;&lt; p1.first() &lt;&lt; ' ' &lt;&lt; p1.second() &lt;&lt; '\\n';\r\n\r\n\tconst Pair&lt;double, int&gt; p2 { 2.3, 4 };\r\n\tstd::cout &lt;&lt; \"Pair: \" &lt;&lt; p2.first() &lt;&lt; ' ' &lt;&lt; p2.second() &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>and print:<\/p>\n<pre>\r\nPair: 5 6.7\r\nPair: 2.3 4\r\n<\/pre>\n<p>Hint: To define a template using two different types, separate the two types by a comma in the template parameter declaration.  See lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-templates-with-multiple-template-types\/\">11.8 -- Function templates with multiple template types<\/a> for more information.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T, typename S&gt;\r\nclass Pair\r\n{\r\nprivate:\r\n\tT m_x;\r\n\tS m_y;\r\n\r\npublic:\r\n\tPair(const T&amp; x, const S&amp; y)\r\n\t\t: m_x{x}, m_y{y}\r\n\t{\r\n\t}\r\n\r\n\tT&amp; first() { return m_x; }\r\n\tS&amp; second() { return m_y; }\r\n\tconst T&amp; first() const { return m_x; }\r\n\tconst S&amp; second() const { return m_y; }\r\n};\r\n\r\nint main()\r\n{\r\n\tPair&lt;int, double&gt; p1 { 5, 6.7 };\r\n\tstd::cout &lt;&lt; \"Pair: \" &lt;&lt; p1.first() &lt;&lt; ' ' &lt;&lt; p1.second() &lt;&lt; '\\n';\r\n\r\n\tconst Pair&lt;double, int&gt; p2 { 2.3, 4 };\r\n\tstd::cout &lt;&lt; \"Pair: \" &lt;&lt; p2.first() &lt;&lt; ' ' &lt;&lt; p2.second() &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<ol start=\"3\">\n<li>A string-value pair is a special type of pair where the first value is always a string type, and the second value can be any type.  Write a template class named StringValuePair that inherits from a partially specialized Pair class (using std::string as the first type, and allowing the user to specify the second type).\n<\/li>\n<\/ol>\n<p>The following program should run:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n\tStringValuePair&lt;int&gt; svp { \"Hello\", 5 };\r\n\tstd::cout &lt;&lt; \"Pair: \" &lt;&lt; svp.first() &lt;&lt; ' ' &lt;&lt; svp.second() &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>and print:<\/p>\n<pre>\r\nPair: Hello 5\r\n<\/pre>\n<p>Hint: When you call the Pair constructor from the StringValuePair constructor, don&#8217;t forget to include the template parameters as part of the Pair class name.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\ntemplate &lt;typename T, typename S&gt;\r\nclass Pair\r\n{\r\nprivate:\r\n\tT m_x{};\r\n\tS m_y{};\r\n\r\npublic:\r\n\tPair(const T&amp; x, const S&amp; y)\r\n\t\t: m_x{ x }, m_y{ y }\r\n\t{\r\n\t}\r\n\r\n\tT&amp; first() { return m_x; }\r\n\tS&amp; second() { return m_y; }\r\n\tconst T&amp; first() const { return m_x; }\r\n\tconst S&amp; second() const { return m_y; }\r\n};\r\n\r\ntemplate &lt;typename S&gt;\r\nclass StringValuePair : public Pair&lt;std::string, S&gt;\r\n{\r\npublic:\r\n\tStringValuePair(std::string_view key, const S&amp; value)\r\n                \/\/ a std::string_view won't implicitly convert to a std::string, we must be explicit\r\n\t\t: Pair&lt;std::string, S&gt;{ static_cast&lt;std::string&gt;(key), value }\r\n\t{\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tStringValuePair&lt;int&gt; svp{ \"Hello\", 5 };\r\n\tstd::cout &lt;&lt; \"Pair: \" &lt;&lt; svp.first() &lt;&lt; ' ' &lt;&lt; svp.second() &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/the-need-for-exceptions\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">27.1<\/span>The need for exceptions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/partial-template-specialization-for-pointers\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">26.6<\/span>Partial template specialization for pointers\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Templates allow us to write functions or classes using placeholder types, so that we can stencil out identical versions of the function or class using different types. A function or class that has been instantiated is called a function or class instance. All template functions or classes must start with &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5158"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=5158"}],"version-history":[{"count":17,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5158\/revisions"}],"predecessor-version":[{"id":15252,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5158\/revisions\/15252"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=5158"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=5158"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=5158"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}