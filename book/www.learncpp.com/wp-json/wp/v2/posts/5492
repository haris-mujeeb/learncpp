{"id":5492,"date":"2017-02-26T12:43:26","date_gmt":"2017-02-26T20:43:26","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=5492"},"modified":"2025-02-18T20:16:46","modified_gmt":"2025-02-19T04:16:46","slug":"move-constructors-and-move-assignment","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/move-constructors-and-move-assignment\/","title":{"rendered":"22.3 &#8212; Move constructors and move assignment"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-smart-pointers-move-semantics\/\">22.1 -- Introduction to smart pointers and move semantics<\/a>, we took a look at std::auto_ptr, discussed the desire for move semantics, and took a look at some of the downsides that occur when functions designed for copy semantics (copy constructors and copy assignment operators) are redefined to implement move semantics.<\/p>\n<p>In this lesson, we&#8217;ll take a deeper look at how C++11 resolves these problems via move constructors and move assignment.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Recapping copy constructors and copy assignment<\/p>\n<p>First, let&#8217;s take a moment to recap copy semantics.<\/p>\n<p>Copy constructors are used to initialize a class by making a copy of an object of the same class.  Copy assignment is used to copy one class object to another existing class object.  By default, C++ will provide a copy constructor and copy assignment operator if one is not explicitly provided.  These compiler-provided functions do shallow copies, which may cause problems for classes that allocate dynamic memory.  So classes that deal with dynamic memory should override these functions to do deep copies.<\/p>\n<p>Returning back to our Auto_ptr smart pointer class example from the first lesson in this chapter, let&#8217;s look at a version that implements a copy constructor and copy assignment operator that do deep copies, and a sample program that exercises them:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate&lt;typename T&gt;\r\nclass Auto_ptr3\r\n{\r\n\tT* m_ptr {};\r\npublic:\r\n\tAuto_ptr3(T* ptr = nullptr)\r\n\t\t: m_ptr { ptr }\r\n\t{\r\n\t}\r\n\r\n\t~Auto_ptr3()\r\n\t{\r\n\t\tdelete m_ptr;\r\n\t}\r\n\r\n\t\/\/ Copy constructor\r\n\t\/\/ Do deep copy of a.m_ptr to m_ptr\r\n\tAuto_ptr3(const Auto_ptr3&amp; a)\r\n\t{\r\n\t\tm_ptr = new T;\r\n\t\t*m_ptr = *a.m_ptr;\r\n\t}\r\n\r\n\t\/\/ Copy assignment\r\n\t\/\/ Do deep copy of a.m_ptr to m_ptr\r\n\tAuto_ptr3&amp; operator=(const Auto_ptr3&amp; a)\r\n\t{\r\n\t\t\/\/ Self-assignment detection\r\n\t\tif (&amp;a == this)\r\n\t\t\treturn *this;\r\n\r\n\t\t\/\/ Release any resource we're holding\r\n\t\tdelete m_ptr;\r\n\r\n\t\t\/\/ Copy the resource\r\n\t\tm_ptr = new T;\r\n\t\t*m_ptr = *a.m_ptr;\r\n\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tT&amp; operator*() const { return *m_ptr; }\r\n\tT* operator-&gt;() const { return m_ptr; }\r\n\tbool isNull() const { return m_ptr == nullptr; }\r\n};\r\n\r\nclass Resource\r\n{\r\npublic:\r\n\tResource() { std::cout &lt;&lt; \"Resource acquired\\n\"; }\r\n\t~Resource() { std::cout &lt;&lt; \"Resource destroyed\\n\"; }\r\n};\r\n\r\nAuto_ptr3&lt;Resource&gt; generateResource()\r\n{\r\n\tAuto_ptr3&lt;Resource&gt; res{new Resource};\r\n\treturn res; \/\/ this return value will invoke the copy constructor\r\n}\r\n\r\nint main()\r\n{\r\n\tAuto_ptr3&lt;Resource&gt; mainres;\r\n\tmainres = generateResource(); \/\/ this assignment will invoke the copy assignment\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In this program, we&#8217;re using a function named generateResource() to create a smart pointer encapsulated resource, which is then passed back to function main().  Function main() then assigns that to an existing Auto_ptr3 object.<\/p>\n<p>When this program is run, it prints:<\/p>\n<pre>\r\nResource acquired\r\nResource acquired\r\nResource destroyed\r\nResource acquired\r\nResource destroyed\r\nResource destroyed\r\n<\/pre>\n<p>(Note: You may only get 4 outputs if your compiler elides the return value from function generateResource())<\/p>\n<p>That&#8217;s a lot of resource creation and destruction going on for such a simple program!  What&#8217;s going on here?<\/p>\n<p>Let&#8217;s take a closer look.  There are 6 key steps that happen in this program (one for each printed message):<\/p>\n<ol start=\"1\">\n<li>Inside generateResource(), local variable res is created and initialized with a dynamically allocated Resource, which causes the first &#8220;Resource acquired&#8221;.\n<\/li>\n<li>Res is returned back to main() by value.  We return by value here because res is a local variable -- it can&#8217;t be returned by address or reference because res will be destroyed when generateResource() ends.  So res is copy constructed into a temporary object.  Since our copy constructor does a deep copy, a new Resource is allocated here, which causes the second &#8220;Resource acquired&#8221;.\n<\/li>\n<li>Res goes out of scope, destroying the originally created Resource, which causes the first &#8220;Resource destroyed&#8221;.\n<\/li>\n<li>The temporary object is assigned to mainres by copy assignment.  Since our copy assignment also does a deep copy, a new Resource is allocated, causing yet another &#8220;Resource acquired&#8221;.\n<\/li>\n<li>The assignment expression ends, and the temporary object goes out of expression scope and is destroyed, causing a &#8220;Resource destroyed&#8221;.\n<\/li>\n<li>At the end of main(), mainres goes out of scope, and our final &#8220;Resource destroyed&#8221; is displayed.\n<\/li>\n<\/ol>\n<p>So, in short, because we call the copy constructor once to copy construct res to a temporary, and copy assignment once to copy the temporary into mainres, we end up allocating and destroying 3 separate objects in total.<\/p>\n<p>Inefficient, but at least it doesn&#8217;t crash!<\/p>\n<p>However, with move semantics, we can do better.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Move constructors and move assignment<\/p>\n<p>C++11 defines two new functions in service of move semantics: a move constructor, and a move assignment operator.  Whereas the goal of the copy constructor and copy assignment is to make a copy of one object to another, the goal of the move constructor and move assignment is to move ownership of the resources from one object to another (which is typically much less expensive than making a copy).<\/p>\n<p>Defining a move constructor and move assignment work analogously to their copy counterparts.  However, whereas the copy flavors of these functions take a const l-value reference parameter (which will bind to just about anything), the move flavors of these functions use non-const rvalue reference parameters (which only bind to rvalues).<\/p>\n<p>Here&#8217;s the same Auto_ptr3 class as above, with a move constructor and move assignment operator added.  We&#8217;ve left in the deep-copying copy constructor and copy assignment operator for comparison purposes.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate&lt;typename T&gt;\r\nclass Auto_ptr4\r\n{\r\n\tT* m_ptr {};\r\npublic:\r\n\tAuto_ptr4(T* ptr = nullptr)\r\n\t\t: m_ptr { ptr }\r\n\t{\r\n\t}\r\n\r\n\t~Auto_ptr4()\r\n\t{\r\n\t\tdelete m_ptr;\r\n\t}\r\n\r\n\t\/\/ Copy constructor\r\n\t\/\/ Do deep copy of a.m_ptr to m_ptr\r\n\tAuto_ptr4(const Auto_ptr4&amp; a)\r\n\t{\r\n\t\tm_ptr = new T;\r\n\t\t*m_ptr = *a.m_ptr;\r\n\t}\r\n\r\n\t\/\/ Move constructor\r\n\t\/\/ Transfer ownership of a.m_ptr to m_ptr\r\n\tAuto_ptr4(Auto_ptr4&amp;&amp; a) noexcept\r\n\t\t: m_ptr { a.m_ptr }\r\n\t{\r\n\t\ta.m_ptr = nullptr; \/\/ we'll talk more about this line below\r\n\t}\r\n\r\n\t\/\/ Copy assignment\r\n\t\/\/ Do deep copy of a.m_ptr to m_ptr\r\n\tAuto_ptr4&amp; operator=(const Auto_ptr4&amp; a)\r\n\t{\r\n\t\t\/\/ Self-assignment detection\r\n\t\tif (&amp;a == this)\r\n\t\t\treturn *this;\r\n\r\n\t\t\/\/ Release any resource we're holding\r\n\t\tdelete m_ptr;\r\n\r\n\t\t\/\/ Copy the resource\r\n\t\tm_ptr = new T;\r\n\t\t*m_ptr = *a.m_ptr;\r\n\r\n\t\treturn *this;\r\n\t}\r\n\r\n\t\/\/ Move assignment\r\n\t\/\/ Transfer ownership of a.m_ptr to m_ptr\r\n\tAuto_ptr4&amp; operator=(Auto_ptr4&amp;&amp; a) noexcept\r\n\t{\r\n\t\t\/\/ Self-assignment detection\r\n\t\tif (&amp;a == this)\r\n\t\t\treturn *this;\r\n\r\n\t\t\/\/ Release any resource we're holding\r\n\t\tdelete m_ptr;\r\n\r\n\t\t\/\/ Transfer ownership of a.m_ptr to m_ptr\r\n\t\tm_ptr = a.m_ptr;\r\n\t\ta.m_ptr = nullptr; \/\/ we'll talk more about this line below\r\n\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tT&amp; operator*() const { return *m_ptr; }\r\n\tT* operator-&gt;() const { return m_ptr; }\r\n\tbool isNull() const { return m_ptr == nullptr; }\r\n};\r\n\r\nclass Resource\r\n{\r\npublic:\r\n\tResource() { std::cout &lt;&lt; \"Resource acquired\\n\"; }\r\n\t~Resource() { std::cout &lt;&lt; \"Resource destroyed\\n\"; }\r\n};\r\n\r\nAuto_ptr4&lt;Resource&gt; generateResource()\r\n{\r\n\tAuto_ptr4&lt;Resource&gt; res{new Resource};\r\n\treturn res; \/\/ this return value will invoke the move constructor\r\n}\r\n\r\nint main()\r\n{\r\n\tAuto_ptr4&lt;Resource&gt; mainres;\r\n\tmainres = generateResource(); \/\/ this assignment will invoke the move assignment\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>The move constructor and move assignment operator are simple.  Instead of deep copying the source object (<code>a<\/code>) into the destination object (the implicit object), we simply move (steal) the source object&#8217;s resources.  This involves shallow copying the source pointer into the implicit object, then setting the source pointer to null.<\/p>\n<p>When run, this program prints:<\/p>\n<pre>\r\nResource acquired\r\nResource destroyed\r\n<\/pre>\n<p>That&#8217;s much better!<\/p>\n<p>The flow of the program is exactly the same as before.  However, instead of calling the copy constructor and copy assignment operators, this program calls the move constructor and move assignment operators.  Looking a little more deeply:<\/p>\n<ol start=\"1\">\n<li>Inside generateResource(), local variable res is created and initialized with a dynamically allocated Resource, which causes the first &#8220;Resource acquired&#8221;.\n<\/li>\n<li>Res is returned back to main() by value.  Res is move constructed into a temporary object, transferring the dynamically created object stored in res to the temporary object.  We&#8217;ll talk about why this happens below.\n<\/li>\n<li>Res goes out of scope.  Because res no longer manages a pointer (it was moved to the temporary), nothing interesting happens here.\n<\/li>\n<li>The temporary object is move assigned to mainres.  This transfers the dynamically created object stored in the temporary to mainres.\n<\/li>\n<li>The assignment expression ends, and the temporary object goes out of expression scope and is destroyed.  However, because the temporary no longer manages a pointer (it was moved to mainres), nothing interesting happens here either.\n<\/li>\n<li>At the end of main(), mainres goes out of scope, and our final &#8220;Resource destroyed&#8221; is displayed.\n<\/li>\n<\/ol>\n<p>So instead of copying our Resource twice (once for the copy constructor and once for the copy assignment), we transfer it twice.  This is more efficient, as Resource is only constructed and destroyed once instead of three times.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>Move constructors and move assignment should be marked as <code>noexcept<\/code>.  This tells the compiler that these functions will not throw exceptions.<\/p>\n<p>We introduce <code>noexcept<\/code> in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/exception-specifications-and-noexcept\/\">27.9 -- Exception specifications and noexcept<\/a> and discuss why move constructors and move assignment are marked as <code>noexcept<\/code> in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdmove_if_noexcept\/\">27.10 -- std::move_if_noexcept<\/a>.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">When are the move constructor and move assignment called?<\/p>\n<p>The move constructor and move assignment are called when those functions have been defined, and the argument for construction or assignment is an rvalue.  Most typically, this rvalue will be a literal or temporary value.<\/p>\n<p>The copy constructor and copy assignment are used otherwise (when the argument is an lvalue, or when the argument is an rvalue and the move constructor or move assignment functions aren&#8217;t defined).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Implicit move constructor and move assignment operator<\/p>\n<p>The compiler will create an implicit move constructor and move assignment operator if all of the following are true:<\/p>\n<ul>\n<li>There are no user-declared copy constructors or copy assignment operators.\n<\/li>\n<li>There are no user-declared move constructors or move assignment operators.\n<\/li>\n<li>There is no user-declared destructor.\n<\/li>\n<\/ul>\n<p>These functions do a memberwise move, which behaves as follows:<\/p>\n<ul>\n<li>If member has a move constructor or move assignment (as appropriate), it will be invoked.\n<\/li>\n<li>Otherwise, the member will be copied.\n<\/li>\n<\/ul>\n<p>Notably, this means that pointers will be copied, not moved!<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>The implicit move constructor and move assignment will copy pointers, not move them.  If you want to move a pointer member, you will need to define the move constructor and move assignment yourself.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The key insight behind move semantics<\/p>\n<p>You now have enough context to understand the key insight behind move semantics.<\/p>\n<p>If we construct an object or do an assignment where the argument is an l-value, the only thing we can reasonably do is copy the l-value.  We can&#8217;t assume it&#8217;s safe to alter the l-value, because it may be used again later in the program.  If we have an expression &#8220;a = b&#8221; (where b is an lvalue), we wouldn&#8217;t reasonably expect b to be changed in any way.<\/p>\n<p>However, if we construct an object or do an assignment where the argument is an r-value, then we know that r-value is just a temporary object of some kind.  Instead of copying it (which can be expensive), we can simply transfer its resources (which is cheap) to the object we&#8217;re constructing or assigning.  This is safe to do because the temporary will be destroyed at the end of the expression anyway, so we know it will never be used again!<\/p>\n<p>C++11, through r-value references, gives us the ability to provide different behaviors when the argument is an r-value vs an l-value, enabling us to make smarter and more efficient decisions about how our objects should behave.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Move semantics is an optimization opportunity.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Move functions should always leave both objects in a valid state<\/p>\n<p>In the above examples, both the move constructor and move assignment functions set a.m_ptr to nullptr.  This may seem extraneous -- after all, if <code>a<\/code> is a temporary r-value, why bother doing &#8220;cleanup&#8221; if parameter <code>a<\/code> is going to be destroyed anyway?<\/p>\n<p>The answer is simple: When <code>a<\/code> goes out of scope, the destructor for <code>a<\/code> will be called, and <code>a.m_ptr<\/code> will be deleted.  If at that point, <code>a.m_ptr<\/code> is still pointing to the same object as <code>m_ptr<\/code>, then <code>m_ptr<\/code> will be left as a dangling pointer.  When the object containing <code>m_ptr<\/code> eventually gets used (or destroyed), we&#8217;ll get undefined behavior.<\/p>\n<p>When implementing move semantics, it is important to ensure the moved-from object is left in a valid state, so that it will destruct properly (without creating undefined behavior).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Automatic l-values returned by value may be moved instead of copied<\/p>\n<p>In the generateResource() function of the Auto_ptr4 example above, when variable res is returned by value, it is moved instead of copied, even though res is an l-value.  The C++ specification has a special rule that says automatic objects returned from a function by value can be moved even if they are l-values.  This makes sense, since res was going to be destroyed at the end of the function anyway!  We might as well steal its resources instead of making an expensive and unnecessary copy.<\/p>\n<p>Although the compiler can move l-value return values, in some cases it may be able to do even better by simply eliding the copy altogether (which avoids the need to make a copy or do a move at all).  In such a case, neither the copy constructor nor move constructor would be called.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Disabling copying<\/p>\n<p>In the Auto_ptr4 class above, we left in the copy constructor and assignment operator for comparison purposes.  But in move-enabled classes, it is sometimes desirable to delete the copy constructor and copy assignment functions to ensure copies aren&#8217;t made.  In the case of our Auto_ptr class, we don&#8217;t want to copy our templated object T -- both because it&#8217;s expensive, and whatever class T is may not even support copying!<\/p>\n<p>Here&#8217;s a version of Auto_ptr that supports move semantics but not copy semantics:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate&lt;typename T&gt;\r\nclass Auto_ptr5\r\n{\r\n\tT* m_ptr {};\r\npublic:\r\n\tAuto_ptr5(T* ptr = nullptr)\r\n\t\t: m_ptr { ptr }\r\n\t{\r\n\t}\r\n\r\n\t~Auto_ptr5()\r\n\t{\r\n\t\tdelete m_ptr;\r\n\t}\r\n\r\n\t\/\/ Copy constructor -- no copying allowed!\r\n\tAuto_ptr5(const Auto_ptr5&amp; a) = delete;\r\n\r\n\t\/\/ Move constructor\r\n\t\/\/ Transfer ownership of a.m_ptr to m_ptr\r\n\tAuto_ptr5(Auto_ptr5&amp;&amp; a) noexcept\r\n\t\t: m_ptr { a.m_ptr }\r\n\t{\r\n\t\ta.m_ptr = nullptr;\r\n\t}\r\n\r\n\t\/\/ Copy assignment -- no copying allowed!\r\n\tAuto_ptr5&amp; operator=(const Auto_ptr5&amp; a) = delete;\r\n\r\n\t\/\/ Move assignment\r\n\t\/\/ Transfer ownership of a.m_ptr to m_ptr\r\n\tAuto_ptr5&amp; operator=(Auto_ptr5&amp;&amp; a) noexcept\r\n\t{\r\n\t\t\/\/ Self-assignment detection\r\n\t\tif (&amp;a == this)\r\n\t\t\treturn *this;\r\n\r\n\t\t\/\/ Release any resource we're holding\r\n\t\tdelete m_ptr;\r\n\r\n\t\t\/\/ Transfer ownership of a.m_ptr to m_ptr\r\n\t\tm_ptr = a.m_ptr;\r\n\t\ta.m_ptr = nullptr;\r\n\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tT&amp; operator*() const { return *m_ptr; }\r\n\tT* operator-&gt;() const { return m_ptr; }\r\n\tbool isNull() const { return m_ptr == nullptr; }\r\n};<\/code><\/pre>\n<p>If you were to try to pass an Auto_ptr5 l-value to a function by value, the compiler would complain that the copy constructor required to initialize the function parameter has been deleted.  This is good, because we should probably be passing Auto_ptr5 by const l-value reference anyway!<\/p>\n<p>Auto_ptr5 is (finally) a good smart pointer class.  And, in fact the standard library contains a class very much like this one (that you should use instead), named std::unique_ptr.  We&#8217;ll talk more about std::unique_ptr later in this chapter.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Another example<\/p>\n<p>Let&#8217;s take a look at another class that uses dynamic memory: a simple dynamic templated array.  This class contains a deep-copying copy constructor and copy assignment operator.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cstddef&gt; \/\/ for std::size_t\r\n\r\ntemplate &lt;typename T&gt;\r\nclass DynamicArray\r\n{\r\nprivate:\r\n\tT* m_array {};\r\n\tint m_length {};\r\n\r\n\tvoid alloc(int length)\r\n\t{\r\n\t\tm_array = new T[static_cast&lt;std::size_t&gt;(length)];\r\n        \tm_length = length;\r\n\t}\r\npublic:\r\n\tDynamicArray(int length)\r\n\t{\r\n\t\talloc(length);\r\n\t}\r\n\r\n\t~DynamicArray()\r\n\t{\r\n\t\tdelete[] m_array;\r\n\t}\r\n\r\n\t\/\/ Copy constructor\r\n\tDynamicArray(const DynamicArray &amp;arr)\r\n\t{\r\n\t\talloc(arr.m_length);\r\n\t\tstd::copy_n(arr.m_array, m_length, m_array); \/\/ copy m_length elements from arr to m_array\r\n\t}\r\n\r\n\t\/\/ Copy assignment\r\n\tDynamicArray&amp; operator=(const DynamicArray &amp;arr)\r\n\t{\r\n\t\tif (&amp;arr == this)\r\n\t\t\treturn *this;\r\n\r\n\t\tdelete[] m_array;\r\n\r\n\t\talloc(arr.m_length);\r\n\r\n\t\tstd::copy_n(arr.m_array, m_length, m_array); \/\/ copy m_length elements from arr to m_array\r\n\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tint getLength() const { return m_length; }\r\n\tT&amp; operator[](int index) { return m_array[index]; }\r\n\tconst T&amp; operator[](int index) const { return m_array[index]; }\r\n};<\/code><\/pre>\n<p>Now let&#8217;s use this class in a program.  To show you how this class performs when we allocate a million integers on the heap, we&#8217;re going to leverage the Timer class we developed in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/timing-your-code\/\">18.4 -- Timing your code<\/a>.  We&#8217;ll use the Timer class to time how fast our code runs, and show you the performance difference between copying and moving.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt; \/\/ for std::copy_n\r\n#include &lt;chrono&gt; \/\/ for std::chrono functions\r\n#include &lt;iostream&gt;\r\n\r\n\/\/ Uses the above DynamicArray class\r\n\r\nclass Timer\r\n{\r\nprivate:\r\n\t\/\/ Type aliases to make accessing nested type easier\r\n\tusing Clock = std::chrono::high_resolution_clock;\r\n\tusing Second = std::chrono::duration&lt;double, std::ratio&lt;1&gt; &gt;;\r\n\t\r\n\tstd::chrono::time_point&lt;Clock&gt; m_beg { Clock::now() };\r\n\r\npublic:\r\n\tvoid reset()\r\n\t{\r\n\t\tm_beg = Clock::now();\r\n\t}\r\n\t\r\n\tdouble elapsed() const\r\n\t{\r\n\t\treturn std::chrono::duration_cast&lt;Second&gt;(Clock::now() - m_beg).count();\r\n\t}\r\n};\r\n\r\n\/\/ Return a copy of arr with all of the values doubled\r\nDynamicArray&lt;int&gt; cloneArrayAndDouble(const DynamicArray&lt;int&gt; &amp;arr)\r\n{\r\n\tDynamicArray&lt;int&gt; dbl(arr.getLength());\r\n\tfor (int i = 0; i &lt; arr.getLength(); ++i)\r\n\t\tdbl[i] = arr[i] * 2;\r\n\r\n\treturn dbl;\r\n}\r\n\r\nint main()\r\n{\r\n\tTimer t;\r\n\r\n\tDynamicArray&lt;int&gt; arr(1000000);\r\n\r\n\tfor (int i = 0; i &lt; arr.getLength(); i++)\r\n\t\tarr[i] = i;\r\n\r\n\tarr = cloneArrayAndDouble(arr);\r\n\r\n\tstd::cout &lt;&lt; t.elapsed();\r\n}<\/code><\/pre>\n<p>On one of the author&#8217;s machines, in release mode, this program executed in 0.00825559 seconds.<\/p>\n<p>Now let&#8217;s update <code>DynamicArray<\/code> by replacing the copy constructor and copy assignment with a move constructor and move assignment, and then run the program again:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cstddef&gt; \/\/ for std::size_t\r\n\r\ntemplate &lt;typename T&gt;\r\nclass DynamicArray\r\n{\r\nprivate:\r\n\tT* m_array {};\r\n\tint m_length {};\r\n\r\n\tvoid alloc(int length)\r\n\t{\r\n\t\tm_array = new T[static_cast&lt;std::size_t&gt;(length)];\r\n\t\tm_length = length;\r\n\t}\r\npublic:\r\n\tDynamicArray(int length)\r\n\t{\r\n\t\talloc(length);\r\n\t}\r\n\r\n\t~DynamicArray()\r\n\t{\r\n\t\tdelete[] m_array;\r\n\t}\r\n\r\n\t\/\/ Copy constructor\r\n\tDynamicArray(const DynamicArray &amp;arr) = delete;\r\n\r\n\t\/\/ Copy assignment\r\n\tDynamicArray&amp; operator=(const DynamicArray &amp;arr) = delete;\r\n\r\n\t\/\/ Move constructor\r\n\tDynamicArray(DynamicArray &amp;&amp;arr) noexcept\r\n\t\t:  m_array { arr.m_array }, m_length { arr.m_length }\r\n\t{\r\n\t\tarr.m_length = 0;\r\n\t\tarr.m_array = nullptr;\r\n\t}\r\n\r\n\t\/\/ Move assignment\r\n\tDynamicArray&amp; operator=(DynamicArray &amp;&amp;arr) noexcept\r\n\t{\r\n\t\tif (&amp;arr == this)\r\n\t\t\treturn *this;\r\n\r\n\t\tdelete[] m_array;\r\n\r\n\t\tm_length = arr.m_length;\r\n\t\tm_array = arr.m_array;\r\n\t\tarr.m_length = 0;\r\n\t\tarr.m_array = nullptr;\r\n\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tint getLength() const { return m_length; }\r\n\tT&amp; operator[](int index) { return m_array[index]; }\r\n\tconst T&amp; operator[](int index) const { return m_array[index]; }\r\n};\r\n\r\n#include &lt;iostream&gt;\r\n#include &lt;chrono&gt; \/\/ for std::chrono functions\r\n\r\nclass Timer\r\n{\r\nprivate:\r\n\t\/\/ Type aliases to make accessing nested type easier\r\n\tusing Clock = std::chrono::high_resolution_clock;\r\n\tusing Second = std::chrono::duration&lt;double, std::ratio&lt;1&gt; &gt;;\r\n\t\r\n\tstd::chrono::time_point&lt;Clock&gt; m_beg { Clock::now() };\r\n\r\npublic:\r\n\tvoid reset()\r\n\t{\r\n\t\tm_beg = Clock::now();\r\n\t}\r\n\t\r\n\tdouble elapsed() const\r\n\t{\r\n\t\treturn std::chrono::duration_cast&lt;Second&gt;(Clock::now() - m_beg).count();\r\n\t}\r\n};\r\n\r\n\/\/ Return a copy of arr with all of the values doubled\r\nDynamicArray&lt;int&gt; cloneArrayAndDouble(const DynamicArray&lt;int&gt; &amp;arr)\r\n{\r\n\tDynamicArray&lt;int&gt; dbl(arr.getLength());\r\n\tfor (int i = 0; i &lt; arr.getLength(); ++i)\r\n\t\tdbl[i] = arr[i] * 2;\r\n\r\n\treturn dbl;\r\n}\r\n\r\nint main()\r\n{\r\n\tTimer t;\r\n\r\n\tDynamicArray&lt;int&gt; arr(1000000);\r\n\r\n\tfor (int i = 0; i &lt; arr.getLength(); i++)\r\n\t\tarr[i] = i;\r\n\r\n\tarr = cloneArrayAndDouble(arr);\r\n\r\n\tstd::cout &lt;&lt; t.elapsed();\r\n}<\/code><\/pre>\n<p>On the same machine, this program executed in 0.0056 seconds.<\/p>\n<p>Comparing the runtime of the two programs, (0.00825559 - 0.0056) \/ 0.00825559 * 100 = 32.1% faster!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Deleting the move constructor and move assignment<\/p>\n<p>You can delete the move constructor and move assignment using the <code>= delete<\/code> syntax in the exact same way you can delete the copy constructor and copy assignment.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Name\r\n{\r\nprivate:\r\n    std::string m_name {};\r\n\r\npublic:\r\n    Name(std::string_view name) : m_name{ name }\r\n    {\r\n    }\r\n\r\n    Name(const Name&amp; name) = delete;\r\n    Name&amp; operator=(const Name&amp; name) = delete;\r\n    Name(Name&amp;&amp; name) = delete;\r\n    Name&amp; operator=(Name&amp;&amp; name) = delete;\r\n\r\n    const std::string&amp; get() const { return m_name; }\r\n};\r\n\r\nint main()\r\n{\r\n    Name n1{ \"Alex\" };\r\n    n1 = Name{ \"Joe\" }; \/\/ error: move assignment deleted\r\n\r\n    std::cout &lt;&lt; n1.get() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>If you delete the copy constructor, the compiler will not generate an implicit move constructor (making your objects neither copyable nor movable).  Therefore, when deleting the copy constructor, it is useful to be explicit about what behavior you want from your move constructors.  Either explicitly delete them (making it clear this is the desired behavior), or default them (making the class move-only).<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>The <strong>rule of five<\/strong> says that if the copy constructor, copy assignment, move constructor, move assignment, or destructor are defined or deleted, then each of those functions should be defined or deleted.\n<\/p><\/div>\n<p>While deleting only the move constructor and move assignment may seem like a good idea if you want a copyable but not movable object, this has the unfortunate consequence of making the class not returnable by value in cases where mandatory copy elision does not apply.  This happens because a deleted move constructor is still a declared function, and thus is eligible for overload resolution.  And return by value will favor a deleted move constructor over a non-deleted copy constructor.  This is illustrated by the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Name\r\n{\r\nprivate:\r\n    std::string m_name {};\r\n\r\npublic:\r\n    Name(std::string_view name) : m_name{ name }\r\n    {\r\n    }\r\n\r\n    Name(const Name&amp; name) = default;\r\n    Name&amp; operator=(const Name&amp; name) = default;\r\n\r\n    Name(Name&amp;&amp; name) = delete;\r\n    Name&amp; operator=(Name&amp;&amp; name) = delete;\r\n\r\n    const std::string&amp; get() const { return m_name; }\r\n};\r\n\r\nName getJoe()\r\n{\r\n    Name joe{ \"Joe\" };\r\n    return joe; \/\/ error: Move constructor was deleted\r\n}\r\n\r\nint main()\r\n{\r\n    Name n{ getJoe() };\r\n\r\n    std::cout &lt;&lt; n.get() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Issues with move semantics and <code>std::swap<\/code> <span class=\"cpp-section-pill cpp-section-advanced\">Advanced<\/span><\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-the-assignment-operator\/\">21.12 -- Overloading the assignment operator<\/a>, we mentioned the copy and swap idiom.  Copy and swap also works for move semantics, meaning we can implement our move constructor and move assignment by swapping resources with the object that will be destroyed.<\/p>\n<p>This has two benefits:<\/p>\n<ul>\n<li>The persistent object now controls the resources that were previously under ownership of the dying object (which was our primary goal).\n<\/li>\n<li>The dying object now controls the resources that were previously under ownership of the persistent object.  When the dying object actually dies, it can do any kind of cleanup required on those resources.\n<\/li>\n<\/ul>\n<p>When you think about swapping, the first thing that comes to mind is usually <code>std::swap()<\/code>.  However, implementing the move constructor and move assignment using <code>std::swap()<\/code> is problematic, as <code>std::swap()<\/code> calls both the move constructor and move assignment on move-capable objects.  This will result in an infinite recursion issue.<\/p>\n<p>You can see this happen in the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Name\r\n{\r\nprivate:\r\n    std::string m_name {}; \/\/ std::string is move capable\r\n\r\npublic:\r\n    Name(std::string_view name) : m_name{ name }\r\n    {\r\n    }\r\n\r\n    Name(const Name&amp; name) = delete;\r\n    Name&amp; operator=(const Name&amp; name) = delete;\r\n\r\n    Name(Name&amp;&amp; name) noexcept\r\n    {\r\n        std::cout &lt;&lt; \"Move ctor\\n\";\r\n\r\n        std::swap(*this, name); \/\/ bad!\r\n    }\r\n\r\n    Name&amp; operator=(Name&amp;&amp; name) noexcept\r\n    {\r\n        std::cout &lt;&lt; \"Move assign\\n\";\r\n\r\n        std::swap(*this, name); \/\/ bad!\r\n\r\n        return *this;\r\n    }\r\n\r\n    const std::string&amp; get() const { return m_name; }\r\n};\r\n\r\nint main()\r\n{\r\n    Name n1{ \"Alex\" };   \r\n    n1 = Name{\"Joe\"}; \/\/ invokes move assignment\r\n\r\n    std::cout &lt;&lt; n1.get() &lt;&lt; '\\n';\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nMove assign\r\nMove ctor\r\nMove ctor\r\nMove ctor\r\nMove ctor\r\n<\/pre>\n<p>And so on&#8230; until the stack overflows.<\/p>\n<p>You can implement the move constructor and move assignment using your own swap function, as long as your swap member function does not call the move constructor or move assignment.  Here&#8217;s an example of how that can be done:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Name\r\n{\r\nprivate:\r\n    std::string m_name {};\r\n\r\npublic:\r\n    Name(std::string_view name) : m_name{ name }\r\n    {\r\n    }\r\n\r\n    Name(const Name&amp; name) = delete;\r\n    Name&amp; operator=(const Name&amp; name) = delete;\r\n    \r\n    \/\/ Create our own swap friend function to swap the members of Name\r\n    friend void swap(Name&amp; a, Name&amp; b) noexcept\r\n    {\r\n        \/\/ We avoid recursive calls by invoking std::swap on the std::string member,\r\n        \/\/ not on Name\r\n        std::swap(a.m_name, b.m_name);\r\n    }\r\n\r\n    Name(Name&amp;&amp; name) noexcept\r\n    {\r\n        std::cout &lt;&lt; \"Move ctor\\n\";\r\n\r\n        swap(*this, name); \/\/ Now calling our swap, not std::swap\r\n    }\r\n\r\n    Name&amp; operator=(Name&amp;&amp; name) noexcept\r\n    {\r\n        std::cout &lt;&lt; \"Move assign\\n\";\r\n\r\n        swap(*this, name); \/\/ Now calling our swap, not std::swap\r\n\r\n        return *this;\r\n    }\r\n\r\n    const std::string&amp; get() const { return m_name; }\r\n};\r\n\r\nint main()\r\n{\r\n    Name n1{ \"Alex\" };   \r\n    n1 = Name{\"Joe\"}; \/\/ invokes move assignment\r\n\r\n    std::cout &lt;&lt; n1.get() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This works as expected, and prints:<\/p>\n<pre>\nMove assign\r\nJoe\r\n<\/pre>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdmove\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">22.4<\/span>std::move\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/rvalue-references\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">22.2<\/span>R-value references\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we took a look at std::auto_ptr, discussed the desire for move semantics, and took a look at some of the downsides that occur when functions designed for copy semantics (copy constructors and copy assignment operators) are redefined to implement move semantics. In this lesson, we&#8217;ll take a &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5492"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=5492"}],"version-history":[{"count":66,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5492\/revisions"}],"predecessor-version":[{"id":18210,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5492\/revisions\/18210"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=5492"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=5492"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=5492"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}