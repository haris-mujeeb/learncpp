{"id":5752,"date":"2017-05-03T11:28:10","date_gmt":"2017-05-03T19:28:10","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=5752"},"modified":"2025-01-06T16:12:59","modified_gmt":"2025-01-07T00:12:59","slug":"chapter-22-summary-and-quiz","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-22-summary-and-quiz\/","title":{"rendered":"22.x &#8212; Chapter 22 summary and quiz"},"content":{"rendered":"<p>A smart pointer class is a composition class that is designed to manage dynamically allocated memory, and ensure that memory gets deleted when the smart pointer object goes out of scope.<\/p>\n<p>Copy semantics allow our classes to be copied.  This is done primarily via the copy constructor and copy assignment operator.<\/p>\n<p>Move semantics mean a class will transfer ownership of the object rather than making a copy.  This is done primarily via the move constructor and move assignment operator.<\/p>\n<p>std::auto_ptr is deprecated and should be avoided.<\/p>\n<p>An r-value reference is a reference that is designed to be initialized with an r-value.  An r-value reference is created using a double ampersand.  It&#8217;s fine to write functions that take r-value reference parameters, but you should almost never return an r-value reference.<\/p>\n<p>If we construct an object or do an assignment where the argument is an l-value, the only thing we can reasonably do is copy the l-value. We can\u2019t assume it\u2019s safe to alter the l-value, because it may be used again later in the program. If we have an expression \u201ca = b\u201d, we wouldn\u2019t reasonably expect b to be changed in any way.<\/p>\n<p>However, if we construct an object or do an assignment where the argument is an r-value, then we know that r-value is just a temporary object of some kind. Instead of copying it (which can be expensive), we can simply transfer its resources (which is cheap) to the object we\u2019re constructing or assigning. This is safe to do because the temporary will be destroyed at the end of the expression anyway, so we know it will never be used again!<\/p>\n<p>You can use the delete keyword to disable copy semantics for classes you create by deleting the copy constructor and copy assignment operator.<\/p>\n<p>std::move allows you to treat an l-value as r-value.  This is useful when we want to invoke move semantics instead of copy semantics on an l-value.<\/p>\n<p>std::unique_ptr is the smart pointer class that you should probably be using.  It manages a single non-shareable resource.  std::make_unique() (in C++14) should be preferred to create new std::unique_ptr.  std::unique_ptr disables copy semantics.<\/p>\n<p>std::shared_ptr is the smart pointer class used when you need multiple objects accessing the same resource.  The resource will not be destroyed until the last std::shared_ptr managing it is destroyed.  std::make_shared() should be preferred to create new std::shared_ptr.  With std::shared_ptr, copy semantics should be used to create additional std::shared_ptr pointing to the same object.<\/p>\n<p>std::weak_ptr is the smart pointer class used when you need one or more objects with the ability to view and access a resource managed by a std::shared_ptr, but unlike std::shared_ptr, std::weak_ptr is not considered when determining whether the resource should be destroyed.<\/p>\n<p><strong>Quiz time<\/strong><\/p>\n<ol start=\"1\">\n<li>Explain when you should use the following types of pointers.\n<\/li>\n<\/ol>\n<p>1a) std::unique_ptr<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>std::unique_ptr should be used when you want a smart pointer to manage a dynamic object that is not going to be shared.\n<\/p><\/div>\n<p>1b) std::shared_ptr<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p>std::shared_ptr should be used when you want a smart pointer to manage a dynamic object that may be shared.  The object won&#8217;t be deallocated until all std::shared_ptr holding the object are destroyed.\n<\/p><\/div>\n<p>1c) std::weak_ptr<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<p>std::weak_ptr should be used when you want access to an object that is being managed by a std::shared_ptr, but don&#8217;t want the lifetime of the std::shared_ptr to be tied to the lifetime of the std::weak_ptr.\n<\/p><\/div>\n<p>1d) std::auto_ptr<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<p>std::auto_ptr has been deprecated and was removed in C++17.  It should not be used.\n<\/p><\/div>\n<ol start=\"2\">\n<li>Explain why move semantics is focused around r-values.\n<\/li>\n<\/ol>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\n<p>Because r-values are temporary, we know they are going to get destroyed after they are used.  When passing or returning an r-value by value, it&#8217;s wasteful to make a copy and then destroy the original.  Instead, we can simply move (steal) the r-value&#8217;s resources, which is generally more efficient.\n<\/p><\/div>\n<ol start=\"3\">\n<li>What&#8217;s wrong with the following code?  Update the program to be best practices compliant.\n<\/li>\n<\/ol>\n<p>3a)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;memory&gt; \/\/ for std::shared_ptr\r\n \r\nclass Resource\r\n{\r\npublic:\r\n\tResource() { std::cout &lt;&lt; \"Resource acquired\\n\"; }\r\n\t~Resource() { std::cout &lt;&lt; \"Resource destroyed\\n\"; }\r\n};\r\n \r\nint main()\r\n{\r\n\tauto* res{ new Resource{} };\r\n\tstd::shared_ptr&lt;Resource&gt; ptr1{ res };\r\n\tstd::shared_ptr&lt;Resource&gt; ptr2{ res };\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_5'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_5\" style=\"display:none\">\n<p><code>ptr2<\/code> was created from <code>res<\/code> instead of from <code>ptr1<\/code>.  This means that you now have two <code>std::shared_ptr<\/code> each independently trying to manage the <code>Resource<\/code> (they are not aware of each other).  When one goes out of scope, the other will be left with a dangling pointer.<\/p>\n<p><code>ptr2<\/code> should instead be initialized with <code>ptr1<\/code> instead of from <code>res<\/code>.  This will allow both <code>ptr1<\/code> and <code>ptr2<\/code> to share ownership of <code>res<\/code>.  <code>std::make_shared()<\/code> should be used instead of manual dynamic allocation.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;memory&gt; \/\/ for std::shared_ptr\r\n \r\nclass Resource\r\n{\r\npublic:\r\n\tResource() { std::cout &lt;&lt; \"Resource acquired\\n\"; }\r\n\t~Resource() { std::cout &lt;&lt; \"Resource destroyed\\n\"; }\r\n};\r\n \r\nint main()\r\n{\r\n\tauto ptr1{ std::make_shared&lt;Resource&gt;() };\r\n\tauto ptr2{ ptr1 };\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/object-relationships\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">23.1<\/span>Object relationships\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/circular-dependency-issues-with-stdshared_ptr-and-stdweak_ptr\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">22.7<\/span>Circular dependency issues with std::shared_ptr, and std::weak_ptr\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>A smart pointer class is a composition class that is designed to manage dynamically allocated memory, and ensure that memory gets deleted when the smart pointer object goes out of scope. Copy semantics allow our classes to be copied. This is done primarily via the copy constructor and copy assignment &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5752"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=5752"}],"version-history":[{"count":24,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5752\/revisions"}],"predecessor-version":[{"id":18094,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5752\/revisions\/18094"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=5752"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=5752"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=5752"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}