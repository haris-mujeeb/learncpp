{"id":15343,"date":"2023-09-11T12:21:03","date_gmt":"2023-09-11T19:21:03","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15343"},"modified":"2024-09-16T16:14:22","modified_gmt":"2024-09-16T23:14:22","slug":"default-constructors-and-default-arguments","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/default-constructors-and-default-arguments\/","title":{"rendered":"14.11 &#8212; Default constructors and default arguments"},"content":{"rendered":"<p>A <strong>default constructor<\/strong> is a constructor that accepts no arguments.  Typically, this is a constructor that has been defined with no parameters.<\/p>\n<p>Here is an example of a class that has a default constructor:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Foo\r\n{\r\npublic:\r\n    Foo() \/\/ default constructor\r\n    {\r\n        std::cout &lt;&lt; \"Foo default constructed\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Foo foo{}; \/\/ No initialization values, calls Foo's default constructor\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When the above program runs, an object of type <code>Foo<\/code> is created.  Since no initialization values have been provided, the default constructor <code>Foo()<\/code> is called, which prints:<\/p>\n<pre>\nFoo default constructed\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Value initialization vs default initialization for class types<\/p>\n<p>If a class type has a default constructor, both value initialization and default initialization will call the default constructor.  Thus, for such a class such as the <code>Foo<\/code> class in the example above, the following are essentially equivalent:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    Foo foo{}; \/\/ value initialization, calls Foo() default constructor\r\n    Foo foo2;  \/\/ default initialization, calls Foo() default constructor<\/code><\/pre>\n<p>However, as we already covered in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/default-member-initialization\/\">13.9 -- Default member initialization<\/a>, value initialization is safer for aggregates.  Since it&#8217;s difficult to tell whether a class type is an aggregate or non-aggregate, it&#8217;s safer to just use value initialization for everything and not worry about it.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Prefer value initialization over default initialization for all class types.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constructors with default arguments<\/p>\n<p>As with all functions, the rightmost parameters of constructors can have default arguments.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover default arguments in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/default-arguments\/\">11.5 -- Default arguments<\/a>.\n<\/p><\/div>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Foo\r\n{\r\nprivate:\r\n    int m_x { };\r\n    int m_y { };\r\n\r\npublic:\r\n    Foo(int x=0, int y=0) \/\/ has default arguments\r\n        : m_x { x }\r\n        , m_y { y }\r\n    {\r\n        std::cout &lt;&lt; \"Foo(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \") constructed\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Foo foo1{};     \/\/ calls Foo(int, int) constructor using default arguments\r\n    Foo foo2{6, 7}; \/\/ calls Foo(int, int) constructor\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\nFoo(0, 0) constructed\r\nFoo(6, 7) constructed\r\n<\/pre>\n<p>If all of the parameters in a constructor have default arguments, the constructor is a default constructor (because it can be called with no arguments).<\/p>\n<p>We&#8217;ll see examples of where this can be useful in the next lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/delegating-constructors\/\">14.12 -- Delegating constructors<\/a>).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Overloaded constructors<\/p>\n<p>Because constructors are functions, they can be overloaded.  That is, we can have multiple constructors so that we can construct objects in different ways:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Foo\r\n{\r\nprivate:\r\n    int m_x {};\r\n    int m_y {};\r\n\r\npublic:\r\n    Foo() \/\/ default constructor\r\n    {\r\n        std::cout &lt;&lt; \"Foo constructed\\n\";\r\n    }\r\n\r\n    Foo(int x, int y) \/\/ non-default constructor\r\n        : m_x { x }, m_y { y }\r\n    {\r\n        std::cout &lt;&lt; \"Foo(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \") constructed\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Foo foo1{};     \/\/ Calls Foo() constructor\r\n    Foo foo2{6, 7}; \/\/ Calls Foo(int, int) constructor\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>A corollary of the above is that a class should only have one default constructor.  If more than one default constructor is provided, the compiler will be unable to disambiguate which should be used:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Foo\r\n{\r\nprivate:\r\n    int m_x {};\r\n    int m_y {};\r\n\r\npublic:\r\n    Foo() \/\/ default constructor\r\n    {\r\n        std::cout &lt;&lt; \"Foo constructed\\n\";\r\n    }\r\n\r\n    Foo(int x=1, int y=2) \/\/ default constructor\r\n        : m_x { x }, m_y { y }\r\n    {\r\n        std::cout &lt;&lt; \"Foo(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \") constructed\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Foo foo{}; \/\/ compile error: ambiguous constructor function call\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, we instantiate <code>foo<\/code> with no arguments, so the compiler will look for a default constructor.  It will find two, and be unable to disambiguate which constructor should be used.  This will result in a compile error.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">An implicit default constructor<\/p>\n<p>If a non-aggregate class type object has no user-declared constructors, the compiler will generate a public default constructor (so that the class can be value or default initialized).  This constructor is called an <strong>implicit default constructor<\/strong>.<\/p>\n<p>Consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Foo\r\n{\r\nprivate:\r\n    int m_x{};\r\n    int m_y{};\r\n\r\n    \/\/ Note: no constructors declared\r\n};\r\n\r\nint main()\r\n{\r\n    Foo foo{};\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This class has no user-declared constructors, so the compiler will generate an implicit default constructor for us.  That constructor will be used to instantiate <code>foo{}<\/code>.<\/p>\n<p>The implicit default constructor is equivalent to a constructor that has no parameters, no member initializer list, and no statements in the body of the constructor.  In other words, for the above <code>Foo<\/code> class, the compiler generates this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">public:\r\n    Foo() \/\/ implicitly generated default constructor\r\n    {\r\n    }<\/code><\/pre>\n<p>The implicit default constructor is useful mostly when we have classes that have no data members.  If a class has data members, we&#8217;ll probably want to make them initializable with values provided by the user, and the implicit default constructor isn&#8217;t sufficient for that.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using <code>= default<\/code> to generate an explicitly defaulted default constructor<\/p>\n<p>In cases where we would write a default constructor that is equivalent to the implicitly generated default constructor, we can instead tell the compiler to generate a default constructor for us.  This constructor is called an <strong>explicitly defaulted default constructor<\/strong>, and it can be generated by using the <code>= default<\/code> syntax:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Foo\r\n{\r\nprivate:\r\n    int m_x {};\r\n    int m_y {};\r\n\r\npublic:\r\n    Foo() = default; \/\/ generates an explicitly defaulted default constructor\r\n\r\n    Foo(int x, int y)\r\n        : m_x { x }, m_y { y }\r\n    {\r\n        std::cout &lt;&lt; \"Foo(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \") constructed\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Foo foo{}; \/\/ calls Foo() default constructor\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, since we have a user-declared constructor (<code>Foo(int, int)<\/code>), an implicit default constructor would not normally be generated.  However, because we&#8217;ve told the compiler to generate such a constructor, it will.  This constructor will subsequently be used by our instantiation of <code>foo{}<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Prefer an explicitly defaulted default constructor (<code>= default<\/code>) over a default constructor with an empty body.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Explicitly defaulted default constructor vs empty user-defined constructor<\/p>\n<p>There are at least two cases where the explicitly defaulted default constructor behaves differently than an empty user-defined constructor.<\/p>\n<ol start=\"1\">\n<li>When value initializing a class, if the class has a user-defined default constructor, the object will be default initialized.  However, if the class has a default constructor that is not user-provided (that is, a default constructor that is either implicitly defined, or defined using <code>= default<\/code>), the object will be zero-initialized before being default initialized.\n<\/li>\n<\/ol>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass User\r\n{\r\nprivate:\r\n    int m_a; \/\/ note: no default initialization value\r\n    int m_b {};\r\n\r\npublic:\r\n    User() {} \/\/ user-defined empty constructor\r\n\r\n    int a() const { return m_a; }\r\n    int b() const { return m_b; }\r\n};\r\n\r\nclass Default\r\n{\r\nprivate:\r\n    int m_a; \/\/ note: no default initialization value\r\n    int m_b {};\r\n\r\npublic:\r\n    Default() = default; \/\/ explicitly defaulted default constructor\r\n\r\n    int a() const { return m_a; }\r\n    int b() const { return m_b; }\r\n};\r\n\r\nclass Implicit\r\n{\r\nprivate:\r\n    int m_a; \/\/ note: no default initialization value\r\n    int m_b {};\r\n\r\npublic:\r\n    \/\/ implicit default constructor\r\n\r\n    int a() const { return m_a; }\r\n    int b() const { return m_b; }\r\n};\r\n\r\nint main()\r\n{\r\n    User user{}; \/\/ default initialized\r\n    std::cout &lt;&lt; user.a() &lt;&lt; ' ' &lt;&lt; user.b() &lt;&lt; '\\n';\r\n\r\n    Default def{}; \/\/ zero initialized, then default initialized\r\n    std::cout &lt;&lt; def.a() &lt;&lt; ' ' &lt;&lt; def.b() &lt;&lt; '\\n';\r\n\r\n    Implicit imp{}; \/\/ zero initialized, then default initialized\r\n    std::cout &lt;&lt; imp.a() &lt;&lt; ' ' &lt;&lt; imp.b() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>On the author&#8217;s machine, this prints:<\/p>\n<pre>\n782510864 0\r\n0 0\r\n0 0\r\n<\/pre>\n<p>Note that <code>user.a<\/code> was not zero initialized before being default initialized, and thus was left uninitialized.<\/p>\n<p>In practice, this shouldn&#8217;t matter since you should be providing default member initializers for all data members!<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>For a class that does not have a user-provided default constructor, value initialization will first zero-initialize the class, while default initialization will not.  Given this, default initialization may be more performant than value initialization (at the cost of being less safe).  If you are looking to squeeze out every bit of performance in a section of code that initializes a lot of objects that do not have user-provided default constructors, changing those objects to be default initialized may be worth exploring.  Alternatively, you could try changing the class to have a default constructor with an empty body.  This avoids the zero-initialization case when using value initialization, but may inhibit other optimizations.\n<\/p><\/div>\n<ol start=\"2\">\n<li>Prior to C++20, a class with a user-defined default constructor (even if it has an empty body) makes the class a non-aggregate, whereas an explicitly defaulted default constructor does not.  Assuming the class was otherwise an aggregate, the former would cause the class to use list initialization instead of aggregate initialization.  In C++20 onward, this inconsistency was addressed, so that both make the class a non-aggregate.\n<\/li>\n<\/ol>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Only create a default constructor when it makes sense<\/p>\n<p>A default constructor allows us to create objects of a non-aggregate class type with no user-provided initialization values.  Thus, a class should only provide a default constructor when it makes sense for objects of a class type to be created using all default values.<\/p>\n<p>For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Fraction\r\n{\r\nprivate:\r\n    int m_numerator{ 0 };\r\n    int m_denominator{ 1 };\r\n\r\npublic:\r\n    Fraction() = default;\r\n    Fraction(int numerator, int denominator)\r\n        : m_numerator{ numerator }\r\n        , m_denominator{ denominator }\r\n    {\r\n    }\r\n\r\n    void print() const\r\n    {\r\n        std::cout &lt;&lt; \"Fraction(\" &lt;&lt; m_numerator &lt;&lt; \", \" &lt;&lt; m_denominator &lt;&lt; \")\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Fraction f1 {3, 5};\r\n    f1.print();\r\n\r\n    Fraction f2 {}; \/\/ will get Fraction 0\/1\r\n    f2.print();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>For a class representing a fraction, it makes sense to allow the user to create Fraction objects with no initializers (in which case, the user will get the fraction 0\/1).<\/p>\n<p>Now consider this class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Employee\r\n{\r\nprivate:\r\n    std::string m_name{ };\r\n    int m_id{ };\r\n\r\npublic:\r\n    Employee(std::string_view name, int id)\r\n        : m_name{ name }\r\n        , m_id{ id }\r\n    {\r\n    }\r\n\r\n    void print() const\r\n    {\r\n        std::cout &lt;&lt; \"Employee(\" &lt;&lt; m_name &lt;&lt; \", \" &lt;&lt; m_id &lt;&lt; \")\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Employee e1 { \"Joe\", 1 };\r\n    e1.print();\r\n\r\n    Employee e2 {}; \/\/ compile error: no matching constructor\r\n    e2.print();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>For a class representing an employee, it doesn&#8217;t make sense to allow creation of employees with no name.  Thus, such a class should not have a default constructor, so that a compilation error will result if the user of the class tries to do so.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/delegating-constructors\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.12<\/span>Delegating constructors\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constructor-member-initializer-lists\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.10<\/span>Constructor member initializer lists\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>A is a constructor that accepts no arguments. Typically, this is a constructor that has been defined with no parameters. Here is an example of a class that has a default constructor: #include &lt;iostream&gt; class Foo { public: Foo() \/\/ default constructor { std::cout &lt;&lt; &#8220;Foo default constructed\\n&#8221;; } }; &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15343"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15343"}],"version-history":[{"count":15,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15343\/revisions"}],"predecessor-version":[{"id":17611,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15343\/revisions\/17611"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15343"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15343"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15343"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}