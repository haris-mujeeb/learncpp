{"id":106,"date":"2007-07-16T18:19:52","date_gmt":"2007-07-17T02:19:52","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-programming\/611-references-2\/"},"modified":"2024-11-11T13:33:39","modified_gmt":"2024-11-11T21:33:39","slug":"lvalue-references","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/lvalue-references\/","title":{"rendered":"12.3 &#8212;  Lvalue references"},"content":{"rendered":"<p>In C++, a <strong>reference<\/strong> is an alias for an existing object.  Once a reference has been defined, any operation on the reference is applied to the object being referenced.  This means we can use a reference to read or modify the object being referenced.<\/p>\n<p>Although references might seem silly, useless, or redundant at first, references are used everywhere in C++ (we&#8217;ll see examples of this in a few lessons).<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>A reference is essentially identical to the object being referenced.\n<\/p><\/div>\n<p>You can also create references to functions, though this is done less often.<\/p>\n<p>Modern C++ contains two types of references: lvalue references, and rvalue references.  In this chapter, we&#8217;ll discuss lvalue references.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>Because we&#8217;ll be talking about lvalues and rvalues in this lesson, please review <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/value-categories-lvalues-and-rvalues\/\">12.2 -- Value categories (lvalues and rvalues)<\/a> if you need a refresher on these terms before proceeding.  Rvalue references are covered in the chapter on move semantics (<a href=\"https:\/\/www.learncpp.com#Chapter22\">chapter 22<\/a>).\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Lvalue references types<\/p>\n<p>An <strong>lvalue reference<\/strong> (commonly just called a &#8220;reference&#8221; since prior to C++11 there was only one type of reference) acts as an alias for an existing lvalue (such as a variable).<\/p>\n<p>Just like the type of an object determines what kind of value it can hold, the type of a reference determines what type of object it can reference.  Lvalue reference types can be identified by use of a single ampersand (&#038;) in the type specifier:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ regular types\r\nint        \/\/ a normal int type (not an reference)\r\nint&amp;       \/\/ an lvalue reference to an int object\r\ndouble&amp;    \/\/ an lvalue reference to a double object\r\nconst int&amp; \/\/ an lvalue reference to a const int object<\/code><\/pre>\n<p>For example, <code>int&amp;<\/code> is the type of an lvalue reference to an <code>int<\/code> object, and <code>const int&amp;<\/code> is the type of an lvalue reference to a <code>const int<\/code> object.<\/p>\n<p>A type that specifies a reference (e.g. <code>int&amp;<\/code>) is called a <strong>reference type<\/strong>.  The type that can be referenced (e.g. <code>int<\/code>) is called the <strong>referenced type<\/strong>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Nomenclature<\/p>\n<p>There are two kinds of lvalue references:<\/p>\n<ul>\n<li>An lvalue reference to a non-const is commonly just called an &#8220;lvalue reference&#8221;, but may also be referred to as an <strong>lvalue reference to non-const<\/strong> or a <strong>non-const lvalue reference<\/strong> (since it isn&#8217;t defined using the <code>const<\/code> keyword).\n<\/li>\n<li>An lvalue reference to a const  is commonly called either an <strong>lvalue reference to const<\/strong> or a <strong>const lvalue reference<\/strong>.\n<\/li>\n<\/ul>\n<\/div>\n<p>We&#8217;ll focus on non-const lvalue references in this lesson, and on const lvalue references in the next lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/lvalue-references-to-const\/\">12.4 -- Lvalue references to const<\/a>).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Lvalue reference variables<\/p>\n<p>One of the things we can do with an lvalue reference type is create an lvalue reference variable.  An <strong>lvalue reference variable<\/strong> is a variable that acts as a reference to an lvalue (usually another variable).<\/p>\n<p>To create an lvalue reference variable, we simply define a variable with an lvalue reference type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 5 };    \/\/ x is a normal integer variable\r\n    int&amp; ref { x }; \/\/ ref is an lvalue reference variable that can now be used as an alias for variable x\r\n\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n';  \/\/ print the value of x (5)\r\n    std::cout &lt;&lt; ref &lt;&lt; '\\n'; \/\/ print the value of x via ref (5)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, the type <code>int&amp;<\/code> defines <code>ref<\/code> as an lvalue reference to an int, which we then initialize with lvalue expression <code>x<\/code>.  Thereafter, <code>ref<\/code> and <code>x<\/code> can be used synonymously.  This program thus prints:<\/p>\n<pre>\n5\r\n5\r\n<\/pre>\n<p>From the compiler&#8217;s perspective, it doesn&#8217;t matter whether the ampersand is &#8220;attached&#8221; to the type name (<code>int&amp; ref<\/code>) or the variable&#8217;s name (<code>int &amp;ref<\/code>), and which you choose is a matter of style.  Modern C++ programmers tend to prefer attaching the ampersand to the type, as it makes clearer that the reference is part of the type information, not the identifier.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>When defining a reference, place the ampersand next to the type (not the reference variable&#8217;s name).\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>For those of you already familiar with pointers, the ampersand in this context does not mean &#8220;address of&#8221;, it means &#8220;lvalue reference to&#8221;.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Modifying values through a non-const lvalue reference<\/p>\n<p>In the above example, we showed that we can use a reference to read the value of the object being referenced.  We can also use a non-const reference to modify the value of the object being referenced:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 5 }; \/\/ normal integer variable\r\n    int&amp; ref { x }; \/\/ ref is now an alias for variable x\r\n\r\n    std::cout &lt;&lt; x &lt;&lt; ref &lt;&lt; '\\n'; \/\/ print 55\r\n\r\n    x = 6; \/\/ x now has value 6\r\n\r\n    std::cout &lt;&lt; x &lt;&lt; ref &lt;&lt; '\\n'; \/\/ prints 66\r\n\r\n    ref = 7; \/\/ the object being referenced (x) now has value 7\r\n\r\n    std::cout &lt;&lt; x &lt;&lt; ref &lt;&lt; '\\n'; \/\/ prints 77\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This code prints:<\/p>\n<pre>\n55\r\n66\r\n77\r\n<\/pre>\n<p>In the above example, <code>ref<\/code> is an alias for <code>x<\/code>, so we are able to change the value of <code>x<\/code> through either <code>x<\/code> or <code>ref<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Reference initialization<\/p>\n<p>Much like constants, all references must be initialized.  References are initialized using a form of initialization called <strong>reference initialization<\/strong>.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int&amp; invalidRef;   \/\/ error: references must be initialized\r\n\r\n    int x { 5 };\r\n    int&amp; ref { x }; \/\/ okay: reference to int is bound to int variable\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>When a reference is initialized with an object (or function), we say it is <strong>bound<\/strong> to that object (or function).  The process by which such a reference is bound is called <strong>reference binding<\/strong>.  The object (or function) being referenced is sometimes called the <strong>referent<\/strong>.<\/p>\n<p>Non-const lvalue references can only be bound to a <em>modifiable<\/em> lvalue.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int x { 5 };\r\n    int&amp; ref { x };         \/\/ okay: non-const lvalue reference bound to a modifiable lvalue\r\n\r\n    const int y { 5 };\r\n    int&amp; invalidRef { y };  \/\/ invalid: non-const lvalue reference can't bind to a non-modifiable lvalue \r\n    int&amp; invalidRef2 { 0 }; \/\/ invalid: non-const lvalue reference can't bind to an rvalue\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>If non-const lvalue references could be bound to non-modifiable (const) lvalues or rvalues, then you would be able to change those values through the reference, which would be a violation of their const-ness.\n<\/p><\/div>\n<p>Lvalue references to <code>void<\/code> are disallowed (what would be the point?).<\/p>\n<p>Even though the type of the reference (e.g. <code>int&amp;<\/code>) doesn&#8217;t exactly match the type of the object being bound (e.g. <code>int<\/code>), no conversion is applied here (not even a trivial conversion) -- the difference in types is handled as part of the reference initialization process.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A reference will (usually) only bind to an object matching its referenced type<\/p>\n<p>In most cases, a reference will only bind to an object whose type matches the referenced type, (there are some exceptions to this rule that we&#8217;ll discuss when we get into inheritance).<\/p>\n<p>If you try to bind a reference to an object that does not match its referenced type, the compiler will try to implicitly convert the object to the referenced type and then bind the reference to that.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Since the result of a conversion is an rvalue, and a non-const lvalue reference can&#8217;t bind to an rvalue, trying to bind a non-const lvalue reference to an object that does not match its referenced type will result in a compilation error.\n<\/p><\/div>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int x { 5 };\r\n    int&amp; ref { x };            \/\/ okay: referenced type (int) matches type of initializer\r\n\r\n    double d { 6.0 };\r\n    int&amp; invalidRef { d };     \/\/ invalid: conversion of double to int is narrowing conversion, disallowed by list initialization\r\n    double&amp; invalidRef2 { x }; \/\/ invalid: non-const lvalue reference can't bind to rvalue (result of converting x to double)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">References can&#8217;t be reseated (changed to refer to another object)<\/p>\n<p>Once initialized, a reference in C++ cannot be <strong>reseated<\/strong>, meaning it cannot be changed to reference another object.<\/p>\n<p>New C++ programmers often try to reseat a reference by using assignment to provide the reference with another variable to reference.  This will compile and run -- but not function as expected.  Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 5 };\r\n    int y { 6 };\r\n\r\n    int&amp; ref { x }; \/\/ ref is now an alias for x\r\n    \r\n    ref = y; \/\/ assigns 6 (the value of y) to x (the object being referenced by ref)\r\n    \/\/ The above line does NOT change ref into a reference to variable y!\r\n\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n'; \/\/ user is expecting this to print 5\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Perhaps surprisingly, this prints:<\/p>\n<pre>\n6\r\n<\/pre>\n<p>When a reference is evaluated in an expression, it resolves to the object it&#8217;s referencing.  So <code>ref = y<\/code> doesn&#8217;t change <code>ref<\/code> to now reference <code>y<\/code>.  Rather, because <code>ref<\/code> is an alias for <code>x<\/code>, the expression evaluates as if it was written <code>x = y<\/code> -- and since <code>y<\/code> evaluates to value <code>6<\/code>, <code>x<\/code> is assigned the value <code>6<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Reference scope and duration<\/p>\n<p>Reference variables follow the same scoping and duration rules that normal variables do:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 5 }; \/\/ normal integer\r\n    int&amp; ref { x }; \/\/ reference to variable value\r\n\r\n     return 0;\r\n} \/\/ x and ref die here<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">References and referents have independent lifetimes<\/p>\n<p>With one exception (that we&#8217;ll cover next lesson), the lifetime of a reference and the lifetime of its referent are independent.  In other words, both of the following are true:<\/p>\n<ul>\n<li>A reference can be destroyed before the object it is referencing.\n<\/li>\n<li>The object being referenced can be destroyed before the reference.\n<\/li>\n<\/ul>\n<p>When a reference is destroyed before the referent, the referent is not impacted.  The following program demonstrates this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x { 5 };\r\n\r\n    {\r\n        int&amp; ref { x };   \/\/ ref is a reference to x\r\n        std::cout &lt;&lt; ref &lt;&lt; '\\n'; \/\/ prints value of ref (5)\r\n    } \/\/ ref is destroyed here -- x is unaware of this\r\n\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n'; \/\/ prints value of x (5)\r\n\r\n    return 0;\r\n} \/\/ x destroyed here<\/code><\/pre>\n<p>The above prints:<\/p>\n<pre>\n5\r\n5\r\n<\/pre>\n<p>When <code>ref<\/code> dies, variable <code>x<\/code> carries on as normal, blissfully unaware that a reference to it has been destroyed.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Dangling references<\/p>\n<p>When an object being referenced is destroyed before a reference to it, the reference is left referencing an object that no longer exists.  Such a reference is called a <strong>dangling reference<\/strong>.  Accessing a dangling reference leads to undefined behavior.<\/p>\n<p>Dangling references are fairly easy to avoid, but we&#8217;ll show a case where this can happen in practice in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/return-by-reference-and-return-by-address\/\">12.12 -- Return by reference and return by address<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">References aren&#8217;t objects<\/p>\n<p>Perhaps surprisingly, references are not objects in C++.  A reference is not required to exist or occupy storage.  If possible, the compiler will optimize references away by replacing all occurrences of a reference with the referent.  However, this isn&#8217;t always possible, and in such cases, references may require storage.<\/p>\n<p>This also means that the term &#8220;reference variable&#8221; is a bit of a misnomer, as variables are objects with a name, and references aren&#8217;t objects.<\/p>\n<p>Because references aren&#8217;t objects, they can&#8217;t be used anywhere an object is required (e.g. you can&#8217;t have a reference to a reference, since an lvalue reference must reference an identifiable object).  In cases where you need a reference that is an object or a reference that can be reseated, <code>std::reference_wrapper<\/code> (which we cover in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/aggregation\/\">23.3 -- Aggregation<\/a>) provides a solution.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>Consider the following variables:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int var{};\r\nint&amp; ref1{ var };  \/\/ an lvalue reference bound to var\r\nint&amp; ref2{ ref1 }; \/\/ an lvalue reference bound to var<\/code><\/pre>\n<p>Because <code>ref2<\/code> (a reference) is initialized with <code>ref1<\/code> (a reference), you might be tempted to conclude that <code>ref2<\/code> is a reference to a reference.  It is not.  Because <code>ref1<\/code> is a reference to <code>var<\/code>, when used in an expression (such as an initializer), <code>ref1<\/code> evaluates to <code>var<\/code>.  So <code>ref2<\/code> is just a normal lvalue reference (as indicated by its type <code>int&amp;<\/code>), bound to <code>var<\/code>.<\/p>\n<p>A reference to a reference (to an <code>int<\/code>) would have syntax <code>int&amp;&amp;<\/code> -- but since C++ doesn&#8217;t support references to references, this syntax was repurposed in C++11 to indicate an rvalue reference (which we cover in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/rvalue-references\/\">22.2 -- R-value references<\/a>).\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>If references seem a bit useless at this point, don&#8217;t worry.  References are used a lot, and we&#8217;ll cover one of the primary reasons why shortly, in lessons <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pass-by-lvalue-reference\/\">12.5 -- Pass by lvalue reference<\/a> and <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pass-by-const-lvalue-reference\/\">12.6 -- Pass by const lvalue reference<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Determine what values the following program prints by yourself (do not compile the program).<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x{ 1 };\r\n    int&amp; ref{ x };\r\n\r\n    std::cout &lt;&lt; x &lt;&lt; ref &lt;&lt; '\\n';\r\n\r\n    int y{ 2 };\r\n    ref = y;\r\n    y = 3;\r\n\r\n    std::cout &lt;&lt; x &lt;&lt; ref &lt;&lt; '\\n';\r\n\r\n    x = 4;\r\n\r\n    std::cout &lt;&lt; x &lt;&lt; ref &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>11<br \/>\n22<br \/>\n44<\/p>\n<p>Because <code>ref<\/code> is bound to <code>x<\/code>, <code>x<\/code> and <code>ref<\/code> are synonymous, so they will always print the same value.  The line <code>ref = y<\/code> assigns the value of <code>y<\/code> (2) to <code>ref<\/code> -- it does not change <code>ref<\/code> to reference <code>y<\/code>.  The subsequent line <code>y = 3<\/code> only changes <code>y<\/code>.\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/lvalue-references-to-const\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.4<\/span>Lvalue references to const\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/value-categories-lvalues-and-rvalues\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.2<\/span>Value categories (lvalues and rvalues)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In C++, a reference is an alias for an existing object. Once a reference has been defined, any operation on the reference is applied to the object being referenced. This means we can use a reference to read or modify the object being referenced. Although references might seem silly, useless, &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/106"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=106"}],"version-history":[{"count":58,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/106\/revisions"}],"predecessor-version":[{"id":17849,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/106\/revisions\/17849"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=106"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=106"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=106"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}