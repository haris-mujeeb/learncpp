{"id":4979,"date":"2016-11-09T18:23:26","date_gmt":"2016-11-10T02:23:26","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=4979"},"modified":"2025-03-05T17:34:03","modified_gmt":"2025-03-06T01:34:03","slug":"using-declarations-and-using-directives","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/using-declarations-and-using-directives\/","title":{"rendered":"7.13 &#8212; Using declarations and using directives"},"content":{"rendered":"<p>You&#8217;ve probably seen this program in a lot of textbooks and tutorials:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n    cout &lt;&lt; \"Hello world!\\n\";\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>If you see this, run.  Your textbook or tutorial are probably out of date.  In this lesson, we&#8217;ll explore why.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>Some IDEs will also auto-populate new C++ projects with a similar program (so you can compile something immediately, rather than starting from a blank file).\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A short history lesson<\/p>\n<p>Back before C++ had support for namespaces, all of the names that are now in the <code>std<\/code> namespace were in the global namespace.  This caused naming collisions between program identifiers and standard library identifiers.  Programs that worked under one version of C++ might have a naming conflict with a newer version of C++.<\/p>\n<p>In 1995, namespaces were standardized, and all of the functionality from the standard library was moved out of the global namespace and into namespace <code>std<\/code>.  This change broke older code that was still using names without <code>std::<\/code>.<\/p>\n<p>As anyone who has worked on a large codebase knows, any change to a codebase (no matter how trivial) risks breaking the program.  Updating every name that was now moved into the <code>std<\/code> namespace to use the <code>std::<\/code> prefix was a massive risk.  A solution was requested.<\/p>\n<p>Fast forward to today -- if you&#8217;re using the standard library a lot, typing <code>std::<\/code> before everything you use from the standard library can become repetitive, and in some cases, can make your code harder to read.<\/p>\n<p>C++ provides some solutions to both of these problems, in the form of using-statements.<\/p>\n<p>But first, let&#8217;s define two terms.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Qualified and unqualified names<\/p>\n<p>A name can be either qualified or unqualified.<\/p>\n<p>A <strong>qualified name<\/strong> is a name that includes an associated scope.  Most often, names are qualified with a namespace using the scope resolution operator (::).  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::cout \/\/ identifier cout is qualified by namespace std\r\n::foo \/\/ identifier foo is qualified by the global namespace<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>A name can also be qualified by a class name using the scope resolution operator (::), or by a class object using the member selection operators (. or ->).  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class C; \/\/ some class\r\n\r\nC::s_member; \/\/ s_member is qualified by class C\r\nobj.x; \/\/ x is qualified by class object obj\r\nptr-&gt;y; \/\/ y is qualified by pointer to class object ptr<\/code><\/pre>\n<\/div>\n<p>An <strong>unqualified name<\/strong> is a name that does not include a scoping qualifier.  For example, <code>cout<\/code> and <code>x<\/code> are unqualified names, as they do not include an associated scope.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using-declarations<\/p>\n<p>One way to reduce the repetition of typing <code>std::<\/code> over and over is to utilize a using-declaration statement.  A <strong>using declaration<\/strong> allows us to use an unqualified name (with no scope) as an alias for a qualified name.<\/p>\n<p>Here&#8217;s our basic Hello world program, using a using-declaration on line 5:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n   using std::cout; \/\/ this using declaration tells the compiler that cout should resolve to std::cout\r\n   cout &lt;&lt; \"Hello world!\\n\"; \/\/ so no std:: prefix is needed here!\r\n\r\n   return 0;\r\n} \/\/ the using declaration expires at the end of the current scope<\/code><\/pre>\n<p>The using-declaration <code>using std::cout;<\/code> tells the compiler that we&#8217;re going to be using the object <code>cout<\/code> from the <code>std<\/code> namespace.  So whenever it sees <code>cout<\/code>, it will assume that we mean <code>std::cout<\/code>.  If there&#8217;s a naming conflict between <code>std::cout<\/code> and some other use of <code>cout<\/code> that is visible from within <code>main()<\/code>, <code>std::cout<\/code> will be preferred.  Therefore on line 6, we can type <code>cout<\/code> instead of <code>std::cout<\/code>.<\/p>\n<p>This doesn&#8217;t save much effort in this trivial example, but if you are using <code>cout<\/code> many times inside of a function, a using-declaration can make your code more readable.  Note that you will need a separate using-declaration for each name (e.g. one for <code>std::cout<\/code>, one for <code>std::cin<\/code>, etc&#8230;).<\/p>\n<p>The using-declaration is active from the point of declaration to the end of the scope in which it is declared.<\/p>\n<p>Although using-declarations are less explicit than using the <code>std::<\/code> prefix, they are generally considered safe and acceptable to use in source (.cpp) files, with one exception that we&#8217;ll discuss below.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using-directives<\/p>\n<p>Another way to simplify things is to use a using-directive.  A <strong>using directive<\/strong> allows <em>all<\/em> identifiers in a given namespace to be referenced without qualification from the scope of the using-directive. <\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>For technical reasons, using-directives do not actually introduce new meanings for names into the current scope -- instead they introduce new meanings for names into an outer scope (more details about which outer scope is picked can be found <a href=\"https:\/\/quuxplusone.github.io\/blog\/2020\/12\/21\/using-directive\/\">here<\/a>).\n<\/div>\n<p>Here&#8217;s our Hello world program again, with a using-directive on line 5:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n   using namespace std; \/\/ all names from std namespace now accessible without qualification\r\n   cout &lt;&lt; \"Hello world!\\n\"; \/\/ so no std:: prefix is needed here\r\n\r\n   return 0;\r\n} \/\/ the using-directive ends at the end of the current scope<\/code><\/pre>\n<p>The using-directive <code>using namespace std;<\/code> tells the compiler that all of the names in the <code>std<\/code> namespace should be accessible without qualification in the current scope (in this case, of function <code>main()<\/code>).  When we then use unqualified identifier <code>cout<\/code>, it will resolve to <code>std::cout<\/code>.<\/p>\n<p>Using-directives are the solution that was provided for old pre-namespace codebases that used unqualified names for standard library functionality.  Rather than having to manually update every unqualified name to a qualified name (which was risky), a single using-directive (<code>using namespace std;<\/code>) could be placed at the top of each file, and all of the names that had been moved to the <code>std<\/code> namespace could still be used unqualified.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><a name=\"avoidUsingNamespace\"><\/a>Problems with using-directives (a.k.a. why you should avoid &#8220;using namespace std;&#8221;) <a href=\"#avoidUsingNamespace\"><i class=\"fa fa-link\" style=\"font-size: 0.8em;\"><\/i><\/a><\/p>\n<p>In modern C++, using-directives generally offer little benefit (saving some typing) compared to the risk.  This is due to two factors:<\/p>\n<ol start=\"1\">\n<li>Using-directives allow unqualified access to <em>all<\/em> of the names from a namespace (potentially including lots of names you&#8217;ll never use).\n<\/li>\n<li>Using-directives do not prefer names from the namespace identified by the using-directive over other names.\n<\/li>\n<\/ol>\n<p>The end result is that the possibility for naming collisions to occur increases significantly (especially if you import the <code>std<\/code> namespace).<\/p>\n<p>First, let&#8217;s take a look at an illustrative example where using-directives cause a naming collision:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nnamespace A\r\n{\r\n\tint x { 10 };\r\n}\r\n\r\nnamespace B\r\n{\r\n\tint x{ 20 };\r\n}\r\n\r\nint main()\r\n{\r\n\tusing namespace A;\r\n\tusing namespace B;\r\n\r\n\tstd::cout &lt;&lt; x &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In the above example, the compiler is unable to determine whether the <code>x<\/code> in <code>main<\/code> refers to <code>A::x<\/code> or <code>B::x<\/code>.  In this case, it will fail to compile with an &#8220;ambiguous symbol&#8221; error.  We could resolve this by removing one of the using-directives, employing a using-declaration instead, or qualifying <code>x<\/code> (as <code>A::x<\/code> or <code>B::x<\/code>).<\/p>\n<p>Here&#8217;s another more subtle example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt; \/\/ imports the declaration of std::cout\r\n\r\nint cout() \/\/ declares our own \"cout\" function\r\n{\r\n    return 5;\r\n}\r\n\r\nint main()\r\n{\r\n    using namespace std; \/\/ makes std::cout accessible as \"cout\"\r\n    cout &lt;&lt; \"Hello, world!\\n\"; \/\/ uh oh!  Which cout do we want here?  The one in the std namespace or the one we defined above?\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this example, the compiler is unable to determine whether our unqualified use of <code>cout<\/code> means <code>std::cout<\/code> or the <code>cout<\/code> function we&#8217;ve defined, and again will fail to compile with an &#8220;ambiguous symbol&#8221; error.  Although this example is trivial, if we had explicitly prefixed <code>std::cout<\/code> like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    std::cout &lt;&lt; \"Hello, world!\\n\"; \/\/ tell the compiler we mean std::cout<\/code><\/pre>\n<p>or used a using-declaration instead of a using-directive:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    using std::cout; \/\/ tell the compiler that cout means std::cout\r\n    cout &lt;&lt; \"Hello, world!\\n\"; \/\/ so this means std::cout<\/code><\/pre>\n<p>then our program wouldn&#8217;t have any issues in the first place.  And while you&#8217;re probably not likely to write a function named &#8220;cout&#8221;, there are hundreds of other names in the <code>std<\/code> namespace just waiting to collide with your names.<\/p>\n<p>Even if a using-directive does not cause naming collisions today, it makes your code more vulnerable to future collisions.  For example, if your code includes a using-directive for some library that is then updated, all of the new names introduced in the updated library are now candidates for naming collisions with your existing code.<\/p>\n<p>For example, the following program compiles and runs fine:<\/p>\n<p>FooLib.h (part of some third-party library):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef FOOLIB\r\n#define FOOLIB\r\n\r\nnamespace Foo\r\n{\r\n    int a { 20 };\r\n}\r\n\r\n#endif<\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;FooLib.h&gt; \/\/ a third-party library we installed outside our project directory, thus angled brackets used\r\n\r\nvoid print()\r\n{\r\n    std::cout &lt;&lt; \"Hello\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    using namespace Foo; \/\/ Because we're lazy and want to access Foo:: qualified names without typing the Foo:: prefix\r\n\r\n    std::cout &lt;&lt; a &lt;&lt; '\\n'; \/\/ uses Foo::a\r\n    print(); \/\/ calls ::print()\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Now let&#8217;s say you update FooLib to a new version, and FooLib.h changes to this:<\/p>\n<p>FooLib.h (updated):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef FOOLIB\r\n#define FOOLIB\r\n\r\nnamespace Foo\r\n{\r\n    int a { 20 };\r\n    void print() { std::cout &lt;&lt; \"Timmah!\"; } \/\/ This function added\r\n}\r\n#endif<\/code><\/pre>\n<p>Your main.cpp hasn&#8217;t changed, but it will no longer compile!  This is because our using-directive causes <code>Foo::print()<\/code> to be accessible as just <code>print()<\/code>, and it is now ambiguous whether the call to <code>print()<\/code> means <code>::print()<\/code> or <code>Foo::print()<\/code>.<\/p>\n<p>There is a more insidious version of this problem that can occur as well.  The updated library may introduce a function that not only has the same name, but is actually a better match for some function call.  In such a case, the compiler may decide to prefer the new function instead, and the behavior of your program will change unexpectedly and silently.<\/p>\n<p>Consider the following program:<\/p>\n<p>Foolib.h (part of some third-party library):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef FOOLIB_H\r\n#define FOOLIB_H\r\n\r\nnamespace Foo\r\n{\r\n    int a { 20 };\r\n}\r\n#endif<\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;Foolib.h&gt; \/\/ a third-party library we installed outside our project directory, thus angled brackets used\r\n\r\nint get(long)\r\n{\r\n    return 1;\r\n}\r\n\r\nint main()\r\n{\r\n    using namespace Foo; \/\/ Because we're lazy and want to access Foo:: qualified names without typing the Foo:: prefix\r\n    std::cout &lt;&lt; a &lt;&lt; '\\n'; \/\/ uses Foo::a\r\n\r\n    std::cout &lt;&lt; get(0) &lt;&lt; '\\n'; \/\/ calls ::get(long)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program runs and prints <code>1<\/code>.<\/p>\n<p>Now, let&#8217;s say we update the Foolib library, which includes an updated Foolib.h that looks like this:<\/p>\n<p>Foolib.h (updated):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef FOOLIB_H\r\n#define FOOLIB_H\r\n\r\nnamespace Foo\r\n{\r\n    int a { 20 };\r\n\r\n    int get(int) { return 2; } \/\/ new function added\r\n}\r\n#endif<\/code><\/pre>\n<p>Once again, our <code>main.cpp<\/code> file hasn&#8217;t changed at all, but this program now compiles, runs, and prints <code>2<\/code>!<\/p>\n<p>When the compiler encounters a function call, it has to determine what function definition it should match the function call with.  In selecting a function from a set of potentially matching functions, it will prefer a function that requires no argument conversions over a function that requires argument conversions.  Because the literal <code>0<\/code> is an integer, C++ will prefer to match <code>print(0)<\/code> with the newly introduced <code>print(int)<\/code> (no conversions) over <code>print(long)<\/code> (which requires a conversion from <code>int<\/code> to <code>long<\/code>).  That causes an unexpected change to our program behavior.<\/p>\n<p>In this case, the change in behavior is fairly obvious.  But in a more complex program, where the returned value isn&#8217;t just printed, this issue could be very difficult to discover.<\/p>\n<p>This would not have happened if we&#8217;d used a using-declaration or explicit scope qualifier.<\/p>\n<p>Finally, the lack of explicit scope prefixes make it harder for a reader to tell what functions are part of a library and what\u2019s part of your program. For example, if we use a using-directive:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">using namespace NS;\r\n\r\nint main()\r\n{\r\n    foo(); \/\/ is this foo a user-defined function, or part of the NS library?\r\n}<\/code><\/pre>\n<p>It\u2019s unclear whether the call to <code>foo()<\/code> is actually a call to <code>NS::foo()<\/code> or to a <code>foo()<\/code> that is a user-defined function.  Modern IDEs should be able to disambiguate this for you when you hover over a name, but having to hover over each name just to see where it comes from is tedious.<\/p>\n<p>Without the using-directive, it\u2019s much clearer:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    NS::foo(); \/\/ clearly part of the NS library\r\n    foo(); \/\/ likely a user-defined function\r\n}<\/code><\/pre>\n<p>In this version, the call to <code>NS::foo()<\/code> is clearly a library call. The call to plain <code>foo()<\/code> is probably a call to a user-defined function (some libraries, including certain standard library headers, do put names into the global namespace, so it\u2019s not a guarantee).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The scope of using-statements<\/p>\n<p>If a using-declaration or using-directive is used within a block, the names are applicable to just that block (it follows normal block scoping rules).  This is a good thing, as it reduces the chances for naming collisions to occur to just within that block.<\/p>\n<p>If a using-declaration or using-directive is used in a namespace (including the global namespace), the names are applicable to the entire rest of the file (they have file scope).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Do not use using-statements in header files, or before an #include directive<\/p>\n<p>A good rule of thumb is that using-statements should not be placed anywhere where they might have an impact on code in a different file.  Nor should they be placed anywhere where another file&#8217;s code might be able to impact them.<\/p>\n<p>More specifically, this means using-statements should not be used in header files, nor before an #include directive.<\/p>\n<p>For example, if you placed a using-statement in the global namespace of a header file, then every other file that #included that header would also get that using-statement.  That&#8217;s clearly bad.  This also applies to namespaces inside header files, for the same reason.<\/p>\n<p>But what about using-statements within functions defined inside header files?  Surely that can&#8217;t be bad since the scope of the using-statement is contained to the function, right?  Even that&#8217;s a no.  And it&#8217;s a no for the same reason that we shouldn&#8217;t use using-statements before an #include directive.<\/p>\n<p>It turns out that the behavior of using-statements is dependent on what identifiers have already been introduced.  This makes them order-dependent, as their function may change if the identifiers that have been introduced before them change.<\/p>\n<p>We will illustrate this with an example:<\/p>\n<p>FooInt.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">namespace Foo\r\n{\r\n    void print(int)\r\n    {\r\n        std::cout &lt;&lt; \"print(int)\\n\" &lt;&lt; std::endl;\r\n    }\r\n}<\/code><\/pre>\n<p>FooDouble.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">namespace Foo\r\n{\r\n    void print(double)\r\n    {\r\n        std::cout &lt;&lt; \"print(double)\\n\" &lt;&lt; std::endl;\r\n    }\r\n}<\/code><\/pre>\n<p>main.cpp (okay):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n#include \"FooDouble.h\"\r\n#include \"FooInt.h\"\r\n\r\nusing Foo::print; \/\/ print means Foo::print\r\n\r\nint main()\r\n{\r\n    print(5);  \/\/ Calls Foo::print(int)\r\n}<\/code><\/pre>\n<p>When run, this program calls <code>Foo::print(int)<\/code>, which prints <code>print(int)<\/code>.<\/p>\n<p>Now let&#8217;s change main.cpp slightly.<\/p>\n<p>main.cpp (bad):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n#include \"FooDouble.h\"\r\n\r\nusing Foo::print; \/\/ we moved the using-statement here, before the #include directive\r\n#include \"FooInt.h\"\r\n\r\nint main()\r\n{\r\n    print(5);  \/\/ Calls Foo::print(double)\r\n}<\/code><\/pre>\n<p>All we&#8217;ve done is move <code>using Foo::print;<\/code> before <code>#include \"FooInt.h\"<\/code>.  And our program now prints <code>print(double)<\/code>!  Regardless of why this happens, you&#8217;ll likely agree that this is the kind of behavior we want to avoid!<\/p>\n<p>So then to loop back around, the reason we shouldn&#8217;t use using-statements in functions that are defined in header files is the same reason -- we can&#8217;t control which other headers might be #included before our header, and it&#8217;s possible those headers might do something that alters the way our using-statement behaves!<\/p>\n<p>The only place it is truly safe to use using-statements is in our source (.cpp) files, after all the #includes.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>This example uses a concept we haven&#8217;t covered yet called &#8220;function overloading&#8221; (we cover this in lesson  <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-function-overloading\/\">11.1 -- Introduction to function overloading<\/a>).  All you need to know for this example is that two functions in the same scope can have the same name so long as the parameters of each are distinct.  Since <code>int<\/code> and <code>double<\/code> are distinct types, there is no issue having both <code>Foo::print(int)<\/code> and <code>Foo::print(double)<\/code> living side-by-side.<\/p>\n<p>In the working version, when the compiler encounters <code>using Foo::print<\/code>, it has already seen both <code>Foo::print(int)<\/code> and <code>Foo::print(double)<\/code>, so it makes both available to be called as just <code>print()<\/code>.  Since <code>Foo::print(int)<\/code> is a better match than <code>Foo::print(double)<\/code>, it calls <code>Foo::print(int)<\/code>.<\/p>\n<p>In the bad version, when the compiler encounters <code>using Foo::print<\/code>, it has only seen a declaration for <code>Foo::print(double)<\/code>, so it only makes <code>Foo::print(double)<\/code> available to be called unqualified.  So when we call <code>print(5)<\/code> only <code>Foo::print(double)<\/code> is even eligible to be matched.  Thus <code>Foo::print(double)<\/code> is the one that gets called!\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Cancelling or replacing a using-statement<\/p>\n<p>Once a using-statement has been declared, there&#8217;s no way to cancel or replace it with a different using-statement within the scope in which it was declared.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    using namespace Foo;\r\n\r\n    \/\/ there's no way to cancel the \"using namespace Foo\" here!\r\n    \/\/ there's also no way to replace \"using namespace Foo\" with a different using statement\r\n\r\n    return 0;\r\n} \/\/ using namespace Foo ends here<\/code><\/pre>\n<p>The best you can do is intentionally limit the scope of the using-statement from the outset using the block scoping rules.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    {\r\n        using namespace Foo;\r\n        \/\/ calls to Foo:: stuff here\r\n    } \/\/ using namespace Foo expires\r\n \r\n    {\r\n        using namespace Goo;\r\n        \/\/ calls to Goo:: stuff here\r\n    } \/\/ using namespace Goo expires\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Of course, all of this headache can be avoided by explicitly using the scope resolution operator (::) in the first place.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Best practices for using-statements<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Prefer explicit namespace qualifiers over using-statements.<\/p>\n<p>Avoid using-directives altogether (except <code>using namespace std::literals<\/code> to access the <code>s<\/code> and <code>sv<\/code> literal suffixes).  Using-declarations are okay in .cpp files, after the #include directives.  Do not use using-statements in header files (especially in the global namespace of header files).\n<\/div>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>The <code>using<\/code> keyword is also used to define type aliases, which are unrelated to using-statements.  We cover type aliases in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/typedefs-and-type-aliases\/\">10.7 -- Typedefs and type aliases<\/a>.\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/unnamed-and-inline-namespaces\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.14<\/span>Unnamed and inline namespaces\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/scope-duration-and-linkage-summary\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.12<\/span>Scope, duration, and linkage summary\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>You&#8217;ve probably seen this program in a lot of textbooks and tutorials: #include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; &#8220;Hello world!\\n&#8221;; return 0; } If you see this, run. Your textbook or tutorial are probably out of date. In this lesson, we&#8217;ll explore why. Tip Some IDEs &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4979"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=4979"}],"version-history":[{"count":50,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4979\/revisions"}],"predecessor-version":[{"id":18241,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4979\/revisions\/18241"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=4979"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=4979"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=4979"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}