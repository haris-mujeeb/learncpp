{"id":6024,"date":"2017-06-27T16:24:53","date_gmt":"2017-06-28T00:24:53","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=6024"},"modified":"2024-07-17T20:36:42","modified_gmt":"2024-07-18T03:36:42","slug":"hiding-inherited-functionality","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/hiding-inherited-functionality\/","title":{"rendered":"24.8 &#8212; Hiding inherited functionality"},"content":{"rendered":"<p><strong>Changing an inherited member&#8217;s access level<\/strong><\/p>\n<p>C++ gives us the ability to change an inherited member&#8217;s access specifier in the derived class.  This is done by using a <em>using declaration<\/em> to identify the (scoped) base class member that is having its access changed in the derived class, under the new access specifier.<\/p>\n<p>For example, consider the following Base:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\nprivate:\r\n    int m_value {};\r\n\r\npublic:\r\n    Base(int value)\r\n        : m_value { value }\r\n    {\r\n    }\r\n\r\nprotected:\r\n    void printValue() const { std::cout &lt;&lt; m_value; }\r\n};<\/code><\/pre>\n<p>Because Base::printValue() has been declared as protected, it can only be called by Base or its derived classes.  The public can not access it.<\/p>\n<p>Let&#8217;s define a Derived class that changes the access specifier of printValue() to public:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Derived: public Base\r\n{\r\npublic:\r\n    Derived(int value)\r\n        : Base { value }\r\n    {\r\n    }\r\n\r\n    \/\/ Base::printValue was inherited as protected, so the public has no access\r\n    \/\/ But we're changing it to public via a using declaration\r\n    using Base::printValue; \/\/ note: no parenthesis here\r\n};<\/code><\/pre>\n<p>This means that this code will now work:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    Derived derived { 7 };\r\n\r\n    \/\/ printValue is public in Derived, so this is okay\r\n    derived.printValue(); \/\/ prints 7\r\n    return 0;\r\n}<\/code><\/pre>\n<p>You can only change the access specifiers of base members the derived class would normally be able to access.  Therefore, you can never change the access specifier of a base member from private to protected or public, because derived classes do not have access to private members of the base class.<\/p>\n<p><strong>Hiding functionality<\/strong><\/p>\n<p>In C++, it is not possible to remove or restrict functionality from a base class other than by modifying the source code.  However, in a derived class, it is possible to hide functionality that exists in the base class, so that it can not be accessed through the derived class.  This can be done simply by changing the relevant access specifier.<\/p>\n<p>For example, we can make a public member private:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n\tint m_value{};\r\n};\r\n\r\nclass Derived : public Base\r\n{\r\nprivate:\r\n\tusing Base::m_value;\r\n\r\npublic:\r\n\tDerived(int value) : Base { value }\r\n\t{\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tDerived derived{ 7 };\r\n\tstd::cout &lt;&lt; derived.m_value; \/\/ error: m_value is private in Derived\r\n\r\n\tBase&amp; base{ derived };\r\n\tstd::cout &lt;&lt; base.m_value; \/\/ okay: m_value is public in Base\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This allowed us to take a poorly designed base class and encapsulate its data in our derived class.  Alternatively, instead of inheriting Base&#8217;s members publicly and making m_value private by overriding its access specifier, we could have inherited Base privately, which would have caused all of Base&#8217;s member to be inherited privately in the first place.<\/p>\n<p>However, it is worth noting that while m_value is private in the Derived class, it is still public in the Base class.  Therefore the encapsulation of m_value in Derived can still be subverted by casting to Base&#038; and directly accessing the member.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>For the same reason, if a Base class has a public virtual function, and the Derived class changes the access specifier to private, the public can still access the private Derived function by casting a Derived object to a Base&#038; and calling the virtual function.  The compiler will allow this because the function is public in Base.  However, because the object is actually a Derived, virtual function resolution will resolve to (and call) the (private) Derived version of the function.  Access controls are not enforced at runtime.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass A\r\n{\r\npublic:\r\n    virtual void fun()\r\n    {\r\n        std::cout &lt;&lt; \"public A::fun()\\n\";\r\n    }\r\n};\r\n\r\nclass B : public A\r\n{\r\nprivate:\r\n    virtual void fun()\r\n    {\r\n         std::cout &lt;&lt; \"private B::fun()\\n\";\r\n   }\r\n};\r\n\r\nint main()\r\n{\r\n    B b {};\r\n    b.fun();                  \/\/ compile error: not allowed as B::fun() is private\r\n    static_cast&lt;A&amp;&gt;(b).fun(); \/\/ okay: A::fun() is public, resolves to private B::fun() at runtime\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<p>Perhaps surprisingly, given a set of overloaded functions in the base class, there is no way to change the access specifier for a single overload.  You can only change them all:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Base\r\n{\r\npublic:\r\n    int m_value{};\r\n\r\n    int getValue() const { return m_value; }\r\n    int getValue(int) const { return m_value; }\r\n};\r\n\r\nclass Derived : public Base\r\n{\r\nprivate:\r\n\tusing Base::getValue; \/\/ make ALL getValue functions private\r\n\r\npublic:\r\n\tDerived(int value) : Base { value }\r\n\t{\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tDerived derived{ 7 };\r\n\tstd::cout &lt;&lt; derived.getValue();  \/\/ error: getValue() is private in Derived\r\n\tstd::cout &lt;&lt; derived.getValue(5); \/\/ error: getValue(int) is private in Derived\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Deleting functions in the derived class<\/p>\n<p>You can also mark member functions as deleted in the derived class, which ensures they can&#8217;t be called at all through a derived object:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\nclass Base\r\n{\r\nprivate:\r\n\tint m_value {};\r\n\r\npublic:\r\n\tBase(int value)\r\n\t\t: m_value { value }\r\n\t{\r\n\t}\r\n\r\n\tint getValue() const { return m_value; }\r\n};\r\n\r\nclass Derived : public Base\r\n{\r\npublic:\r\n\tDerived(int value)\r\n\t\t: Base { value }\r\n\t{\r\n\t}\r\n\r\n\r\n\tint getValue() const = delete; \/\/ mark this function as inaccessible\r\n};\r\n\r\nint main()\r\n{\r\n\tDerived derived { 7 };\r\n\r\n\t\/\/ The following won't work because getValue() has been deleted!\r\n\tstd::cout &lt;&lt; derived.getValue();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In the above example, we&#8217;ve marked the getValue() function as deleted.  This means that the compiler will complain when we try to call the derived version of the function.  Note that the Base version of getValue() is still accessible though.  We can call Base::getValue() in one of two ways:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n\tDerived derived { 7 };\r\n\r\n\t\/\/ We can call the Base::getValue() function directly\r\n\tstd::cout &lt;&lt; derived.Base::getValue();\r\n\r\n\t\/\/ Or we can upcast Derived to a Base reference and getValue() will resolve to Base::getValue()\r\n\tstd::cout &lt;&lt; static_cast&lt;Base&amp;&gt;(derived).getValue();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>If using the casting method, we cast to a Base&#038; rather than a Base to avoid making a copy of the Base portion of <code>derived<\/code>.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/multiple-inheritance\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">24.9<\/span>Multiple inheritance\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/calling-inherited-functions-and-overriding-behavior\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">24.7<\/span>Calling inherited functions and overriding behavior\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Changing an inherited member&#8217;s access level C++ gives us the ability to change an inherited member&#8217;s access specifier in the derived class. This is done by using a using declaration to identify the (scoped) base class member that is having its access changed in the derived class, under the new &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/6024"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=6024"}],"version-history":[{"count":21,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/6024\/revisions"}],"predecessor-version":[{"id":6035,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/6024\/revisions\/6035"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=6024"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=6024"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=6024"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}