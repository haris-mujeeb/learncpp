{"id":12411,"date":"2022-01-18T10:20:51","date_gmt":"2022-01-18T18:20:51","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=12411"},"modified":"2024-07-31T16:18:42","modified_gmt":"2024-07-31T23:18:42","slug":"unscoped-enumerator-integral-conversions","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/unscoped-enumerator-integral-conversions\/","title":{"rendered":"13.3 &#8212; Unscoped enumerator integral conversions"},"content":{"rendered":"<p>In the prior lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/unscoped-enumerations\/\">13.2 -- Unscoped enumerations<\/a>), we mentioned that enumerators are symbolic constants.  What we didn&#8217;t tell you then is that these enumerators have values that are of an integral type.<\/p>\n<p>This is similar to the case with chars (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chars\/\">4.11 -- Chars<\/a>).  Consider:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">char ch { 'A' };<\/code><\/pre>\n<p>A char is really just a 1-byte integral value, and the character <code>'A'<\/code> gets converted to an integral value (in this case, <code>65<\/code>) and stored.<\/p>\n<p>When we define an enumeration, each enumerator is automatically associated with an integer value based on its position in the enumerator list.  By default, the first enumerator is given the integral value <code>0<\/code>, and each subsequent enumerator has a value one greater than the previous enumerator:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">enum Color\r\n{\r\n    black,   \/\/ 0\r\n    red,     \/\/ 1\r\n    blue,    \/\/ 2\r\n    green,   \/\/ 3\r\n    white,   \/\/ 4\r\n    cyan,    \/\/ 5\r\n    yellow,  \/\/ 6\r\n    magenta, \/\/ 7\r\n};\r\n\r\nint main()\r\n{\r\n    Color shirt{ blue }; \/\/ shirt actually stores integral value 2\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>It is possible to explicitly define the value of enumerators.  These integral values can be positive or negative, and can share the same value as other enumerators.  Any non-defined enumerators are given a value one greater than the previous enumerator.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">enum Animal\r\n{\r\n    cat = -3,    \/\/ values can be negative\r\n    dog,         \/\/ -2\r\n    pig,         \/\/ -1\r\n    horse = 5,\r\n    giraffe = 5, \/\/ shares same value as horse\r\n    chicken,     \/\/ 6 \r\n};<\/code><\/pre>\n<p>Note in this case, <code>horse<\/code> and <code>giraffe<\/code> have been given the same value.  When this happens, the enumerators become non-distinct -- essentially, <code>horse<\/code> and <code>giraffe<\/code> are interchangeable.  Although C++ allows it, assigning the same value to two enumerators in the same enumeration should generally be avoided.<\/p>\n<p>Most of the time, the default values for enumerators will be exactly what you want, so do not provide your own values unless you have a specific reason to do so.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Avoid assigning explicit values to your enumerators unless you have a compelling reason to do so.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Value-initializing an enumeration<\/p>\n<p>If an enumeration is zero-initialized (which happens when we use value-initialization), the enumeration will be given value <code>0<\/code>, even if there is no corresponding enumerator with that value.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nenum Animal\r\n{\r\n    cat = -3,    \/\/ -3\r\n    dog,         \/\/ -2\r\n    pig,         \/\/ -1\r\n    \/\/ note: no enumerator with value 0 in this list\r\n    horse = 5,   \/\/ 5\r\n    giraffe = 5, \/\/ 5\r\n    chicken,     \/\/ 6 \r\n};\r\n\r\nint main()\r\n{\r\n    Animal a {}; \/\/ value-initialization zero-initializes a to value 0\r\n    std::cout &lt;&lt; a; \/\/ prints 0\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This has two semantic consequences:<\/p>\n<ul>\n<li>If there is an enumerator with value 0, value-initialization defaults the enumeration to the meaning of that enumerator.  For example, using the prior <code>enum Color<\/code> example, a value-initialized <code>Color<\/code> will default to <code>black<\/code>).  For this reason, it is a good idea to consider making the enumerator with value 0 the one that represents the best default meaning for your enumeration.\n<\/li>\n<\/ul>\n<p>Something like this is likely to cause problems:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">enum UniverseResult\r\n{\r\n    destroyUniverse, \/\/ default value (0)\r\n    saveUniverse\r\n};<\/code><\/pre>\n<ul>\n<li>If there is no enumerator with value 0, value-initialization makes it easy to create a semantically invalid enumeration.  In such cases, we recommend adding an &#8220;invalid&#8221; or &#8220;unknown&#8221; enumerator with value 0 so that you have documentation for the meaning of that state, and a name for that state that you can explicitly handle.\n<\/li>\n<\/ul>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">enum Winner\r\n{\r\n    winnerUnknown, \/\/ default value (0)\r\n    player1,\r\n    player2,\r\n};\r\n\r\n\/\/ somewhere later in your code\r\nif (w == winnerUnknown) \/\/ handle case appropriately<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Make the enumerator representing 0 the one that is the best default meaning for your enumeration.  If no good default meaning exists, consider adding an &#8220;invalid&#8221; or &#8220;unknown&#8221; enumerator that has value 0, so that state is explicitly documented and can be explicitly handled where appropriate.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Unscoped enumerations will implicitly convert to integral values<\/p>\n<p>Even though enumerations store integral values, they are not considered to be an integral type (they are a compound type).  However, an unscoped enumeration will implicitly convert to an integral value.  Because enumerators are compile-time constants, this is a constexpr conversion (we cover these in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/narrowing-conversions-list-initialization-and-constexpr-initializers\/\">10.4 -- Narrowing conversions, list initialization, and constexpr initializers<\/a>).<\/p>\n<p>Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nenum Color\r\n{\r\n    black, \/\/ assigned 0\r\n    red, \/\/ assigned 1\r\n    blue, \/\/ assigned 2\r\n    green, \/\/ assigned 3\r\n    white, \/\/ assigned 4\r\n    cyan, \/\/ assigned 5\r\n    yellow, \/\/ assigned 6\r\n    magenta, \/\/ assigned 7\r\n};\r\n\r\nint main()\r\n{\r\n    Color shirt{ blue };\r\n\r\n    std::cout &lt;&lt; \"Your shirt is \" &lt;&lt; shirt &lt;&lt; '\\n'; \/\/ what does this do?\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Since enumerated types hold integral values, as you might expect, this prints:<\/p>\n<pre>\nYour shirt is 2\r\n<\/pre>\n<p>When an enumerated type is used in a function call or with an operator, the compiler will first try to find a function or operator that matches the enumerated type.  For example, when the compiler tries to compile <code>std::cout &lt;&lt; shirt<\/code>, the compiler will first look to see if <code>operator&lt;&lt;<\/code> knows how to print an object of type <code>Color<\/code> (because <code>shirt<\/code> is of type <code>Color<\/code>) to <code>std::cout<\/code>.  It doesn&#8217;t.<\/p>\n<p>Since the compiler can&#8217;t find a match, it will then then check if <code>operator&lt;&lt;<\/code> knows how to print an object of the integral type that the unscoped enumeration converts to.  Since it does, the value in <code>shirt<\/code> gets converted to an integral value and printed as integral value <code>2<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We show how to convert an enumeration into a string in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/converting-an-enumeration-to-and-from-a-string\/\">13.4 -- Converting an enumeration to and from a string<\/a>.<br \/>\nWe teach <code>std::cout<\/code> how to print an enumerator in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-overloading-the-i-o-operators\/\">13.5 -- Introduction to overloading the I\/O operators<\/a>.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><a name=\"base\"><\/a>Enumeration size and underlying type (base) <a href=\"#base\"><i class=\"fa fa-link\" style=\"font-size: 0.8em;\"><\/i><\/a><\/p>\n<p>Enumerators have values that are of an integral type.  But what integral type?  The specific integral type used to represent the value of enumerators is called the enumeration&#8217;s <strong>underlying type<\/strong> (or <strong>base<\/strong>).<\/p>\n<p>For unscoped enumerations, the C++ standard does not specify which specific integral type should be used as the underlying type, so the choice is implementation-defined.  Most compilers will use <code>int<\/code> as the underlying type (meaning an unscoped enum will be the same size as an <code>int<\/code>), unless a larger type is required to store the enumerator values.  But you shouldn&#8217;t assume this will hold true for every compiler or platform.<\/p>\n<p>It is possible to explicitly specify an underlying type for an enumeration.  The underlying type must be an integral type.  For example, if you are working in some bandwidth-sensitive context (e.g. sending data over a network) you may want to specify a smaller type for your enumeration:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cstdint&gt;  \/\/ for std::int8_t\r\n#include &lt;iostream&gt;\r\n\r\n\/\/ Use an 8-bit integer as the enum underlying type\r\nenum Color : std::int8_t\r\n{\r\n    black,\r\n    red,\r\n    blue,\r\n};\r\n\r\nint main()\r\n{\r\n    Color c{ black };\r\n    std::cout &lt;&lt; sizeof(c) &lt;&lt; '\\n'; \/\/ prints 1 (byte)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Specify the base type of an enumeration only when necessary.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Because <code>std::int8_t<\/code> and <code>std::uint8_t<\/code> are usually type aliases for char types, using either of these types as the enum base will most likely cause the enumerators to print as char values rather than int values.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Integer to unscoped enumerator conversion<\/p>\n<p>While the compiler will implicitly convert an unscoped enumeration to an integer, it will <em>not<\/em> implicitly convert an integer to an unscoped enumeration.  The following will produce a compiler error:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">enum Pet \/\/ no specified base\r\n{\r\n    cat, \/\/ assigned 0\r\n    dog, \/\/ assigned 1\r\n    pig, \/\/ assigned 2\r\n    whale, \/\/ assigned 3\r\n};\r\n\r\nint main()\r\n{\r\n    Pet pet { 2 }; \/\/ compile error: integer value 2 won't implicitly convert to a Pet\r\n    pet = 3;       \/\/ compile error: integer value 3 won't implicitly convert to a Pet\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>There are two ways to work around this.<\/p>\n<p>First, you can explicitly convert an integer to an unscoped enumerator using <code>static_cast<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">enum Pet \/\/ no specified base\r\n{\r\n    cat, \/\/ assigned 0\r\n    dog, \/\/ assigned 1\r\n    pig, \/\/ assigned 2\r\n    whale, \/\/ assigned 3\r\n};\r\n\r\nint main()\r\n{\r\n    Pet pet { static_cast&lt;Pet&gt;(2) }; \/\/ convert integer 2 to a Pet\r\n    pet = static_cast&lt;Pet&gt;(3);       \/\/ our pig evolved into a whale!\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>We&#8217;ll see an example in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/converting-an-enumeration-to-and-from-a-string\/\">13.4 -- Converting an enumeration to and from a string<\/a> where we make use of this.<\/p>\n<p>It is safe to static_cast any integral value that is represented by an enumerator of the target enumeration.  Since our <code>Pet<\/code> enumeration has enumerators with values <code>0<\/code>, <code>1<\/code>, <code>2<\/code>, and <code>3<\/code>, static_casting integral values <code>0<\/code>, <code>1<\/code>, <code>2<\/code>, and <code>3<\/code> to a <code>Pet<\/code> is valid.<\/p>\n<p>It is also safe to static_cast any integral value that is in range of the target enumeration&#8217;s underlying type, even if there are no enumerators representing that value.  Static casting a value outside the range of the underlying type will result in undefined behavior.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>If the enumeration has an explicitly defined underlying type, the range of the enumeration is identical to the range of the underlying type.<\/p>\n<p>If the enumeration does not have an explicit underlying type, things are a bit more complicated.  In this case, the compiler gets to pick the underlying type, and it can pick any signed or unsigned type so long as the value of all enumerators fit in that type.  Given this, it is only safe to static_cast integral values that fit in the range of the smallest number of bits that can hold the value of all enumerators.<\/p>\n<p>Let&#8217;s do two examples to illustrate this:<\/p>\n<ul>\n<li>With enumerators that have values 2, 9, and 12, these enumerators could minimally fit in an unsigned 4-bit integral type with range 0 to 15.  Therefore, it is only safe to static_cast integral values 0 through 15 to this enumerated type.\n<\/li>\n<li>With enumerators that have values -28, 2, and 6, these enumerators could minimally fit in a signed 6-bit integral type with range -32 to 31.  Therefore, it is only safe to static_cast integral values -32 through 31 to this enumerated type.\n<\/li>\n<\/ul>\n<\/div>\n<p>Second, as of C++17, if an unscoped enumeration has an explicitly specified base, then the compiler will allow you to list initialize an unscoped enumeration using an integral value:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">enum Pet: int \/\/ we've specified a base\r\n{\r\n    cat, \/\/ assigned 0\r\n    dog, \/\/ assigned 1\r\n    pig, \/\/ assigned 2\r\n    whale, \/\/ assigned 3\r\n};\r\n\r\nint main()\r\n{\r\n    Pet pet1 { 2 }; \/\/ ok: can brace initialize unscoped enumeration with specified base with integer (C++17)\r\n    Pet pet2 (2);   \/\/ compile error: cannot direct initialize with integer\r\n    Pet pet3 = 2;   \/\/ compile error: cannot copy initialize with integer\r\n\r\n    pet1 = 3;       \/\/ compile error: cannot assign with integer\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>True or false. Enumerators can be:<\/p>\n<ul>\n<li>Given an integer value\n<\/li>\n<\/ul>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>True\n<\/p><\/div>\n<ul>\n<li>Given no explicit value\n<\/li>\n<\/ul>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p>True.  Enumerators not explicitly assigned a value will be implicitly assigned the integer value of the previous enumerator + 1.  If there is no previous enumerator, the enumerator will assume value 0.\n<\/p><\/div>\n<ul>\n<li>Given a floating point value\n<\/li>\n<\/ul>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<p>False\n<\/p><\/div>\n<ul>\n<li>Given a negative value\n<\/li>\n<\/ul>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<p>True\n<\/p><\/div>\n<ul>\n<li>Given a non-unique value\n<\/li>\n<\/ul>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\n<p>True\n<\/p><\/div>\n<ul>\n<li>Given the value of a prior enumerator (e.g. magenta = red)\n<\/li>\n<\/ul>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_5'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_5\" style=\"display:none\">\n<p>True.  Enumerators need not be unique.  Since enumerators implicitly convert to integers, and integers can be given to enumerators, enumerators can be initialized with other enumerators (though there is typically little reason to do so!).\n<\/p><\/div>\n<ul>\n<li>Given a non-constexpr value\n<\/li>\n<\/ul>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_6'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_6\" style=\"display:none\">\n<p>False.  Since enumerators are constexpr, their values must also be constexpr.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/converting-an-enumeration-to-and-from-a-string\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.4<\/span>Converting an enumeration to and from a string\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/unscoped-enumerations\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.2<\/span>Unscoped enumerations\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the prior lesson (), we mentioned that enumerators are symbolic constants. What we didn&#8217;t tell you then is that these enumerators have values that are of an integral type. This is similar to the case with chars (). Consider: char ch { &#8216;A&#8217; }; A char is really just &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12411"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=12411"}],"version-history":[{"count":42,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12411\/revisions"}],"predecessor-version":[{"id":17418,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12411\/revisions\/17418"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=12411"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=12411"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=12411"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}