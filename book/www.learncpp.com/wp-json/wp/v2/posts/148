{"id":148,"date":"2007-10-25T13:19:33","date_gmt":"2007-10-25T21:19:33","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/99-overloading-the-parenthesis-operator\/"},"modified":"2024-11-14T13:51:55","modified_gmt":"2024-11-14T21:51:55","slug":"overloading-the-parenthesis-operator","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-the-parenthesis-operator\/","title":{"rendered":"21.10 &#8212; Overloading the parenthesis operator"},"content":{"rendered":"<p>All of the overloaded operators you have seen so far let you define the type of the operator&#8217;s parameters, but not the number of parameters (which is fixed based on the type of the operator).  For example, operator== always takes two parameters, whereas operator! always takes one.  The parenthesis operator (operator()) is a particularly interesting operator in that it allows you to vary both the type AND number of parameters it takes.<\/p>\n<p>There are two things to keep in mind: first, the parenthesis operator must be implemented as a member function.  Second, in non-object-oriented C++, the () operator is used to call functions.  In the case of classes, operator() is just a normal operator that calls a function (named operator()) like any other overloaded operator.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">An example<\/p>\n<p>Let&#8217;s take a look at an example that lends itself to overloading this operator:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Matrix\r\n{\r\nprivate:\r\n    double data[4][4]{};\r\n};<\/code><\/pre>\n<p>Matrices are a key component of linear algebra, and are often used to do geometric modeling and 3D computer graphics work.  In this case, all you need to recognize is that the Matrix class is a 4 by 4 two-dimensional array of doubles.<\/p>\n<p>In the lesson on <a href=\"http:\/\/www.learncpp.com\/cpp-tutorial\/98-overloading-the-subscript-operator\/\">overloading the subscript operator<\/a>, you learned that we could overload operator[] to provide direct access to a private one-dimensional array.  However, in this case, we want access to a private two-dimensional array.  Prior to C++23, operator[] is limited to a single parameter, and therefore is not sufficient to let us directly index a two-dimensional array.<\/p>\n<p>However, because the () operator can take as many parameters as we want it to have, we can declare a version of operator() that takes two integer index parameters, and use it to access our two-dimensional array.  Here is an example of this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt; \/\/ for assert()\r\n\r\nclass Matrix\r\n{\r\nprivate:\r\n    double m_data[4][4]{};\r\n\r\npublic:\r\n    double&amp; operator()(int row, int col);\r\n    double operator()(int row, int col) const; \/\/ for const objects\r\n};\r\n\r\ndouble&amp; Matrix::operator()(int row, int col)\r\n{\r\n    assert(row &gt;= 0 &amp;&amp; row &lt; 4);\r\n    assert(col &gt;= 0 &amp;&amp; col &lt; 4);\r\n\r\n    return m_data[row][col];\r\n}\r\n\r\ndouble Matrix::operator()(int row, int col) const\r\n{\r\n    assert(row &gt;= 0 &amp;&amp; row &lt; 4);\r\n    assert(col &gt;= 0 &amp;&amp; col &lt; 4);\r\n\r\n    return m_data[row][col];\r\n}<\/code><\/pre>\n<p>Now we can declare a Matrix and access its elements like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    Matrix matrix;\r\n    matrix(1, 2) = 4.5;\r\n    std::cout &lt;&lt; matrix(1, 2) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>which produces the result:<\/p>\n<pre>\r\n4.5\r\n<\/pre>\n<p>Now, let&#8217;s overload the () operator again, this time in a way that takes no parameters at all:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt; \/\/ for assert()\r\nclass Matrix\r\n{\r\nprivate:\r\n    double m_data[4][4]{};\r\n\r\npublic:\r\n    double&amp; operator()(int row, int col);\r\n    double operator()(int row, int col) const;\r\n    void operator()();\r\n};\r\n\r\ndouble&amp; Matrix::operator()(int row, int col)\r\n{\r\n    assert(row &gt;= 0 &amp;&amp; row &lt; 4);\r\n    assert(col &gt;= 0 &amp;&amp; col &lt; 4);\r\n\r\n    return m_data[row][col];\r\n}\r\n\r\ndouble Matrix::operator()(int row, int col) const\r\n{\r\n    assert(row &gt;= 0 &amp;&amp; row &lt; 4);\r\n    assert(col &gt;= 0 &amp;&amp; col &lt; 4);\r\n\r\n    return m_data[row][col];\r\n}\r\n\r\nvoid Matrix::operator()()\r\n{\r\n    \/\/ reset all elements of the matrix to 0.0\r\n    for (int row{ 0 }; row &lt; 4; ++row)\r\n    {\r\n        for (int col{ 0 }; col &lt; 4; ++col)\r\n        {\r\n            m_data[row][col] = 0.0;\r\n        }\r\n    }\r\n}<\/code><\/pre>\n<p>And here&#8217;s our new example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    Matrix matrix{};\r\n    matrix(1, 2) = 4.5;\r\n    matrix(); \/\/ erase matrix\r\n    std::cout &lt;&lt; matrix(1, 2) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>which produces the result:<\/p>\n<pre>\r\n0\r\n<\/pre>\n<p>Because the () operator is so flexible, it can be tempting to use it for many different purposes.  However, this is strongly discouraged, since the () symbol does not really give any indication of what the operator is doing.  In our example above, it would be better to have written the erase functionality as a function called clear() or erase(), as <code>matrix.erase()<\/code> is easier to understand than <code>matrix()<\/code> (which could do anything!).<\/p>\n<p>Note: As of C++23, you can use <code>operator[]<\/code> with multiple indices.  This works just like <code>operator()<\/code> does above.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Having fun with functors<\/p>\n<p>Operator() is also commonly overloaded to implement <strong>functors<\/strong> (or <strong>function object<\/strong>), which are classes that operate like functions.  The advantage of a functor over a normal function is that functors can store data in member variables (since they are classes).<\/p>\n<p>Here&#8217;s a simple functor:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Accumulator\r\n{\r\nprivate:\r\n    int m_counter{ 0 };\r\n\r\npublic:\r\n    int operator() (int i) { return (m_counter += i); }\r\n\r\n    void reset() { m_counter = 0; } \/\/ optional \r\n};\r\n\r\nint main()\r\n{\r\n    Accumulator acc{};\r\n    std::cout &lt;&lt; acc(1) &lt;&lt; '\\n'; \/\/ prints 1\r\n    std::cout &lt;&lt; acc(3) &lt;&lt; '\\n'; \/\/ prints 4\r\n\r\n    Accumulator acc2{};\r\n    std::cout &lt;&lt; acc2(10) &lt;&lt; '\\n'; \/\/ prints 10\r\n    std::cout &lt;&lt; acc2(20) &lt;&lt; '\\n'; \/\/ prints 30\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>Note that using our Accumulator looks just like making a normal function call, but our Accumulator object is storing an accumulated value.<\/p>\n<p>The nice thing about functors is that we can instantiate as many separate functor objects as we need, and use them all simultaneously.  Functors can also have other member functions (e.g. <code>reset()<\/code>) that do convenient things.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Conclusion<\/p>\n<p>Operator() is sometimes overloaded with two parameters to index multidimensional arrays, or to retrieve a subset of a one dimensional array (with the two parameters defining the subset to return).  Anything else is probably better written as a member function with a more descriptive name.<\/p>\n<p>Operator() is also often overloaded to create functors.  Although simple functors (such as the example above) are fairly easily understood, functors are typically used in more advanced programming topics, and deserve their own lesson.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Write a class named MyString that holds a <code>std::string<\/code>.  Overload <code>operator&lt;&lt;<\/code> to output the string.  Overload <code>operator()<\/code> to return the substring that starts at the index of the first parameter (as a <code>MyString<\/code>).  The length of the substring should be defined by the second parameter.<\/p>\n<p>The following code should run:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    MyString s { \"Hello, world!\" };\r\n    std::cout &lt;&lt; s(7, 5) &lt;&lt; '\\n'; \/\/ start at index 7 and return 5 characters\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This should print<\/p>\n<pre>\r\nworld\r\n<\/pre>\n<p>Hint: You can use <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/string\/basic_string\/substr\"><code>std::string::substr<\/code><\/a> to get a substring of a std::string.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass MyString\r\n{\r\nprivate:\r\n\tstd::string m_string{};\r\n\r\npublic:\r\n\tMyString(std::string_view string = {})\r\n\t\t:m_string{ string }\r\n\t{\r\n\t}\r\n\r\n\tMyString operator()(int start, int length)\r\n\t{\r\n\t\tassert(start &gt;= 0);\r\n\t\tassert(start + length &lt;= static_cast&lt;int&gt;(m_string.length()) &amp;&amp; \"MyString::operator(int, int): Substring is out of range\");\r\n\r\n\t\treturn MyString { m_string.substr(\r\n\t\t\tstatic_cast&lt;std::string::size_type&gt;(start),\r\n\t\t\tstatic_cast&lt;std::string::size_type&gt;(length)\r\n\t\t\t)};\r\n\t}\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyString&amp; s)\r\n\t{\r\n\t\tout &lt;&lt; s.m_string;\r\n\r\n\t\treturn out;\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tMyString s{ \"Hello, world!\" };\r\n\tstd::cout &lt;&lt; s(7, 5) &lt;&lt; '\\n'; \/\/ start at index 7 and return 5 characters\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>This quiz question is extra credit.<\/p>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #1<\/p>\n<p>Why is the above inefficient if we don&#8217;t need to modify the returned substring?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p>Inside our <code>operator()<\/code>, <code>std::string::substr<\/code> returns a <code>std::string<\/code>, which means when we call it, we&#8217;re making a copy of part of the source string.  Our overloaded <code>operator()<\/code> uses this to construct a new <code>MyString<\/code>, which contains a <code>std::string<\/code> member, which makes another copy.  We then return this <code>MyString<\/code> to the caller, which makes a third copy.  The compiler will probably optimize some of these copies out of existence, but at least one <code>std::string<\/code> (containing the resulting substring) must be kept.<\/p>\n<p>We only need a copy of the substring in cases where we intend to modify the substring, or when the substring will outlive the original string.  This isn&#8217;t typically the case, so we&#8217;re making expensive copies that we typically won&#8217;t need.\n<\/p><\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #2<\/p>\n<p>What might we do instead?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<p><code>std::string_view<\/code> is capable of viewing a substring of an existing string without making a copy.  If our <code>operator()<\/code> were to return a <code>std::string_view<\/code>, then the caller could use the <code>std::string_view<\/code> when that suffices, or convert it to a <code>std::string<\/code> or <code>MyString<\/code> if they need to modify or persist the substring.\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">&gt; Step #3<\/p>\n<p>Update <code>operator()<\/code> from the prior quiz solution to return the substring as a <code>std::string_view<\/code> instead.<\/p>\n<p>Hint: <code>std::string::substr()<\/code> returns a <code>std::string<\/code>.  <code>std::string_view::substr()<\/code> returns a <code>std::string_view<\/code>.  Be very careful not to return a dangling <code>std::string_view!<\/code>.<\/p>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_0'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_0\" style=\"display:none; margin-bottom: 1em\">Hint: Don&#8217;t create any <code>std::string<\/code> temporaries, as these will be destroyed at the end of the function, and any <code>std::string_view<\/code> of those <code>std::string<\/code> will be left dangling.<\/div>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_1'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_1\" style=\"display:none; margin-bottom: 1em\">Hint: Creating <code>std::string_view<\/code> temporaries is okay, as long as they are views of <code>m_string<\/code>.<\/div>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass MyString\r\n{\r\nprivate:\r\n\tstd::string m_string{};\r\n\r\npublic:\r\n\tMyString(std::string_view string = {})\r\n\t\t:m_string{ string }\r\n\t{\r\n\t}\r\n\r\n\tstd::string_view operator()(int start, int length)\r\n\t{\r\n\t\tassert(start &gt;= 0);\r\n\t\tassert(start + length &lt;= static_cast&lt;int&gt;(m_string.length()) &amp;&amp; \"MyString::operator(int, int): Substring is out of range\");\r\n\r\n\t\t\/\/ Create a std::string_view of m_string, so we can use std::string_view::substr() instead of std::string::substr()\r\n\t\treturn std::string_view{ m_string }.substr(\r\n\t\t\tstatic_cast&lt;std::string_view::size_type&gt;(start),\r\n\t\t\tstatic_cast&lt;std::string_view::size_type&gt;(length)\r\n\t\t);\r\n\t}\r\n\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const MyString&amp; s)\r\n\t{\r\n\t\tout &lt;&lt; s.m_string;\r\n\r\n\t\treturn out;\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\tMyString s{ \"Hello, world!\" };\r\n\tstd::cout &lt;&lt; s(7, 5) &lt;&lt; '\\n'; \/\/ start at index 7 and return 5 characters\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Let&#8217;s explore <code>return std::string_view{ m_string }.substr();<\/code> further.  First, we&#8217;re creating a temporary <code>std::string_view<\/code> of <code>m_string<\/code>, which is inexpensive and lets us access <code>std::string_view<\/code> member functions.  Next, we call <code>std::string_view::substr<\/code> on this temporary to get our substring (as a non-null-terminated view of <code>m_string<\/code>).  We then return this view to the caller.  Since the <code>std::string_view<\/code> we return to the caller is still a view of <code>m_string<\/code> (which is still in scope), our returned <code>std::string_view<\/code> is not dangling. <\/p>\n<p>The end result is we create 3 <code>std::string_view<\/code> instead of 3 <code>std::string<\/code>, which is more efficient.\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-typecasts\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.11<\/span>Overloading typecasts\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-the-subscript-operator\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.9<\/span>Overloading the subscript operator\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>All of the overloaded operators you have seen so far let you define the type of the operator&#8217;s parameters, but not the number of parameters (which is fixed based on the type of the operator). For example, operator== always takes two parameters, whereas operator! always takes one. The parenthesis operator &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/148"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=148"}],"version-history":[{"count":40,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/148\/revisions"}],"predecessor-version":[{"id":17857,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/148\/revisions\/17857"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=148"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=148"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=148"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}