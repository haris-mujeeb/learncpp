{"id":135,"date":"2007-09-18T09:08:25","date_gmt":"2007-09-18T17:08:25","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/812-static-member-functions\/"},"modified":"2024-10-18T10:08:26","modified_gmt":"2024-10-18T17:08:26","slug":"static-member-functions","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/static-member-functions\/","title":{"rendered":"15.7 &#8212; Static member functions"},"content":{"rendered":"<p>In the previous lesson on <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/static-member-variables\/\">15.6 -- Static member variables<\/a>, you learned that static member variables are member variables that belong to the class rather than objects of the class.  If a static member variable is public, it can be accessed directly using the class name and the scope resolution operator:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Something\r\n{\r\npublic:\r\n    static inline int s_value { 1 };\r\n};\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; Something::s_value; \/\/ s_value is public, we can access it directly\r\n}<\/code><\/pre>\n<p>But what if a static member variable is private?  Consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Something\r\n{\r\nprivate: \/\/ now private\r\n    static inline int s_value { 1 };\r\n};\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; Something::s_value; \/\/ error: s_value is private and can't be accessed directly outside the class\r\n}<\/code><\/pre>\n<p>In this case, we can&#8217;t access <code>Something::s_value<\/code> directly from <code>main()<\/code>, because it is private.  Normally we access private members through public member functions.  While we could create a normal public member function to access <code>s_value<\/code>, we&#8217;d then need to instantiate an object of the class type to use the function!<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Something\r\n{\r\nprivate:\r\n    static inline int s_value { 1 };\r\n\r\npublic:\r\n    int getValue() { return s_value; }\r\n};\r\n\r\nint main()\r\n{\r\n    Something s{};\r\n    std::cout &lt;&lt; s.getValue(); \/\/ works, but requires us to instantiate an object to call getValue()\r\n}<\/code><\/pre>\n<p>We can do better.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Static member functions<\/p>\n<p>Member variables aren&#8217;t the only type of member that can be made static.  Member functions can be made static as well.  Here is the above example with a static member function accessor:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Something\r\n{\r\nprivate:\r\n    static inline int s_value { 1 };\r\n\r\npublic:\r\n    static int getValue() { return s_value; } \/\/ static member function\r\n};\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; Something::getValue() &lt;&lt; '\\n';\r\n}<\/code><\/pre>\n<p>Because static member functions are not associated with a particular object, they can be called directly by using the class name and the scope resolution operator (e.g. <code>Something::getValue()<\/code>).  Like static member variables, they can also be called through objects of the class type, though this is not recommended.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Static member functions have no <code>this<\/code> pointer<\/p>\n<p>Static member functions have two interesting quirks worth noting.  First, because static member functions are not attached to an object, they have no <code>this<\/code> pointer!  This makes sense when you think about it -- the <code>this<\/code> pointer always points to the object that the member function is working on.  Static member functions do not work on an object, so the <code>this<\/code> pointer is not needed.<\/p>\n<p>Second, static member functions can directly access other static members (variables or functions), but not non-static members.  This is because non-static members must belong to a class object, and static member functions have no class object to work with!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Static members defined outside the class definition<\/p>\n<p>Static member functions can also be defined outside of the class declaration.  This works the same way as for normal member functions.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass IDGenerator\r\n{\r\nprivate:\r\n    static inline int s_nextID { 1 };\r\n\r\npublic:\r\n     static int getNextID(); \/\/ Here's the declaration for a static function\r\n};\r\n\r\n\/\/ Here's the definition of the static function outside of the class.  Note we don't use the static keyword here.\r\nint IDGenerator::getNextID() { return s_nextID++; } \r\n\r\nint main()\r\n{\r\n    for (int count{ 0 }; count &lt; 5; ++count)\r\n        std::cout &lt;&lt; \"The next ID is: \" &lt;&lt; IDGenerator::getNextID() &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\nThe next ID is: 1\r\nThe next ID is: 2\r\nThe next ID is: 3\r\nThe next ID is: 4\r\nThe next ID is: 5\r\n<\/pre>\n<p>Note that because all the data and functions in this class are static, we don&#8217;t need to instantiate an object of the class to make use of its functionality!  This class utilizes a static member variable to hold the value of the next ID to be assigned, and provides a static member function to return that ID and increment it.<\/p>\n<p>As noted in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/classes-and-header-files\/\">15.2 -- Classes and header files<\/a>, member functions defined inside the class definition are implicitly inline.  Member functions defined outside the class definition are not implicitly inline, but can be made inline by using the <code>inline<\/code> keyword.  Therefore a static member function that is defined in a header file should be made <code>inline<\/code> so as not to violate the One Definition Rule (ODR) if that header is then included into multiple translation units.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A word of warning about classes with all static members<\/p>\n<p>Be careful when writing classes with all static members.  Although such &#8220;pure static classes&#8221; (also called &#8220;monostates&#8221;) can be useful, they also come with some potential downsides.<\/p>\n<p>First, because all static members are instantiated only once, there is no way to have multiple copies of a pure static class (without cloning the class and renaming it).  For example, if you needed two independent <code>IDGenerator<\/code>, this would not be possible with a pure static class.<\/p>\n<p>Second, in the lesson on global variables, you learned that global variables are dangerous because any piece of code can change the value of the global variable and end up breaking another piece of seemingly unrelated code.  The same holds true for pure static classes.  Because all of the members belong to the class (instead of object of the class), and class declarations usually have global scope, a pure static class is essentially the equivalent of declaring functions and global variables in a globally accessible namespace, with all the requisite downsides that global variables have.<\/p>\n<p>Instead of writing a class with all static members, consider writing a normal class and instantiating a global instance of it (global variables have static duration).  That way the global instance can be used when appropriate, but local instances can still be instantiated if and when that is useful.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Pure static classes vs namespaces<\/p>\n<p>Pure static classes have a lot of overlap with namespaces.  Both allow you to define variables with static duration and functions within their scope region.  However, one significant difference is that classes have access controls while namespaces do not.<\/p>\n<p>In general, a static class is preferable when you have static data members and\/or need access controls.  Otherwise, prefer a namespace.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">C++ does not support static constructors<\/p>\n<p>If you can initialize normal member variables via a constructor, then by extension it makes sense that you should be able to initialize static member variables via a static constructor.  And while some modern languages do support static constructors for precisely this purpose, C++ is unfortunately not one of them.<\/p>\n<p>If your static variable can be directly initialized, no constructor is needed: you can initialize the static member variable at the point of definition (even if it is private).  We do this in the <code>IDGenerator<\/code> example above.  Here&#8217;s another example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Chars\r\n{\r\n    char first{};\r\n    char second{};\r\n    char third{};\r\n    char fourth{};\r\n    char fifth{};\r\n};\r\n\r\nstruct MyClass\r\n{\r\n\tstatic inline Chars s_mychars { 'a', 'e', 'i', 'o', 'u' }; \/\/ initialize static variable at point of definition\r\n};\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; MyClass::s_mychars.third; \/\/ print i\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>If initializing your static member variable requires executing code (e.g. a loop), there are many different, somewhat obtuse ways of doing this.  One way that works with all variables, static or not, is to use a function to create an object, fill it with data, and return it to the caller.  This returned value can be copied into the object being initialized.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Chars\r\n{\r\n    char first{};\r\n    char second{};\r\n    char third{};\r\n    char fourth{};\r\n    char fifth{};\r\n};\r\n\r\nclass MyClass\r\n{\r\nprivate:\r\n    static Chars generate()\r\n    {\r\n        Chars c{}; \/\/ create an object\r\n        c.first = 'a'; \/\/ fill it with values however you like\r\n        c.second = 'e';\r\n        c.third = 'i';\r\n        c.fourth = 'o';\r\n        c.fifth = 'u';\r\n        \r\n        return c; \/\/ return the object\r\n    }\r\n\r\npublic:\r\n\tstatic inline Chars s_mychars { generate() }; \/\/ copy the returned object into s_mychars\r\n};\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; MyClass::s_mychars.third; \/\/ print i\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>A lambda can also be used for this.\n<\/p><\/div>\n<p>We show a practical example of this methodology in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/global-random-numbers-random-h\/#RandomH\">8.15 -- Global random numbers (Random.h)<\/a> (though we do it with a namespace rather than a static class, it works the same way)<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>Convert the <code>Random<\/code> namespace in the following example to a class with static members:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;chrono&gt;\r\n#include &lt;random&gt;\r\n#include &lt;iostream&gt;\r\n\r\nnamespace Random\r\n{\r\n\tinline std::mt19937 generate()\r\n\t{\r\n\t\tstd::random_device rd{};\r\n\r\n\t\t\/\/ Create seed_seq with high-res clock and 7 random numbers from std::random_device\r\n\t\tstd::seed_seq ss{\r\n\t\t\tstatic_cast&lt;std::seed_seq::result_type&gt;(std::chrono::steady_clock::now().time_since_epoch().count()),\r\n\t\t\t\trd(), rd(), rd(), rd(), rd(), rd(), rd() };\r\n\r\n\t\treturn std::mt19937{ ss };\r\n\t}\r\n\r\n\tinline std::mt19937 mt{ generate() }; \/\/ generates a seeded std::mt19937 and copies it into our global object\r\n\r\n\t\/\/ Generate a random int between [min, max] (inclusive)\r\n\tinline int get(int min, int max)\r\n\t{\r\n\t\treturn std::uniform_int_distribution{min, max}(mt);\r\n\t}\r\n}\r\n\r\nint main()\r\n{\r\n\t\/\/ Print a bunch of random numbers\r\n\tfor (int count{ 1 }; count &lt;= 10; ++count)\r\n\t\tstd::cout &lt;&lt; Random::get(1, 6) &lt;&lt; '\\t';\r\n\r\n\tstd::cout &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;chrono&gt;\r\n#include &lt;random&gt;\r\n#include &lt;iostream&gt;\r\n\r\nclass Random\r\n{\r\nprivate: \/\/ could be public if we want these to be accessible\r\n\tstatic std::mt19937 generate()\r\n\t{\r\n\t\tstd::random_device rd{};\r\n\r\n\t\t\/\/ Create seed_seq with high-res clock and 7 random numbers from std::random_device\r\n\t\tstd::seed_seq ss{\r\n\t\t\tstatic_cast&lt;std::seed_seq::result_type&gt;(std::chrono::steady_clock::now().time_since_epoch().count()),\r\n\t\t\t\trd(), rd(), rd(), rd(), rd(), rd(), rd() };\r\n\r\n\t\treturn std::mt19937{ ss };\r\n\t}\r\n\r\n\tstatic inline std::mt19937 mt{ generate() }; \/\/ generates a seeded std::mt19937 and copies it into our global object\r\n\r\npublic:\r\n\t\/\/ Generate a random int between [min, max] (inclusive)\r\n\tstatic int get(int min, int max)\r\n\t{\r\n\t\treturn std::uniform_int_distribution{min, max}(mt);\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\t\/\/ Print a bunch of random numbers\r\n\tfor (int count{ 1 }; count &lt;= 10; ++count)\r\n\t\tstd::cout &lt;&lt; Random::get(1, 6) &lt;&lt; '\\t';\r\n\r\n\tstd::cout &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>Any object declared in a namespace is a global variable.  When we declare <code>inline std::mt19937 mt<\/code> inside a namespace, we&#8217;re declaring <code>mt<\/code> as an inline global variable.  This allows the entire program to use a single instance of <code>std::mt19937<\/code> (via global variable <code>mt<\/code>).<\/p>\n<p>In contrast, when a class object is instantiated, that class object contains a copy of each non-static data members.  We don&#8217;t want each class object to have its own copy of <code>std::mt19937<\/code>.  Therefore, we declare <code>static inline std::mt19937 mt<\/code>, which tells the compiler that a single instance of <code>std::mt19937<\/code> should exist as part of the <code>Random<\/code> class.  Defining <code>mt<\/code> as <code>static inline<\/code> makes it an inline variable, allowing us to initialize it inside the class definition (we cover this point in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/static-member-variables\/\">15.6 -- Static member variables<\/a>).<\/p>\n<p>We also make the member functions <code>static<\/code> so that they can be accessed without instantiating a <code>Random<\/code> object.\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/friend-non-member-functions\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">15.8<\/span>Friend non-member functions\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/static-member-variables\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">15.6<\/span>Static member variables\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the previous lesson on , you learned that static member variables are member variables that belong to the class rather than objects of the class. If a static member variable is public, it can be accessed directly using the class name and the scope resolution operator: #include &lt;iostream&gt; class &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/135"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=135"}],"version-history":[{"count":32,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/135\/revisions"}],"predecessor-version":[{"id":17767,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/135\/revisions\/17767"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=135"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=135"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=135"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}