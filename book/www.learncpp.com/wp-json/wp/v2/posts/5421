{"id":5421,"date":"2017-02-17T10:10:59","date_gmt":"2017-02-17T18:10:59","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=5421"},"modified":"2025-02-04T20:44:02","modified_gmt":"2025-02-05T04:44:02","slug":"introduction-to-smart-pointers-move-semantics","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-smart-pointers-move-semantics\/","title":{"rendered":"22.1 &#8212; Introduction to smart pointers and move semantics"},"content":{"rendered":"<p>Consider a function in which we dynamically allocate a value:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void someFunction()\r\n{\r\n    Resource* ptr = new Resource(); \/\/ Resource is a struct or class\r\n\r\n    \/\/ do stuff with ptr here\r\n\r\n    delete ptr;\r\n}<\/code><\/pre>\n<p>Although the above code seems fairly straightforward, it&#8217;s fairly easy to forget to deallocate ptr.  Even if you do remember to delete ptr at the end of the function, there are a myriad of ways that ptr may not be deleted if the function exits early.  This can happen via an early return:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid someFunction()\r\n{\r\n    Resource* ptr = new Resource();\r\n\r\n    int x;\r\n    std::cout &lt;&lt; \"Enter an integer: \";\r\n    std::cin &gt;&gt; x;\r\n\r\n    if (x == 0)\r\n        return; \/\/ the function returns early, and ptr won\u2019t be deleted!\r\n\r\n    \/\/ do stuff with ptr here\r\n\r\n    delete ptr;\r\n}<\/code><\/pre>\n<p>or via a thrown exception:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid someFunction()\r\n{\r\n    Resource* ptr = new Resource();\r\n\r\n    int x;\r\n    std::cout &lt;&lt; \"Enter an integer: \";\r\n    std::cin &gt;&gt; x;\r\n\r\n    if (x == 0)\r\n        throw 0; \/\/ the function returns early, and ptr won\u2019t be deleted!\r\n\r\n    \/\/ do stuff with ptr here\r\n\r\n    delete ptr;\r\n}<\/code><\/pre>\n<p>In the above two programs, the early return or throw statement execute, causing the function to terminate without variable ptr being deleted.  Consequently, the memory allocated for variable ptr is now leaked (and will be leaked again every time this function is called and returns early).<\/p>\n<p>At heart, these kinds of issues occur because pointer variables have no inherent mechanism to clean up after themselves.<\/p>\n<p><strong>Smart pointer classes to the rescue?<\/strong><\/p>\n<p>One of the best things about classes is that they contain destructors that automatically get executed when an object of the class goes out of scope.  So if you allocate (or acquire) memory in your constructor, you can deallocate it in your destructor, and be guaranteed that the memory will be deallocated when the class object is destroyed (regardless of whether it goes out of scope, gets explicitly deleted, etc&#8230;).  This is at the heart of the RAII programming paradigm that we talked about in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/destructors\/\">19.3 -- Destructors<\/a>.<\/p>\n<p>So can we use a class to help us manage and clean up our pointers?  We can!<\/p>\n<p>Consider a class whose sole job was to hold and &#8220;own&#8221; a pointer passed to it, and then deallocate that pointer when the class object went out of scope.  As long as objects of that class were only created as local variables, we could guarantee that the class would properly go out of scope (regardless of when or how our functions terminate) and the owned pointer would get destroyed.<\/p>\n<p>Here&#8217;s a first draft of the idea:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nclass Auto_ptr1\r\n{\r\n\tT* m_ptr {};\r\npublic:\r\n\t\/\/ Pass in a pointer to \"own\" via the constructor\r\n\tAuto_ptr1(T* ptr=nullptr)\r\n\t\t:m_ptr(ptr)\r\n\t{\r\n\t}\r\n\t\r\n\t\/\/ The destructor will make sure it gets deallocated\r\n\t~Auto_ptr1()\r\n\t{\r\n\t\tdelete m_ptr;\r\n\t}\r\n\r\n\t\/\/ Overload dereference and operator-&gt; so we can use Auto_ptr1 like m_ptr.\r\n\tT&amp; operator*() const { return *m_ptr; }\r\n\tT* operator-&gt;() const { return m_ptr; }\r\n};\r\n\r\n\/\/ A sample class to prove the above works\r\nclass Resource\r\n{\r\npublic:\r\n    Resource() { std::cout &lt;&lt; \"Resource acquired\\n\"; }\r\n    ~Resource() { std::cout &lt;&lt; \"Resource destroyed\\n\"; }\r\n};\r\n\r\nint main()\r\n{\r\n\tAuto_ptr1&lt;Resource&gt; res(new Resource()); \/\/ Note the allocation of memory here\r\n\r\n        \/\/ ... but no explicit delete needed\r\n\r\n\t\/\/ Also note that we use &lt;Resource&gt;, not &lt;Resource*&gt;\r\n        \/\/ This is because we've defined m_ptr to have type T* (not T)\r\n\r\n\treturn 0;\r\n} \/\/ res goes out of scope here, and destroys the allocated Resource for us<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\r\nResource acquired\r\nResource destroyed\r\n<\/pre>\n<p>Consider how this program and class work.  First, we dynamically create a Resource, and pass it as a parameter to our templated Auto_ptr1 class.  From that point forward, our Auto_ptr1 variable res owns that Resource object (Auto_ptr1 has a composition relationship with m_ptr).  Because res is declared as a local variable and has block scope, it will go out of scope when the block ends, and be destroyed (no worries about forgetting to deallocate it).  And because it is a class, when it is destroyed, the Auto_ptr1 destructor will be called.  That destructor will ensure that the Resource pointer it is holding gets deleted!<\/p>\n<p>As long as Auto_ptr1 is defined as a local variable (with automatic duration, hence the &#8220;Auto&#8221; part of the class name), the Resource will be guaranteed to be destroyed at the end of the block it is declared in, regardless of how the function terminates (even if it terminates early).<\/p>\n<p>Such a class is called a smart pointer.  A <strong>Smart pointer<\/strong> is a composition class that is designed to manage dynamically allocated memory and ensure that memory gets deleted when the smart pointer object goes out of scope.  (Relatedly, built-in pointers are sometimes called &#8220;dumb pointers&#8221; because they can&#8217;t clean up after themselves).<\/p>\n<p>Now let&#8217;s go back to our someFunction() example above, and show how a smart pointer class can solve our challenge:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nclass Auto_ptr1\r\n{\r\n\tT* m_ptr {};\r\npublic:\r\n\t\/\/ Pass in a pointer to \"own\" via the constructor\r\n\tAuto_ptr1(T* ptr=nullptr)\r\n\t\t:m_ptr(ptr)\r\n\t{\r\n\t}\r\n\t\r\n\t\/\/ The destructor will make sure it gets deallocated\r\n\t~Auto_ptr1()\r\n\t{\r\n\t\tdelete m_ptr;\r\n\t}\r\n\r\n\t\/\/ Overload dereference and operator-&gt; so we can use Auto_ptr1 like m_ptr.\r\n\tT&amp; operator*() const { return *m_ptr; }\r\n\tT* operator-&gt;() const { return m_ptr; }\r\n};\r\n\r\n\/\/ A sample class to prove the above works\r\nclass Resource\r\n{\r\npublic:\r\n    Resource() { std::cout &lt;&lt; \"Resource acquired\\n\"; }\r\n    ~Resource() { std::cout &lt;&lt; \"Resource destroyed\\n\"; }\r\n    void sayHi() { std::cout &lt;&lt; \"Hi!\\n\"; }\r\n};\r\n\r\nvoid someFunction()\r\n{\r\n    Auto_ptr1&lt;Resource&gt; ptr(new Resource()); \/\/ ptr now owns the Resource\r\n \r\n    int x;\r\n    std::cout &lt;&lt; \"Enter an integer: \";\r\n    std::cin &gt;&gt; x;\r\n \r\n    if (x == 0)\r\n        return; \/\/ the function returns early\r\n \r\n    \/\/ do stuff with ptr here\r\n    ptr-&gt;sayHi();\r\n}\r\n\r\nint main()\r\n{\r\n    someFunction();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>If the user enters a non-zero integer, the above program will print:<\/p>\n<pre>\r\nResource acquired\r\nHi!\r\nResource destroyed\r\n<\/pre>\n<p>If the user enters zero, the above program will terminate early, printing:<\/p>\n<pre>\r\nResource acquired\r\nResource destroyed\r\n<\/pre>\n<p>Note that even in the case where the user enters zero and the function terminates early, the Resource is still properly deallocated.<\/p>\n<p>Because the ptr variable is a local variable, ptr will be destroyed when the function terminates (regardless of how it terminates).  And because the Auto_ptr1 destructor will clean up the Resource, we are assured that the Resource will be properly cleaned up.<\/p>\n<p><strong>A critical flaw<\/strong><\/p>\n<p>The Auto_ptr1 class has a critical flaw lurking behind some auto-generated code.  Before reading further, see if you can identify what it is.  We&#8217;ll wait&#8230;<\/p>\n<p>(Hint: consider what parts of a class get auto-generated if you don&#8217;t supply them)<\/p>\n<p>(Jeopardy music)<\/p>\n<p>Okay, time&#8217;s up.<\/p>\n<p>Rather than tell you, we&#8217;ll show you.  Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ Same as above\r\ntemplate &lt;typename T&gt;\r\nclass Auto_ptr1\r\n{\r\n\tT* m_ptr {};\r\npublic:\r\n\tAuto_ptr1(T* ptr=nullptr)\r\n\t\t:m_ptr(ptr)\r\n\t{\r\n\t}\r\n\t\r\n\t~Auto_ptr1()\r\n\t{\r\n\t\tdelete m_ptr;\r\n\t}\r\n\r\n\tT&amp; operator*() const { return *m_ptr; }\r\n\tT* operator-&gt;() const { return m_ptr; }\r\n};\r\n\r\nclass Resource\r\n{\r\npublic:\r\n\tResource() { std::cout &lt;&lt; \"Resource acquired\\n\"; }\r\n\t~Resource() { std::cout &lt;&lt; \"Resource destroyed\\n\"; }\r\n};\r\n\r\nint main()\r\n{\r\n\tAuto_ptr1&lt;Resource&gt; res1(new Resource());\r\n\tAuto_ptr1&lt;Resource&gt; res2(res1); \/\/ Alternatively, don't initialize res2 and then assign res2 = res1;\r\n\r\n\treturn 0;\r\n} \/\/ res1 and res2 go out of scope here<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\r\nResource acquired\r\nResource destroyed\r\nResource destroyed\r\n<\/pre>\n<p>Very likely (but not necessarily) your program will crash at this point.  See the problem now?  Because we haven&#8217;t supplied a copy constructor or an assignment operator, C++ provides one for us.  And the functions it provides do shallow copies.  So when we initialize res2 with res1, both Auto_ptr1 variables are pointed at the same Resource.  When res2 goes out of the scope, it deletes the resource, leaving res1 with a dangling pointer.  When res1 goes to delete its (already deleted) Resource, undefined behavior will result (probably a crash)!<\/p>\n<p>You&#8217;d run into a similar problem with a function like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void passByValue(Auto_ptr1&lt;Resource&gt; res)\r\n{\r\n}\r\n\r\nint main()\r\n{\r\n\tAuto_ptr1&lt;Resource&gt; res1(new Resource());\r\n\tpassByValue(res1);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In this program, <code>res1<\/code> will be copied by value into parameter <code>res<\/code>, so both <code>res1.m_ptr<\/code> and <code>res.m_ptr<\/code> will hold the same address.<\/p>\n<p>When <code>res<\/code> is destroyed at the end of the function, <code>res1.m_ptr<\/code> is left dangling.  When <code>res1.m_ptr<\/code> is later deleted, undefined behavior will result.<\/p>\n<p>So clearly this isn&#8217;t good.  How can we address this?<\/p>\n<p>Well, one thing we could do would be to explicitly define and delete the copy constructor and assignment operator, thereby preventing any copies from being made in the first place.  That would prevent the pass by value case (which is good, we probably shouldn&#8217;t be passing these by value anyway).<\/p>\n<p>But then how would we return an Auto_ptr1 from a function back to the caller?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">??? generateResource()\r\n{\r\n     Resource* r{ new Resource() };\r\n     return Auto_ptr1(r);\r\n}<\/code><\/pre>\n<p>We can&#8217;t return our Auto_ptr1 by reference, because the local Auto_ptr1 will be destroyed at the end of the function, and the caller will be left with a dangling reference.  We could return pointer r as <code>Resource*<\/code>, but then we might forget to delete r later, which is the whole point of using smart pointers in the first place.  So that&#8217;s out.  Returning the Auto_ptr1 by value is the only option that makes sense -- but then we end up with shallow copies, duplicated pointers, and crashes.<\/p>\n<p>Another option would be to overload the copy constructor and assignment operator to make deep copies.  In this way, we&#8217;d at least guarantee to avoid duplicate pointers to the same object.  But copying can be expensive (and may not be desirable or even possible), and we don&#8217;t want to make needless copies of objects just to return an Auto_ptr1 from a function.  Plus assigning or initializing a dumb pointer doesn&#8217;t copy the object being pointed to, so why would we expect smart pointers to behave differently?<\/p>\n<p>What do we do?<\/p>\n<p><strong>Move semantics<\/strong><\/p>\n<p>What if, instead of having our copy constructor and assignment operator copy the pointer (&#8220;copy semantics&#8221;), we instead transfer\/move ownership of the pointer from the source to the destination object?  This is the core idea behind move semantics.  <strong>Move semantics<\/strong> means the class will transfer ownership of the object rather than making a copy.<\/p>\n<p>Let&#8217;s update our Auto_ptr1 class to show how this can be done:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nclass Auto_ptr2\r\n{\r\n\tT* m_ptr {};\r\npublic:\r\n\tAuto_ptr2(T* ptr=nullptr)\r\n\t\t:m_ptr(ptr)\r\n\t{\r\n\t}\r\n\t\r\n\t~Auto_ptr2()\r\n\t{\r\n\t\tdelete m_ptr;\r\n\t}\r\n\r\n\t\/\/ A copy constructor that implements move semantics\r\n\tAuto_ptr2(Auto_ptr2&amp; a) \/\/ note: not const\r\n\t{\r\n\t\t\/\/ We don't need to delete m_ptr here.  This constructor is only called when we're creating a new object, and m_ptr can't be set prior to this.\r\n\t\tm_ptr = a.m_ptr; \/\/ transfer our dumb pointer from the source to our local object\r\n\t\ta.m_ptr = nullptr; \/\/ make sure the source no longer owns the pointer\r\n\t}\r\n\t\r\n\t\/\/ An assignment operator that implements move semantics\r\n\tAuto_ptr2&amp; operator=(Auto_ptr2&amp; a) \/\/ note: not const\r\n\t{\r\n\t\tif (&amp;a == this)\r\n\t\t\treturn *this;\r\n\r\n\t\tdelete m_ptr; \/\/ make sure we deallocate any pointer the destination is already holding first\r\n\t\tm_ptr = a.m_ptr; \/\/ then transfer our dumb pointer from the source to the local object\r\n\t\ta.m_ptr = nullptr; \/\/ make sure the source no longer owns the pointer\r\n\t\treturn *this;\r\n\t}\r\n\r\n\tT&amp; operator*() const { return *m_ptr; }\r\n\tT* operator-&gt;() const { return m_ptr; }\r\n\tbool isNull() const { return m_ptr == nullptr; }\r\n};\r\n\r\nclass Resource\r\n{\r\npublic:\r\n\tResource() { std::cout &lt;&lt; \"Resource acquired\\n\"; }\r\n\t~Resource() { std::cout &lt;&lt; \"Resource destroyed\\n\"; }\r\n};\r\n\r\nint main()\r\n{\r\n\tAuto_ptr2&lt;Resource&gt; res1(new Resource());\r\n\tAuto_ptr2&lt;Resource&gt; res2; \/\/ Start as nullptr\r\n\r\n\tstd::cout &lt;&lt; \"res1 is \" &lt;&lt; (res1.isNull() ? \"null\\n\" : \"not null\\n\");\r\n\tstd::cout &lt;&lt; \"res2 is \" &lt;&lt; (res2.isNull() ? \"null\\n\" : \"not null\\n\");\r\n\r\n\tres2 = res1; \/\/ res2 assumes ownership, res1 is set to null\r\n\r\n\tstd::cout &lt;&lt; \"Ownership transferred\\n\";\r\n\r\n\tstd::cout &lt;&lt; \"res1 is \" &lt;&lt; (res1.isNull() ? \"null\\n\" : \"not null\\n\");\r\n\tstd::cout &lt;&lt; \"res2 is \" &lt;&lt; (res2.isNull() ? \"null\\n\" : \"not null\\n\");\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\r\nResource acquired\r\nres1 is not null\r\nres2 is null\r\nOwnership transferred\r\nres1 is null\r\nres2 is not null\r\nResource destroyed\r\n<\/pre>\n<p>Note that our overloaded operator= gave ownership of m_ptr from res1 to res2!  Consequently, we don&#8217;t end up with duplicate copies of the pointer, and everything gets tidily cleaned up.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">A reminder<\/p>\n<p>Deleting a nullptr is okay, as it does nothing.\n<\/p><\/div>\n<p><strong>std::auto_ptr, and why it was a bad idea<\/strong><\/p>\n<p>Now would be an appropriate time to talk about std::auto_ptr.  std::auto_ptr, introduced in C++98 and removed in C++17, was C++&#8217;s first attempt at a standardized smart pointer.  std::auto_ptr opted to implement move semantics just like the Auto_ptr2 class does.<\/p>\n<p>However, std::auto_ptr (and our Auto_ptr2 class) has a number of problems that makes using it dangerous.<\/p>\n<p>First, because std::auto_ptr implements move semantics through the copy constructor and assignment operator, passing a std::auto_ptr by value to a function will cause your resource to get moved to the function parameter (and be destroyed at the end of the function when the function parameters go out of scope).  Then when you go to access your auto_ptr argument from the caller (not realizing it was transferred and deleted), you&#8217;re suddenly dereferencing a null pointer.  Crash!<\/p>\n<p>Second, std::auto_ptr always deletes its contents using non-array delete. This means auto_ptr won&#8217;t work correctly with dynamically allocated arrays, because it uses the wrong kind of deallocation.  Worse, it won&#8217;t prevent you from passing it a dynamic array, which it will then mismanage, leading to memory leaks.<\/p>\n<p>Finally, auto_ptr doesn&#8217;t play nice with a lot of the other classes in the standard library, including most of the containers and algorithms.  This occurs because those standard library classes assume that when they copy an item, it actually makes a copy, not a move.<\/p>\n<p>Because of the above mentioned shortcomings, std::auto_ptr has been deprecated in C++11 and removed in C++17.<\/p>\n<p><strong>Moving forward<\/strong><\/p>\n<p>The core problem with the design of std::auto_ptr is that prior to C++11, the C++ language simply had no mechanism to differentiate &#8220;copy semantics&#8221; from &#8220;move semantics&#8221;.  Overriding the copy semantics to implement move semantics leads to weird edge cases and inadvertent bugs.  For example, you can write <code>res1 = res2<\/code> and have no idea whether res2 will be changed or not!<\/p>\n<p>Because of this, in C++11, the concept of &#8220;move&#8221; was formally defined, and &#8220;move semantics&#8221; were added to the language to properly differentiate copying from moving. Now that we&#8217;ve set the stage for why move semantics can be useful, we&#8217;ll explore the topic of move semantics throughout the rest of this chapter.  We&#8217;ll also fix our Auto_ptr2 class using move semantics.<\/p>\n<p>In C++11, std::auto_ptr has been replaced by a bunch of other types of &#8220;move-aware&#8221; smart pointers: std::unique_ptr, std::weak_ptr, and std::shared_ptr.  We&#8217;ll also explore the two most popular of these: unique_ptr (which is a direct replacement for auto_ptr) and shared_ptr.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/rvalue-references\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">22.2<\/span>R-value references\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-21-project\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.y<\/span>Chapter 21 project\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Consider a function in which we dynamically allocate a value: void someFunction() { Resource* ptr = new Resource(); \/\/ Resource is a struct or class \/\/ do stuff with ptr here delete ptr; } Although the above code seems fairly straightforward, it&#8217;s fairly easy to forget to deallocate ptr. Even &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5421"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=5421"}],"version-history":[{"count":51,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5421\/revisions"}],"predecessor-version":[{"id":18160,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5421\/revisions\/18160"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=5421"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=5421"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=5421"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}