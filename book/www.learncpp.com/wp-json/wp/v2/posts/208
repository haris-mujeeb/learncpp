{"id":208,"date":"2008-08-17T18:59:03","date_gmt":"2008-08-18T02:59:03","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=208"},"modified":"2024-03-16T15:53:05","modified_gmt":"2024-03-16T22:53:05","slug":"partial-template-specialization","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/partial-template-specialization\/","title":{"rendered":"26.5 &#8212; Partial template specialization"},"content":{"rendered":"<p>This lesson and the next are optional reading for those desiring a deeper knowledge of C++ templates.  Partial template specialization is not used all that often (but can be useful in specific cases).<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/template-non-type-parameters\/\">26.2 -- Template non-type parameters<\/a>, you learned how expression parameters could be used to parameterize template classes.<\/p>\n<p>Let&#8217;s take another look at the Static Array class we used in one of our previous examples:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;typename T, int size&gt; \/\/ size is the expression parameter\r\nclass StaticArray\r\n{\r\nprivate:\r\n    \/\/ The expression parameter controls the size of the array\r\n    T m_array[size]{};\r\n \r\npublic:\r\n    T* getArray() { return m_array; }\r\n\t\r\n    const T&amp; operator[](int index) const { return m_array[index]; }\r\n    T&amp; operator[](int index) { return m_array[index]; }\r\n};<\/code><\/pre>\n<p>This class takes two template parameters: one type parameter and one expression parameter.<\/p>\n<p>Now, let&#8217;s say we wanted to write a function to print out the whole array.  Although we could implement this as a member function, we&#8217;re going to do it as a non-member function instead because it will make the successive examples easier to follow.<\/p>\n<p>Using templates, we might write something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;typename T, int size&gt;\r\nvoid print(const StaticArray&lt;T, size&gt;&amp; array)\r\n{\r\n    for (int count{ 0 }; count &lt; size; ++count)\r\n        std::cout &lt;&lt; array[count] &lt;&lt; ' ';\r\n}<\/code><\/pre>\n<p>This would allow us to do the following:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T, int size&gt; \/\/ size is a template non-type parameter\r\nclass StaticArray\r\n{\r\nprivate:\r\n\tT m_array[size]{};\r\n\r\npublic:\r\n\tT* getArray() { return m_array; }\r\n\r\n\tconst T&amp; operator[](int index) const { return m_array[index]; }\r\n\tT&amp; operator[](int index) { return m_array[index]; }\r\n};\r\n\r\ntemplate &lt;typename T, int size&gt;\r\nvoid print(const StaticArray&lt;T, size&gt;&amp; array)\r\n{\r\n\tfor (int count{ 0 }; count &lt; size; ++count)\r\n\t\tstd::cout &lt;&lt; array[count] &lt;&lt; ' ';\r\n}\r\n\r\nint main()\r\n{\r\n\t\/\/ declare an int array\r\n\tStaticArray&lt;int, 4&gt; int4{};\r\n\tint4[0] = 0;\r\n\tint4[1] = 1;\r\n\tint4[2] = 2;\r\n\tint4[3] = 3;\r\n\r\n\t\/\/ Print the array\r\n\tprint(int4);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>and get the following result:<\/p>\n<pre>\r\n0 1 2 3\r\n<\/pre>\n<p>Although this works, it has a design flaw.  Consider the following:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\nint main()\r\n{\r\n    \/\/ Declare a char array\r\n    StaticArray&lt;char, 14&gt; char14{};\r\n\r\n    \/\/ Copy some data into it\r\n    constexpr std::string_view hello{ \"Hello, world!\" };\r\n    std::copy_n(hello.begin(), hello.size(), char14.getArray());\r\n\r\n    \/\/ Print the array\r\n    print(char14);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>(We covered std::strcpy in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/c-style-strings\/\">17.10 -- C-style strings<\/a> if you need a refresher)<\/p>\n<p>This program will compile, execute, and produce the following value (or one similar):<\/p>\n<pre>\r\nH e l l o ,   w o r l d !\r\n<\/pre>\n<p>For non-char types, it makes sense to put a space between each array element, so they don&#8217;t run together.  However, with a char type, it makes more sense to print everything run together as a C-style string, which our print() function doesn&#8217;t do.<\/p>\n<p>So how can we fix this?<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Template specialization to the rescue?<\/p>\n<p>One might first think of using template specialization.  The problem with full template specialization is that all template parameters must be explicitly defined.<\/p>\n<p>Consider:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\ntemplate &lt;typename T, int size&gt; \/\/ size is the expression parameter\r\nclass StaticArray\r\n{\r\nprivate:\r\n\t\/\/ The expression parameter controls the size of the array\r\n\tT m_array[size]{};\r\n\r\npublic:\r\n\tT* getArray() { return m_array; }\r\n\r\n\tconst T&amp; operator[](int index) const { return m_array[index]; }\r\n\tT&amp; operator[](int index) { return m_array[index]; }\r\n};\r\n\r\ntemplate &lt;typename T, int size&gt;\r\nvoid print(const StaticArray&lt;T, size&gt;&amp; array)\r\n{\r\n\tfor (int count{ 0 }; count &lt; size; ++count)\r\n\t\tstd::cout &lt;&lt; array[count] &lt;&lt; ' ';\r\n}\r\n\r\n\/\/ Override print() for fully specialized StaticArray&lt;char, 14&gt;\r\ntemplate &lt;&gt;\r\nvoid print(const StaticArray&lt;char, 14&gt;&amp; array)\r\n{\r\n\tfor (int count{ 0 }; count &lt; 14; ++count)\r\n\t\tstd::cout &lt;&lt; array[count];\r\n}\r\n\r\nint main()\r\n{\r\n    \/\/ Declare a char array\r\n    StaticArray&lt;char, 14&gt; char14{};\r\n\r\n    \/\/ Copy some data into it\r\n    constexpr std::string_view hello{ \"Hello, world!\" };\r\n    std::copy_n(hello.begin(), hello.size(), char14.getArray());\r\n\r\n    \/\/ Print the array\r\n    print(char14);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>As you can see, we&#8217;ve now provided an overloaded print function for fully specialized <code>StaticArray&lt;char, 14&gt;<\/code>.  Indeed, this prints:<\/p>\n<pre>\r\nHello, world!\r\n<\/pre>\n<p>Although this solves the issue of making sure print() can be called with a <code>StaticArray&lt;char, 14&gt;<\/code>, it brings up another problem: using full template specialization means we have to explicitly define the length of the array this function will accept!  Consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    \/\/ Declare a char array\r\n    StaticArray&lt;char, 12&gt; char12{};\r\n\r\n    \/\/ Copy some data into it\r\n    constexpr std::string_view hello{ \"Hello, mom!\" };\r\n    std::copy_n(hello.begin(), hello.size(), char12.getArray());\r\n\r\n    \/\/ Print the array\r\n    print(char12);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Calling <code>print()<\/code> with <code>char12<\/code> will call the version of <code>print()<\/code> that takes a <code>StaticArray&lt;T, size&gt;<\/code>, because <code>char12<\/code> is of type <code>StaticArray&lt;char, 12&gt;<\/code>, and our overloaded print() will only be called when passed a <code>StaticArray&lt;char, 14&gt;<\/code>.<\/p>\n<p>Although we could make a copy of print() that handles <code>StaticArray&lt;char, 12&gt;<\/code>, what happens when we want to call print() with an array size of 5, or 22?  We&#8217;d have to copy the function for each different array size.  That&#8217;s redundant.<\/p>\n<p>Obviously full template specialization is too restrictive a solution here.  The solution we are looking for is partial template specialization.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Partial template specialization<\/strong><\/p>\n<p>Partial template specialization allows us to specialize classes (but not individual functions!) where some, but not all, of the template parameters have been explicitly defined.  For our challenge above, the ideal solution would be to have our overloaded print function work with StaticArray of type char, but leave the length expression parameter templated so it can vary as needed.  Partial template specialization allows us to do just that!<\/p>\n<p>Here&#8217;s our example with an overloaded print function that takes a partially specialized StaticArray:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ overload of print() function for partially specialized StaticArray&lt;char, size&gt;\r\ntemplate &lt;int size&gt; \/\/ size is still a template non-type parameter\r\nvoid print(const StaticArray&lt;char, size&gt;&amp; array) \/\/ we're explicitly defining type char here\r\n{\r\n\tfor (int count{ 0 }; count &lt; size; ++count)\r\n\t\tstd::cout &lt;&lt; array[count];\r\n}<\/code><\/pre>\n<p>As you can see here, we&#8217;ve explicitly declared that this function will only work for StaticArray of type char, but size is still a templated expression parameter, so it will work for char arrays of any size.  That&#8217;s all there is to it!<\/p>\n<p>Here&#8217;s a full program using this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;algorithm&gt;\r\n#include &lt;iostream&gt;\r\n#include &lt;string_view&gt;\r\n\r\ntemplate &lt;typename T, int size&gt; \/\/ size is the expression parameter\r\nclass StaticArray\r\n{\r\nprivate:\r\n\t\/\/ The expression parameter controls the size of the array\r\n\tT m_array[size]{};\r\n\r\npublic:\r\n\tT* getArray() { return m_array; }\r\n\r\n\tconst T&amp; operator[](int index) const { return m_array[index]; }\r\n\tT&amp; operator[](int index) { return m_array[index]; }\r\n};\r\n\r\ntemplate &lt;typename T, int size&gt;\r\nvoid print(const StaticArray&lt;T, size&gt;&amp; array)\r\n{\r\n\tfor (int count{ 0 }; count &lt; size; ++count)\r\n\t\tstd::cout &lt;&lt; array[count] &lt;&lt; ' ';\r\n}\r\n\r\n\/\/ overload of print() function for partially specialized StaticArray&lt;char, size&gt;\r\ntemplate &lt;int size&gt;\r\nvoid print(const StaticArray&lt;char, size&gt;&amp; array)\r\n{\r\n\tfor (int count{ 0 }; count &lt; size; ++count)\r\n\t\tstd::cout &lt;&lt; array[count];\r\n}\r\n\r\nint main()\r\n{\r\n\t\/\/ Declare an char array of size 14\r\n\tStaticArray&lt;char, 14&gt; char14{};\r\n\r\n\t\/\/ Copy some data into it\r\n\tconstexpr std::string_view hello14{ \"Hello, world!\" };\r\n\tstd::copy_n(hello14.begin(), hello14.size(), char14.getArray());\r\n\r\n\t\/\/ Print the array\r\n\tprint(char14);\r\n\r\n\tstd::cout &lt;&lt; ' ';\r\n\r\n\t\/\/ Now declare an char array of size 12\r\n\tStaticArray&lt;char, 12&gt; char12{};\r\n\r\n\t\/\/ Copy some data into it\r\n\tconstexpr std::string_view hello12{ \"Hello, mom!\" };\r\n\tstd::copy_n(hello12.begin(), hello12.size(), char12.getArray());\r\n\r\n\t\/\/ Print the array\r\n\tprint(char12);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\nHello, world! Hello, mom!\r\n<\/pre>\n<p>Just as we expect.<\/p>\n<p>Partial template specialization can only be used with classes, not template functions (functions must be fully specialized).  Our <code>void print(StaticArray&lt;char, size&gt; &amp;array)<\/code> example works because the print function is not partially specialized (it&#8217;s just an overloaded template function that happens to have a partially-specialized class parameter).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Partial template specialization for member functions<\/p>\n<p>The limitation on the partial specialization of functions can lead to some challenges when dealing with member functions.  For example, what if we had defined StaticArray like this?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;typename T, int size&gt;\r\nclass StaticArray\r\n{\r\nprivate:\r\n    T m_array[size]{};\r\n \r\npublic:\r\n    T* getArray() { return m_array; }\r\n\t\r\n    const T&amp; operator[](int index) const { return m_array[index]; }\r\n    T&amp; operator[](int index) { return m_array[index]; }\r\n\r\n    void print() const;\r\n};\r\n\r\ntemplate &lt;typename T, int size&gt; \r\nvoid StaticArray&lt;T, size&gt;::print() const\r\n{\r\n    for (int i{ 0 }; i &lt; size; ++i)\r\n        std::cout &lt;&lt; m_array[i] &lt;&lt; ' ';\r\n    std::cout &lt;&lt; '\\n';\r\n}<\/code><\/pre>\n<p>print() is now a member function of class <code>StaticArray&lt;T, int&gt;<\/code>.  So what happens when we want to partially specialize print(), so that it works differently?  You might try this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Doesn't work, can't partially specialize functions\r\ntemplate &lt;int size&gt;\r\nvoid StaticArray&lt;double, size&gt;::print() const\r\n{\r\n\tfor (int i{ 0 }; i &lt; size; ++i)\r\n\t\tstd::cout &lt;&lt; std::scientific &lt;&lt; m_array[i] &lt;&lt; ' ';\r\n\tstd::cout &lt;&lt; '\\n';\r\n}<\/code><\/pre>\n<p>Unfortunately, this doesn&#8217;t work, because we&#8217;re trying to partially specialize a function, which is disallowed.<\/p>\n<p>So how do we get around this?  One obvious way is to partially specialize the entire class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T, int size&gt;\r\nclass StaticArray\r\n{\r\nprivate:\r\n\tT m_array[size]{};\r\n\r\npublic:\r\n\tT* getArray() { return m_array; }\r\n\r\n\tconst T&amp; operator[](int index) const { return m_array[index]; }\r\n\tT&amp; operator[](int index) { return m_array[index]; }\r\n\r\n\tvoid print() const;\r\n};\r\n\r\ntemplate &lt;typename T, int size&gt; \r\nvoid StaticArray&lt;T, size&gt;::print() const\r\n{\r\n\tfor (int i{ 0 }; i &lt; size; ++i)\r\n\t\tstd::cout &lt;&lt; m_array[i] &lt;&lt; ' ';\r\n\tstd::cout &lt;&lt; '\\n';\r\n}\r\n\r\n\/\/ Partially specialized class\r\ntemplate &lt;int size&gt;\r\nclass StaticArray&lt;double, size&gt;\r\n{\r\nprivate:\r\n\tdouble m_array[size]{};\r\n\r\npublic:\r\n\tdouble* getArray() { return m_array; }\r\n\r\n\tconst double&amp; operator[](int index) const { return m_array[index]; }\r\n\tdouble&amp; operator[](int index) { return m_array[index]; }\r\n\r\n\tvoid print() const;\r\n};\r\n\r\n\/\/ Member function of partially specialized class\r\ntemplate &lt;int size&gt;\r\nvoid StaticArray&lt;double, size&gt;::print() const\r\n{\r\n\tfor (int i{ 0 }; i &lt; size; ++i)\r\n\t\tstd::cout &lt;&lt; std::scientific &lt;&lt; m_array[i] &lt;&lt; ' ';\r\n\tstd::cout &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n\t\/\/ declare an integer array with room for 6 integers\r\n\tStaticArray&lt;int, 6&gt; intArray{};\r\n\r\n\t\/\/ Fill it up in order, then print it\r\n\tfor (int count{ 0 }; count &lt; 6; ++count)\r\n\t\tintArray[count] = count;\r\n\r\n\tintArray.print();\r\n\r\n\t\/\/ declare a double buffer with room for 4 doubles\r\n\tStaticArray&lt;double, 4&gt; doubleArray{};\r\n\r\n\tfor (int count{ 0 }; count &lt; 4; ++count)\r\n\t\tdoubleArray[count] = (4.0 + 0.1 * count);\r\n\r\n\tdoubleArray.print();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\n0 1 2 3 4 5\r\n4.000000e+00 4.100000e+00 4.200000e+00 4.300000e+00\r\n<\/pre>\n<p>This works because <code>StaticArray&lt;double, size&gt;::print()<\/code> is no longer a partially specialized function -- it is a non-specialized member of partially specialized class <code>StaticArray&lt;double, size&gt;<\/code>.<\/p>\n<p>However, this isn&#8217;t a great solution, because we have to duplicate a lot of code from <code>StaticArray&lt;T, size&gt;<\/code> to <code>StaticArray&lt;double, size&gt;<\/code>.<\/p>\n<p>If only there were some way to reuse the code in <code>StaticArray&lt;T, size&gt;<\/code> in <code>StaticArray&lt;double, size&gt;<\/code>.  Sounds like a job for inheritance!<\/p>\n<p>You might start off trying to write that code like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;int size&gt; \/\/ size is the expression parameter\r\nclass StaticArray&lt;double, size&gt;: public StaticArray&lt;T, size&gt;<\/code><\/pre>\n<p>But this doesn&#8217;t work, because we&#8217;ve used <code>T<\/code> without defining it.  There is no syntax that allows us to inherit in such a manner.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>Even if we were able to define <code>T<\/code> as a type template parameter, when <code>StaticArray&lt;double, size&gt;<\/code> was instantiated, the compiler would need to replace the <code>T<\/code> in <code>StaticArray&lt;T, size&gt;<\/code> with an actual type.  What actual type would it use?  The only type that makes sense is <code>T=double<\/code>, but that would leave <code>StaticArray&lt;double, size&gt;<\/code> inheriting from itself!\n<\/div>\n<p>Fortunately, there&#8217;s a workaround, by using a common base class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T, int size&gt;\r\nclass StaticArray_Base\r\n{\r\nprotected:\r\n\tT m_array[size]{};\r\n\r\npublic:\r\n\tT* getArray() { return m_array; }\r\n\r\n\tconst T&amp; operator[](int index) const { return m_array[index]; }\r\n\tT&amp; operator[](int index) { return m_array[index]; }\r\n\r\n\tvoid print() const\r\n\t{\r\n\t\tfor (int i{ 0 }; i &lt; size; ++i)\r\n\t\t\tstd::cout &lt;&lt; m_array[i] &lt;&lt; ' ';\r\n\t\tstd::cout &lt;&lt; '\\n';\r\n\t}\r\n\r\n\t\/\/ Don't forget a virtual destructor if you're going to use virtual function resolution\r\n};\r\n\r\ntemplate &lt;typename T, int size&gt;\r\nclass StaticArray: public StaticArray_Base&lt;T, size&gt;\r\n{\r\n};\r\n\r\ntemplate &lt;int size&gt;\r\nclass StaticArray&lt;double, size&gt;: public StaticArray_Base&lt;double, size&gt;\r\n{\r\npublic:\r\n\r\n\tvoid print() const\r\n\t{\r\n\t\tfor (int i{ 0 }; i &lt; size; ++i)\r\n\t\t\tstd::cout &lt;&lt; std::scientific &lt;&lt; this-&gt;m_array[i] &lt;&lt; ' ';\r\n\/\/ note: The this-&gt; prefix in the above line is needed.\r\n\/\/ See https:\/\/stackoverflow.com\/a\/6592617 or https:\/\/isocpp.org\/wiki\/faq\/templates#nondependent-name-lookup-members for more info on why.\r\n\t\tstd::cout &lt;&lt; '\\n';\r\n\t}\r\n};\r\n\r\nint main()\r\n{\r\n\t\/\/ declare an integer array with room for 6 integers\r\n\tStaticArray&lt;int, 6&gt; intArray{};\r\n\r\n\t\/\/ Fill it up in order, then print it\r\n\tfor (int count{ 0 }; count &lt; 6; ++count)\r\n\t\tintArray[count] = count;\r\n\r\n\tintArray.print();\r\n\r\n\t\/\/ declare a double buffer with room for 4 doubles\r\n\tStaticArray&lt;double, 4&gt; doubleArray{};\r\n\r\n\tfor (int count{ 0 }; count &lt; 4; ++count)\r\n\t\tdoubleArray[count] = (4.0 + 0.1 * count);\r\n\r\n\tdoubleArray.print();\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints the same as above, but has significantly less duplicated code.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/partial-template-specialization-for-pointers\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">26.6<\/span>Partial template specialization for pointers\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-template-specialization\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">26.4<\/span>Class template specialization\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>This lesson and the next are optional reading for those desiring a deeper knowledge of C++ templates. Partial template specialization is not used all that often (but can be useful in specific cases). In lesson , you learned how expression parameters could be used to parameterize template classes. Let&#8217;s take &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[12,21,14,22,15,16],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/208"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=208"}],"version-history":[{"count":56,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/208\/revisions"}],"predecessor-version":[{"id":3746,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/208\/revisions\/3746"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=208"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=208"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=208"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}