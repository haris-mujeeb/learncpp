{"id":5130,"date":"2016-12-03T17:10:15","date_gmt":"2016-12-04T01:10:15","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=5130"},"modified":"2024-07-30T14:45:37","modified_gmt":"2024-07-30T21:45:37","slug":"function-template-specialization","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/function-template-specialization\/","title":{"rendered":"26.3 &#8212; Function template specialization"},"content":{"rendered":"<p>When instantiating a function template for a given type, the compiler stencils out a copy of the templated function and replaces the template type parameters with the actual types used in the variable declaration.  This means a particular function will have the same implementation details for each instanced type (just using different types).  While most of the time this is exactly what you want, occasionally there are cases where it is useful to implement a templated function slightly differently for a specific data type.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using a non-template function<\/p>\n<p>Consider the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nvoid print(const T&amp; t)\r\n{\r\n    std::cout &lt;&lt; t &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    print(5);\r\n    print(6.7);\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n5\r\n6.7\r\n<\/pre>\n<p>Now, let&#8217;s say we want double values (and only double values) to output in scientific notation.<\/p>\n<p>One way to get different behavior for a given type is to define a non-template function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nvoid print(const T&amp; t)\r\n{\r\n    std::cout &lt;&lt; t &lt;&lt; '\\n';\r\n}\r\n\r\nvoid print(double d)\r\n{\r\n    std::cout &lt;&lt; std::scientific &lt;&lt; d &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    print(5);\r\n    print(6.7);\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>When the compiler goes to resolve <code>print(6.7)<\/code>, it will see that <code>print(double)<\/code> has already been defined by us, and use that instead of instantiating a version from <code>print(const T&amp;)<\/code>.<\/p>\n<p>This produces the result:<\/p>\n<pre>\n5\r\n6.700000e+000\r\n<\/pre>\n<p>One nice thing about defining functions this way is that the non-template function doesn&#8217;t need to have the same signature as the function template.  Note that <code>print(const T&amp;)<\/code> uses pass by const reference, whereas <code>print(double)<\/code> uses pass by value.<\/p>\n<p>Generally, prefer to define a non-template function if that option is available.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Function template specialization<\/p>\n<p>Another way to achieve a similar result is to use explicit template specialization.  <strong>Explicit template specialization<\/strong> (often shortened to <strong>template specialization<\/strong>) is a feature that allows us to explicitly define different implementations of a template for specific types or values.  When all of the template parameters are specialized, it is called a <strong>full specialization<\/strong>.  When only some of the template parameters are specialized, it is called a <strong>partial specialization<\/strong>.<\/p>\n<p>Let&#8217;s create a specialization of <code>print&lt;T&gt;<\/code> when <code>T<\/code> is a <code>double<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ Here's our primary template (must come first)\r\ntemplate &lt;typename T&gt;\r\nvoid print(const T&amp; t)\r\n{\r\n    std::cout &lt;&lt; t &lt;&lt; '\\n';\r\n}\r\n\r\n\/\/ A full specialization of primary template print&lt;T&gt; for type double\r\n\/\/ Full specializations are not implicitly inline, so make this inline if put in header file\r\ntemplate&lt;&gt;                          \/\/ template parameter declaration containing no template parameters \r\nvoid print&lt;double&gt;(const double&amp; d) \/\/ specialized for type double\r\n{\r\n    std::cout &lt;&lt; std::scientific &lt;&lt; d &lt;&lt; '\\n'; \r\n}\r\n\r\nint main()\r\n{\r\n    print(5);\r\n    print(6.7);\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>In order to specialize a template, the compiler first must have seen a declaration for the primary template.  The primary template in the example above is <code>print&lt;T&gt;(const T&amp;)<\/code>.<\/p>\n<p>Now, let&#8217;s take a closer look at our function template specialization:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template&lt;&gt;                          \/\/ template parameter declaration containing no template parameters \r\nvoid print&lt;double&gt;(const double&amp; d) \/\/ specialized for type double<\/code><\/pre>\n<p>First, we need a template parameter declaration so the compiler knows we&#8217;re doing something related to templates.  However, in this case, we don&#8217;t actually need any template parameters, so we use an empty pair of angled brackets.  Since we have no template parameters in the specialization, this is a full specialization.<\/p>\n<p>On the next line, <code>print&lt;double&gt;<\/code> tells the compiler that we&#8217;re specializing the <code>print<\/code> primary template function for type <code>double<\/code>.  The specialization must have the same signature as the primary template (except the specialization substitutes <code>double<\/code> anywhere the primary template uses <code>T<\/code>).  Because the primary template has a parameter of type <code>const T&amp;<\/code>, the specialization must have a parameter of type <code>const double&amp;<\/code>.  The specialization cannot use pass-by-value when the primary template uses pass-by-reference (or vice-versa).<\/p>\n<p>This example prints the same result as above.<\/p>\n<p>Note that if a matching non-template function and a matching template function specialization both exist, the non-template function will take precedence.  Also, full specializations are not implicitly inline, so if you define one in a header file, make sure you <code>inline<\/code> it to avoid ODR violations.<\/p>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Full specializations are not implicitly inline (partial specializations are implicitly inline).  If you put a full specialization in a header file, it should be marked as <code>inline<\/code> so that it does not cause ODR violations when included into multiple translation units.\n<\/div>\n<p>Just like normal functions, function template specializations can be deleted (using <code>= delete<\/code>) if you want any function calls that resolve to the specialization to produce a compilation error.<\/p>\n<p>In general, you should avoid function template specializations in favor of non-template functions whenever possible.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Function template specialization for member functions?<\/p>\n<p>Now consider the following class template:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nclass Storage\r\n{\r\nprivate:\r\n    T m_value {};\r\npublic:\r\n    Storage(T value)\r\n      : m_value { value }\r\n    {\r\n    }\r\n\r\n    void print()\r\n    {\r\n        std::cout &lt;&lt; m_value &lt;&lt; '\\n';\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    \/\/ Define some storage units\r\n    Storage i { 5 };\r\n    Storage d { 6.7 };\r\n\r\n    \/\/ Print out some values\r\n    i.print();\r\n    d.print();\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">5\r\n6.7<\/code><\/pre>\n<p>Let&#8217;s say we again want to create a version of the <code>print()<\/code> function that prints doubles in scientific notation.  However, this time <code>print()<\/code> is a member function, so we can&#8217;t define a non-member function.  So how might we do this?<\/p>\n<p>Although it may seem like we need to use function template specialization here, that&#8217;s the wrong tool.  Note that <code>i.print()<\/code> calls <code>Storage&lt;int&gt;::print()<\/code> and <code>d.print()<\/code> calls <code>Storage&lt;double&gt;::print()<\/code>.  Therefore, if we want to change the behavior of this function when <code>T<\/code> is a double, we need to specialize <code>Storage&lt;double&gt;::print()<\/code>, which is a class template specialization, not a function template specialization!<\/p>\n<p>So how might we do that?  We&#8217;ll cover class template specialization in the next lesson.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-template-specialization\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">26.4<\/span>Class template specialization\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/template-non-type-parameters\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">26.2<\/span>Template non-type parameters\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>When instantiating a function template for a given type, the compiler stencils out a copy of the templated function and replaces the template type parameters with the actual types used in the variable declaration. This means a particular function will have the same implementation details for each instanced type (just &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5130"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=5130"}],"version-history":[{"count":35,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5130\/revisions"}],"predecessor-version":[{"id":17410,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5130\/revisions\/17410"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=5130"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=5130"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=5130"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}