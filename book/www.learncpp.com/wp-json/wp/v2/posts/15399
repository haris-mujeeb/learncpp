{"id":15399,"date":"2023-09-11T14:34:44","date_gmt":"2023-09-11T21:34:44","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=15399"},"modified":"2024-10-19T18:04:58","modified_gmt":"2024-10-20T01:04:58","slug":"arrays-loops-and-sign-challenge-solutions","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/arrays-loops-and-sign-challenge-solutions\/","title":{"rendered":"16.7 &#8212; Arrays, loops, and sign challenge solutions"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/unsigned-integers-and-why-to-avoid-them\/\">4.5 -- Unsigned integers, and why to avoid them<\/a>, we noted how we generally prefer to use signed values to hold quantities, because unsigned values can act in surprising ways.  However, in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdvector-and-the-unsigned-length-and-subscript-problem\/\">16.3 -- std::vector and the unsigned length and subscript problem<\/a>, we discussed how <code>std::vector<\/code> (and other container classes) uses unsigned integral type <code>std::size_t<\/code> for length and indices.<\/p>\n<p>This can lead to problems such as this one:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nvoid printReverse(const std::vector&lt;T&gt;&amp; arr)\r\n{\r\n    for (std::size_t index{ arr.size() - 1 }; index &gt;= 0; --index) \/\/ index is unsigned\r\n    {\r\n        std::cout &lt;&lt; arr[index] &lt;&lt; ' ';\r\n    }\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector arr{ 4, 6, 7, 3, 8, 2, 1, 9 };\r\n\r\n    printReverse(arr);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This code begins by printing the array in reverse:<\/p>\n<pre>\n9 1 2 8 3 7 6 4\r\n<\/pre>\n<p>And then exhibits undefined behavior.  It might print garbage values, or crash the application.<\/p>\n<p>There are two problems here.  First, our loop executes as long as <code>index &gt;= 0<\/code> (or in other words, as long as <code>index<\/code> is positive), which is always true when <code>index<\/code> is unsigned.  Therefore, the loop never terminates.<\/p>\n<p>Second, when we decrement <code>index<\/code> when it has value <code>0<\/code>, it will wrap around to a large positive value, which we then use to index the array on the next iteration.  This is an out-of-bounds index, and will cause undefined behavior.  We run into the same problem if our vector is empty.<\/p>\n<p>And while there are plenty of ways to work around these specific issues, these kinds of issues are magnets for bugs.<\/p>\n<p>Using a signed type for a loop variable more easily avoids such problems, but has its own challenges.  Here&#8217;s a version of the above problem that uses a signed index:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nvoid printReverse(const std::vector&lt;T&gt;&amp; arr)\r\n{\r\n    for (int index{ static_cast&lt;int&gt;(arr.size()) - 1}; index &gt;= 0; --index) \/\/ index is signed\r\n    {\r\n        std::cout &lt;&lt; arr[static_cast&lt;std::size_t&gt;(index)] &lt;&lt; ' ';\r\n    }\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector arr{ 4, 6, 7, 3, 8, 2, 1, 9 };\r\n\r\n    printReverse(arr);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>While this version functions as intended, the code is also a cluttered due to the addition two static casts.  <code>arr[static_cast&lt;std::size_t&gt;(index)]<\/code> is particularly hard to read.  In this case, we&#8217;ve improved safety at a significant cost to readability.<\/p>\n<p>Here&#8217;s another example of using a signed index:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\n\/\/ Function template to calculate the average value in a std::vector\r\ntemplate &lt;typename T&gt;\r\nT calculateAverage(const std::vector&lt;T&gt;&amp; arr)\r\n{\r\n    int length{ static_cast&lt;int&gt;(arr.size()) };\r\n\r\n    T average{ 0 };\r\n    for (int index{ 0 }; index &lt; length; ++index)\r\n        average += arr[static_cast&lt;std::size_t&gt;(index)];\r\n    average \/= length;\r\n\r\n    return average;\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector testScore1 { 84, 92, 76, 81, 56 };\r\n    std::cout &lt;&lt; \"The class 1 average is: \" &lt;&lt; calculateAverage(testScore1) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The cluttering of our code with static casts is pretty terrible.<\/p>\n<p>So what should we do?  This is an area where there is no ideal solution.<\/p>\n<p>There are many viable options here, which we&#8217;ll present in order from what we believe is worst to best.  You will likely encounter all of these in code written by others.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>Although we&#8217;ll be discussing this in the context of <code>std::vector<\/code>, all of the standard library containers (e.g. <code>std::array<\/code>) work similarly and have the same challenges.  The discussion that follows is applicable to any of them.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Leave signed\/unsigned conversion warnings off<\/p>\n<p>If you were wondering why signed\/unsigned conversion warnings are often disabled by default, this topic is one of the key reasons.  Every time we subscript a standard library container using a signed index, a sign conversion warning will be generated.  This will quickly fill up your compilation log with spurious warnings, drowning out warnings that may actually be legitimate.<\/p>\n<p>So one way to avoid having to deal with lots of signed\/unsigned conversion warnings is to simply leave those warnings turned off.<\/p>\n<p>This is the simplest solution, but not one we recommend, as this will also suppress generation of legitimate sign conversion warnings that may cause bugs if not addressed.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using an unsigned loop variable<\/p>\n<p>Many developers believe that since the standard library array types were designed to use unsigned indices, then we should use unsigned indices!  This is a completely reasonable position.  We just need to be extra careful that we do not run into signed\/unsigned mismatches when doing so.  If possible, avoid using the index loop variable for anything but indexing.<\/p>\n<p>If we decide to use this approach, which unsigned type should we actually use?<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdvector-and-the-unsigned-length-and-subscript-problem\/#size_type\">16.3 -- std::vector and the unsigned length and subscript problem<\/a>, we noted that the standard library container classes define nested typedef <code>size_type<\/code>, which is an unsigned integral type used for array lengths and indices.  The <code>size()<\/code> member function returns <code>size_type<\/code>, and <code>operator[]<\/code> uses <code>size_type<\/code> as an index, so using <code>size_type<\/code> as the type of your index is technically the most consistent and safe unsigned type to use (as it will work in all cases, even in the extremely rare case where <code>size_type<\/code> is something other than <code>size_t<\/code>.).  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n\tstd::vector arr { 1, 2, 3, 4, 5 };\r\n\r\n\tfor (std::vector&lt;int&gt;::size_type index { 0 }; index &lt; arr.size(); ++index)\r\n\t\tstd::cout &lt;&lt; arr[index] &lt;&lt; ' ';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>However, using <code>size_type<\/code> has a major downside: because it is a nested type, to use it we have to explicitly prefix the name with the fully templated name of the container (meaning we have to type <code>std::vector&lt;int&gt;::size_type<\/code> rather than just <code>std::size_type<\/code>).  This requires a lot of typing, is hard to read, and varies depending on the container and element type.<\/p>\n<p>When used inside a function template, we can use <code>T<\/code> for the template arguments.  But we also need to prefix the type with the <code>typename<\/code> keyword:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nvoid printArray(const std::vector&lt;T&gt;&amp; arr)\r\n{\r\n\t\/\/ typename keyword prefix required for dependent type\r\n\tfor (typename std::vector&lt;T&gt;::size_type index { 0 }; index &lt; arr.size(); ++index)\r\n\t\tstd::cout &lt;&lt; arr[index] &lt;&lt; ' ';\r\n}\r\n\r\nint main()\r\n{\r\n\tstd::vector arr { 9, 7, 5, 3, 1 };\r\n\r\n\tprintArray(arr);\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>If you forget the <code>typename<\/code> keyword, your compiler will probably remind you to add it.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Any name that depends on a type containing a template parameter is called a <strong>dependent name<\/strong>.  Dependent names must be prefixed with the keyword <code>typename<\/code> in order to be used as a type.<\/p>\n<p>In the above example, <code>std::vector&lt;T&gt;<\/code> is a type with a template parameter, so nested type <code>std::vector&lt;T&gt;::size_type<\/code> is a dependent name, and must be prefixed with <code>typename<\/code> to be used as a type.\n<\/div>\n<p>You may occasionally see the array type aliased to make the loop easier to read:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    using arrayi = std::vector&lt;int&gt;;\r\n    for (arrayi::size_type index { 0 }; index &lt; arr.size(); ++index)<\/code><\/pre>\n<p>A more general solution is to have the compiler fetch the type of the array type object for us, so that we don&#8217;t have to explicitly specify the container type or template arguments.  To do so, we can use the <strong>decltype<\/strong> keyword, which returns the type of its parameter.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    \/\/ arr is some non-reference type\r\n    for (decltype(arr)::size_type index { 0 }; index &lt; arr.size(); ++index) \/\/ decltype(arr) resolves to std::vector&lt;int&gt;<\/code><\/pre>\n<p>However, if <code>arr<\/code> is a reference type (e.g. an array passed by reference), the above doesn&#8217;t work.  We need to first remove the reference from <code>arr<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">template &lt;typename T&gt;\r\nvoid printArray(const std::vector&lt;T&gt;&amp; arr)\r\n{\r\n\t\/\/ arr can be a reference or non-reference type\r\n\tfor (typename std::remove_reference_t&lt;decltype(arr)&gt;::size_type index { 0 }; index &lt; arr.size(); ++index)\r\n\t\tstd::cout &lt;&lt; arr[index] &lt;&lt; ' ';\r\n}<\/code><\/pre>\n<p>Unfortunately, this is no longer very concise or easy to remember.<\/p>\n<p>Because <code>size_type<\/code> is almost always a typedef for <code>size_t<\/code>, many programmers just skip using <code>size_type<\/code> altogether and use the easier to remember and type <code>std::size_t<\/code> directly:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    for (std::size_t index { 0 }; index &lt; arr.size(); ++index)<\/code><\/pre>\n<p>Unless you&#8217;re using custom allocators (and you probably aren&#8217;t), we believe this is a reasonable approach.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Using a signed loop variable<\/p>\n<p>Although it makes working with the standard library container types a bit more difficult, using a signed loop variable is consistent with the best practices employed in the rest of our code (to favor signed values for quantities).  And the more we can consistently apply our best practices, the fewer errors we will have overall.<\/p>\n<p>If we are going to use signed loop variables, there are three issues we need to address:<\/p>\n<ul>\n<li>What signed type should we use?\n<\/li>\n<li>Getting the length of the array as a signed value\n<\/li>\n<li>Converting the signed loop variable to an unsigned index\n<\/li>\n<\/ul>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">What signed type should we use?<\/p>\n<p>There are three (sometimes four) good options here.<\/p>\n<ol start=\"1\">\n<li>Unless you are working with a very large array, using <code>int<\/code> should be fine (particularly on architectures where int is 4 bytes).  <code>int<\/code> is the default signed integral type we use for everything when we don&#8217;t really care about the type otherwise, and there&#8217;s little reason to do otherwise here.\n<\/li>\n<li>If you are dealing with very large arrays, or if you want to be a bit more defensive, you can use the strangely named <code>std::ptrdiff_t<\/code>.  This typedef is often used as the signed counterpart to <code>std::size_t<\/code>.\n<\/li>\n<li>Because <code>std::ptrdiff_t<\/code> has a weird name, another good approach is to define your own type alias for indices:\n<\/li>\n<\/ol>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">using Index = std::ptrdiff_t;\r\n\r\n\/\/ Sample loop using index\r\nfor (Index index{ 0 }; index &lt; static_cast&lt;Index&gt;(arr.size()); ++index)<\/code><\/pre>\n<p>We&#8217;ll show a full example of this in the next section.<\/p>\n<p>Defining your own type alias also has a potential future benefit: if the C++ standard library ever releases a type designed to be used as a signed index, it will be easy to either modify <code>Index<\/code> to alias that type, or to find\/replace <code>Index<\/code> with whatever that type is named.<\/p>\n<ol start=\"4\">\n<li>In cases where you can derive the type of your loop variable from the initializer, you can use <code>auto<\/code> to have the compiler deduce the type:\n<\/li>\n<\/ol>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    for (auto index{ static_cast&lt;std::ptrdiff_t&gt;(arr.size())-1 }; index &gt;= 0; --index)<\/code><\/pre>\n<p>In C++23, the <code>Z<\/code> suffix can be used to define a literal of the type that is the signed counterpart to <code>std::size_t<\/code> (probably <code>std::ptrdiff_t<\/code>):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    for (auto index{ 0Z }; index &lt; static_cast&lt;std::ptrdiff_t&gt;(arr.size()); ++index)<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Getting the length of an array as a signed value<\/p>\n<ol start=\"1\">\n<li>Pre-C++20, the best option is to <code>static_cast<\/code> the return value of the <code>size()<\/code> member function or <code>std::size()<\/code> to a signed type:\n<\/li>\n<\/ol>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nusing Index = std::ptrdiff_t;\r\n\r\nint main()\r\n{\r\n    std::vector arr{ 9, 7, 5, 3, 1 };\r\n\r\n    for (auto index{ static_cast&lt;Index&gt;(arr.size())-1 }; index &gt;= 0; --index)\r\n        std::cout &lt;&lt; arr[static_cast&lt;std::size_t&gt;(index)] &lt;&lt; ' ';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>That way, the unsigned value returned by <code>arr.size()<\/code> will be converted to a signed type, so our comparison operator will have two signed operands.  And because signed indices won&#8217;t overflow when they go negative, we don&#8217;t have the wrap-around problem we ran into when using unsigned indices.<\/p>\n<p>The downside of this approach is that it clutters up our loop, making it harder to read.  We can address this by moving the length out of the loop:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nusing Index = std::ptrdiff_t;\r\n\r\nint main()\r\n{\r\n    std::vector arr{ 9, 7, 5, 3, 1 };\r\n\r\n    auto length{ static_cast&lt;Index&gt;(arr.size()) }; \r\n    for (auto index{ length-1 }; index &gt;= 0; --index)\r\n        std::cout &lt;&lt; arr[static_cast&lt;std::size_t&gt;(index)] &lt;&lt; ' ';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<ol start=\"2\">\n<li>In C++20, use <code>std::ssize()<\/code>:\n<\/li>\n<\/ol>\n<p>If you want more evidence that the designers of C++ now believe that signed indices are the way to go, consider the introduction of <code>std::ssize()<\/code> in C++20.  This function returns the size of an array type as a signed type (likely <code>ptrdiff_t<\/code>).<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::vector arr{ 9, 7, 5, 3, 1 };\r\n\r\n    for (auto index{ std::ssize(arr)-1 }; index &gt;= 0; --index) \/\/ std::ssize introduced in C++20\r\n        std::cout &lt;&lt; arr[static_cast&lt;std::size_t&gt;(index)] &lt;&lt; ' ';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Converting the signed loop variable to an unsigned index<\/p>\n<p>Once we have a signed loop variable, we&#8217;re going to run into implicit sign conversion warnings whenever we try to use that signed loop variable as an index.  So we need some way to convert our signed loop variable to an unsigned value wherever we intend to use it as an index.<\/p>\n<ol start=\"1\">\n<li>The obvious option is to static cast our signed loop variable into an unsigned index.  We show this in the prior example.  Unfortunately, we need to do this everywhere we subscript the array, and it makes our array indices hard to read.\n<\/li>\n<li>Use a conversion function with a short name:\n<\/li>\n<\/ol>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;type_traits&gt; \/\/ for std::is_integral and std::is_enum\r\n#include &lt;vector&gt;\r\n\r\nusing Index = std::ptrdiff_t;\r\n\r\n\/\/ Helper function to convert `value` into an object of type std::size_t\r\n\/\/ UZ is the suffix for literals of type std::size_t.\r\ntemplate &lt;typename T&gt;\r\nconstexpr std::size_t toUZ(T value)\r\n{\r\n    \/\/ make sure T is an integral type\r\n    static_assert(std::is_integral&lt;T&gt;() || std::is_enum&lt;T&gt;());\r\n    \r\n    return static_cast&lt;std::size_t&gt;(value);\r\n}\r\n\r\nint main()\r\n{\r\n    std::vector arr{ 9, 7, 5, 3, 1 };\r\n\r\n    auto length { static_cast&lt;Index&gt;(arr.size()) };  \/\/ in C++20, prefer std::ssize()\r\n    for (auto index{ length-1 }; index &gt;= 0; --index)\r\n        std::cout &lt;&lt; arr[toUZ(index)] &lt;&lt; ' '; \/\/ use toUZ() to avoid sign conversion warning\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, we&#8217;ve created a function named <code>toUZ()<\/code> that is designed to convert integral values to values of type <code>std::size_t<\/code>.  This allows us to index our array as <code>arr[toUZ(index)]<\/code>, which is pretty readable.<\/p>\n<ol start=\"3\">\n<li>Use a custom view\n<\/li>\n<\/ol>\n<p>In prior lessons, we discussed how <code>std::string<\/code> owns a string, whereas <code>std::string_view<\/code> is a view into a string that exists elsewhere.  One of the neat things about <code>std::string_view<\/code> is how it can view different types of strings (C-style string literals, <code>std::string<\/code>, and other <code>std::string_view<\/code>) but keeps a consistent interface for us to use.<\/p>\n<p>While we can&#8217;t modify the standard library containers to accept a signed integral index, we can create our own custom view class to &#8220;view&#8221; a standard library container class.  And in doing so, we can define our own interface to work however we want.<\/p>\n<p>In the following example, we define a custom view class that can view any standard library container that supports indexing.  Our interface will do two things:<\/p>\n<ul>\n<li>Allow us to access elements using <code>operator[]<\/code> with a signed integral type.\n<\/li>\n<li>Get the length of the container as a signed integral type (since <code>std::ssize()<\/code> is only available on C++20).\n<\/li>\n<\/ul>\n<p>This uses operator overloading (which we briefly introduced in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-overloading-the-i-o-operators\/\">13.5 -- Introduction to overloading the I\/O operators<\/a>) to implement <code>operator[]<\/code>.  You don&#8217;t need to know how <code>SignedArrayView<\/code> is implemented in order to use it.<\/p>\n<p>SignedArrayView.h:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#ifndef SIGNED_ARRAY_VIEW_H\r\n#define SIGNED_ARRAY_VIEW_H\r\n\r\n#include &lt;cstddef&gt; \/\/ for std::size_t and std::ptrdiff_t\r\n\r\n\/\/ SignedArrayView provides a view into a container that supports indexing\r\n\/\/ allowing us to work with these types using signed indices\r\ntemplate &lt;typename T&gt;\r\nclass SignedArrayView \/\/ requires C++17\r\n{\r\nprivate:\r\n    T&amp; m_array;\r\n\r\npublic:\r\n    using Index = std::ptrdiff_t;\r\n\r\n    SignedArrayView(T&amp; array)\r\n        : m_array{ array } {}\r\n\r\n    \/\/ Overload operator[] to take a signed index\r\n    constexpr auto&amp; operator[](Index index) { return m_array[static_cast&lt;typename T::size_type&gt;(index)]; }\r\n    constexpr const auto&amp; operator[](Index index) const { return m_array[static_cast&lt;typename T::size_type&gt;(index)]; }\r\n    constexpr auto ssize() const { return static_cast&lt;Index&gt;(m_array.size()); }\r\n};\r\n\r\n#endif<\/code><\/pre>\n<p>main.cpp:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;vector&gt;\r\n#include \"SignedArrayView.h\"\r\n\r\nint main()\r\n{\r\n    std::vector arr{ 9, 7, 5, 3, 1 };\r\n    SignedArrayView sarr{ arr }; \/\/ Create a signed view of our std::vector\r\n\r\n    for (auto index{ sarr.ssize() - 1 }; index &gt;= 0; --index)\r\n        std::cout &lt;&lt; sarr[index] &lt;&lt; ' '; \/\/ index using a signed type\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Index the underlying C-style array instead<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdvector-and-the-unsigned-length-and-subscript-problem\/\">16.3 -- std::vector and the unsigned length and subscript problem<\/a>, we noted that instead of indexing the standard library container, we can instead call the <code>data()<\/code> member function and index that instead.  Since <code>data()<\/code> returns the array data as a C-style array, and C-style arrays allow indexing with both signed and unsigned values, this avoids sign conversion issues.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    std::vector arr{ 9, 7, 5, 3, 1 };\r\n\r\n    auto length { static_cast&lt;Index&gt;(arr.size()) };  \/\/ in C++20, prefer std::ssize()\r\n    for (auto index{ length - 1 }; index &gt;= 0; --index)\r\n        std::cout &lt;&lt; arr.data()[index] &lt;&lt; ' ';       \/\/ use data() to avoid sign conversion warning\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>We believe that this method is the best of the indexing options:<\/p>\n<ul>\n<li>We can use signed loop variables and indices.\n<\/li>\n<li>We don&#8217;t have to define any custom types or type aliases.\n<\/li>\n<li>The hit to readability from using <code>data()<\/code> isn&#8217;t very big.\n<\/li>\n<li>There should be no performance hit in optimized code.\n<\/li>\n<\/ul>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The only sane choice: avoid indexing altogether!<\/p>\n<p>All of the options presented above have their own downsides, so it&#8217;s hard to recommend one approach over the other.  However, there is a choice that is far more sane than the others: avoid indexing with integral values altogether.<\/p>\n<p>C++ provides several other methods for traversing through arrays that do not use indices at all.  And if we don&#8217;t have indices, then we don&#8217;t run into all of these signed\/unsigned conversion issues.<\/p>\n<p>Two common methods for array traversal without indices include range-based for loops, and iterators.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover ranged-for loops in the next lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/range-based-for-loops-for-each\/\">16.8 -- Range-based for loops (for-each)<\/a>).<br \/>\nWe cover iterators in upcoming lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-iterators\/\">18.2 -- Introduction to iterators<\/a>.\n<\/p><\/div>\n<p>If you&#8217;re only using the index variable to traverse the array, then prefer a method that does not use indices.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Avoid array indexing with integral values whenever possible.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/range-based-for-loops-for-each\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">16.8<\/span>Range-based for loops (for-each)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/arrays-and-loops\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">16.6<\/span>Arrays and loops\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we noted how we generally prefer to use signed values to hold quantities, because unsigned values can act in surprising ways. However, in lesson , we discussed how std::vector (and other container classes) uses unsigned integral type std::size_t for length and indices. This can lead to problems &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15399"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=15399"}],"version-history":[{"count":14,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15399\/revisions"}],"predecessor-version":[{"id":17774,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/15399\/revisions\/17774"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=15399"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=15399"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=15399"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}