{"id":89,"date":"2007-07-02T09:29:09","date_gmt":"2007-07-02T17:29:09","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-programming\/eight-c-programming-mistakes-the-compiler-wont-catch\/"},"modified":"2018-02-27T09:39:19","modified_gmt":"2018-02-27T17:39:19","slug":"eight-c-programming-mistakes-the-compiler-wont-catch","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-programming\/eight-c-programming-mistakes-the-compiler-wont-catch\/","title":{"rendered":"Eight C++ programming mistakes the compiler won&#8217;t catch"},"content":{"rendered":"<p><!--adsense#FloatRight--><br \/>\nC++ is a complex language, full of subtle traps for the unwary. There is an almost infinite number of ways to screw things up.  Fortunately, modern compilers are pretty good at detecting a large number of these cases and notifying the programmer via compile errors or warnings.  Ultimately, any error that is compiler-detectable becomes a non-issue if properly handled, as it will be caught and fixed before the program leaves development.  At worst, a compiler-detectable error results in lost time while the programmer searches for a solution or workaround.<\/p>\n<p>The dangerous errors are the ones that compilers are <em>unable<\/em> to detect.  These errors are much less likely to be noticed, and can cause severe consequences such as incorrect outputs, corrupted data, and\/or program crashes.  As the size of a programming project increases, the complexity of the logic and large number of paths of execution can help obscure these bugs, causing them to appear only intermittently, making them particularly hard to track down and debug.  Although this list may be mostly review to experienced programmers, the consequences of making one of these errors is also amplified due to the scale and commercial nature of the projects experienced programmers tend to work on.  <\/p>\n<p>These examples were all tested using Visual Studio 2005 Express using the default warning level.  Your results may vary on other compilers.  <strong>I highly recommend all programmers use the highest warning level possible!<\/strong>.  Some items that may not be flagged as a potential problem at the default warning level may be caught at the highest warning level!<\/p>\n<p>(Note: This article is part 1 in an intended series of articles)<\/p>\n<p><br clear=\"all\"><\/p>\n<hr>\n<h3>1) Uninitialized variables<\/h3>\n<p>Uninitialized variables are one of the most devious mistakes commonly made in C++.  Memory allocated to a variable in C++ is not cleared or zeroed upon allocation.  Consequently, an uninitialized variable will have some value, but there is no way to predict what that value will actually be.  Furthermore, the value of the variable may change each time the program is executed.  This can result in intermittent problems, which are particularly hard to track down.  Consider the following snippet:<\/p>\n<pre>\r\nif (bValue)\r\n    \/\/ do A\r\nelse\r\n    \/\/ do B\r\n<\/pre>\n<p>If bValue is uninitialized, it could evaluate to either true or false, and either branch could be taken.<\/p>\n<p>In some basic cases, the compiler will be able to inform you of an uninitialized variable.  The following causes a compiler warning on most compilers:<\/p>\n<pre>\r\nint foo()\r\n{\r\nint nX;\r\nreturn nX;\r\n}\r\n<\/pre>\n<p>However, other simple cases generally do not produce warnings:<\/p>\n<pre>\r\nvoid increment(int &amp;amp;nValue)\r\n{\r\n    ++nValue;\r\n}\r\n\r\nint foo()\r\n{\r\nint nX;\r\nincrement(nX);\r\nreturn nX;\r\n}\r\n<\/pre>\n<p>The above may not produce a warning because the compiler typically doesn&#8217;t keep track of whether increment() assigns a value to nValue.<\/p>\n<p>Uninitialized variables are even more likely to appear in classes, where member declaration are generally separated by from the constructor implementation:<\/p>\n<pre>\r\nclass Foo\r\n{\r\nprivate:\r\n    int m_nValue;\r\n\r\npublic:\r\n    Foo();\r\n    int GetValue() { return m_nValue; }\r\n};\r\n\r\nFoo::Foo()\r\n{\r\n    \/\/ Oops, we forget to initialize m_nValue\r\n}\r\n\r\nint main()\r\n{\r\n    Foo cFoo;\r\n    if (cFoo.GetValue() &amp;gt; 0)\r\n        \/\/ do something\r\n    else\r\n        \/\/ do something else\r\n}\r\n<\/pre>\n<p>Note that m_nValue is never initialized.  Consequently, GetValue() returns a junk value, and either branch may be executed.<\/p>\n<p>New programmers often make the following mistake when declaring multiple variables:<\/p>\n<pre>\r\nint nValue1, nValue2 = 5;\r\n<\/pre>\n<p>The assumption being made here is that 5 is assigned to both nValue1 and nValue2, when in fact the value of 5 is only assigned to nValue2, and nValue1 is uninitialized.<\/p>\n<p>Because uninitialized variables can evaluate to any value, which can cause the program to exhibit different behavior each time it is run, problems caused by uninitialized variables are particularly hard to find.  One run, the program may work fine.  The next time, it may crash.  The after that, it may produce the wrong output.<\/p>\n<p>To compound problems finding uninitialized variables, variable declared when running the program in a debugger are typically zeroed.  This means your program may work fine every time when run in a debugger, but crash intermittently in release mode!  If this is the case, an uninitialized variable is often the root of your problem.<\/p>\n<hr>\n<h3>2) Integer division<\/h3>\n<p>Most binary operators in C++ require both operands to be the same type.  If the operands are of different types, one of the operands is promoted to match the type of the other.<\/p>\n<p>In C++, the division operator can be thought of as two different operators: one that works on integer operands, and one that works on floating point operands.  If the operands are of a floating point type, the division operator will return a floating point value:<\/p>\n<pre>\r\nfloat fX = 7;\r\nfloat fY = 2;\r\nfloat fValue = fX \/ fY; \/\/ fValue = 3.5\r\n<\/pre>\n<p>If the operands are of an integer type, the division operator will drop any faction and return an integer value:<\/p>\n<pre>\r\nint nX = 7;\r\nint nY = 2;\r\nint nValue = nX \/ nY; \/\/ nValue = 3\r\n<\/pre>\n<p>If one operand is an integer, and the other is a floating point value, the integer value will be promoted to a floating point type:<\/p>\n<pre>\r\nfloat fX = 7.0;\r\nint nY = 2;\r\nfloat fValue = fX \/ nY;\r\n\r\n\/\/ nY is promoted to float, floating point division used\r\n\/\/ fValue = 3.5\r\n<\/pre>\n<p>Many new programmers attempt to do the following:<\/p>\n<pre>\r\nint nX = 7;\r\nint nY = 2;\r\nfloat fValue = nX \/ nY;  \/\/ fValue = 3 (not 3.5!)\r\n<\/pre>\n<p>The underlying assumption here is that nX \/ nY will result in a floating point division because the result is being assigned to a floating point value.  However, this is not the case.  nX \/ nY is evaluated first, resulting in an integer value, which is then promoted to a float and assigned to fValue.  However, by that point, the fraction has already been lost.<\/p>\n<p>In order to force two integers to use floating point division, one of the values should be cast to a floating point value:<\/p>\n<pre>\r\nint nX = 7;\r\nint nY = 2;\r\nfloat fValue = static_cast&amp;lt;float&amp;gt;(nX) \/ nY; \/\/ fValue = 3.5\r\n<\/pre>\n<p>Because nX is being explicitly cast to a float, nY will be implicitly promoted to a float, which will cause the division operator to perform floating point division, resulting in a value of 3.5.<\/p>\n<p>It is often hard to tell at a glance whether a given division operation is performing integer or floating point division:<\/p>\n<pre>\r\nz = x \/ y; \/\/ is this integer or floating point division?\r\n<\/pre>\n<p>However, using Hungarian Notation can help disambiguate the case and help prevent mistakes:<\/p>\n<pre>\r\nint nZ = nX \/ nY; \/\/ integer division\r\ndouble dZ = dX \/ dY; \/\/ floating point division\r\n<\/pre>\n<p>One other interesting issue with integer division is that C++ does not define how to truncate the result when one operand is negative.  Consequently, the compiler is free to truncate up or down!  For example, -5 \/ 2 can evaluate to either -3 or -2, depending on whether the compiler rounds down or rounds toward 0.  Most modern compilers round towards 0.<\/p>\n<hr>\n<h3>3) = vs ==<\/h3>\n<p>This one is an oldie but a goodie.  Many beginning C++ programmers confuse the meaning of the assignment operator (=) with the equality operator (==).  But even programmers who know the difference can make a typo that will have unintended results:<\/p>\n<pre>\r\n\/\/ if nValue is 0, return 1, otherwise return nValue\r\nint foo(int nValue)\r\n{\r\n    if (nValue = 0) \/\/ TYPO!\r\n        return 1;\r\n    else\r\n        return nValue;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &amp;lt;&amp;lt; foo(0) &amp;lt;&amp;lt; std::endl;\r\n    std::cout &amp;lt;&amp;lt; foo(1) &amp;lt;&amp;lt; std::endl;\r\n    std::cout &amp;lt;&amp;lt; foo(2) &amp;lt;&amp;lt; std::endl;\r\n\r\n    return 0;\r\n}\r\n<\/pre>\n<p>Function foo() is intended to return 1 if nValue is 0, otherwise return nValue.  But due to inadvertently using the assignment operator instead of the equality operator, the program produces an unexpected result:<\/p>\n<pre>\r\n0\r\n0\r\n0\r\n<\/pre>\n<p>When the <em>if statement<\/em> in foo() is evaluated, nValue is assigned the value of 0.  <code>if (nValue = 0)<\/code> evaluates the same way that <code>nValue = 0; if (nValue)<\/code> evaluates.  Consequently, the if condition is false, which causes the else statement to return nValue, which was just assigned the value of 0!<\/p>\n<p>Consequently, this function always returns 0.<\/p>\n<p>Running a modern compiler at the highest warning level will cause it to issue a warning when an assignment is used in a conditional statement, or a note that the statement does nothing when an equality test is used instead of an assignment outside of a conditional.  This is one issue that is essentially fixable -- if you use the higher warning levels.<\/p>\n<hr>\n<h3>4) Mixing signed and unsigned values<\/h3>\n<p>As mentioned in the section on integer division, most binary operators in C++ require both operands to be the same type.  If the operands are of different types, one of the operands is promoted to match the type of the other.<\/p>\n<p>This can lead to some very unexpected results when mixing signed and unsigned values!  Consider the following case:<\/p>\n<pre>\r\ncout &amp;lt;&amp;lt; 10 - 15u; \/\/ 15u is unsigned\r\n<\/pre>\n<p>One would expect the answer to be -5.  However, because 10 is a signed integer and 15 is an unsigned integer, the type promotion rules come into effect here.  The hierarchy used for type promotion in C++ looks like this:<\/p>\n<p>long double (highest)<br \/>\ndouble<br \/>\nfloat<br \/>\nunsigned long int<br \/>\nlong int<br \/>\nunsigned int<br \/>\nint (lowest)<\/p>\n<p>Because the int operand is considered lower than the unsigned int operand, the int is promoted to an unsigned int.  Fortunately, 10 is already a positive number, so the promotion does not cause our number to be interpreted any differently.<\/p>\n<p>Thus, we effectively have:<\/p>\n<pre>\r\ncout &amp;lt;&amp;lt; 10u - 15u\r\n<\/pre>\n<p>Here&#8217;s where the tricky part happens.  Because both variables are unsigned integers, the result of the operation is also an unsigned integer!  10u - 15u = -5u.  But unsigned variables can not hold negative numbers, and thus the -5 is interpreted as 4,294,967,291 (assuming 32 bit integers).<\/p>\n<p>Consequently, the following program:<\/p>\n<pre>\r\ncout &amp;lt;&amp;lt; 10 - 15u; \/\/ 15u is unsigned\r\n<\/pre>\n<p>prints 4,294,967,291, not -5.<\/p>\n<p>This situation can come up in more obscure forms:<\/p>\n<pre>\r\nint nX;\r\nunsigned int nY;\r\n\r\nif (nX - nY &amp;lt; 0)\r\n    \/\/ do something\r\n<\/pre>\n<p>Due to the type conversion, this if statement will always evaluate to false, which is clearly not what the programmer intends!<\/p>\n<hr>\n<h3>5) delete vs. delete[]<\/h3>\n<p>Many C++ programmers forget that there are actually two forms of both the new and delete operators: a scalar version, and an array version.<\/p>\n<p>Operator new is used to allocate scalar (non-array) data on the heap.  If the object being allocated is a class type, the object&#8217;s constructor is called.<\/p>\n<pre>\r\nFoo *pScalar = new Foo;\r\n<\/pre>\n<p>The delete operator is used to destroy a scalar object that has been allocated using the new operator.  If the object being destroyed is a class type, the object&#8217;s destructor is called.<\/p>\n<pre>\r\ndelete pScalar;\r\n<\/pre>\n<p>Now consider the following snippet:<\/p>\n<pre>\r\nFoo *pArray = new Foo[10];\r\n<\/pre>\n<p>This snippet allocates an array of 10 Foo.  Because the subscript [10] is placed after the int type specifier, many C++ programmers do not realize that operator new[] is being called to do the array allocation instead of operator new.  Operator new[] ensures that the constructor is called for each object being constructed.<\/p>\n<p>Conversely, to delete an array, the delete[] operator should be used:<\/p>\n<pre>\r\ndelete[] pArray;\r\n<\/pre>\n<p>This ensures that the destructor for each object in the array is called.<\/p>\n<p>If the delete operator is used on an array, only the first object will be destructed, and heap corruption can result!<\/p>\n<hr>\n<h3>6) Side effects in compound expressions or function calls<\/h3>\n<p>A side effect is a result of an operator, expression, statement, or function that persists even after the operator, expression, statement, or function has finished being evaluated.<\/p>\n<p>Side effects can often be useful:<\/p>\n<pre>\r\nx = 5;\r\n<\/pre>\n<p>The assignment operator has the side effect of changing the value of x permanently.  Other C++ operators with useful side effects include *=, \/=, %=, +=, -=, <<=, >>=, &#038;=, |=, ^=, and the infamous ++ and -- operators.<\/p>\n<p>However, there are several places in C++ where the order of operations is undefined, and these can lead to inconsistent behavior.  For example:<\/p>\n<pre>\r\nint multiply(int x, int y)\r\n{\r\n    return x * y;\r\n}\r\n\r\nint main()\r\n{\r\n    int x = 5;\r\n    std::cout &amp;lt;&amp;lt; multiply(x, ++x);\r\n}\r\n<\/pre>\n<p>Because the order of evaluation of the function parameters for multiply() is undefined, this could print 30 or 36, depending on whether x or ++x is evaluated first.<\/p>\n<p>A slightly stranger example involving operators:<\/p>\n<pre>\r\nint foo(int x)\r\n{\r\nreturn x;\r\n}\r\n\r\nint main()\r\n{\r\n    int x = 5;\r\n    std::cout &amp;lt;&amp;lt; foo(x) * foo(++x);\r\n}\r\n<\/pre>\n<p>Because the order of evaluation of the operands of C++ operators is undefined (for most operators -- there are a few exceptions), this could also print 30 or 36, depending on whether the left or right operand is evaluated first.<\/p>\n<p>Also consider the following compound expression:<\/p>\n<pre>\r\nif (x == 1 &amp;amp;&amp;amp; ++y == 2)\r\n    \/\/ do something\r\n<\/pre>\n<p>The intent of the programmer is probably to say &#8220;if x is 1 and the pre-incremented value of y is 2, then do something&#8221;.  However, if x does not equal 1, C++ uses short-circuit evaluation, which means that ++y never gets evaluated! Thus, y will only be incremented if x evaluates to 1, which is probably not what the programmer intended!<\/p>\n<p>A good rule of thumb is to put any operator that causes a side effect in it&#8217;s own statement.<\/p>\n<hr>\n<h3>7) Switch statements without break<\/h3>\n<p>Another classic mistake that new programmers make is forgetting to use break to end a switch block:<\/p>\n<pre>\r\nswitch (nValue)\r\n{\r\n    case 1: eColor = Color::BLUE;\r\n    case 2: eColor = Color::PURPLE;\r\n    case 3: eColor = Color::GREEN;\r\n    default: eColor = Color::RED;\r\n}\r\n<\/pre>\n<p>When the switch expression evaluates to the same value as the case label expression, execution starts at the matching case statement.   Execution then continues until either the end of the switch block is reached, or a return, goto, or break statement is executed.  Any other labels are ignored!<\/p>\n<p>Consider what happens if nValue is 1 in the above program.  Case 1 matches, so eColor is set to Color::BLUE.  Evaluation proceeds to the next statement, which sets eColor to Color::PURPLE.  The next statement sets it to Color::GREEN.  And finally, it gets set to Color::RED.<\/p>\n<p>In fact, this snippet ends up setting eColor to COLOR::RED no matter what the value of nValue is!<\/p>\n<p>The correct way to write the above program is:<\/p>\n<pre>\r\nswitch (nValue)\r\n{\r\n    case 1: eColor = Color::BLUE;  break;\r\n    case 2: eColor = Color::PURPLE;  break;\r\n    case 3: eColor = Color::GREEN;  break;\r\n    default: eColor = Color::RED;  break;\r\n}\r\n<\/pre>\n<p>The break terminates the case statement, thus causing eColor to retain the value that the programmer intended.<\/p>\n<p>Although this is very basic switch\/case logic, it is very easy to miss a break statement and end up with inadvertent fall-through.  <\/p>\n<hr>\n<h3>8) Calling virtual functions in constructors<\/h3>\n<p>Consider the following program:<\/p>\n<pre>\r\nclass Base\r\n{\r\nprivate:\r\n    int m_nID;\r\npublic:\r\n    Base()\r\n    {\r\n        m_nID = ClassID();\r\n    }\r\n\r\n    \/\/ ClassID returns a class-specific ID number\r\n    virtual int ClassID() { return 1; }\r\n\r\n    int GetID() { return m_nID; }\r\n};\r\n\r\nclass Derived: public Base\r\n{\r\npublic:\r\n    Derived()\r\n    {\r\n    }\r\n\r\n    virtual int ClassID() { return 2; }\r\n};\r\n\r\nint main()\r\n{\r\n    Derived cDerived;\r\n    cout &amp;lt;&amp;lt; cDerived.GetID(); \/\/ prints 1, not 2!\r\n    return 0;\r\n}\r\n<\/pre>\n<p>In this program, the programmer has called a virtual function inside the constructor of a base class, expecting it to resolve to Derived::ClassID().  It doesn&#8217;t -- and consequently, the program prints 1 instead of 2.<\/p>\n<p>When an class that has been derived from a base classes is instantiated, the base class object is constructed before the derived class object.  This is done because the derived class members may be dependent upon members of the base class already being initialized.  Consequently, when the base object constructor is being executed, there is no derived object!  It hasn&#8217;t been created yet.  Thus, any call to a virtual function can only resolve to the level of the base class, not the derived class. <\/p>\n<p>As pertains to this example, when the Base portion of cDerived is being constructed, the Derived portion does not exist yet.  Thus, the function call to ClassID() resolves to Base::ClassID() (not Derived::ClassID()), which sets m_nID to 1.<\/p>\n<p>Once the Derived portion of cDerived has been constructed, any calls to ClassID() on this object will resolve to Derived::ClassID() as anticipated.<\/p>\n<p>Note that some other programming languages (such as C# and Java) will resolve virtual function calls to the most derived class even if the derived class has not been initialized yet!  C++ differs in this regard, and does so for the programmer&#8217;s safety.  That is not to say one way is necessarily better than the other, but merely to denote that different languages may have different behaviors.<\/p>\n<hr>\n<h3>Conclusion<\/h3>\n<p>As this is the first article in this series, I thought it appropriate to start with some of the more basic issues that new programmers will encounter.  Future articles in this series will tackle programming mistakes of an increasingly complex nature.  <\/p>\n<p>Regardless of a programmer&#8217;s experience level, mistakes happens, whether through lack of knowledge, a typo, or general carelessness.  Being aware of which issues are <em>most likely<\/em> to cause trouble can help reduce the probability that they <em>will<\/em> cause trouble.  While there is no substitute for experience and knowledge, good unit testing can help catch many of these before they get buried under layers of other code!<\/p>\n<p>Related articles:<\/p>\n<ul>\n<li><a href=\"http:\/\/www.learncpp.com\/general-programming\/six-language-independent-ways-to-write-better-code\/\">Six language-independent ways to write better code<\/a><\/li>\n<\/ul>\n","protected":false},"excerpt":{"rendered":"<p>C++ is a complex language, full of subtle traps for the unwary. There is an almost infinite number of ways to screw things up. Fortunately, modern compilers are pretty good at detecting a large number of these cases and notifying the programmer via compile errors or warnings. Ultimately, any error &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[4],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/89"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=89"}],"version-history":[{"count":5,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/89\/revisions"}],"predecessor-version":[{"id":6694,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/89\/revisions\/6694"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=89"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=89"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=89"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}