{"id":114,"date":"2007-07-19T14:07:35","date_gmt":"2007-07-19T22:07:35","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/613-void-pointers\/"},"modified":"2023-09-29T12:12:21","modified_gmt":"2023-09-29T19:12:21","slug":"void-pointers","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/void-pointers\/","title":{"rendered":"19.5 &#8212; Void pointers"},"content":{"rendered":"<p>The <strong>void pointer<\/strong>, also known as the generic pointer, is a special type of pointer that can be pointed at objects of any data type!  A void pointer is declared like a normal pointer, using the void keyword as the pointer&#8217;s type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void* ptr {}; \/\/ ptr is a void pointer<\/code><\/pre>\n<p>A void pointer can point to objects of any data type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int nValue {};\r\nfloat fValue {};\r\n\r\nstruct Something\r\n{\r\n    int n;\r\n    float f;\r\n};\r\n\r\nSomething sValue {};\r\n\r\nvoid* ptr {};\r\nptr = &amp;nValue; \/\/ valid\r\nptr = &amp;fValue; \/\/ valid\r\nptr = &amp;sValue; \/\/ valid<\/code><\/pre>\n<p>However, because the void pointer does not know what type of object it is pointing to, dereferencing a void pointer is illegal.  Instead, the void pointer must first be cast to another pointer type before the dereference can be performed.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int value{ 5 };\r\nvoid* voidPtr{ &amp;value };\r\n\r\n\/\/ std::cout &lt;&lt; *voidPtr &lt;&lt; '\\n'; \/\/ illegal: dereference of void pointer\r\n\r\nint* intPtr{ static_cast&lt;int*&gt;(voidPtr) }; \/\/ however, if we cast our void pointer to an int pointer...\r\n\r\nstd::cout &lt;&lt; *intPtr &lt;&lt; '\\n'; \/\/ then we can dereference the result<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\n5\r\n<\/pre>\n<p>The next obvious question is: If a void pointer doesn&#8217;t know what it&#8217;s pointing to, how do we know what to cast it to?  Ultimately, that is up to you to keep track of.<\/p>\n<p>Here&#8217;s an example of a void pointer in use:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;cassert&gt;\r\n#include &lt;iostream&gt;\r\n\r\nenum class Type\r\n{\r\n    tInt, \/\/ note: we can't use \"int\" here because it's a keyword, so we'll use \"tInt\" instead\r\n    tFloat,\r\n    tCString\r\n};\r\n\r\nvoid printValue(void* ptr, Type type)\r\n{\r\n    switch (type)\r\n    {\r\n    case Type::tInt:\r\n        std::cout &lt;&lt; *static_cast&lt;int*&gt;(ptr) &lt;&lt; '\\n'; \/\/ cast to int pointer and perform indirection\r\n        break;\r\n    case Type::tFloat:\r\n        std::cout &lt;&lt; *static_cast&lt;float*&gt;(ptr) &lt;&lt; '\\n'; \/\/ cast to float pointer and perform indirection\r\n        break;\r\n    case Type::tCString:\r\n        std::cout &lt;&lt; static_cast&lt;char*&gt;(ptr) &lt;&lt; '\\n'; \/\/ cast to char pointer (no indirection)\r\n        \/\/ std::cout will treat char* as a C-style string\r\n        \/\/ if we were to perform indirection through the result, then we'd just print the single char that ptr is pointing to\r\n        break;\r\n    default:\r\n        std::cerr &lt;&lt; \"printValue(): invalid type provided\\n\"; \r\n        assert(false &amp;&amp; \"type not found\");\r\n        break;\r\n    }\r\n}\r\n\r\nint main()\r\n{\r\n    int nValue{ 5 };\r\n    float fValue{ 7.5f };\r\n    char szValue[]{ \"Mollie\" };\r\n\r\n    printValue(&amp;nValue, Type::tInt);\r\n    printValue(&amp;fValue, Type::tFloat);\r\n    printValue(szValue, Type::tCString);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\r\n5\r\n7.5\r\nMollie\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Void pointer miscellany<\/p>\n<p>Void pointers can be set to a null value:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void* ptr{ nullptr }; \/\/ ptr is a void pointer that is currently a null pointer<\/code><\/pre>\n<p>Because a void pointer does not know what type of object it is pointing to, deleting a void pointer will result in undefined behavior.  If you need to delete a void pointer, <code>static_cast<\/code> it back to the appropriate type first.<\/p>\n<p>It is not possible to do pointer arithmetic on a void pointer.  This is because pointer arithmetic requires the pointer to know what size object it is pointing to, so it can increment or decrement the pointer appropriately.<\/p>\n<p>Note that there is no such thing as a void reference.  This is because a void reference would be of type void &#038;, and would not know what type of value it referenced.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Conclusion<\/p>\n<p>In general, it is a good idea to avoid using void pointers unless absolutely necessary, as they effectively allow you to avoid type checking.  This allows you to inadvertently do things that make no sense, and the compiler won&#8217;t complain about it.  For example, the following would be valid:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">    int nValue{ 5 };\r\n    printValue(&amp;nValue, Type::tCString);<\/code><\/pre>\n<p>But who knows what the result would actually be!<\/p>\n<p>Although the above function seems like a neat way to make a single function handle multiple data types, C++ actually offers a much better way to do the same thing (via function overloading) that retains type checking to help prevent misuse.  Many other places where void pointers would once be used to handle multiple data types are now better done using templates, which also offer strong type checking.<\/p>\n<p>However, very occasionally, you may still find a reasonable use for the void pointer.  Just make sure there isn&#8217;t a better (safer) way to do the same thing using other language mechanisms first!<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>What&#8217;s the difference between a void pointer and a null pointer?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\nA void pointer is a pointer that can point to any type of object, but does not know what type of object it points to.  A void pointer must be explicitly cast into another type of pointer to perform indirection.  A null pointer is a pointer that does not point to an address.  A void pointer can be a null pointer.<\/p>\n<p>Thus, a void pointer refers to the type of the pointer, whereas a null pointer refers to the value (address) of the pointer.\n<\/p><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-pointers\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">20.1<\/span>Function Pointers\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pointers-to-pointers\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">19.4<\/span>Pointers to pointers and dynamic multidimensional arrays\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>The void pointer, also known as the generic pointer, is a special type of pointer that can be pointed at objects of any data type! A void pointer is declared like a normal pointer, using the void keyword as the pointer&#8217;s type: void* ptr {}; \/\/ ptr is a void &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/114"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=114"}],"version-history":[{"count":32,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/114\/revisions"}],"predecessor-version":[{"id":15813,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/114\/revisions\/15813"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=114"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=114"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=114"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}