{"id":128,"date":"2007-09-05T15:10:27","date_gmt":"2007-09-05T23:10:27","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/85-constructors\/"},"modified":"2024-12-29T23:43:24","modified_gmt":"2024-12-30T07:43:24","slug":"introduction-to-constructors","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-constructors\/","title":{"rendered":"14.9 &#8212; Introduction to constructors"},"content":{"rendered":"<p>When a class type is an aggregate, we can use aggregate initialization to initialize the class type directly:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">struct Foo \/\/ Foo is an aggregate\r\n{\r\n    int x {};\r\n    int y {};\r\n};\r\n\r\nint main()\r\n{\r\n    Foo foo { 6, 7 }; \/\/ uses aggregate initialization\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Aggregate inititalization does memberwise initialization (members are initialized in the order in which they are defined).  So when <code>foo<\/code> is instantiated in the above example, <code>foo.x<\/code> is initialized to <code>6<\/code>, and <code>foo.y<\/code> is initialized to <code>7<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We discuss the definition of an aggregate and aggregate initialization in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/struct-aggregate-initialization\/\">13.8 -- Struct aggregate initialization<\/a>.\n<\/p><\/div>\n<p>However, as soon as we make any member variables private (to hide our data), our class type is no longer an aggregate (because aggregates cannot have private members).  And that means we&#8217;re no longer able to use aggregate initialization:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Foo \/\/ Foo is not an aggregate (has private members)\r\n{\r\n    int m_x {};\r\n    int m_y {};\r\n};\r\n\r\nint main()\r\n{\r\n    Foo foo { 6, 7 }; \/\/ compile error: can not use aggregate initialization\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Not allowing class types with private members to be initialized via aggregate initialization makes sense for a number of reasons:<\/p>\n<ul>\n<li>Aggregate initialization requires knowing about the implementation of the class (since you have to know what the members are, and what order they were defined in), which we&#8217;re intentionally trying to avoid when we hide our data members.\n<\/li>\n<li>If our class had some kind of invariant, we&#8217;d be relying on the user to initialize the class in a way that preserves the invariant.\n<\/li>\n<\/ul>\n<p>So then how do we initialize a class with private member variables?  The error message given by the compiler for the prior example provides a clue: &#8220;error: no matching constructor for initialization of &#8216;Foo'&#8221;<\/p>\n<p>We must need a matching constructor.  But what the heck is that?<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constructors<\/p>\n<p>A <strong>constructor<\/strong> is a special member function that is automatically called after a non-aggregate class type object is created.<\/p>\n<p>When a non-aggregate class type object is defined, the compiler looks to see if it can find an accessible constructor that is a match for the initialization values provided by the caller (if any).<\/p>\n<ul>\n<li>If an accessible matching constructor is found, memory for the object is allocated, and then the constructor function is called.\n<\/li>\n<li>If no accessible matching constructor can be found, a compilation error will be generated.\n<\/li>\n<\/ul>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Many new programmers are confused about whether constructors create the objects or not.  They do not -- the compiler sets up the memory allocation for the object prior to the constructor call.  The constructor is then called on the uninitialized object.<\/p>\n<p>However, if a matching constructor cannot be found for a set of initializers, the compiler will error.  So while constructors don&#8217;t create objects, the lack of a matching constructor will prevent creation of an object.\n<\/p><\/div>\n<p>Beyond determining how an object may be created, constructors generally perform two functions:<\/p>\n<ul>\n<li>They typically perform initialization of any member variables (via a member initialization list)\n<\/li>\n<li>They may perform other setup functions (via statements in the body of the constructor).  This might include things such as error checking the initialization values, opening a file or database, etc&#8230;\n<\/li>\n<\/ul>\n<p>After the constructor finishes executing, we say that the object has been &#8220;constructed&#8221;, and the object should now be in a consistent, usable state.<\/p>\n<p>Note that aggregates are not allowed to have constructors -- so if you add a constructor to an aggregate, it is no longer an aggregate.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Naming constructors<\/p>\n<p>Unlike normal member functions, constructors have specific rules for how they must be named:<\/p>\n<ul>\n<li>Constructors must have the same name as the class (with the same capitalization).  For template classes, this name excludes the template parameters.\n<\/li>\n<li>Constructors have no return type (not even <code>void<\/code>).\n<\/li>\n<\/ul>\n<p>Because constructors are typically part of the interface for your class, they are usually public.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">A basic constructor example<\/p>\n<p>Let&#8217;s add a basic constructor to our example above:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Foo\r\n{\r\nprivate:\r\n    int m_x {};\r\n    int m_y {};\r\n\r\npublic:\r\n    Foo(int x, int y) \/\/ here's our constructor function that takes two initializers\r\n    {\r\n        std::cout &lt;&lt; \"Foo(\" &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; \") constructed\\n\";\r\n    }\r\n\r\n    void print() const\r\n    {\r\n        std::cout &lt;&lt; \"Foo(\" &lt;&lt; m_x &lt;&lt; \", \" &lt;&lt; m_y &lt;&lt; \")\\n\";\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Foo foo{ 6, 7 }; \/\/ calls Foo(int, int) constructor\r\n    foo.print();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program will now compile and produce the result:<\/p>\n<pre>\nFoo(6, 7) constructed\r\nFoo(0, 0)\r\n<\/pre>\n<p>When the compiler sees the definition <code>Foo foo{ 6, 7 }<\/code>, it looks for a matching <code>Foo<\/code> constructor that will accept two <code>int<\/code> arguments.  <code>Foo(int, int)<\/code> is a match, so the compiler will allow the definition.<\/p>\n<p>At runtime, when <code>foo<\/code> is instantiated, memory for <code>foo<\/code> is allocated, and then the <code>Foo(int, int)<\/code> constructor is called with parameter <code>x<\/code> initialized to <code>6<\/code> and parameter <code>y<\/code> initialized to <code>7<\/code>.  The body of the constructor function then executes and prints <code>Foo(6, 7) constructed<\/code>.<\/p>\n<p>When we call the <code>print()<\/code> member function, you&#8217;ll note that members <code>m_x<\/code> and <code>m_y<\/code> have value 0.  This is because although our <code>Foo(int, int)<\/code> constructor function was called, it did not actually initialize the members.  We&#8217;ll show how to do that in the next lesson.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We discuss the differences between using copy, direct, and list initialization to initialize objects with a constructor in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-initialization-and-copy-elision\/\">14.15 -- Class initialization and copy elision<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constructor implicit conversion of arguments<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/implicit-type-conversion\/\">10.1 -- Implicit type conversion<\/a>, we noted that the compiler will perform implicit conversion of arguments in a function call (if needed) in order to match a function definition where the parameters are a different type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">void foo(int, int)\r\n{\r\n}\r\n\r\nint main()\r\n{\r\n    foo('a', true); \/\/ will match foo(int, int)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This is no different for constructors: the <code>Foo(int, int)<\/code> constructor will match any call whose arguments are implicitly convertible to <code>int<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Foo\r\n{\r\npublic:\r\n    Foo(int x, int y)\r\n    {\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    Foo foo{ 'a', true }; \/\/ will match Foo(int, int) constructor\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constructors should not be const<\/p>\n<p>A constructor needs to be able to initialize the object being constructed -- therefore, a constructor must not be const.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Something\r\n{\r\nprivate:\r\n    int m_x{};\r\n\r\npublic:\r\n    Something() \/\/ constructors must be non-const\r\n    {\r\n        m_x = 5; \/\/ okay to modify members in non-const constructor\r\n    }\r\n\r\n    int getX() const { return m_x; } \/\/ const\r\n};\r\n\r\nint main()\r\n{\r\n    const Something s{}; \/\/ const object, implicitly invokes (non-const) constructor\r\n\r\n    std::cout &lt;&lt; s.getX(); \/\/ prints 5\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>Normally a non-const member function can&#8217;t be invoked on a const object.  However, the C++ standard explicitly states (per <a href=\"https:\/\/eel.is\/c++draft\/class.ctor.general#5\">class.ctor.general#5<\/a>) that const doesn&#8217;t apply to an object under construction, and only comes into effect after the constructor ends.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constructors vs setters<\/p>\n<p>Constructors are designed to initialize an entire object at the point of instantiation.  Setters are designed to assign a value to a single member of an existing object.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constructor-member-initializer-lists\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.10<\/span>Constructor member initializer lists\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/the-benefits-of-data-hiding-encapsulation\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">14.8<\/span>The benefits of data hiding (encapsulation)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>When a class type is an aggregate, we can use aggregate initialization to initialize the class type directly: struct Foo \/\/ Foo is an aggregate { int x {}; int y {}; }; int main() { Foo foo { 6, 7 }; \/\/ uses aggregate initialization return 0; } Aggregate &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/128"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=128"}],"version-history":[{"count":101,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/128\/revisions"}],"predecessor-version":[{"id":18045,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/128\/revisions\/18045"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=128"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=128"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=128"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}