{"id":5150,"date":"2016-12-05T23:15:11","date_gmt":"2016-12-06T07:15:11","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=5150"},"modified":"2024-03-29T10:09:26","modified_gmt":"2024-03-29T17:09:26","slug":"partial-template-specialization-for-pointers","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/partial-template-specialization-for-pointers\/","title":{"rendered":"26.6 &#8212; Partial template specialization for pointers"},"content":{"rendered":"<p>In previous lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-template-specialization\/\">26.4 -- Class template specialization<\/a>, we took a look at a simple templated <code>Storage<\/code> class, along with a specialization for type <code>double<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nclass Storage\r\n{\r\nprivate:\r\n    T m_value {};\r\npublic:\r\n    Storage(T value)\r\n      : m_value { value }\r\n    {\r\n    }\r\n\r\n    void print()\r\n    {\r\n        std::cout &lt;&lt; m_value &lt;&lt; '\\n';\r\n    }\r\n};\r\n\r\ntemplate&lt;&gt;\r\nvoid Storage&lt;double&gt;::print() \/\/ fully specialized for type double\r\n{\r\n    std::cout &lt;&lt; std::scientific &lt;&lt; m_value &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    \/\/ Define some storage units\r\n    Storage i { 5 };\r\n    Storage d { 6.7 }; \/\/ will cause Storage&lt;double&gt; to be implicitly instantiated\r\n\r\n    \/\/ Print out some values\r\n    i.print(); \/\/ calls Storage&lt;int&gt;::print (instantiated from Storage&lt;T&gt;)\r\n    d.print(); \/\/ calls Storage&lt;double&gt;::print (called from explicit specialization of Storage&lt;double&gt;::print())\r\n}<\/code><\/pre>\n<p>However, as simple as this class is, it has a hidden flaw: it compiles but malfunctions when <code>T<\/code> is a pointer type.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    double d { 1.2 };\r\n    double *ptr { &amp;d };\r\n\r\n    Storage s { ptr };\r\n    s.print();\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>On the authors machine, this produced the result:<\/p>\n<pre>\n0x7ffe164e0f50\r\n<\/pre>\n<p>What happened?  Because <code>ptr<\/code> is a <code>double*<\/code>, <code>s<\/code> has type <code>Storage&lt;double*&gt;<\/code>, which means <code>m_value<\/code> has type <code>double*<\/code>.  When the constructor is invoked, <code>m_value<\/code> receives a copy of the address that <code>ptr<\/code> is holding, and it is this address that is printed when the <code>print()<\/code> member function is called.<\/p>\n<p>So how do we fix this?<\/p>\n<p>One option would be to add a full specialization for type <code>double*<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nclass Storage\r\n{\r\nprivate:\r\n    T m_value {};\r\npublic:\r\n    Storage(T value)\r\n      : m_value { value }\r\n    {\r\n    }\r\n\r\n    void print()\r\n    {\r\n        std::cout &lt;&lt; m_value &lt;&lt; '\\n';\r\n    }\r\n};\r\n\r\ntemplate&lt;&gt;\r\nvoid Storage&lt;double*&gt;::print() \/\/ fully specialized for type double*\r\n{\r\n    if (m_value)\r\n        std::cout &lt;&lt; std::scientific &lt;&lt; *m_value &lt;&lt; '\\n';\r\n}\r\n\r\ntemplate&lt;&gt;\r\nvoid Storage&lt;double&gt;::print() \/\/ fully specialized for type double (for comparison, not used)\r\n{\r\n    std::cout &lt;&lt; std::scientific &lt;&lt; m_value &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    double d { 1.2 };\r\n    double *ptr { &amp;d };\r\n\r\n    Storage s { ptr };\r\n    s.print(); \/\/ calls Storage&lt;double*&gt;::print()\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>This now prints the correct result:<\/p>\n<pre>\n1.200000e+00\r\n<\/pre>\n<p>But this only solves the problem when <code>T<\/code> is of type <code>double*<\/code>.  What about when <code>T<\/code> is <code>int*<\/code>, or <code>char*<\/code>, or any other pointer type?<\/p>\n<p>We really don&#8217;t want to have to create a full specialization for every pointer type.  And in fact, it&#8217;s not even possible, because the user can always pass in a pointer to a program-defined type.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Partial template specialization for pointers<\/p>\n<p>You might think to to try creating a template function overloaded on type <code>T*<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ doesn't work\r\ntemplate&lt;typename T&gt;\r\nvoid Storage&lt;T*&gt;::print()\r\n{\r\n    if (m_value)\r\n        std::cout &lt;&lt; std::scientific &lt;&lt; *m_value &lt;&lt; '\\n';\r\n}<\/code><\/pre>\n<p>Such a function is a partially specialized template function because it&#8217;s restricting what type <code>T<\/code> can be (to a pointer type), but <code>T<\/code> is still a type template parameter.<\/p>\n<p>Unfortunately, this doesn&#8217;t work for a simple reason: as of the time of writing (C++23) functions cannot be partially specialized.  As we noted in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/partial-template-specialization\/\">26.5 -- Partial template specialization<\/a>, only classes can be partially specialized.<\/p>\n<p>So let&#8217;s partially specialize the <code>Storage<\/code> class instead:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nclass Storage \/\/ This is our primary template class (same as previous)\r\n{\r\nprivate:\r\n    T m_value {};\r\npublic:\r\n    Storage(T value)\r\n      : m_value { value }\r\n    {\r\n    }\r\n\r\n    void print()\r\n    {\r\n        std::cout &lt;&lt; m_value &lt;&lt; '\\n';\r\n    }\r\n};\r\n\r\ntemplate &lt;typename T&gt; \/\/ we still have a type template parameter\r\nclass Storage&lt;T*&gt; \/\/ This is partially specialized for T*\r\n{\r\nprivate:\r\n    T* m_value {};\r\npublic:\r\n    Storage(T* value)\r\n      : m_value { value }\r\n    {\r\n    }\r\n\r\n    void print();\r\n};\r\n\r\ntemplate &lt;typename T&gt;\r\nvoid Storage&lt;T*&gt;::print() \/\/ This is a non-specialized function of partially specialized class Storage&lt;T*&gt;\r\n{\r\n    if (m_value)\r\n        std::cout &lt;&lt; std::scientific &lt;&lt; *m_value &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    double d { 1.2 };\r\n    double *ptr { &amp;d };\r\n\r\n    Storage s { ptr }; \/\/ instantiates Storage&lt;double*&gt; from partially specialized class\r\n    s.print(); \/\/ calls Storage&lt;double*&gt;::print()\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>We&#8217;ve defined <code>Storage&lt;T*&gt;::print()<\/code> outside the class just to show how it&#8217;s done, and to show that the definition is identical to the partially specialized function <code>Storage&lt;T*&gt;::print()<\/code> that did not work above.  However, now that <code>Storage&lt;T*&gt;<\/code> is a partially specialized class, <code>Storage&lt;T*&gt;::print()<\/code> is no longer partially specialized -- it is a non-specialized function, which is why it is allowed.<\/p>\n<p>It&#8217;s worth noting that our type template parameter is defined as <code>T<\/code>, not <code>T*<\/code>.  This means that <code>T<\/code> will be deduced as the non-pointer type, so we have to use <code>T*<\/code> anywhere we want a pointer to <code>T<\/code>.  It&#8217;s also worth a reminder that the partial specialization <code>Storage&lt;T*&gt;<\/code> needs to be defined after the primary template class <code>Storage&lt;T&gt;<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Ownership and lifetime issues<\/p>\n<p>The above partially specialized class <code>Storage&lt;T*&gt;<\/code> has another potential issue.  Because <code>m_value<\/code> is a <code>T*<\/code>, it is a pointer to the object that is passed in.  If that object is then destroyed, our <code>Storage&lt;T*&gt;<\/code> will be left dangling.<\/p>\n<p>The core problem is that our implementation of <code>Storage&lt;T&gt;<\/code> has copy semantics (meaning it makes a copy of its initializer) but <code>Storage&lt;T*&gt;<\/code> has reference semantics (meaning it&#8217;s a reference to its initializer).  This inconsistency is a recipe for bugs.<\/p>\n<p>There are a few different ways we can deal with such issues (in order of increasing complexity):<\/p>\n<ol start=\"1\">\n<li>Make it clear really clear that <code>Storage&lt;T*&gt;<\/code> is a view class (with reference semantics), so it&#8217;s on the caller to ensure the object being pointed to stays valid for as long as the <code>Storage&lt;T*&gt;<\/code> does.  Unfortunately, because this partially specialized class must have the same name as a the primary template class, we can&#8217;t give it a name like <code>StorageView<\/code>.  So we&#8217;re restricted to using comments or other things that might be missed.  Not a great option.\n<\/li>\n<li>Prevent use of <code>Storage&lt;T*&gt;<\/code> altogether.  We probably don&#8217;t need <code>Storage&lt;T*&gt;<\/code> to exist, as the caller can always dereference the pointer at the point of instantiation to use <code>Storage&lt;T&gt;<\/code> and make a copy of the value (which is semantically appropriate for a storage class).\n<\/li>\n<\/ol>\n<p>However, while you can delete an overloaded function, C++ (as of C++23) won&#8217;t let you delete a class.  The obvious solution is to partially specialize <code>Storage&lt;T*&gt;<\/code> and then do something to make it not compile (e.g. <code>static_assert<\/code>) when the template is instantiated, this approach has one major downside: <code>std::nullptr_t<\/code> is not a pointer type, so <code>Storage&lt;std::nullptr_t&gt;<\/code> won&#8217;t match <code>Storage&lt;T*&gt;<\/code>!<\/p>\n<p>A better solution is to avoid partial specialization altogether, and use a <code>static_assert<\/code> on our primary template to ensure <code>T<\/code> is a type that we&#8217;re okay with.  Here&#8217;s an example of that approach:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;type_traits&gt; \/\/ for std::is_pointer_v and std::is_null_pointer_v\r\n\r\ntemplate &lt;typename T&gt;\r\nclass Storage\r\n{\r\n    \/\/ Make sure T isn't a pointer or a std::nullptr_t\r\n    static_assert(!std::is_pointer_v&lt;T&gt; &amp;&amp; !std::is_null_pointer_v&lt;T&gt;, \"Storage&lt;T*&gt; and Storage&lt;nullptr&gt; disallowed\");\r\n\r\nprivate:\r\n    T m_value {};\r\n\r\npublic:\r\n    Storage(T value)\r\n      : m_value { value }\r\n    {\r\n    }\r\n\r\n    void print()\r\n    {\r\n        std::cout &lt;&lt; m_value &lt;&lt; '\\n';\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    double d { 1.2 };\r\n\r\n    Storage s1 { d }; \/\/ ok\r\n    s1.print();\r\n\r\n    Storage s2 { &amp;d }; \/\/ static_assert because T is a pointer\r\n    s2.print();\r\n\r\n    Storage s3 { nullptr }; \/\/ static_assert because T is a nullptr\r\n    s3.print();\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<ol start=\"3\">\n<li>Have <code>Storage&lt;T*&gt;<\/code> make a copy of the object on the heap.  If you do all the heap memory management yourself, this requires overloading the constructor, copy constructor, copy assignment, and destructor.  An easier alternative is to just use <code>std::unique_ptr<\/code> (which we cover in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdunique_ptr\/\">22.5 -- std::unique_ptr<\/a>):\n<\/li>\n<\/ol>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;type_traits&gt; \/\/ for std::is_pointer_v and std::is_null_pointer_v\r\n#include &lt;memory&gt;\r\n\r\ntemplate &lt;typename T&gt;\r\nclass Storage\r\n{\r\n    \/\/ Make sure T isn't a pointer or a std::nullptr_t\r\n    static_assert(!std::is_pointer_v&lt;T&gt; &amp;&amp; !std::is_null_pointer_v&lt;T&gt;, \"Storage&lt;T*&gt; and Storage&lt;nullptr&gt; disallowed\");\r\n\r\nprivate:\r\n    T m_value {};\r\n\r\npublic:\r\n    Storage(T value)\r\n      : m_value { value }\r\n    {\r\n    }\r\n\r\n    void print()\r\n    {\r\n        std::cout &lt;&lt; m_value &lt;&lt; '\\n';\r\n    }\r\n};\r\n\r\ntemplate &lt;typename T&gt;\r\nclass Storage&lt;T*&gt;\r\n{\r\nprivate:\r\n    std::unique_ptr&lt;T&gt; m_value {}; \/\/ use std::unique_ptr to automatically deallocate when Storage is destroyed\r\n\r\npublic:\r\n    Storage(T* value)\r\n      : m_value { std::make_unique&lt;T&gt;(value ? *value : 0) } \/\/ or throw exception when !value\r\n    {\r\n    }\r\n\r\n    void print()\r\n    {\r\n        if (m_value)\r\n            std::cout &lt;&lt; *m_value &lt;&lt; '\\n';\r\n    }\r\n};\r\n\r\nint main()\r\n{\r\n    double d { 1.2 };\r\n\r\n    Storage s1 { d }; \/\/ ok\r\n    s1.print();\r\n\r\n    Storage s2 { &amp;d }; \/\/ ok, copies d on heap\r\n    s2.print();\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Using partial template class specialization to create separate pointer and non-pointer implementations of a class is extremely useful when you want a class to handle both differently, but in a way that\u2019s completely transparent to the end-user.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-26-summary-and-quiz\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">26.x<\/span>Chapter 26 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/partial-template-specialization\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">26.5<\/span>Partial template specialization\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In previous lesson , we took a look at a simple templated Storage class, along with a specialization for type double: #include &lt;iostream&gt; template &lt;typename T&gt; class Storage { private: T m_value {}; public: Storage(T value) : m_value { value } { } void print() { std::cout &lt;&lt; m_value &lt;&lt; &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5150"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=5150"}],"version-history":[{"count":28,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5150\/revisions"}],"predecessor-version":[{"id":16861,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/5150\/revisions\/16861"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=5150"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=5150"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=5150"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}