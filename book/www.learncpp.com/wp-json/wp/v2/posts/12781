{"id":12781,"date":"2022-03-28T09:12:47","date_gmt":"2022-03-28T16:12:47","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=12781"},"modified":"2025-02-18T19:40:26","modified_gmt":"2025-02-19T03:40:26","slug":"constexpr-functions","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-functions\/","title":{"rendered":"F.1 &#8212; Constexpr functions"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-variables\/\">5.6 -- Constexpr variables<\/a>, we introduced the <code>constexpr<\/code> keyword, which we used to create compile-time (symbolic) constants.  We also introduced constant expressions, which are expressions that can be evaluated at compile-time rather than runtime.<\/p>\n<p>One challenge with constant expressions is that function call to a normal function are not allowed in constant expressions.  This means we cannot use such function calls anywhere a constant expression is required.<\/p>\n<p>Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    constexpr double radius { 3.0 };\r\n    constexpr double pi { 3.14159265359 };\r\n    constexpr double circumference { 2.0 * radius * pi };\r\n    \r\n    std::cout &lt;&lt; \"Our circle has circumference \" &lt;&lt; circumference &lt;&lt; \"\\n\";\r\n\r\n    return 0;    \r\n}<\/code><\/pre>\n<p>This produces the result:<\/p>\n<pre>\nOur circle has circumference 18.8496\r\n<\/pre>\n<p>Having a complex initializer for <code>circumference<\/code> isn&#8217;t great (and requires us to instantiate two supporting variables, <code>radius<\/code> and <code>pi<\/code>).  So let&#8217;s make it a function instead:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\ndouble calcCircumference(double radius)\r\n{\r\n    constexpr double pi { 3.14159265359 };\r\n    return 2.0 * pi * radius;\r\n}\r\n\r\nint main()\r\n{\r\n    constexpr double circumference { calcCircumference(3.0) }; \/\/ compile error\r\n    \r\n    std::cout &lt;&lt; \"Our circle has circumference \" &lt;&lt; circumference &lt;&lt; \"\\n\";\r\n\r\n    return 0;    \r\n}<\/code><\/pre>\n<p>This code is much cleaner.  It also doesn&#8217;t compile.  Constexpr variable <code>circumference<\/code> requires that its initializer is a constant expression, and the call <code>calcCircumference()<\/code> isn&#8217;t a constant expression.<\/p>\n<p>In this particular case, we could make <code>circumference<\/code> non-constexpr, and the program would compile.  While we&#8217;d lose the benefits of constant expressions, at least the program would run.<\/p>\n<p>However, there are other cases in C++ (which we&#8217;ll introduce in the future) where we do not have alternate options available, and only a constant expression will do.  In those cases, we&#8217;d really like to be able to use functions, but calls to normal functions just won&#8217;t work.  So what are we to do?<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constexpr functions can be used in constant expressions<\/p>\n<p>A <strong>constexpr function<\/strong> is a function that is allowed to be called in a constant expression.<\/p>\n<p>To make a function a constexpr function, we simply use the <code>constexpr<\/code> keyword in front of the function&#8217;s return type.  <\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>The <code>constexpr<\/code> keyword is used to signal to the compiler and other developers that a function can be used in a constant expression.\n<\/div>\n<p>Here&#8217;s the same example as above, but using a constexpr function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nconstexpr double calcCircumference(double radius) \/\/ now a constexpr function\r\n{\r\n    constexpr double pi { 3.14159265359 };\r\n    return 2.0 * pi * radius;\r\n}\r\n\r\nint main()\r\n{\r\n    constexpr double circumference { calcCircumference(3.0) }; \/\/ now compiles\r\n    \r\n    std::cout &lt;&lt; \"Our circle has circumference \" &lt;&lt; circumference &lt;&lt; \"\\n\";\r\n\r\n    return 0;    \r\n}<\/code><\/pre>\n<p>Because <code>calcCircumference()<\/code> is now a constexpr function, it can be used in a constant expression, such as the initializer of <code>circumference<\/code>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constexpr functions can be evaluated at compile time<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constant-expressions\/\">5.5 -- Constant expressions<\/a>, we noted that in contexts that require a constant expression (such as the initialization of a constexpr variable), a constant expression is required to evaluate at compile-time.  If a required constant expression contains a constexpr function call, that constexpr function call must evaluate at compile-time.<\/p>\n<p>In our example above, variable <code>circumference<\/code> is constexpr and thus requires a constant expression initializer.  Since <code>calcCircumference()<\/code> is part of this required constant expression, <code>calcCircumference()<\/code> must be evaluated at compile-time.<\/p>\n<p>When a function call is evaluated at compile-time, the compiler will calculate the return value of the function call at compile-time, and then replace the function call with the return value.<\/p>\n<p>So in our example, the call to <code>calcCircumference(3.0)<\/code> is replaced with the result of the function call, which is <code>18.8496<\/code>.  In other words, the compiler will compile this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nconstexpr double calcCircumference(double radius)\r\n{\r\n    constexpr double pi { 3.14159265359 };\r\n    return 2.0 * pi * radius;\r\n}\r\n\r\nint main()\r\n{\r\n    constexpr double circumference { 18.8496 };\r\n    \r\n    std::cout &lt;&lt; \"Our circle has circumference \" &lt;&lt; circumference &lt;&lt; \"\\n\";\r\n\r\n    return 0;    \r\n}<\/code><\/pre>\n<p>To evaluate at compile-time, two other things must also be true:<\/p>\n<ul>\n<li>The call to the constexpr function must have arguments that are known at compile time (e.g. are constant expressions).\n<\/li>\n<li>All statements and expressions within the constexpr function must be evaluatable at compile-time.\n<\/li>\n<\/ul>\n<p>When a constexpr (or consteval) function is being evaluated at compile-time, any other functions it calls are required to be evaluated at compile-time (otherwise the initial function would not be able to return a result at compile-time).<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>There are some other lesser encountered criteria as well.  These can be found <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/language\/constexpr\">here<\/a>.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Constexpr functions can also be evaluated at runtime<\/p>\n<p>Constexpr functions can also be evaluated at runtime, in which case they will return a non-constexpr result.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nconstexpr int greater(int x, int y)\r\n{\r\n    return (x &gt; y ? x : y);\r\n}\r\n\r\nint main()\r\n{\r\n    int x{ 5 }; \/\/ not constexpr\r\n    int y{ 6 }; \/\/ not constexpr\r\n\r\n    std::cout &lt;&lt; greater(x, y) &lt;&lt; \" is greater!\\n\"; \/\/ will be evaluated at runtime\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In this example, because arguments <code>x<\/code> and <code>y<\/code> are not constant expressions, the function cannot be resolved at compile-time.  However, the function will still be resolved at runtime, returning the expected value as a non-constexpr <code>int<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>When a constexpr function evaluates at runtime, it evaluates just like a normal (non-constexpr) function would.  In other words, the <code>constexpr<\/code> has no effect in this case.\n<\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Allowing functions with a constexpr return type to be evaluated at either compile-time or runtime was allowed so that a single function can serve both cases.<\/p>\n<p>Otherwise, you&#8217;d need to have separate functions (a function with a constexpr return type, and a function with a non-constexpr return type).  This would not only require duplicate code, the two functions would also need to have different names!\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Remind me again why we care whether our functions execute at compile-time?<\/p>\n<p>Now would be a great time to review the benefits that compile-time programming techniques can provide: <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constant-expressions\/#compiletimebenefits\">5.5 -- Constant expressions<\/a>.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/constexpr-functions-part-2\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">F.2<\/span>Constexpr functions (part 2)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-11-summary-and-quiz\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">11.x<\/span>Chapter 11 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we introduced the constexpr keyword, which we used to create compile-time (symbolic) constants. We also introduced constant expressions, which are expressions that can be evaluated at compile-time rather than runtime. One challenge with constant expressions is that function call to a normal function are not allowed in &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12781"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=12781"}],"version-history":[{"count":63,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12781\/revisions"}],"predecessor-version":[{"id":18209,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12781\/revisions\/18209"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=12781"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=12781"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=12781"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}