{"id":28,"date":"2007-06-02T15:01:37","date_gmt":"2007-06-02T23:01:37","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=28"},"modified":"2025-01-03T16:25:15","modified_gmt":"2025-01-04T00:25:15","slug":"forward-declarations","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/forward-declarations\/","title":{"rendered":"2.7 &#8212; Forward declarations and definitions"},"content":{"rendered":"<p>Take a look at this seemingly innocent sample program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"The sum of 3 and 4 is: \" &lt;&lt; add(3, 4) &lt;&lt; '\\n';\r\n    return 0;\r\n}\r\n\r\nint add(int x, int y)\r\n{\r\n    return x + y;\r\n}<\/code><\/pre>\n<p>You would expect this program to produce the result:<\/p>\n<pre>\r\nThe sum of 3 and 4 is: 7\r\n<\/pre>\n<p>But in fact, it doesn&#8217;t compile at all!  Visual Studio produces the following compile error:<\/p>\n<pre>\r\nadd.cpp(5) : error C3861: 'add': identifier not found\r\n<\/pre>\n<p>The reason this program doesn&#8217;t compile is because the compiler compiles the contents of code files sequentially.  When the compiler reaches the function call <em>add()<\/em> on line 5 of <em>main<\/em>, it doesn&#8217;t know what <em>add<\/em> is, because we haven&#8217;t defined <em>add<\/em> until line 9!  That produces the error, <em>identifier not found<\/em>.<\/p>\n<p>Older versions of Visual Studio would produce an additional error:<\/p>\n<pre>\r\nadd.cpp(9) : error C2365: 'add'; : redefinition; previous definition was 'formerly unknown identifier'\r\n<\/pre>\n<p>This is somewhat misleading, given that <em>add<\/em> wasn&#8217;t ever defined in the first place.  Despite this, it&#8217;s useful to generally note that it is fairly common for a single error to produce many redundant or related errors or warnings.  It can sometimes be hard to tell whether any error or warning beyond the first is a consequence of the first issue, or whether it is an independent issue that needs to be resolved separately.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>When addressing compilation errors or warnings in your programs, resolve the first issue listed and then compile again.\n<\/p><\/div>\n<p>To fix this problem, we need to address the fact that the compiler doesn&#8217;t know what add is.  There are two common ways to address the issue.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Option 1: Reorder the function definitions<\/p>\n<p>One way to address the issue is to reorder the function definitions so <em>add<\/em> is defined before <em>main<\/em>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y)\r\n{\r\n    return x + y;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"The sum of 3 and 4 is: \" &lt;&lt; add(3, 4) &lt;&lt; '\\n';\r\n    return 0;\r\n}<\/code><\/pre>\n<p>That way, by the time <em>main<\/em> calls <em>add<\/em>, the compiler will already know what <em>add<\/em> is.  Because this is such a simple program, this change is relatively easy to do.  However, in a larger program, it can be tedious trying to figure out which functions call which other functions (and in what order) so they can be declared sequentially.<\/p>\n<p>Furthermore, this option is not always possible.  Let&#8217;s say we&#8217;re writing a program that has two functions <em>A<\/em> and <em>B<\/em>.  If function <em>A<\/em> calls function <em>B<\/em>, and function <em>B<\/em> calls function <em>A<\/em>, then there&#8217;s no way to order the functions in a way that will make the compiler happy.  If you define <em>A<\/em> first, the compiler will complain it doesn&#8217;t know what <em>B<\/em> is.  If you define <em>B<\/em> first, the compiler will complain that it doesn&#8217;t know what <em>A<\/em> is.  <\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Option 2: Use a forward declaration<\/p>\n<p>We can also fix this by using a forward declaration.<\/p>\n<p>A <strong>forward declaration<\/strong> allows us to tell the compiler about the existence of an identifier <em>before<\/em> actually defining the identifier.<\/p>\n<p>In the case of functions, this allows us to tell the compiler about the existence of a function before we define the function&#8217;s body.  This way, when the compiler encounters a call to the function, it&#8217;ll understand that we&#8217;re making a function call, and can check to ensure we&#8217;re calling the function correctly, even if it doesn&#8217;t yet know how or where the function is defined.<\/p>\n<p>To write a forward declaration for a function, we use a <strong>function declaration<\/strong> statement (also called a <strong>function prototype<\/strong>).  The function declaration consists of the function&#8217;s return type, name, and parameter types, terminated with a semicolon.  The names of the parameters can be optionally included.  The function body is not included in the declaration.<\/p>\n<p>Here&#8217;s a function declaration for the <em>add<\/em> function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int add(int x, int y); \/\/ function declaration includes return type, name, parameters, and semicolon.  No function body!<\/code><\/pre>\n<p>Now, here&#8217;s our original program that didn&#8217;t compile, using a function declaration as a forward declaration for function <em>add<\/em>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y); \/\/ forward declaration of add() (using a function declaration)\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"The sum of 3 and 4 is: \" &lt;&lt; add(3, 4) &lt;&lt; '\\n'; \/\/ this works because we forward declared add() above\r\n    return 0;\r\n}\r\n\r\nint add(int x, int y) \/\/ even though the body of add() isn't defined until here\r\n{\r\n    return x + y;\r\n}<\/code><\/pre>\n<p>Now when the compiler reaches the call to <em>add<\/em> in main, it will know what <em>add<\/em> looks like (a function that takes two integer parameters and returns an integer), and it won&#8217;t complain.<\/p>\n<p>It is worth noting that function declarations do not need to specify the names of the parameters (as they are not considered to be part of the function declaration).  In the above code, you can also forward declare your function like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int add(int, int); \/\/ valid function declaration<\/code><\/pre>\n<p>However, we prefer to name our parameters (using the same names as the actual function).  This allows you to understand what the function parameters are just by looking at the declaration.  For example, if you were to see the declaration <code>void doSomething(int, int, int)<\/code>, you may think you remember what each of the parameters represent, but you may also get it wrong.<\/p>\n<p>Also many automated documentation generation tools will generate documentation from the content of header files, which is where declarations are often placed.  We discuss header files and declarations in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/header-files\/\">2.11 -- Header files<\/a>.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Keep the parameter names in your function declarations.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>You can easily create function declarations by copy\/pasting your function&#8217;s header and adding a semicolon.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Why forward declarations?<\/p>\n<p>You may be wondering why we would use a forward declaration if we could just reorder the functions to make our programs work.  <\/p>\n<p>Most often, forward declarations are used to tell the compiler about the existence of some function that has been defined in a different code file.  Reordering isn&#8217;t possible in this scenario because the caller and the callee are in completely different files!  We&#8217;ll discuss this in more detail in the next lesson (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/programs-with-multiple-code-files\/\">2.8 -- Programs with multiple code files<\/a>).<\/p>\n<p>Forward declarations can also be used to define our functions in an order-agnostic manner.  This allows us to define functions in whatever order maximizes organization (e.g. by clustering related functions together) or reader understanding.<\/p>\n<p>Less often, there are times when we have two functions that call each other.  Reordering isn&#8217;t possible in this case either, as there is no way to reorder the functions such that each is before the other.  Forward declarations give us a way to resolve such circular dependencies.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Forgetting the function body<\/p>\n<p>New programmers often wonder what happens if they forward declare a function but do not define it.<\/p>\n<p>The answer is: it depends.  If a forward declaration is made, but the function is never called, the program will compile and run fine.  However, if a forward declaration is made and the function is called, but the program never defines the function, the program will compile okay, but the linker will complain that it can&#8217;t resolve the function call.<\/p>\n<p>Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y); \/\/ forward declaration of add()\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"The sum of 3 and 4 is: \" &lt;&lt; add(3, 4) &lt;&lt; '\\n';\r\n    return 0;\r\n}\r\n\r\n\/\/ note: No definition for function add<\/code><\/pre>\n<p>In this program, we forward declare <em>add<\/em>, and we call <em>add<\/em>, but we never define <em>add<\/em> anywhere.  When we try and compile this program, Visual Studio produces the following message:<\/p>\n<pre>\r\nCompiling...\r\nadd.cpp\r\nLinking...\r\nadd.obj : error LNK2001: unresolved external symbol \"int __cdecl add(int,int)\" (?add@@YAHHH@Z)\r\nadd.exe : fatal error LNK1120: 1 unresolved externals\r\n<\/pre>\n<p>As you can see, the program compiled okay, but it failed at the link stage because <em>int add(int, int)<\/em> was never defined.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Other types of forward declarations<\/p>\n<p>Forward declarations are most often used with functions.  However, forward declarations can also be used with other identifiers in C++, such as variables and types.  Variables and types have a different syntax for forward declaration, so we&#8217;ll cover these in future lessons.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Declarations vs. definitions<\/p>\n<p>In C++, you&#8217;ll frequently hear the words &#8220;declaration&#8221; and &#8220;definition&#8221; used, and often interchangeably.  What do they mean?  You now have enough fundamental knowledge to understand the difference between the two.<\/p>\n<p>A <strong>declaration<\/strong> tells the <em>compiler<\/em> about the <em>existence<\/em> of an identifier and its associated type information.  Here are some examples of declarations:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int add(int x, int y); \/\/ tells the compiler about a function named \"add\" that takes two int parameters and returns an int.  No body!\r\nint x;                 \/\/ tells the compiler about an integer variable named x<\/code><\/pre>\n<p>A <strong>definition<\/strong> is a declaration that actually implements (for functions and types) or instantiates (for variables) the identifier.<\/p>\n<p>Here are some examples of definitions:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ because this function has a body, it is an implementation of function add()\r\nint add(int x, int y)\r\n{\r\n    int z{ x + y };   \/\/ instantiates variable z\r\n\r\n    return z;\r\n}\r\n\r\nint x;                \/\/ instantiates variable x<\/code><\/pre>\n<p>In C++, all definitions are declarations.  Therefore <code>int x;<\/code> is both a definition and a declaration.<\/p>\n<p>Conversely, not all declarations are definitions.  Declarations that aren&#8217;t definitions are called <strong>pure declarations<\/strong>.  Types of pure declarations include forward declarations for function, variables, and types.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Nomenclature<\/p>\n<p>In common language, the term &#8220;declaration&#8221; is typically used to mean &#8220;a pure declaration&#8221;, and &#8220;definition&#8221; is used to mean &#8220;a definition that also serves as a declaration&#8221;.  Thus, we&#8217;d typically call <code>int x;<\/code> a definition, even though it is both a definition and a declaration.\n<\/div>\n<p>When the compiler encounters an identifier, it will check to ensure use of that identifier is valid (e.g. that the identifier is in scope, that it is used in a syntactically valid manner, etc&#8230;).<\/p>\n<p>In most cases, a declaration is sufficient to allow the compiler to ensure an identifier is being used properly.  For example, when the compiler encounters function call <code>add(5, 6)<\/code>, if it has already seen the declaration for <code>add(int, int)<\/code>, then it can validate that <code>add<\/code> is actually a function that takes two <code>int<\/code> parameters.  It does not need to have actually seen the definition for function <code>add<\/code> (which may exist in some other file).<\/p>\n<p>However, there are a few cases where the compiler must be able to see a full definition in order to use an identifier (such as for template definitions and type definitions, both of which we will discuss in future lessons).<\/p>\n<p>Here&#8217;s a summary table:<\/p>\n<div class=\"cpp-table-wrapper\">\n<table class=\"cpp-table\">\n<tr>\n<th> Term <\/th>\n<th> Technical Meaning <\/th>\n<th> Examples <\/th>\n<\/tr>\n<tr>\n<td> Declaration <\/td>\n<td> Tells compiler about an identifier and its associated type information. <\/td>\n<td> void foo(); \/\/ function forward declaration (no body)<br \/>void goo() {}; \/\/ function definition (has body)<br \/>int x; \/\/ variable definition <\/td>\n<\/tr>\n<tr>\n<td> Definition <\/td>\n<td> Implements a function or instantiates a variable.<br \/>Definitions are also declarations. <\/td>\n<td> void foo() { } \/\/ function definition (has body)<br \/>int x; \/\/ variable definition <\/td>\n<\/tr>\n<tr>\n<td> Pure declaration <\/td>\n<td> A declaration that isn&#8217;t a definition. <\/td>\n<td> void foo(); \/\/ function forward declaration (no body) <\/td>\n<\/tr>\n<tr>\n<td> Initialization <\/td>\n<td> Provides an initial value for a defined object. <\/td>\n<td> int x { 2 }; \/\/ x is initialized to value 2 <\/td>\n<\/tr>\n<\/table>\n<\/div>\n<p>The term &#8220;declaration&#8221; is commonly used to mean &#8220;pure declaration&#8221;, and the term &#8220;definition&#8221; used for anything that is both a definition and a declaration.  We use this common nomenclature in the example column comments.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\"><a name=\"ODR\"><\/a>The one definition rule (ODR) <a href=\"#ODR\"><i class=\"fa fa-link\" style=\"font-size: 0.8em;\"><\/i><\/a><\/p>\n<p>The <strong>one definition rule<\/strong> (or ODR for short) is a well-known rule in C++.  The ODR has three parts:<\/p>\n<ol start=\"1\">\n<li>Within a <em>file<\/em>, each function, variable, type, or template in a given scope can only have one definition.  Definitions occurring in different scopes (e.g. local variables defined inside different functions, or functions defined inside different namespaces) do not violate this rule.\n<\/li>\n<li>Within a <em>program<\/em>, each function or variable in a given scope can only have one definition.  This rule exists because programs can have more than one file (we&#8217;ll cover this in the next lesson).  Functions and variables not visible to the linker are excluded from this rule (discussed further in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/internal-linkage\/\">7.6 -- Internal linkage<\/a>).\n<\/li>\n<li>Types, templates, inline functions, and inline variables are allowed to have duplicate definitions in different files, so long as each definition is identical.  We haven&#8217;t covered what most of these things are yet, so don&#8217;t worry about this for now -- we&#8217;ll bring it back up when it&#8217;s relevant.\n<\/li>\n<\/ol>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We discuss ODR part 3 exemptions further in the following lessons:<\/p>\n<ul>\n<li>Types (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-program-defined-user-defined-types\/\">13.1 -- Introduction to program-defined (user-defined) types<\/a>).\n<\/li>\n<li>Function templates (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-templates\/\">11.6 -- Function templates<\/a> and <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/function-template-instantiation\/\">11.7 -- Function template instantiation<\/a>).\n<\/li>\n<li>Inline functions and variables (<a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/inline-functions-and-variables\/\">7.9 -- Inline functions and variables<\/a>).\n<\/li>\n<\/ul>\n<\/div>\n<p>Violating part 1 of the ODR will cause the compiler to issue a redefinition error.  Violating ODR part 2 will cause the linker to issue a redefinition error.  Violating ODR part 3 will cause undefined behavior.<\/p>\n<p>Here&#8217;s an example of a violation of part 1:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int add(int x, int y)\r\n{\r\n     return x + y;\r\n}\r\n\r\nint add(int x, int y) \/\/ violation of ODR, we've already defined function add(int, int)\r\n{\r\n     return x + y;\r\n}\r\n\r\nint main()\r\n{\r\n    int x{};\r\n    int x{ 5 }; \/\/ violation of ODR, we've already defined x\r\n}<\/code><\/pre>\n<p>In this example, function <code>add(int, int)<\/code> is defined twice (in the global scope), and local variable <code>int x<\/code> is defined twice (in the scope of <code>main()<\/code>).  The Visual Studio compiler thus issues the following compile errors:<\/p>\n<pre>\nproject3.cpp(9): error C2084: function 'int add(int,int)' already has a body\r\nproject3.cpp(3): note: see previous definition of 'add'\r\nproject3.cpp(16): error C2086: 'int x': redefinition\r\nproject3.cpp(15): note: see declaration of 'x'\r\n<\/pre>\n<p>However, it is not a violation of ODR part 1 for <code>main()<\/code> to have a local variable defined as <code>int x<\/code> and <code>add()<\/code> to also have a function parameter defined as <code>int x<\/code>.  These definitions occur in different scopes (in the scope of each respective function), so they are considered to be separate definitions for two distinct objects, not a definition and redefinition of the same object.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">For advanced readers<\/p>\n<p>Functions that share an identifier but have different sets of parameters are also considered to be distinct functions, so such definitions do not violate the ODR.  We discuss this further in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-function-overloading\/\">11.1 -- Introduction to function overloading<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>What is a function prototype?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p>A function prototype is a declaration statement that includes a function&#8217;s name, return type, parameter types, and optionally the parameter names.  It does not include the function body.  It tells the compiler about the existence of a function before it is defined.\n<\/p><\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>What is a forward declaration?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p>A forward declaration tells the compiler that an identifier exists before it is actually defined.\n<\/p><\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #3<\/p>\n<p>How do we declare a forward declaration for functions?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<p>For functions, a function declaration\/prototype serves as a forward declaration.\n<\/p><\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #4<\/p>\n<p>Write the function declaration for this function (use the preferred form with names):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int doMath(int first, int second, int third, int fourth)\r\n{\r\n     return first + second * third \/ fourth;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">\/\/ Do not forget the semicolon at the end, since these are statements.\r\nint doMath(int first, int second, int third, int fourth);<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #5<\/p>\n<p>For each of the following programs, state whether they fail to compile, fail to link, or compile and link successfully.  If you are not sure, try compiling them!<\/p>\n<p>a)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\nint add(int x, int y);\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"3 + 4 + 5 = \" &lt;&lt; add(3, 4, 5) &lt;&lt; '\\n';\r\n    return 0;\r\n}\r\n\r\nint add(int x, int y)\r\n{\r\n    return x + y;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\nDoesn&#8217;t compile.  The compiler will complain that it can&#8217;t find a matching <code>add()<\/code> function that takes 3 arguments.  The forward declaration of <code>add()<\/code> only has two parameters.<\/div>\n<p>b)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\nint add(int x, int y);\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"3 + 4 + 5 = \" &lt;&lt; add(3, 4, 5) &lt;&lt; '\\n';\r\n    return 0;\r\n}\r\n\r\nint add(int x, int y, int z)\r\n{\r\n    return x + y + z;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_5'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_5\" style=\"display:none\">\nDoesn&#8217;t compile.  The compiler will complain that it can&#8217;t find a matching <code>add()<\/code> function that takes 3 arguments.  The forward declaration of <code>add()<\/code> only has two parameters, and the definition of function <code>add()<\/code> that has 3 parameters hasn&#8217;t been seen yet.<\/div>\n<p>c)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\nint add(int x, int y);\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"3 + 4 = \" &lt;&lt; add(3, 4) &lt;&lt; '\\n';\r\n    return 0;\r\n}\r\n\r\nint add(int x, int y, int z)\r\n{\r\n    return x + y + z;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_6'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_6\" style=\"display:none\">\nDoesn&#8217;t link.  The compiler will match the forward declaration of add to the function call to add() in main().  However, no add() function that takes two parameters was ever implemented (we only implemented one that took 3 parameters), so the linker will complain.<\/div>\n<p>d)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\nint add(int x, int y, int z);\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"3 + 4 + 5 = \" &lt;&lt; add(3, 4, 5) &lt;&lt; '\\n';\r\n    return 0;\r\n}\r\n\r\nint add(int z, int y, int x) \/\/ names don't match the declaration\r\n{\r\n    return x + y + z;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_7'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_7\" style=\"display:none\">\nCompiles and links.  The types in the function call to add() matches the forward declaration, and the definition of add() also matches.  The fact that the names don&#8217;t match the declaration doesn&#8217;t matter, as the names in a declaration are optional (and if provided, ignored by the compiler).<\/div>\n<p>e)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\nint add(int, int, int); \/\/ no parameter names\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"3 + 4 + 5 = \" &lt;&lt; add(3, 4, 5) &lt;&lt; '\\n';\r\n    return 0;\r\n}\r\n\r\nint add(int x, int y, int z)\r\n{\r\n    return x + y + z;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_8'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_8\" style=\"display:none\">\nCompiles and links.  This is the same as the prior case.  Function declarations do not need to specify the names of the parameters (even though we generally prefer to include them).<\/div>\n<p>f)<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint add(int x, int y);\r\n\r\nint add(int x, int y, int z)\r\n{\r\n    return x + y + z;\r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"3 + 4 + 5 = \" &lt;&lt; add(3, 4, 5) &lt;&lt; '\\n';\r\n    return 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_9'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_9\" style=\"display:none\">\nCompiles and links.  The forward declaration of add() with two parameters is not used.<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/programs-with-multiple-code-files\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">2.8<\/span>Programs with multiple code files\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/why-functions-are-useful-and-how-to-use-them-effectively\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">2.6<\/span>Why functions are useful, and how to use them effectively\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Take a look at this seemingly innocent sample program: #include &lt;iostream&gt; int main() { std::cout &lt;&lt; &#8220;The sum of 3 and 4 is: &#8221; &lt;&lt; add(3, 4) &lt;&lt; &#8216;\\n&#8217;; return 0; } int add(int x, int y) { return x + y; } You would expect this program to produce &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/28"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=28"}],"version-history":[{"count":99,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/28\/revisions"}],"predecessor-version":[{"id":18073,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/28\/revisions\/18073"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=28"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=28"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=28"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}