{"id":4445,"date":"2016-08-19T17:18:22","date_gmt":"2016-08-20T01:18:22","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=4445"},"modified":"2023-12-07T12:03:29","modified_gmt":"2023-12-07T20:03:29","slug":"association","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/association\/","title":{"rendered":"23.4 &#8212; Association"},"content":{"rendered":"<p>In the previous two lessons, we&#8217;ve looked at two types of object composition, composition and aggregation.  Object composition is used to model relationships where a complex object is built from one or more simpler objects (parts).<\/p>\n<p>In this lesson, we&#8217;ll take a look at a weaker type of relationship between two otherwise unrelated objects, called an association.  Unlike object composition relationships, in an association, there is no implied whole\/part relationship.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Association<\/p>\n<p>To qualify as an <strong>association<\/strong>, an object and another object must have the following relationship:<\/p>\n<ul>\n<li>The associated object (member) is otherwise unrelated to the object (class)<\/li>\n<li>The associated object (member) can belong to more than one object (class) at a time<\/li>\n<li>The associated object (member) does <em>not<\/em> have its existence managed by the object (class)<\/li>\n<li>The associated object (member) may or may not know about the existence of the object (class)<\/li>\n<\/ul>\n<p>Unlike a composition or aggregation, where the part is a part of the whole object, in an association, the associated object is otherwise unrelated to the object.  Just like an aggregation, the associated object can belong to multiple objects simultaneously, and isn&#8217;t managed by those objects.  However, unlike an aggregation, where the relationship is always unidirectional, in an association, the relationship may be unidirectional or bidirectional (where the two objects are aware of each other).<\/p>\n<p>The relationship between doctors and patients is a great example of an association.  The doctor clearly has a relationship with his patients, but conceptually it&#8217;s not a part\/whole (object composition) relationship.  A doctor can see many patients in a day, and a patient can see many doctors (perhaps they want a second opinion, or they are visiting different types of doctors).  Neither of the object&#8217;s lifespans are tied to the other.<\/p>\n<p>We can say that association models as &#8220;uses-a&#8221; relationship.  The doctor &#8220;uses&#8221; the patient (to earn income).  The patient uses the doctor (for whatever health purposes they need).<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Implementing associations<\/p>\n<p>Because associations are a broad type of relationship, they can be implemented in many different ways.  However, most often, associations are implemented using pointers, where the object points at the associated object.<\/p>\n<p>In this example, we&#8217;ll implement a bi-directional Doctor\/Patient relationship, since it makes sense for the Doctors to know who their Patients are, and vice-versa.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;functional&gt; \/\/ reference_wrapper\r\n#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n#include &lt;vector&gt;\r\n\r\n\/\/ Since Doctor and Patient have a circular dependency, we're going to forward declare Patient\r\nclass Patient;\r\n\r\nclass Doctor\r\n{\r\nprivate:\r\n\tstd::string m_name{};\r\n\tstd::vector&lt;std::reference_wrapper&lt;const Patient&gt;&gt; m_patient{};\r\n\r\npublic:\r\n\tDoctor(std::string_view name) :\r\n\t\tm_name{ name }\r\n\t{\r\n\t}\r\n\r\n\tvoid addPatient(Patient&amp; patient);\r\n\t\r\n\t\/\/ We'll implement this function below Patient since we need Patient to be defined at that point\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Doctor&amp; doctor);\r\n\r\n\tconst std::string&amp; getName() const { return m_name; }\r\n};\r\n\r\nclass Patient\r\n{\r\nprivate:\r\n\tstd::string m_name{};\r\n\tstd::vector&lt;std::reference_wrapper&lt;const Doctor&gt;&gt; m_doctor{}; \/\/ so that we can use it here\r\n\r\n\t\/\/ We're going to make addDoctor private because we don't want the public to use it.\r\n\t\/\/ They should use Doctor::addPatient() instead, which is publicly exposed\r\n\tvoid addDoctor(const Doctor&amp; doctor)\r\n\t{\r\n\t\tm_doctor.push_back(doctor);\r\n\t}\r\n\r\npublic:\r\n\tPatient(std::string_view name)\r\n\t\t: m_name{ name }\r\n\t{\r\n\t}\r\n\r\n\t\/\/ We'll implement this function below to parallel operator&lt;&lt;(std::ostream&amp;, const Doctor&amp;)\r\n\tfriend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Patient&amp; patient);\r\n\r\n\tconst std::string&amp; getName() const { return m_name; }\r\n\r\n\t\/\/ We'll friend Doctor::addPatient() so it can access the private function Patient::addDoctor()\r\n\tfriend void Doctor::addPatient(Patient&amp; patient);\r\n};\r\n\r\nvoid Doctor::addPatient(Patient&amp; patient)\r\n{\r\n\t\/\/ Our doctor will add this patient\r\n\tm_patient.push_back(patient);\r\n\r\n\t\/\/ and the patient will also add this doctor\r\n\tpatient.addDoctor(*this);\r\n}\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Doctor&amp; doctor)\r\n{\r\n\tif (doctor.m_patient.empty())\r\n\t{\r\n\t\tout &lt;&lt; doctor.m_name &lt;&lt; \" has no patients right now\";\r\n\t\treturn out;\r\n\t}\r\n\r\n\tout &lt;&lt; doctor.m_name &lt;&lt; \" is seeing patients: \";\r\n\tfor (const auto&amp; patient : doctor.m_patient)\r\n\t\tout &lt;&lt; patient.get().getName() &lt;&lt; ' ';\r\n\r\n\treturn out;\r\n}\r\n\r\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Patient&amp; patient)\r\n{\r\n\tif (patient.m_doctor.empty())\r\n\t{\r\n\t\tout &lt;&lt; patient.getName() &lt;&lt; \" has no doctors right now\";\r\n\t\treturn out;\r\n\t}\r\n\r\n\tout &lt;&lt; patient.m_name &lt;&lt; \" is seeing doctors: \";\r\n\tfor (const auto&amp; doctor : patient.m_doctor)\r\n\t\tout &lt;&lt; doctor.get().getName() &lt;&lt; ' ';\r\n\r\n\treturn out;\r\n}\r\n\r\nint main()\r\n{\r\n\t\/\/ Create a Patient outside the scope of the Doctor\r\n\tPatient dave{ \"Dave\" };\r\n\tPatient frank{ \"Frank\" };\r\n\tPatient betsy{ \"Betsy\" };\r\n\r\n\tDoctor james{ \"James\" };\r\n\tDoctor scott{ \"Scott\" };\r\n\r\n\tjames.addPatient(dave);\r\n\r\n\tscott.addPatient(dave);\r\n\tscott.addPatient(betsy);\r\n\r\n\tstd::cout &lt;&lt; james &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; scott &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; dave &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; frank &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; betsy &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\r\nJames is seeing patients: Dave\r\nScott is seeing patients: Dave Betsy\r\nDave is seeing doctors: James Scott\r\nFrank has no doctors right now\r\nBetsy is seeing doctors: Scott\r\n<\/pre>\n<p>In general, you should avoid bidirectional associations if a unidirectional one will do, as they add complexity and tend to be harder to write without making errors.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Reflexive association<\/p>\n<p>Sometimes objects may have a relationship with other objects of the same type.  This is called a <strong>reflexive association<\/strong>.  A good example of a reflexive association is the relationship between a university course and its prerequisites (which are also university courses).<\/p>\n<p>Consider the simplified case where a Course can only have one prerequisite.  We can do something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Course\r\n{\r\nprivate:\r\n    std::string m_name{};\r\n    const Course* m_prerequisite{};\r\n\r\npublic:\r\n    Course(std::string_view name, const Course* prerequisite = nullptr):\r\n        m_name{ name }, m_prerequisite{ prerequisite }\r\n    {\r\n    }\r\n\r\n};<\/code><\/pre>\n<p>This can lead to a chain of associations (a course has a prerequisite, which has a prerequisite, etc&#8230;)<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Associations can be indirect<\/p>\n<p>In all of the previous cases, we&#8217;ve used either pointers or references to directly link objects together.  However, in an association, this is not strictly required.  Any kind of data that allows you to link two objects together suffices.  In the following example, we show how a Driver class can have a unidirectional association with a Car without actually including a Car pointer or reference member:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n#include &lt;string_view&gt;\r\n\r\nclass Car\r\n{\r\nprivate:\r\n\tstd::string m_name{};\r\n\tint m_id{};\r\n\r\npublic:\r\n\tCar(std::string_view name, int id)\r\n\t\t: m_name{ name }, m_id{ id }\r\n\t{\r\n\t}\r\n\r\n\tconst std::string&amp; getName() const { return m_name; }\r\n\tint getId() const { return m_id; }\r\n};\r\n\r\n\/\/ Our CarLot is essentially just a static array of Cars and a lookup function to retrieve them.\r\n\/\/ Because it's static, we don't need to allocate an object of type CarLot to use it\r\nnamespace CarLot\r\n{\r\n    Car carLot[4] { { \"Prius\", 4 }, { \"Corolla\", 17 }, { \"Accord\", 84 }, { \"Matrix\", 62 } };\r\n\r\n\tCar* getCar(int id)\r\n\t{\r\n\t\tfor (auto&amp; car : carLot)\r\n        {\r\n\t\t\tif (car.getId() == id)\r\n\t\t\t{\r\n\t\t\t\treturn &amp;car;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn nullptr;\r\n\t}\r\n};\r\n\r\nclass Driver\r\n{\r\nprivate:\r\n\tstd::string m_name{};\r\n\tint m_carId{}; \/\/ we're associated with the Car by ID rather than pointer\r\n\r\npublic:\r\n\tDriver(std::string_view name, int carId)\r\n\t\t: m_name{ name }, m_carId{ carId }\r\n\t{\r\n\t}\r\n\r\n\tconst std::string&amp; getName() const { return m_name; }\r\n\tint getCarId() const { return m_carId; }\r\n};\r\n\r\nint main()\r\n{\r\n\tDriver d{ \"Franz\", 17 }; \/\/ Franz is driving the car with ID 17\r\n\r\n\tCar* car{ CarLot::getCar(d.getCarId()) }; \/\/ Get that car from the car lot\r\n\t\r\n\tif (car)\r\n\t\tstd::cout &lt;&lt; d.getName() &lt;&lt; \" is driving a \" &lt;&lt; car-&gt;getName() &lt;&lt; '\\n';\r\n\telse\r\n\t\tstd::cout &lt;&lt; d.getName() &lt;&lt; \" couldn't find his car\\n\";\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>In the above example, we have a CarLot holding our cars.  The Driver, who needs a car, doesn&#8217;t have a pointer to his Car -- instead, he has the ID of the car, which we can use to get the Car from the CarLot when we need it.<\/p>\n<p>In this particular example, doing things this way is kind of silly, since getting the Car out of the CarLot requires an inefficient lookup (a pointer connecting the two is much faster).  However, there are advantages to referencing things by a unique ID instead of a pointer.  For example, you can reference things that are not currently in memory (maybe they&#8217;re in a file, or in a database, and can be loaded on demand).  Also, pointers can take 4 or 8 bytes -- if space is at a premium and the number of unique objects is fairly low, referencing them by an 8-bit or 16-bit integer can save lots of memory.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Composition vs aggregation vs association summary<\/p>\n<p>Here&#8217;s a summary table to help you remember the difference between composition, aggregation, and association:<\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<th>Property<\/th>\n<th>Composition<\/th>\n<th>Aggregation<\/th>\n<th>Association<\/th>\n<\/tr>\n<tr>\n<td>Relationship type<\/td>\n<td>Whole\/part<\/td>\n<td>Whole\/part<\/td>\n<td>Otherwise unrelated<\/td>\n<\/tr>\n<tr>\n<td>Members can belong to multiple classes<\/td>\n<td>No<\/td>\n<td>Yes<\/td>\n<td>Yes<\/td>\n<\/tr>\n<tr>\n<td>Members&#8217; existence managed by class<\/td>\n<td>Yes<\/td>\n<td>No<\/td>\n<td>No<\/td>\n<\/tr>\n<tr>\n<td>Directionality<\/td>\n<td>Unidirectional<\/td>\n<td>Unidirectional<\/td>\n<td>Unidirectional or bidirectional<\/td>\n<\/tr>\n<tr>\n<td>Relationship verb<\/td>\n<td>Part-of<\/td>\n<td>Has-a<\/td>\n<td>Uses-a<\/td>\n<\/tr>\n<p><\/table><\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/dependencies\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">23.5<\/span>Dependencies\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/aggregation\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">23.3<\/span>Aggregation\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In the previous two lessons, we&#8217;ve looked at two types of object composition, composition and aggregation. Object composition is used to model relationships where a complex object is built from one or more simpler objects (parts). In this lesson, we&#8217;ll take a look at a weaker type of relationship between &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4445"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=4445"}],"version-history":[{"count":41,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4445\/revisions"}],"predecessor-version":[{"id":16200,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/4445\/revisions\/16200"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=4445"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=4445"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=4445"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}