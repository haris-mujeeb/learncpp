{"id":107,"date":"2007-07-17T11:40:59","date_gmt":"2007-07-17T19:40:59","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/612-references-vs-pointers-and-member-selection\/"},"modified":"2024-07-02T13:17:20","modified_gmt":"2024-07-02T20:17:20","slug":"member-selection-with-pointers-and-references","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/member-selection-with-pointers-and-references\/","title":{"rendered":"13.12 &#8212; Member selection with pointers and references"},"content":{"rendered":"<p class=\"cpp-section\">Member selection for structs and references to structs<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-structs-members-and-member-selection\/\">13.7 -- Introduction to structs, members, and member selection<\/a>, we showed that you can use the member selection operator (.) to select a member from a struct object:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Employee\r\n{\r\n    int id {};\r\n    int age {};\r\n    double wage {};\r\n};\r\n\r\nint main()\r\n{\r\n    Employee joe { 1, 34, 65000.0 };\r\n\r\n    \/\/ Use member selection operator (.) to select a member from struct object\r\n    ++joe.age; \/\/ Joe had a birthday\r\n    joe.wage = 68000.0; \/\/ Joe got a promotion\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>Since references to an object act just like the object itself, we can also use the member selection operator (.) to select a member from a reference to a struct:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Employee\r\n{\r\n    int id{};\r\n    int age{};\r\n    double wage{};\r\n};\r\n\r\nvoid printEmployee(const Employee&amp; e)\r\n{\r\n    \/\/ Use member selection operator (.) to select member from reference to struct\r\n    std::cout &lt;&lt; \"Id: \" &lt;&lt; e.id &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"Age: \" &lt;&lt; e.age &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; \"Wage: \" &lt;&lt; e.wage &lt;&lt; '\\n';\r\n}\r\n\r\nint main()\r\n{\r\n    Employee joe{ 1, 34, 65000.0 };\r\n\r\n    ++joe.age;\r\n    joe.wage = 68000.0;\r\n\r\n    printEmployee(joe);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Member selection for pointers to structs<\/p>\n<p>However, the member selection operator (.) can&#8217;t be used directly on a pointer to a struct:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Employee\r\n{\r\n    int id{};\r\n    int age{};\r\n    double wage{};\r\n};\r\n\r\nint main()\r\n{\r\n    Employee joe{ 1, 34, 65000.0 };\r\n\r\n    ++joe.age;\r\n    joe.wage = 68000.0;\r\n\r\n    Employee* ptr{ &amp;joe };\r\n    std::cout &lt;&lt; ptr.id &lt;&lt; '\\n'; \/\/ Compile error: can't use operator. with pointers\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>With normal variables or references, we can access objects directly.  However, because pointers hold addresses, we first need to dereference the pointer to get the object before we can do anything with it.  So one way to access a member from a pointer to a struct is as follows:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Employee\r\n{\r\n    int id{};\r\n    int age{};\r\n    double wage{};\r\n};\r\n\r\nint main()\r\n{\r\n    Employee joe{ 1, 34, 65000.0 };\r\n\r\n    ++joe.age;\r\n    joe.wage = 68000.0;\r\n\r\n    Employee* ptr{ &amp;joe };\r\n    std::cout &lt;&lt; (*ptr).id &lt;&lt; '\\n'; \/\/ Not great but works: First dereference ptr, then use member selection\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>However, this is a bit ugly, especially because we need to parenthesize the dereference operation so it will take precedence over the member selection operation.<\/p>\n<p>To make for a cleaner syntax, C++ offers a <strong>member selection from pointer operator (-&gt;)<\/strong> (also sometimes called the <strong>arrow operator<\/strong>) that can be used to select members from a pointer to an object:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Employee\r\n{\r\n    int id{};\r\n    int age{};\r\n    double wage{};\r\n};\r\n\r\nint main()\r\n{\r\n    Employee joe{ 1, 34, 65000.0 };\r\n\r\n    ++joe.age;\r\n    joe.wage = 68000.0;\r\n\r\n    Employee* ptr{ &amp;joe };\r\n    std::cout &lt;&lt; ptr-&gt;id &lt;&lt; '\\n'; \/\/ Better: use -&gt; to select member from pointer to object\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This member selection from pointer operator (-&gt;) works identically to the member selection operator (.) but does an implicit dereference of the pointer object before selecting the member.  Thus <code>ptr-&gt;id<\/code> is equivalent to <code>(*ptr).id<\/code>.<\/p>\n<p>This arrow operator is not only easier to type, but is also much less prone to error because the indirection is implicitly done for you, so there are no precedence issues to worry about.  Consequently, when doing member access through a pointer, always use the -&gt; operator instead of the . operator.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>When using a pointer to access a member, use the member selection from pointer operator (-&gt;) instead of the member selection operator (.).\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Chaining <code>operator-&gt;<\/code><\/p>\n<p>If the member accessed via <code>operator-&gt;<\/code> is a pointer to a class type, <code>operator-&gt;<\/code> can be applied again in the same expression to access the member of that class type.<\/p>\n<p>The following example illustrates this (courtesy of reader Luna):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nstruct Point\r\n{\r\n    double x {};\r\n    double y {};\r\n};\r\n\r\nstruct Triangle\r\n{\r\n    Point* a {};\r\n    Point* b {};\r\n    Point* c {};\r\n};\r\n\r\nint main()\r\n{\r\n    Point a {1,2};\r\n    Point b {3,7};\r\n    Point c {10,2};\r\n\r\n    Triangle tr { &amp;a, &amp;b, &amp;c };\r\n    Triangle* ptr {&amp;tr};\r\n\r\n    \/\/ ptr is a pointer to a Triangle, which contains members that are pointers to a Point\r\n    \/\/ To access member y of Point c of the Triangle pointed to by ptr, the following are equivalent:\r\n\r\n    \/\/ access via operator.\r\n    std::cout &lt;&lt; (*(*ptr).c).y &lt;&lt; '\\n'; \/\/ ugly!\r\n\r\n    \/\/ access via operator-&gt;\r\n    std::cout &lt;&lt; ptr -&gt; c -&gt; y &lt;&lt; '\\n'; \/\/ much nicer\r\n}<\/code><\/pre>\n<p>When using more than one <code>operator-&gt;<\/code> in sequence (e.g <code>ptr-&gt;c-&gt;y<\/code>), the expression can be hard to read.  Adding whitespace between the members and <code>operator-&gt;<\/code> (e.g. <code>ptr -&gt; c -&gt; y<\/code>) can make it a bit easier to distinguish the members being accessed from the operator.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Mixing pointers and non-pointers to members<\/p>\n<p>The member selection operator is always applied to the currently selected variable. If you have a mix of pointers and normal member variables, you can see member selections where . and -&gt; are both used in sequence:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;string&gt;\r\n\r\nstruct Paw\r\n{\r\n    int claws{};\r\n};\r\n \r\nstruct Animal\r\n{\r\n    std::string name{};\r\n    Paw paw{};\r\n};\r\n \r\nint main()\r\n{\r\n    Animal puma{ \"Puma\", { 5 } };\r\n \r\n    Animal* ptr{ &amp;puma };\r\n \r\n    \/\/ ptr is a pointer, use -&gt;\r\n    \/\/ paw is not a pointer, use .\r\n\r\n    std::cout &lt;&lt; (ptr-&gt;paw).claws &lt;&lt; '\\n';\r\n \r\n    return 0;\r\n}<\/code><\/pre>\n<p>Note that in the case of <code>(ptr-&gt;paw).claws<\/code>, parentheses aren&#8217;t necessary since both <code>operator-&gt;<\/code> and <code>operator.<\/code> evaluate in left to right order, but it does help readability slightly.<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/class-templates\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.13<\/span>Class templates\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/struct-miscellany\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">13.11<\/span>Struct miscellany\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Member selection for structs and references to structs In lesson , we showed that you can use the member selection operator (.) to select a member from a struct object: #include &lt;iostream&gt; struct Employee { int id {}; int age {}; double wage {}; }; int main() { Employee joe &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/107"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=107"}],"version-history":[{"count":33,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/107\/revisions"}],"predecessor-version":[{"id":17271,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/107\/revisions\/17271"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=107"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=107"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=107"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}