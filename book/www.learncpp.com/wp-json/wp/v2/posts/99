{"id":99,"date":"2007-07-10T18:52:36","date_gmt":"2007-07-11T02:52:36","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/67-introduction-to-pointers\/"},"modified":"2025-02-07T18:15:10","modified_gmt":"2025-02-08T02:15:10","slug":"introduction-to-pointers","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-pointers\/","title":{"rendered":"12.7 &#8212; Introduction to pointers"},"content":{"rendered":"<p>Pointers are one of C++&#8217;s historical boogeymen, and a place where many aspiring C++ learners have gotten stuck.  However, as you&#8217;ll see shortly, pointers are nothing to be scared of.<\/p>\n<p>In fact, pointers behave a lot like lvalue references.  But before we explain that further, let&#8217;s do some setup.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>If you&#8217;re rusty or not familiar with lvalue references, now would be a good time to review them.  We cover lvalue references in lessons <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/lvalue-references\/\">12.3 --  Lvalue references<\/a>, <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/lvalue-references-to-const\/\">12.4 -- Lvalue references to const<\/a>, and <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pass-by-lvalue-reference\/\">12.5 -- Pass by lvalue reference<\/a>.\n<\/p><\/div>\n<p>Consider a normal variable, like this one:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">char x {}; \/\/ chars use 1 byte of memory<\/code><\/pre>\n<p>Simplifying a bit, when the code generated for this definition is executed, a piece of memory from RAM will be assigned to this object.  For the sake of example, let\u2019s say that the variable <code>x<\/code> is assigned memory address <code>140<\/code>.  Whenever we use variable <code>x<\/code> in an expression or statement, the program will go to memory address <code>140<\/code> to access the value stored there.<\/p>\n<p>The nice thing about variables is that we don&#8217;t need to worry about what specific memory addresses are assigned, or how many bytes are required to store the object&#8217;s value.  We just refer to the variable by its given identifier, and the compiler translates this name into the appropriately assigned memory address.  The compiler takes care of all the addressing.<\/p>\n<p>This is also true with references:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    char x {}; \/\/ assume this is assigned memory address 140\r\n    char&amp; ref { x }; \/\/ ref is an lvalue reference to x (when used with a type, &amp; means lvalue reference)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Because <code>ref<\/code> acts as an alias for <code>x<\/code>, whenever we use <code>ref<\/code>, the program will go to memory address <code>140<\/code> to access the value.  Again the compiler takes care of the addressing, so that we don&#8217;t have to think about it.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The address-of operator (&#038;)<\/p>\n<p>Although the memory addresses used by variables aren&#8217;t exposed to us by default, we do have access to this information.  The <strong>address-of operator<\/strong> (&#038;) returns the memory address of its operand.  This is pretty straightforward:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x{ 5 };\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n';  \/\/ print the value of variable x\r\n    std::cout &lt;&lt; &amp;x &lt;&lt; '\\n'; \/\/ print the memory address of variable x\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>On the author&#8217;s machine, the above program printed:<\/p>\n<pre>\n5\r\n0027FEA0\r\n<\/pre>\n<p>In the above example, we use the address-of operator (&#038;) to retrieve the address assigned to variable <code>x<\/code> and print that address to the console.  Memory addresses are typically printed as hexadecimal values (we covered hex in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/numeral-systems-decimal-binary-hexadecimal-and-octal\/\">5.3 -- Numeral systems (decimal, binary, hexadecimal, and octal)<\/a>), often without the 0x prefix.<\/p>\n<p>For objects that use more than one byte of memory, address-of will return the memory address of the first byte used by the object.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>The &#038; symbol tends to cause confusion because it has different meanings depending on context:<\/p>\n<ul>\n<li>When following a type name, &#038; denotes an lvalue reference: <code>int&amp; ref<\/code>.\n<\/li>\n<li>When used in a unary context in an expression, &#038; is the address-of operator: <code>std::cout &lt;&lt; &amp;x<\/code>.\n<\/li>\n<li>When used in a binary context in an expression, &#038; is the Bitwise AND operator: <code>std::cout &lt;&lt; x &amp; y<\/code>.\n<\/li>\n<\/ul>\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The dereference operator (*)<\/p>\n<p>Getting the address of a variable isn&#8217;t very useful by itself.<\/p>\n<p>The most useful thing we can do with an address is access the value stored at that address.  The <strong>dereference operator<\/strong> (*) (also occasionally called the <strong>indirection operator<\/strong>) returns the value at a given memory address as an lvalue:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x{ 5 };\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n';  \/\/ print the value of variable x\r\n    std::cout &lt;&lt; &amp;x &lt;&lt; '\\n'; \/\/ print the memory address of variable x\r\n\r\n    std::cout &lt;&lt; *(&amp;x) &lt;&lt; '\\n'; \/\/ print the value at the memory address of variable x (parentheses not required, but make it easier to read)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>On the author&#8217;s machine, the above program printed:<\/p>\n<pre>\n5\r\n0027FEA0\r\n5\r\n<\/pre>\n<p>This program is pretty simple.  First we declare a variable <code>x<\/code> and print its value.  Then we print the address of variable <code>x<\/code>.  Finally, we use the dereference operator to get the value at the memory address of variable <code>x<\/code> (which is just the value of <code>x<\/code>), which we print to the console.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Given a memory address, we can use the dereference operator (*) to get the value at that address (as an lvalue).<\/p>\n<p>The address-of operator (&#038;) and dereference operator (*) work as opposites: address-of gets the address of an object, and dereference gets the object at an address.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Tip<\/p>\n<p>Although the dereference operator looks just like the multiplication operator, you can distinguish them because the dereference operator is unary, whereas the multiplication operator is binary.\n<\/p><\/div>\n<p>Getting the memory address of a variable and then immediately dereferencing that address to get a value isn&#8217;t that useful either (after all, we can just use the variable to access the value).<\/p>\n<p>But now that we have the address-of operator (&#038;) and dereference operator (*) added to our toolkits, we&#8217;re ready to talk about pointers.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Pointers<\/p>\n<p>A <strong>pointer<\/strong> is an object that holds a <em>memory address<\/em> (typically of another variable) as its value.  This allows us to store the address of some other object to use later.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>In modern C++, the pointers we are talking about here are sometimes called &#8220;raw pointers&#8221; or &#8220;dumb pointers&#8221;, to help differentiate them from &#8220;smart pointers&#8221; that were introduced into the language more recently.  We cover smart pointers in <a href=\"https:\/\/www.learncpp.com#Chapter22\">chapter 22<\/a>.\n<\/p><\/div>\n<p>A type that specifies a pointer (e.g. <code>int*<\/code>) is called a <strong>pointer type<\/strong>.  Much like reference types are declared using an ampersand (&#038;) character, pointer types are declared using an asterisk (*):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int;  \/\/ a normal int\r\nint&amp;; \/\/ an lvalue reference to an int value\r\n\r\nint*; \/\/ a pointer to an int value (holds the address of an integer value)<\/code><\/pre>\n<p>To create a pointer variable, we simply define a variable with a pointer type:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int x { 5 };    \/\/ normal variable\r\n    int&amp; ref { x }; \/\/ a reference to an integer (bound to x)\r\n\r\n    int* ptr;       \/\/ a pointer to an integer\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Note that this asterisk is part of the declaration syntax for pointers, not a use of the dereference operator.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>When declaring a pointer type, place the asterisk next to the type name.\n<\/p><\/div>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Although you generally should not declare multiple variables on a single line, if you do, the asterisk has to be included with each variable.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int* ptr1, ptr2;   \/\/ incorrect: ptr1 is a pointer to an int, but ptr2 is just a plain int!\r\nint* ptr3, * ptr4; \/\/ correct: ptr3 and ptr4 are both pointers to an int<\/code><\/pre>\n<p>Although this is sometimes used as an argument to not place the asterisk with the type name (instead placing it next to the variable name), it&#8217;s a better argument for avoiding defining multiple variables in the same statement.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Pointer initialization<\/p>\n<p>Like normal variables, pointers are <em>not<\/em> initialized by default.  A pointer that has not been initialized is sometimes called a <strong>wild pointer<\/strong>.  Wild pointers contain a garbage address, and dereferencing a wild pointer will result in undefined behavior.  Because of this, you should always initialize your pointers to a known value.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Always initialize your pointers.\n<\/p><\/div>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int x{ 5 };\r\n\r\n    int* ptr;        \/\/ an uninitialized pointer (holds a garbage address)\r\n    int* ptr2{};     \/\/ a null pointer (we'll discuss these in the next lesson)\r\n    int* ptr3{ &amp;x }; \/\/ a pointer initialized with the address of variable x\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Since pointers hold addresses, when we initialize or assign a value to a pointer, that value has to be an address.  Typically, pointers are used to hold the address of another variable (which we can get using the address-of operator (&#038;)).<\/p>\n<p>Once we have a pointer holding the address of another object, we can then use the dereference operator (*) to access the value at that address.  For example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x{ 5 };\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n'; \/\/ print the value of variable x\r\n\r\n    int* ptr{ &amp;x }; \/\/ ptr holds the address of x\r\n    std::cout &lt;&lt; *ptr &lt;&lt; '\\n'; \/\/ use dereference operator to print the value at the address that ptr is holding (which is x's address)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This prints:<\/p>\n<pre>\n5\r\n5\r\n<\/pre>\n<p>Conceptually, you can think of the above snippet like this:<br \/>\n<img src=\"http:\/\/www.learncpp.com\/images\/CppTutorial\/Section6\/6-Pointer.png\"><\/p>\n<p>This is where pointers get their name from -- <code>ptr<\/code> is holding the address of <code>x<\/code>, so we say that <code>ptr<\/code> is &#8220;pointing to&#8221; <code>x<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>A note on pointer nomenclature: &#8220;X pointer&#8221; (where X is some type) is a commonly used shorthand for &#8220;pointer to an X&#8221;.  So when we say, &#8220;an integer pointer&#8221;, we really mean &#8220;a pointer to an integer&#8221;.  This understanding will be valuable when we talk about const pointers.\n<\/p><\/div>\n<p>Much like the type of a reference has to match the type of object being referred to, the type of the pointer has to match the type of the object being pointed to:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int main()\r\n{\r\n    int i{ 5 };\r\n    double d{ 7.0 };\r\n\r\n    int* iPtr{ &amp;i };     \/\/ ok: a pointer to an int can point to an int object\r\n    int* iPtr2 { &amp;d };   \/\/ not okay: a pointer to an int can't point to a double object\r\n    double* dPtr{ &amp;d };  \/\/ ok: a pointer to a double can point to a double object\r\n    double* dPtr2{ &amp;i }; \/\/ not okay: a pointer to a double can't point to an int object\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>With one exception that we&#8217;ll discuss next lesson, initializing a pointer with a literal value is disallowed:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int* ptr{ 5 }; \/\/ not okay\r\nint* ptr{ 0x0012FF7C }; \/\/ not okay, 0x0012FF7C is treated as an integer literal<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Pointers and assignment<\/p>\n<p>We can use assignment with pointers in two different ways:<\/p>\n<ol start=\"1\">\n<li>To change what the pointer is pointing at (by assigning the pointer a new address)\n<\/li>\n<li>To change the value being pointed at (by assigning the dereferenced pointer a new value)\n<\/li>\n<\/ol>\n<p>First, let&#8217;s look at a case where a pointer is changed to point at a different object:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x{ 5 };\r\n    int* ptr{ &amp;x }; \/\/ ptr initialized to point at x\r\n\r\n    std::cout &lt;&lt; *ptr &lt;&lt; '\\n'; \/\/ print the value at the address being pointed to (x's address)\r\n\r\n    int y{ 6 };\r\n    ptr = &amp;y; \/\/ \/\/ change ptr to point at y\r\n\r\n    std::cout &lt;&lt; *ptr &lt;&lt; '\\n'; \/\/ print the value at the address being pointed to (y's address)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The above prints:<\/p>\n<pre>\n5\r\n6\r\n<\/pre>\n<p>In the above example, we define pointer <code>ptr<\/code>, initialize it with the address of <code>x<\/code>, and dereference the pointer to print the value being pointed to (<code>5<\/code>).  We then use the assignment operator to change the address that <code>ptr<\/code> is holding to the address of <code>y<\/code>.  We then dereference the pointer again to print the value being pointed to (which is now <code>6<\/code>).<\/p>\n<p>Now let&#8217;s look at how we can also use a pointer to change the value being pointed at:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x{ 5 };\r\n    int* ptr{ &amp;x }; \/\/ initialize ptr with address of variable x\r\n\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n';    \/\/ print x's value\r\n    std::cout &lt;&lt; *ptr &lt;&lt; '\\n'; \/\/ print the value at the address that ptr is holding (x's address)\r\n\r\n    *ptr = 6; \/\/ The object at the address held by ptr (x) assigned value 6 (note that ptr is dereferenced here)\r\n\r\n    std::cout &lt;&lt; x &lt;&lt; '\\n';\r\n    std::cout &lt;&lt; *ptr &lt;&lt; '\\n'; \/\/ print the value at the address that ptr is holding (x's address)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\n5\r\n5\r\n6\r\n6\r\n<\/pre>\n<p>In this example, we define pointer <code>ptr<\/code>, initialize it with the address of <code>x<\/code>, and then print the value of both <code>x<\/code> and <code>*ptr<\/code> (<code>5<\/code>).  Because <code>*ptr<\/code> returns an lvalue, we can use this on the left hand side of an assignment statement, which we do to change the value being pointed at by <code>ptr<\/code> to <code>6<\/code>.  We then print the value of both <code>x<\/code> and <code>*ptr<\/code> again to show that the value has been updated as expected.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>When we use a pointer without a dereference (<code>ptr<\/code>), we are accessing the address held by the pointer.  Modifying this (<code>ptr = &amp;y<\/code>) changes what the pointer is pointing at.<\/p>\n<p>When we dereference a pointer (<code>*ptr<\/code>), we are accessing the object being pointed at.  Modifying this (<code>*ptr = 6;<\/code>) changes the value of the object being pointed at.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Pointers behave much like lvalue references<\/p>\n<p>Pointers and lvalue references behave similarly.  Consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x{ 5 };\r\n    int&amp; ref { x };  \/\/ get a reference to x\r\n    int* ptr { &amp;x }; \/\/ get a pointer to x\r\n\r\n    std::cout &lt;&lt; x;\r\n    std::cout &lt;&lt; ref;  \/\/ use the reference to print x's value (5)\r\n    std::cout &lt;&lt; *ptr &lt;&lt; '\\n'; \/\/ use the pointer to print x's value (5)\r\n\r\n    ref = 6; \/\/ use the reference to change the value of x\r\n    std::cout &lt;&lt; x;\r\n    std::cout &lt;&lt; ref;  \/\/ use the reference to print x's value (6)\r\n    std::cout &lt;&lt; *ptr &lt;&lt; '\\n'; \/\/ use the pointer to print x's value (6)\r\n\r\n    *ptr = 7; \/\/ use the pointer to change the value of x\r\n    std::cout &lt;&lt; x;\r\n    std::cout &lt;&lt; ref;  \/\/ use the reference to print x's value (7)\r\n    std::cout &lt;&lt; *ptr &lt;&lt; '\\n'; \/\/ use the pointer to print x's value (7)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\n555\r\n666\r\n777\r\n<\/pre>\n<p>In the above program, we create a normal variable <code>x<\/code> with value <code>5<\/code>, and then create an lvalue reference and a pointer to <code>x<\/code>.  Next, we use the lvalue reference to change the value from <code>5<\/code> to <code>6<\/code>, and show that we can access that updated value via all three methods.  Finally, we use the dereferenced pointer to change the value from <code>6<\/code> to <code>7<\/code>, and again show that we can access the updated value via all three methods.<\/p>\n<p>Thus, pointers and references both provide a way to indirectly access another object.  The primary difference is that with pointers, we need to explicitly get the address to point at, and we have to explicitly dereference the pointer to get the value.  With references, the address-of and dereference happens implicitly.<\/p>\n<p>There are some other differences between pointers and references worth mentioning:<\/p>\n<ul>\n<li>References must be initialized, pointers are not required to be initialized (but should be).\n<\/li>\n<li>References are not objects, pointers are.\n<\/li>\n<li>References can not be reseated (changed to reference something else), pointers can change what they are pointing at.\n<\/li>\n<li>References must always be bound to an object, pointers can point to nothing (we&#8217;ll see an example of this in the next lesson).\n<\/li>\n<li>References are &#8220;safe&#8221; (outside of dangling references), pointers are inherently dangerous (we&#8217;ll also discuss this in the next lesson).\n<\/li>\n<\/ul>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The address-of operator returns a pointer<\/p>\n<p>It&#8217;s worth noting that the address-of operator (&#038;) doesn&#8217;t return the address of its operand as a literal (as C++ doesn&#8217;t support address literals).  Instead, it returns a pointer to the operand (whose value is the address of the operand).  In other words, given variable <code>int x<\/code>, <code>&amp;x<\/code> returns an <code>int*<\/code> holding the address of <code>x<\/code>.<\/p>\n<p>We can see this in the following example:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;typeinfo&gt;\r\n\r\nint main()\r\n{\r\n\tint x{ 4 };\r\n\tstd::cout &lt;&lt; typeid(x).name() &lt;&lt; '\\n';  \/\/ print the type of x\r\n\tstd::cout &lt;&lt; typeid(&amp;x).name() &lt;&lt; '\\n'; \/\/ print the type of &amp;x\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>On Visual Studio, this printed:<\/p>\n<pre>\nint\r\nint *\r\n<\/pre>\n<p>With gcc, this printed <code>i<\/code> (int) and <code>pi<\/code> (pointer to int) instead.  Because the result of typeid().name() is compiler-dependent, your compiler may print something different, but it will have the same meaning.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The size of pointers<\/p>\n<p>The size of a pointer is dependent upon the architecture the executable is compiled for -- a 32-bit executable uses 32-bit memory addresses -- consequently, a pointer on a 32-bit machine is 32 bits (4 bytes).  With a 64-bit executable, a pointer would be 64 bits (8 bytes).  Note that this is true regardless of the size of the object being pointed to:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main() \/\/ assume a 32-bit application\r\n{\r\n    char* chPtr{};        \/\/ chars are 1 byte\r\n    int* iPtr{};          \/\/ ints are usually 4 bytes\r\n    long double* ldPtr{}; \/\/ long doubles are usually 8 or 12 bytes\r\n\r\n    std::cout &lt;&lt; sizeof(chPtr) &lt;&lt; '\\n'; \/\/ prints 4\r\n    std::cout &lt;&lt; sizeof(iPtr) &lt;&lt; '\\n';  \/\/ prints 4\r\n    std::cout &lt;&lt; sizeof(ldPtr) &lt;&lt; '\\n'; \/\/ prints 4\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The size of the pointer is always the same.  This is because a pointer is just a memory address, and the number of bits needed to access a memory address is constant.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Dangling pointers<\/p>\n<p>Much like a dangling reference, a <strong>dangling pointer<\/strong> is a pointer that is holding the address of an object that is no longer valid (e.g. because it has been destroyed).<\/p>\n<p>Dereferencing a dangling pointer (e.g. in order to print the value being pointed at) will lead to undefined behavior, as you are trying to access an object that is no longer valid.<\/p>\n<p>Perhaps surprisingly, the standard says &#8220;Any other use of an invalid pointer <em>value<\/em> has implementation-defined behavior&#8221;.  This means that you can assign an invalid pointer a new value, such as nullptr (because this doesn&#8217;t use the invalid pointer&#8217;s value).  However, any other operations that use the invalid pointer&#8217;s value (such as copying or incrementing an invalid pointer) will yield implementation-defined behavior.<\/p>\n<div class=\"cpp-note cpp-lightbluebackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Key insight<\/p>\n<p>Dereferencing an invalid pointer will lead to undefined behavior.  Any other use of an invalid pointer value is implementation-defined.\n<\/p><\/div>\n<p>Here&#8217;s an example of creating a dangling pointer:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    int x{ 5 };\r\n    int* ptr{ &amp;x };\r\n\r\n    std::cout &lt;&lt; *ptr &lt;&lt; '\\n'; \/\/ valid\r\n\r\n    {\r\n        int y{ 6 };\r\n        ptr = &amp;y;\r\n\r\n        std::cout &lt;&lt; *ptr &lt;&lt; '\\n'; \/\/ valid\r\n    } \/\/ y goes out of scope, and ptr is now dangling\r\n\r\n    std::cout &lt;&lt; *ptr &lt;&lt; '\\n'; \/\/ undefined behavior from dereferencing a dangling pointer\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The above program will probably print:<\/p>\n<pre>\n5\r\n6\r\n6\r\n<\/pre>\n<p>But it may not, as the object that <code>ptr<\/code> was pointing at went out of scope and was destroyed at the end of the inner block, leaving <code>ptr<\/code> dangling.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Conclusion<\/p>\n<p>Pointers are variables that hold a memory address.  They can be dereferenced using the dereference operator (*) to retrieve the value at the address they are holding.  Dereferencing a wild or dangling (or null) pointer will result in undefined behavior and will probably crash your application.<\/p>\n<p>Pointers are both more flexible than references and more dangerous.  We&#8217;ll continue to explore this in the upcoming lessons.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>What values does this program print?  Assume a short is 2 bytes, and a 32-bit machine.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n\tshort value{ 7 }; \/\/ &amp;value = 0012FF60\r\n\tshort otherValue{ 3 }; \/\/ &amp;otherValue = 0012FF54\r\n\r\n\tshort* ptr{ &amp;value };\r\n\r\n\tstd::cout &lt;&lt; &amp;value &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; value &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; ptr &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; *ptr &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; '\\n';\r\n\r\n\t*ptr = 9;\r\n\r\n\tstd::cout &lt;&lt; &amp;value &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; value &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; ptr &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; *ptr &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; '\\n';\r\n\r\n\tptr = &amp;otherValue;\r\n\r\n\tstd::cout &lt;&lt; &amp;otherValue &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; otherValue &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; ptr &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; *ptr &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; '\\n';\r\n\r\n\tstd::cout &lt;&lt; sizeof(ptr) &lt;&lt; '\\n';\r\n\tstd::cout &lt;&lt; sizeof(*ptr) &lt;&lt; '\\n';\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<pre>\n0012FF60\r\n7\r\n0012FF60\r\n7\r\n\r\n0012FF60\r\n9\r\n0012FF60\r\n9\r\n\r\n0012FF54\r\n3\r\n0012FF54\r\n3\r\n\r\n4\r\n2\r\n<\/pre>\n<p>A brief explanation about the 4 and the 2.  A 32-bit machine means that pointers will be 32 bits in length, but sizeof() always prints the size in bytes.  32 bits is 4 bytes.  Thus the <code>sizeof(ptr)<\/code> is 4.  Because <code>ptr<\/code> is a pointer to a short, <code>*ptr<\/code> is a short.  The size of a short in this example is 2 bytes.  Thus the <code>sizeof(*ptr)<\/code> is 2.\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>What&#8217;s wrong with this snippet of code?<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int v1{ 45 };\r\nint* ptr{ &amp;v1 }; \/\/ initialize ptr with address of v1\r\n\r\nint v2 { 78 };\r\n*ptr = &amp;v2;     \/\/ assign ptr to address of v2<\/code><\/pre>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p>The last line of the above snippet doesn&#8217;t compile.<\/p>\n<p>Let&#8217;s examine this program in more detail.<\/p>\n<p>The first and fourth lines contain standard variable definitions, along with an initialization value.  Nothing special here.<\/p>\n<p>On the second line, the asterisk is part of the pointer declaration syntax (not a dereference).  So this line says, &#8220;assign the address of <code>v1<\/code> to <code>ptr<\/code>&#8220;.  This is fine, since pointers hold addresses.<\/p>\n<p>On line five, the asterisk represents a dereference, which is used to get the value that a pointer is pointing to.  So this line says, &#8220;assign the address of <code>v2<\/code> to the value pointed to by <code>ptr<\/code>&#8220;.  The value pointed to by <code>ptr<\/code> is an integer.  So this assignment doesn&#8217;t make any sense -- you can&#8217;t assign an address to an integer!<\/p>\n<p>The fifth line should be:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">ptr = &amp;v2;<\/code><\/pre>\n<p>This correctly assigns the address of <code>v2<\/code> to the pointer.\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/null-pointers\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.8<\/span>Null pointers\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pass-by-const-lvalue-reference\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.6<\/span>Pass by const lvalue reference\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Pointers are one of C++&#8217;s historical boogeymen, and a place where many aspiring C++ learners have gotten stuck. However, as you&#8217;ll see shortly, pointers are nothing to be scared of. In fact, pointers behave a lot like lvalue references. But before we explain that further, let&#8217;s do some setup. Related &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/99"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=99"}],"version-history":[{"count":71,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/99\/revisions"}],"predecessor-version":[{"id":18176,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/99\/revisions\/18176"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=99"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=99"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=99"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}