{"id":2559,"date":"2015-09-14T16:39:04","date_gmt":"2015-09-15T00:39:04","guid":{"rendered":"http:\/\/www.learncpp.com\/?p=2559"},"modified":"2024-07-22T14:17:52","modified_gmt":"2024-07-22T21:17:52","slug":"introduction-to-stdarray","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-stdarray\/","title":{"rendered":"17.1 &#8212; Introduction to std::array"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-containers-and-arrays\/\">16.1 -- Introduction to containers and arrays<\/a>, we introduced containers and arrays.  To summarize:<\/p>\n<ul>\n<li>Containers provide storage for a collection of unnamed objects (called elements).\n<\/li>\n<li>Arrays allocate their elements contiguously in memory, and allow fast, direct access to any element via subscripting.\n<\/li>\n<li>C++ has three different array types that are commonly used: <code>std::vector<\/code>, <code>std::array<\/code>, and C-style arrays.\n<\/li>\n<\/ul>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdvector-resizing-and-capacity\/\">16.10 -- std::vector resizing and capacity<\/a>, we mentioned that arrays fall into two categories:<\/p>\n<ul>\n<li>Fixed-size arrays (also called fixed-length arrays) require that the length of the array be known at the point of instantiation, and that length cannot be changed afterward.    C-style arrays and <code>std::array<\/code> are both fixed-size arrays.\n<\/li>\n<li>Dynamic arrays can be resized at runtime.  <code>std::vector<\/code> is a dynamic array.\n<\/li>\n<\/ul>\n<p>In the previous chapter, we focused on <code>std::vector<\/code>, as it is fast, comparatively easy to use, and versatile.  This makes it our go-to type when we need an array container.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">So why not use dynamic arrays for everything?<\/p>\n<p>Dynamic arrays are powerful and convenient, but like everything in life, they make some tradeoffs for the benefits they offer.<\/p>\n<ul>\n<li><code>std::vector<\/code> is slightly less performant than the fixed-size arrays.  In most cases you probably won&#8217;t notice the difference (unless you&#8217;re writing sloppy code that causes lots of inadvertent reallocations).\n<\/li>\n<li><code>std::vector<\/code> only supports <code>constexpr<\/code> in very limited contexts.\n<\/li>\n<\/ul>\n<p>In modern C++, it is really this latter point that&#8217;s significant.  Constexpr arrays offer the ability to write code that is more robust, and can also be optimized more highly by the compiler.  Whenever we can use a constexpr array, we should -- and if we need a constexpr array, <code>std::array<\/code> is the container class we should be using.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Use <code>std::array<\/code> for constexpr arrays, and <code>std::vector<\/code> for non-constexpr arrays.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Defining a <code>std::array<\/code><\/p>\n<p><code>std::array<\/code> is defined in the &lt;array&gt; header.  It is designed to work similarly to <code>std::vector<\/code>, and as you&#8217;ll see, there are more similarities than differences between the two.<\/p>\n<p>One difference is in how we declare a <code>std::array<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;  \/\/ for std::array\r\n#include &lt;vector&gt; \/\/ for std::vector\r\n\r\nint main()\r\n{\r\n    std::array&lt;int, 5&gt; a {};  \/\/ a std::array of 5 ints\r\n\r\n    std::vector&lt;int&gt; b(5);    \/\/ a std::vector of 5 ints (for comparison)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Our <code>std::array<\/code> declaration has two template arguments.  The first (<code>int<\/code>) is a type template argument defining the type of the array element.  The second (<code>5<\/code>) is an integral non-type template argument defining the array length.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We cover non-type template parameters in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/non-type-template-parameters\/\">11.9 -- Non-type template parameters<\/a>.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">The length of a <code>std::array<\/code> must be a constant expression<\/p>\n<p>Unlike a <code>std::vector<\/code>, which can be resized at runtime, the length of a <code>std::array<\/code> must be a constant expression.  Most often, the value provided for the length will be an integer literal, constexpr variable, or an unscoped enumerator.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n\r\nint main()\r\n{\r\n    std::array&lt;int, 7&gt; a {}; \/\/ Using a literal constant\r\n\r\n    constexpr int len { 8 };\r\n    std::array&lt;int, len&gt; b {}; \/\/ Using a constexpr variable\r\n\r\n    enum Colors\r\n    {\r\n         red,\r\n         green,\r\n         blue,\r\n         max_colors\r\n    };\r\n\r\n    std::array&lt;int, max_colors&gt; c {}; \/\/ Using an enumerator\r\n\r\n#define DAYS_PER_WEEK 7\r\n    std::array&lt;int, DAYS_PER_WEEK&gt; d {}; \/\/ Using a macro (don't do this, use a constexpr variable instead)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Note that non-const variables and runtime constants cannot be used for the length:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nvoid foo(const int length) \/\/ length is a runtime constant\r\n{\r\n    std::array&lt;int, length&gt; e {}; \/\/ error: length is not a constant expression\r\n}\r\n\r\nint main()\r\n{\r\n    \/\/ using a non-const variable\r\n    int numStudents{};\r\n    std::cin &gt;&gt; numStudents; \/\/ numStudents is non-constant\r\n\r\n    std::array&lt;int, numStudents&gt; {}; \/\/ error: numStudents is not a constant expression\r\n\r\n    foo(7);\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<div class=\"cpp-note cpp-lightredbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Warning<\/p>\n<p>Perhaps surprisingly, a <code>std::array<\/code> can be defined with a length of 0:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    std::array&lt;int, 0&gt; arr {}; \/\/ creates a zero-length std::array\r\n    std::cout &lt;&lt; arr.empty();  \/\/ true if arr is zero-length\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>A zero-length <code>std::array<\/code> is a special-case class that has no data.  As such, calling any member function that accesses the data of a zero-length <code>std::array<\/code> (including <code>operator[]<\/code>) will produce undefined behavior.<\/p>\n<p>You can test whether a <code>std::array<\/code> is zero-length using the <code>empty()<\/code> member function, which returns <code>true<\/code> if the array is zero-length and <code>false<\/code> otherwise.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Aggregate initialization of a <code>std::array<\/code><\/p>\n<p>Perhaps surprisingly, <code>std::array<\/code> is an aggregate.  This means it has no constructors, and instead is initialized using aggregate initialization.  As a quick recap, aggregate initialization allows us to directly initialize the members of aggregates. To do this, we provide an initializer list, which is a brace-enclosed list of comma-separated initialization values.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Related content<\/p>\n<p>We covered aggregate initialization for structs in lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/struct-aggregate-initialization\/\">13.8 -- Struct aggregate initialization<\/a>.\n<\/p><\/div>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n\r\nint main()\r\n{\r\n    std::array&lt;int, 6&gt; fibonnaci = { 0, 1, 1, 2, 3, 5 }; \/\/ copy-list initialization using braced list\r\n    std::array&lt;int, 5&gt; prime { 2, 3, 5, 7, 11 };         \/\/ list initialization using braced list (preferred)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Each of these initialization forms initializes the array members in sequence, starting with element 0.<\/p>\n<p>If a <code>std::array<\/code> is defined without an initializer, the elements will be default initialized.  In most cases, this will result in elements being left uninitialized.<\/p>\n<p>Because we generally want our elements to be initialized, <code>std::array<\/code> should be value initialized (using empty braces) when defined with no initializers.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;vector&gt;\r\n\r\nint main()\r\n{\r\n    std::array&lt;int, 5&gt; a;   \/\/ Members default initialized (int elements are left uninitialized)\r\n    std::array&lt;int, 5&gt; b{}; \/\/ Members value initialized (int elements are zero initialized) (preferred)\r\n\r\n    std::vector&lt;int&gt; v(5);  \/\/ Members value initialized (int elements are zero initialized) (for comparison)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>If more initializers are provided in an initializer list than the defined array length, the compiler will error.  If fewer initializers are provided in an initializer list than the defined array length, the remaining elements without initializers are value initialized:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n\r\nint main()\r\n{\r\n    std::array&lt;int, 4&gt; a { 1, 2, 3, 4, 5 }; \/\/ compile error: too many initializers\r\n    std::array&lt;int, 4&gt; b { 1, 2 };          \/\/ b[2] and b[3] are value initialized\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Const and constexpr <code>std::array<\/code><\/p>\n<p>A <code>std::array<\/code> can be const:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n\r\nint main()\r\n{\r\n    const std::array&lt;int, 5&gt; prime { 2, 3, 5, 7, 11 };\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Even though the elements of a <code>const std::array<\/code> are not explicitly marked as const, they are still treated as const (because the whole array is const).<\/p>\n<p><code>std::array<\/code> also has full support for constexpr:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n\r\nint main()\r\n{\r\n    constexpr std::array&lt;int, 5&gt; prime { 2, 3, 5, 7, 11 };\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This support for constexpr is the key reason to use <code>std::array<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Define your <code>std::array<\/code> as constexpr whenever possible.  If your <code>std::array<\/code> is not constexpr, consider using a <code>std::vector<\/code> instead.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Class template argument deduction (CTAD) for <code>std::array<\/code> <span class=\"cpp-section-pill cpp-section-standard\">C++17<\/span><\/p>\n<p>Using CTAD (class template argument deduction) in C++17, we can have the compiler deduce both the element type and the array length of a <code>std::array<\/code> from a list of initializers:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    constexpr std::array a1 { 9, 7, 5, 3, 1 }; \/\/ The type is deduced to std::array&lt;int, 5&gt;\r\n    constexpr std::array a2 { 9.7, 7.31 };     \/\/ The type is deduced to std::array&lt;double, 2&gt;\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>We favor this syntax whenever practical.  If your compiler is not C++17 capable, you&#8217;ll need to explicitly provide the type and length template arguments.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Use class template argument deduction (CTAD) to have the compiler deduce the type and length of a <code>std::array<\/code> from its initializers.\n<\/div>\n<p>CTAD does not support partial omission of template arguments (as of C++23), so there is no way to use a core language feature to omit just the length or just the type of a <code>std::array<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    constexpr std::array&lt;int&gt; a2 { 9, 7, 5, 3, 1 };     \/\/ error: too few template arguments (length missing)\r\n    constexpr std::array&lt;5&gt; a2 { 9, 7, 5, 3, 1 };       \/\/ error: too few template arguments (type missing)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Omitting just the array length using <code>std::to_array<\/code> <span class=\"cpp-section-pill cpp-section-standard\">C++20<\/span><\/p>\n<p>However, TAD (template argument deduction, used for function template resolution) does support partial omission of template arguments.  Since C++20, it is possible to omit the array length of a <code>std::array<\/code> by using the <code>std::to_array<\/code> helper function:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    constexpr auto myArray1 { std::to_array&lt;int, 5&gt;({ 9, 7, 5, 3, 1 }) }; \/\/ Specify type and size\r\n    constexpr auto myArray2 { std::to_array&lt;int&gt;({ 9, 7, 5, 3, 1 }) };    \/\/ Specify type only, deduce size\r\n    constexpr auto myArray3 { std::to_array({ 9, 7, 5, 3, 1 }) };         \/\/ Deduce type and size\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Unfortunately, using <code>std::to_array<\/code> is more expensive than creating a <code>std::array<\/code> directly, because it involves creation of a temporary <code>std::array<\/code> that is then used to copy initialize our desired <code>std::array<\/code>.  For this reason, <code>std::to_array<\/code> should only be used in cases where the type can&#8217;t be effectively determined from the initializers, and should be avoided when an array is created many times (e.g. inside a loop).<\/p>\n<p>For example, because there is no way to specify a literal of type <code>short<\/code>, you could use the following to create an <code>std::array<\/code> of <code>short<\/code> values (without having to explicitly specify the length of the <code>std::array<\/code>):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    constexpr auto shortArray { std::to_array&lt;short&gt;({ 9, 7, 5, 3, 1 }) };\r\n    std::cout &lt;&lt; sizeof(shortArray[0]) &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Accessing array elements using <code>operator[]<\/code><\/p>\n<p>Just like a <code>std::vector<\/code>, the most common way to access elements of a <code>std::array<\/code> is by using the subscript operator (<code>operator[]<\/code>):<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt; \/\/ for std::array\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    constexpr std::array&lt;int, 5&gt; prime{ 2, 3, 5, 7, 11 };\r\n\r\n    std::cout &lt;&lt; prime[3]; \/\/ print the value of element with index 3 (7)\r\n    std::cout &lt;&lt; prime[9]; \/\/ invalid index (undefined behavior)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>As a reminder, <code>operator[]<\/code> does not do bounds checking.  If an invalid index is provided, undefined behavior will result.<\/p>\n<p>We&#8217;ll discuss a few other ways to index a <code>std::array<\/code> in the next lesson.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<p class=\"cpp-quiz-question\" style=\"clear: both\">Question #1<\/p>\n<p>What type of initialization does <code>std::array<\/code> use?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<p><code>std::array<\/code> is an aggregate, so it uses aggregate initialization.\n<\/div>\n<p>Why should you explicitly value-initialize a <code>std::array<\/code> if you are not providing initialization values?<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p>A <code>std::array<\/code> will default initialize members if no initializers are provided.  This will leave elements of most types uninitialized.\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #2<\/p>\n<p>Define a <code>std::array<\/code> that will hold the high temperature for each day of the year (to the nearest tenth of a degree).<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n\r\nstd::array&lt;double, 365&gt; highTemp {};<\/code><\/pre>\n<\/div>\n<p class=\"cpp-quiz-question cpp-topline\" style=\"clear: both\">Question #3<\/p>\n<p>Initialize a <code>std::array<\/code> with the following values: &#8216;h&#8217;, &#8216;e&#8217;, &#8216;l&#8217;, &#8216;l&#8217;, &#8216;o&#8217;.  Print the value of the element with index 1.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;array&gt;\r\n#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n        constexpr std::array arr { 'h', 'e', 'l', 'l', 'o' };\r\n        std::cout &lt;&lt; arr[1] &lt;&lt; '\\n';\r\n\r\n        return 0;\r\n}<\/code><\/pre>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/stdarray-length-and-indexing\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">17.2<\/span>std::array length and indexing\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/chapter-16-summary-and-quiz\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">16.x<\/span>Chapter 16 summary and quiz\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , we introduced containers and arrays. To summarize: Containers provide storage for a collection of unnamed objects (called elements). Arrays allocate their elements contiguously in memory, and allow fast, direct access to any element via subscripting. C++ has three different array types that are commonly used: std::vector, std::array, &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/2559"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=2559"}],"version-history":[{"count":73,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/2559\/revisions"}],"predecessor-version":[{"id":2674,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/2559\/revisions\/2674"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=2559"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=2559"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=2559"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}