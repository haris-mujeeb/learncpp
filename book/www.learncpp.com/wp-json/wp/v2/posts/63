{"id":63,"date":"2007-06-17T11:14:44","date_gmt":"2007-06-17T19:14:44","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/37-converting-between-binary-and-decimal\/"},"modified":"2025-02-18T21:06:42","modified_gmt":"2025-02-19T05:06:42","slug":"converting-integers-between-binary-and-decimal-representation","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/converting-integers-between-binary-and-decimal-representation\/","title":{"rendered":"O.4 &#8212; Converting integers between binary and decimal representation"},"content":{"rendered":"<p>Consider a decimal integral value, such as 5623.  We intuitively understand that these digits mean (5 * 1000) + (6 * 100) + (2 * 10) + (3 * 1).  Because there are 10 decimal numbers, the value of each subsequent digit to the left increases by a factor of 10.<\/p>\n<p>Binary numbers work the same way, except because there are only 2 binary digits (0 and 1), the value of each digit increases by a factor of 2.  Just like commas are often used to make a large decimal number easy to read (e.g. 1,427,435), we often write binary numbers in groups of 4 bits to make them easier to read (e.g. 1101&nbsp;0101).<\/p>\n<p style=\"clear: both\">The following table counts to 15 in decimal and binary:<\/p>\n<p> <!-- break around image --><\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<th>Decimal Value<\/th>\n<th style=\"text-align:right\">Binary Value<\/th>\n<\/tr>\n<tr>\n<td>0<\/td>\n<td style=\"text-align:right\">0<\/td>\n<\/tr>\n<tr>\n<td>1<\/td>\n<td style=\"text-align:right\">1<\/td>\n<\/tr>\n<tr>\n<td>2<\/td>\n<td style=\"text-align:right\">10<\/td>\n<\/tr>\n<tr>\n<td>3<\/td>\n<td style=\"text-align:right\">11<\/td>\n<\/tr>\n<tr>\n<td>4<\/td>\n<td style=\"text-align:right\">100<\/td>\n<\/tr>\n<tr>\n<td>5<\/td>\n<td style=\"text-align:right\">101<\/td>\n<\/tr>\n<tr>\n<td>6<\/td>\n<td style=\"text-align:right\">110<\/td>\n<\/tr>\n<tr>\n<td>7<\/td>\n<td style=\"text-align:right\">111<\/td>\n<\/tr>\n<tr>\n<td>8<\/td>\n<td style=\"text-align:right\">1000<\/td>\n<\/tr>\n<tr>\n<td>9<\/td>\n<td style=\"text-align:right\">1001<\/td>\n<\/tr>\n<tr>\n<td>10<\/td>\n<td style=\"text-align:right\">1010<\/td>\n<\/tr>\n<tr>\n<td>11<\/td>\n<td style=\"text-align:right\">1011<\/td>\n<\/tr>\n<tr>\n<td>12<\/td>\n<td style=\"text-align:right\">1100<\/td>\n<\/tr>\n<tr>\n<td>13<\/td>\n<td style=\"text-align:right\">1101<\/td>\n<\/tr>\n<tr>\n<td>14<\/td>\n<td style=\"text-align:right\">1110<\/td>\n<\/tr>\n<tr>\n<td>15<\/td>\n<td style=\"text-align:right\">1111<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Converting binary to decimal<\/p>\n<p>In the following examples, we assume that we&#8217;re dealing with unsigned integers.<\/p>\n<p>Consider the 8 bit (1 byte) binary number 0101 1110.  Binary 0101 1110 means (0 * 128) + (1 * 64) + (0 * 32) + (1 * 16) + (1 * 8) + (1 * 4) + (1 * 2) + (0 * 1).  If we sum up all of these parts, we get the decimal number 64 + 16 + 8 + 4 + 2 = 94.<\/p>\n<p>Here is the same process in table format.  We multiply each binary digit by its digit value (determined by its position).  Summing up all these values gives us the total.<\/p>\n<p>Converting 0101 1110 to decimal:<\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<td>Binary digit<\/td>\n<td>0&nbsp;&nbsp;<\/td>\n<td>1&nbsp;&nbsp;<\/td>\n<td>0&nbsp;&nbsp;<\/td>\n<td>1&nbsp;&nbsp;<\/td>\n<td>1&nbsp;&nbsp;<\/td>\n<td>1&nbsp;&nbsp;<\/td>\n<td>1&nbsp;&nbsp;<\/td>\n<td>0&nbsp;&nbsp;<\/td>\n<\/tr>\n<tr>\n<td>* Digit value<\/td>\n<td>128<\/td>\n<td>64<\/td>\n<td>32<\/td>\n<td>16<\/td>\n<td>8<\/td>\n<td>4<\/td>\n<td>2<\/td>\n<td>1<\/td>\n<\/tr>\n<tr>\n<td>= Total (94)<\/td>\n<td>0<\/td>\n<td>64<\/td>\n<td>0<\/td>\n<td>16<\/td>\n<td>8<\/td>\n<td>4<\/td>\n<td>2<\/td>\n<td>0<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>Let&#8217;s convert 1001 0111 to decimal:<\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<td>Binary digit<\/td>\n<td>1&nbsp;&nbsp;<\/td>\n<td>0&nbsp;&nbsp;<\/td>\n<td>0&nbsp;&nbsp;<\/td>\n<td>1&nbsp;&nbsp;<\/td>\n<td>0&nbsp;&nbsp;<\/td>\n<td>1&nbsp;&nbsp;<\/td>\n<td>1&nbsp;&nbsp;<\/td>\n<td>1&nbsp;&nbsp;<\/td>\n<\/tr>\n<tr>\n<td>* Digit value<\/td>\n<td>128<\/td>\n<td>64<\/td>\n<td>32<\/td>\n<td>16<\/td>\n<td>8<\/td>\n<td>4<\/td>\n<td>2<\/td>\n<td>1<\/td>\n<\/tr>\n<tr>\n<td>= Total (151)<\/td>\n<td>128<\/td>\n<td>0<\/td>\n<td>0<\/td>\n<td>16<\/td>\n<td>0<\/td>\n<td>4<\/td>\n<td>2<\/td>\n<td>1<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>1001 0111 binary = 151 in decimal.<\/p>\n<p>This can easily be extended to 16 or 32 bit binary numbers simply by adding more columns.  Note that it&#8217;s easiest to start on the right end, and work your way left, multiplying the digit value by 2 as you go.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Method 1 for converting decimal to binary<\/p>\n<p>Converting from decimal to binary is a little more tricky, but still pretty straightforward.  There are a few good methods to do this.<\/p>\n<p>In this first method, you continually divide by 2, and write down the remainders.  The binary number is constructed at the end from the remainders, from the bottom up.<\/p>\n<p>Converting 148 from decimal to binary (using r to denote a remainder):<\/p>\n<p>148 \/ 2 = 74 r0<br \/>\n74 \/ 2 = 37 r0<br \/>\n37 \/ 2 = 18 r1<br \/>\n18 \/ 2 = 9 r0<br \/>\n9 \/ 2 = 4 r1<br \/>\n4 \/ 2 = 2 r0<br \/>\n2 \/ 2 = 1 r0<br \/>\n1 \/ 2 = 0 r1<\/p>\n<p>Writing all of the remainders from the bottom up: 1001 0100<\/p>\n<p>148 decimal = 1001 0100 binary.<\/p>\n<p>You can verify this answer by converting the binary back to decimal:<\/p>\n<p>(1 * 128) + (0 * 64) + (0 * 32) + (1 * 16) + (0 * 8) + (1 * 4) + (0 * 2) + (0 * 1) = 148<\/p>\n<p>This method is the best for humans, as it only involves dividing by 2.  It is less good for machines because it requires storing all of the bits as they are calculated so they can be printed in reverse order later.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Method 2 for converting decimal to binary<\/p>\n<p>In the remaining two methods, we&#8217;ll work forwards, calculating each bit as we go, so that we don&#8217;t have to reconstruct the binary number at the end.<\/p>\n<p>Consider the decimal number 148 again.  The largest power of 2 that&#8217;s smaller than 148 is 128, so we&#8217;ll start there.<\/p>\n<p>Is 148 >= 128?  Yes, so the 128 bit must be 1.  148 - 128 = 20, which means we need to find bits worth 20 more.<br \/>\nIs 20 >= 64?  No, so the 64 bit must be 0.<br \/>\nIs 20 >= 32?  No, so the 32 bit must be 0.<br \/>\nIs 20 >= 16?  Yes, so the 16 bit must be 1.  20 - 16 = 4, which means we need to find bits worth 4 more.<\/p>\n<p>Is 4 >= 8?  No, so the 8 bit must be 0.<br \/>\nIs 4 >= 4?  Yes, so the 4 bit must be 1.  4 - 4 = 0, which means all the rest of the bits must be 0.<\/p>\n<p>148 = (1 * 128) + (0 * 64) + (0 * 32) + (1 * 16) + (0 * 8) + (1 * 4) + (0 * 2) + (0 * 1) = 1001 0100<\/p>\n<p>In table format:<\/p>\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<td>Binary number<\/td>\n<td>1&nbsp;&nbsp;<\/td>\n<td>0&nbsp;&nbsp;<\/td>\n<td>0&nbsp;&nbsp;<\/td>\n<td>1&nbsp;&nbsp;<\/td>\n<td>0&nbsp;&nbsp;<\/td>\n<td>1&nbsp;&nbsp;<\/td>\n<td>0&nbsp;&nbsp;<\/td>\n<td>0&nbsp;&nbsp;<\/td>\n<\/tr>\n<tr>\n<td>* Digit value<\/td>\n<td>128<\/td>\n<td>64<\/td>\n<td>32<\/td>\n<td>16<\/td>\n<td>8<\/td>\n<td>4<\/td>\n<td>2<\/td>\n<td>1<\/td>\n<\/tr>\n<tr>\n<td>= Total (148)<\/td>\n<td>128<\/td>\n<td>0<\/td>\n<td>0<\/td>\n<td>16<\/td>\n<td>0<\/td>\n<td>4<\/td>\n<td>0<\/td>\n<td>0<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>This method is pretty easy for humans when the numbers are small (e.g. for 8-bit binary numbers).  It&#8217;s also pretty efficient for machines, since each bit requires a comparison, a subtraction, and an assignment.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Method 3 for converting decimal to binary<\/p>\n<p>This method is a variant of method 2 that uses integer division.  Consider the decimal number 148 yet again.  The largest power of 2 that&#8217;s smaller than 148 is 128, so we&#8217;ll start there.<\/p>\n<p>148 \/ 128 = 1 with some remainder.  Since 1 is odd, this bit is a 1.<br \/>\n148 \/ 64 = 2 with some remainder.  Since 2 is even, this bit is a 0.<br \/>\n148 \/ 32 = 4 with some remainder.  Since 4 is even, this bit is a 0.<br \/>\n148 \/ 16 = 9 with some remainder.  Since 9 is odd, this bit is a 1.<br \/>\n148 \/ 8 = 18 with some remainder.  Since 18 is even, this bit is a 0.<br \/>\n148 \/ 4 = 37 with some remainder.  Since 37 is odd, this bit is a 1.<br \/>\n148 \/ 2 = 74 with some remainder.  Since 74 is even, this bit is a 0.<br \/>\n148 \/ 1 = 148 with some remainder.  Since 148 is even, this bit is a 0.<\/p>\n<p>148 = (1 * 128) + (0 * 64) + (0 * 32) + (1 * 16) + (0 * 8) + (1 * 4) + (0 * 2) + (0 * 1) = 1001 0100<\/p>\n<p>This method isn&#8217;t great for humans, as it requires a lot of division.  It&#8217;s also less efficient for machines since division is an inefficient operation.  But it is easy to write in code since it requires no if-statements.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Another example<\/p>\n<p>Let&#8217;s convert 117 to binary using method 1:<\/p>\n<p>117 \/ 2 = 58 r1<br \/>\n58 \/ 2 = 29 r0<br \/>\n29 \/ 2 = 14 r1<br \/>\n14 \/ 2 = 7 r0<br \/>\n7 \/ 2 = 3 r1<br \/>\n3 \/ 2 = 1 r1<br \/>\n1 \/ 2 = 0 r1<\/p>\n<p>Constructing the number from the remainders from the bottom up, 117 = 111 0101 binary<\/p>\n<p>And using method 2:<\/p>\n<p>The largest power of 2 less than 117 is 64.<\/p>\n<p>Is 117 >= 64?  Yes, so the 64 bit must be 1.  117 - 64 = 53.<br \/>\nIs 53 >= 32?  Yes, so the 32 bit must be 1.  53 - 32 = 21.<br \/>\nIs 21 >= 16?  Yes, so the 16 bit must be 1.  21 - 16 = 5.<\/p>\n<p>Is 5 >= 8?  No, so the 8 bit must be 0.<br \/>\nIs 5 >= 4?  Yes, so the 4 bit must be 1.  5 - 4 = 1.<br \/>\nIs 1 >= 2?  No, so the 2 bit must be 0.<br \/>\nIs 1 >= 1?  Yes, so the 1 bit must be 1.<\/p>\n<p>117 decimal = 111 0101 binary.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Adding in binary<\/p>\n<p>In some cases (we&#8217;ll see one in just a moment), it&#8217;s useful to be able to add two binary numbers.  Adding binary numbers is surprisingly easy (maybe even easier than adding decimal numbers), although it may seem odd at first because you&#8217;re not used to it.<\/p>\n<p>Consider two small binary numbers:<br \/>\n0110 (6 in decimal) +<br \/>\n0111 (7 in decimal)<\/p>\n<p>Let&#8217;s add these.  First, line them up, as we have above.  Then, starting from the right and working left, we add each column of digits, just like we do in a decimal number.  However, because a binary digit can only be a 0 or a 1, there are only 4 possibilities:<\/p>\n<ul>\n<li>0 + 0 = 0<\/li>\n<li>0 + 1 = 1<\/li>\n<li>1 + 0 = 1<\/li>\n<li>1 + 1 = 0, carry a 1 over to the next column<\/li>\n<\/ul>\n<p>Let&#8217;s do the first column:<\/p>\n<pre>\r\n0110 (6 in decimal) +\r\n0111 (7 in decimal)\r\n----\r\n   1\r\n<\/pre>\n<p>0 + 1 = 1.  Easy.<\/p>\n<p>Second column:<\/p>\n<pre>\r\n 1\r\n0110 (6 in decimal) +\r\n0111 (7 in decimal)\r\n----\r\n  01\r\n<\/pre>\n<p>1 + 1 = 0, with a carried 1 into the next column<\/p>\n<p>Third column:<\/p>\n<pre>\r\n11\r\n0110 (6 in decimal) +\r\n0111 (7 in decimal)\r\n----\r\n 101\r\n<\/pre>\n<p>This one is a little trickier.  Normally, 1 + 1 = 0, with a carried one into the next column.  However, we already have a 1 carried from the previous column, so we need to add 1.  Thus, we end up with a 1 in this column, with a 1 carried over to the next column.<\/p>\n<p>Last column:<\/p>\n<pre>\r\n11\r\n0110 (6 in decimal) +\r\n0111 (7 in decimal)\r\n----\r\n1101\r\n<\/pre>\n<p>0 + 0 = 0, but there&#8217;s a carried 1, so we add 1.  1101 = 13 in decimal.<\/p>\n<p>Now, how do we add 1 to any given binary number (such as 1011 0011)?  The same as above, only the bottom number is binary 1.<\/p>\n<pre>\r\n      11  (carry column)\r\n1011 0011 (original binary number)\r\n0000 0001 (1 in binary)\r\n---------\r\n1011 0100\r\n<\/pre>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Signed numbers and two&#8217;s complement<\/p>\n<p>In the above examples, we&#8217;ve dealt solely with unsigned integers.  In this section, we&#8217;ll take a look at how signed numbers (which can be negative) are dealt with.<\/p>\n<p>Signed integers are typically stored using a method known as <strong>two&#8217;s complement<\/strong>.  In two&#8217;s complement, the leftmost (most significant) bit is used as the sign bit.  A 0 sign bit means the number is positive (or zero), and a 1 sign bit means the number is negative.<\/p>\n<p>Positive signed numbers are represented in binary just like positive unsigned numbers (with the sign bit set to 0).<\/p>\n<p>Negative signed numbers are represented in binary as the bitwise inverse of the positive number, plus 1.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Converting decimal to binary (two&#8217;s complement)<\/p>\n<p>For example, here&#8217;s how we represent -5 in binary two&#8217;s complement:<\/p>\n<p>First we figure out the binary representation for 5: 0000 0101<br \/>\nThen we invert all of the bits: 1111 1010<br \/>\nThen we add 1: 1111 1011<\/p>\n<p>Converting -76 to binary:<\/p>\n<p>Positive 76 in binary: 0100 1100<br \/>\nInvert all the bits: 1011 0011<br \/>\nAdd 1: 1011 0100<\/p>\n<p>Why do we add 1?  Consider the number 0.  If a negative value was simply represented as the inverse of the positive number (called &#8220;one&#8217;s complement&#8221;), 0 would have two representations: 0000 0000 (positive zero) and 1111 1111 (negative zero).  By adding 1, 1111 1111 intentionally overflows and becomes 0000 0000.  This prevents 0 from having two representations, and simplifies some of the internal logic needed to do arithmetic with negative numbers.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Converting binary (two&#8217;s complement) to decimal<\/p>\n<p>To convert a two&#8217;s complement binary number back into decimal, first look at the sign bit.<\/p>\n<p>If the sign bit is 0, just convert the number as shown for unsigned numbers above.<\/p>\n<p>If the sign bit is 1, then we invert the bits, add 1, then convert to decimal, then make that decimal number negative (because the sign bit was originally negative).<\/p>\n<p>For example, to convert 1001 1110 from two&#8217;s complement into a decimal number:<br \/>\nGiven: 1001 1110<br \/>\nInvert the bits: 0110 0001<br \/>\nAdd 1: 0110 0010<br \/>\nConvert to decimal: (0 * 128) + (1 * 64) + (1 * 32) + (0 * 16) + (0 * 8) + (0 * 4) + (1 * 2) + (0 * 1) = 64 + 32 + 2 = 98<br \/>\nSince the original sign bit was negative, the final value is -98.<\/p>\n<p>There is another method that is easier to calculate by hand.  In this method, the sign bit represents a negative value, all the other bits represent positive values.<\/p>\n<p>Given: 1001 1110<br \/>\nConvert to decimal: (1 * -128) + (0 * 64) + (0 * 32) + (1 * 16) + (1 * 8) + (1 * 4) + (1 * 2) + (0 * 1) = -128 + 16 + 8 + 4 + 2 = -98<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Why types matter<\/p>\n<p>Consider the binary value 1011 0100.  What value does this represent?  You&#8217;d probably say 180, and if this were an unsigned binary number, you&#8217;d be right.<\/p>\n<p>However, if this value was stored using two&#8217;s complement, it would be -76.<\/p>\n<p>And if the value were encoded some other way, it could be something else entirely.<\/p>\n<p>So how does C++ know whether to print a variable containing binary 1011 0100 as 180 or -76?<\/p>\n<p>In case the section title didn&#8217;t give it away, this is where types come into play.  The type of the variable determines both how a variable&#8217;s value is encoded into binary, and decoded back into a value.  So if the variable type was an unsigned integer, it would know that 1011 0100 was standard binary, and should be printed as 180.  If the variable was a signed integer, it would know that 1011 0100 was encoded using two&#8217;s complement (now guaranteed as of C++20), and should be printed as -76.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">What about converting floating point numbers from\/to binary?<\/p>\n<p>How floating point numbers get converted from\/to binary is quite a bit more complicated, and not something you&#8217;re likely to ever need to know.  However, if you&#8217;re curious, see <a href=\"http:\/\/www.tfinley.net\/notes\/cps104\/floating.html\">this site<\/a>, which does a good job of explaining the topic in detail.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Quiz time<\/p>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #1<\/p>\n<p>\nConvert 0100 1101 to decimal.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_0'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_0\" style=\"display:none\">\n<div class=\"cpp-table-wrapper\"><table class=\"cpp-table\"><\/p>\n<tr>\n<td>Binary digit<\/td>\n<td>0&nbsp;&nbsp;<\/td>\n<td>1&nbsp;&nbsp;<\/td>\n<td>0&nbsp;&nbsp;<\/td>\n<td>0&nbsp;&nbsp;<\/td>\n<td>1&nbsp;&nbsp;<\/td>\n<td>1&nbsp;&nbsp;<\/td>\n<td>0&nbsp;&nbsp;<\/td>\n<td>1&nbsp;&nbsp;<\/td>\n<\/tr>\n<tr>\n<td>* Digit value<\/td>\n<td>128<\/td>\n<td>64<\/td>\n<td>32<\/td>\n<td>16<\/td>\n<td>8<\/td>\n<td>4<\/td>\n<td>2<\/td>\n<td>1<\/td>\n<\/tr>\n<tr>\n<td>= Total (77)<\/td>\n<td>0<\/td>\n<td>64<\/td>\n<td>0<\/td>\n<td>0<\/td>\n<td>8<\/td>\n<td>4<\/td>\n<td>0<\/td>\n<td>1<\/td>\n<\/tr>\n<p><\/table><\/div>\n<p>The answer is 77.\n<\/p><\/div>\n<\/p>\n<\/div>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #2<\/p>\n<p>\nConvert 93 to an 8-bit unsigned binary number, using both methods 1 and 2 above.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_1'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_1\" style=\"display:none\">\n<p>Using method 1:<br \/>\n93 \/ 2 = 46 r1<br \/>\n46 \/ 2 = 23 r0<br \/>\n23 \/ 2 = 11 r1<br \/>\n11 \/ 2 = 5 r1<br \/>\n5 \/ 2 = 2 r1<br \/>\n2 \/ 2 = 1 r0<br \/>\n1 \/ 2 = 0 r1<\/p>\n<p>Working backwards from the remainders: 101 1101<\/p>\n<p>Using method 2:<br \/>\nThe largest power of 2 less than 93 is 64.<\/p>\n<p>Is 93 >= 64?  Yes, so the 64 bit is 1.  93 - 64 = 29.<br \/>\nIs 29 >= 32?  No, so the 32 bit is 0.<br \/>\nIs 29 >= 16?  Yes, so the 16 bit is 1.  29 - 16 = 13.<br \/>\nIs 13 >= 8?  Yes, so the 8 bit is 1.  13 - 8 = 5.<br \/>\nIs 5 >= 4?  Yes, so the 4 bit is 1.  5 - 4 = 1.<br \/>\nIs 1 >= 2?  No, so the 2 bit is 0.<br \/>\nIs 1 >= 1?  Yes, so the 1 bit is 1.<\/p>\n<p>The answer is 0101 1101.\n<\/p><\/div>\n<\/p>\n<\/div>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #3<\/p>\n<p>\nConvert -93 to an 8-bit signed binary number (using two&#8217;s complement).<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_2'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_2\" style=\"display:none\">\n<p>We already know that 93 is 0101 1101 from the previous answer.<br \/>\nFor two&#8217;s complement, we invert the bits: 1010 0010<br \/>\nAnd add 1: 1010 0011\n<\/p><\/div>\n<\/p>\n<\/div>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #4<\/p>\n<p>\nConvert 1010 0010 to an unsigned decimal number.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_3'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_3\" style=\"display:none\">\n<p>Working right to left:<br \/>\n1010 0010 = (0 * 1) + (1 * 2) + (0 * 4) + (0 * 8) + (0 * 16) + (1 * 32) + (0 * 64) + (1 * 128) = 2 + 32 + 128 = 162.<\/p>\n<p>The answer is 162.\n<\/p><\/div>\n<\/p>\n<\/div>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #5<\/p>\n<p>\nConvert 1010 0010 to a signed decimal number (assume two&#8217;s complement).<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_4'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_4\" style=\"display:none\">\n<p>Since we&#8217;re told this number is in two&#8217;s complement, we can &#8220;undo&#8221; the two&#8217;s complement by inverting the bits and adding 1.<br \/>\nFirst, start with our binary number: 1010 0010<br \/>\nFlip the bits: 0101 1101<br \/>\nAdd 1: 0101 1110<\/p>\n<p>Convert to decimal: 64 + 16 + 8 + 4 + 2 = 94<br \/>\nRemember that this is a two&#8217;s complement #, and the original left bit was negative: -94<\/p>\n<p>The answer is -94\n<\/p><\/div>\n<\/p>\n<\/div>\n<div class=\"quiz\" style=\"clear: both\">\n<p class=\"quiz-header\">Question #6<\/p>\n<p>Write a program that asks the user to input a number between 0 and 255.  Print this number as an 8-bit binary number (of the form #### ####).  Don&#8217;t use any bitwise operators. Don&#8217;t use <code>std::bitset<\/code>.<\/p>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_0'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_0\" style=\"display:none; margin-bottom: 1em\">Hint: Use method 3.  Assume the largest power of 2 is 128.<\/div>\n<p><a class=\"hint_link_show\" href=\"javascript:void(0)\" onclick=\"cppHintToggle(document.getElementById('cpp_hint_id_1'), this, 'Show Hint', '')\">Show Hint<\/a><\/p>\n<div class=\"wphint\" id=\"cpp_hint_id_1\" style=\"display:none; margin-bottom: 1em\">Hint: You can determine whether a number is even or odd using the remainder operator (%)<\/div>\n<p>Reminder: <code>std::uint8_t<\/code> is usually treated as a char, not an int.  This may cause unexpected behavior when used with input or output.<\/p>\n<p><a class=\"solution_link_show\" href=\"javascript:void(0)\" onclick=\"cppSolutionToggle(document.getElementById('cpp_solution_id_5'), this, 'Show Solution', 'Hide Solution')\">Show Solution<\/a><\/p>\n<div class=\"wpsolution\" id=\"cpp_solution_id_5\" style=\"display:none\">\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printBit(int x, int pow)\r\n{\r\n    std::cout &lt;&lt; ((x \/ pow) % 2);\r\n}\r\n\r\nvoid print8BitBinary(int x)\r\n{\r\n    printBit(x, 128);\r\n    printBit(x, 64);\r\n    printBit(x, 32);\r\n    printBit(x, 16);\r\n\r\n    std::cout &lt;&lt; ' ';\r\n\r\n    printBit(x, 8);\r\n    printBit(x, 4);\r\n    printBit(x, 2);\r\n    printBit(x, 1);    \r\n}\r\n\r\nint main()\r\n{\r\n    std::cout &lt;&lt; \"Enter an integer between 0 and 255: \";\r\n    int x{};\r\n    std::cin &gt;&gt; x;\r\n\r\n    print8BitBinary(x);\r\n    \r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<\/div>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/compound-statements-blocks\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">7.1<\/span>Compound statements (blocks)\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/bit-manipulation-with-bitwise-operators-and-bit-masks\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">O.3<\/span>Bit manipulation with bitwise operators and bit masks\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>Consider a decimal integral value, such as 5623. We intuitively understand that these digits mean (5 * 1000) + (6 * 100) + (2 * 10) + (3 * 1). Because there are 10 decimal numbers, the value of each subsequent digit to the left increases by a factor of &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/63"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=63"}],"version-history":[{"count":48,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/63\/revisions"}],"predecessor-version":[{"id":18212,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/63\/revisions\/18212"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=63"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=63"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=63"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}