{"id":149,"date":"2007-10-30T12:54:51","date_gmt":"2007-10-30T20:54:51","guid":{"rendered":"http:\/\/www.learncpp.com\/cpp-tutorial\/910-overloading-typecasts\/"},"modified":"2025-03-14T12:09:44","modified_gmt":"2025-03-14T19:09:44","slug":"overloading-typecasts","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-typecasts\/","title":{"rendered":"21.11 &#8212; Overloading typecasts"},"content":{"rendered":"<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/explicit-type-conversion-casting-and-static-cast\/\">10.6 -- Explicit type conversion (casting) and static_cast<\/a>, you learned that C++ allows you to convert one data type to another.  The following example shows an int being converted into a double:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">int n{ 5 };\r\nauto d{ static_cast&lt;double&gt;(n) }; \/\/ int cast to a double<\/code><\/pre>\n<p>C++ already knows how to convert between the built-in data types.  However, by default, C++ doesn&#8217;t know how to convert any of our program-defined classes.<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/converting-constructors-and-the-explicit-keyword\/\">14.16 -- Converting constructors and the explicit keyword<\/a>, we showed how we can use a converting constructor to create a class type object from another type of object.  But this only works if the destination type is a class type that can be modified to add such a constructor.  What if this is not the case?<\/p>\n<p>Take a look at the following class:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Cents\r\n{\r\nprivate:\r\n    int m_cents{};\r\npublic:\r\n    Cents(int cents=0)\r\n        : m_cents{ cents }\r\n    {\r\n    }\r\n\r\n    int getCents() const { return m_cents; }\r\n    void setCents(int cents) { m_cents = cents; }\r\n};<\/code><\/pre>\n<p>This class is pretty simple: it holds some number of cents as an integer, and provides access functions to get and set the number of cents.  It also provides a constructor for converting an <code>int<\/code> into a <code>Cents<\/code>.<\/p>\n<p>If we can convert an <code>int<\/code> into a <code>Cents<\/code> (via a constructor), then we might also want to provide a way to convert a <code>Cents<\/code> back into an <code>int<\/code>.  In some cases, this might not be desirable, but it does make sense here.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Author&#8217;s note<\/p>\n<p>A poem:<\/p>\n<p>Converting our ints into some Cents<br \/>\nWill use a constructor that assents<br \/>\nOf course Cents to ints also make sense<br \/>\nBut the compiler errors and prevents.<\/p>\n<p>To allow such conversion events<br \/>\nWe give the compiler our consents<br \/>\nAnd then define how, for all intents<br \/>\nWe can transform these type of contents.<\/p>\n<p>So what&#8217;s the syntax that circumvents<br \/>\nThe compiler&#8217;s static type defense?<br \/>\nWe&#8217;ll detail just how quite soon, and hence<br \/>\nYou&#8217;ll no longer be kept in suspense.\n<\/p><\/div>\n<p>One not-great way is to use a conversion function.  In this example, we use member function <code>getCents()<\/code> to &#8220;convert&#8221; our <code>Cents<\/code> variable back into an <code>int<\/code> so we can print it using <code>printInt()<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printInt(int value)\r\n{\r\n    std::cout &lt;&lt; value;\r\n}\r\n\r\nint main()\r\n{\r\n    Cents cents{ 7 };\r\n    printInt(cents.getCents()); \/\/ print 7\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>While this function produces the result we want, it&#8217;s not truly a conversion, as the compiler won&#8217;t understand that it should use this function for casts or implicit conversion.  This also means that if we do a lot of <code>Cents<\/code> to <code>int<\/code> conversions, our code will be littered with calls to getCents(), which is messy.<\/p>\n<p>What else can we do?<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Overloading a typecast<\/p>\n<p>This is where overloading the typecast operators comes into play.  Such a typecast can be used explicitly (via a cast) or implicitly by the compiler to perform conversions as needed.<\/p>\n<p>Let&#8217;s show how we overload a typecast to define a conversion from <code>Cents<\/code> to <code>int<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Cents\r\n{\r\nprivate:\r\n    int m_cents{};\r\npublic:\r\n    Cents(int cents=0)\r\n        : m_cents{ cents }\r\n    {\r\n    }\r\n\r\n    \/\/ Overloaded int cast\r\n    operator int() const { return m_cents; }\r\n\r\n    int getCents() const { return m_cents; }\r\n    void setCents(int cents) { m_cents = cents; }\r\n};<\/code><\/pre>\n<p>To do so, we&#8217;ve written a new overloaded operator named <code>operator int()<\/code>.  Note that there is a space between the word operator and the type we are casting to.<\/p>\n<p>There are a few things worth noting here:<\/p>\n<ul>\n<li>Overloaded typecasts must be non-static members, and should be <code>const<\/code> so they can be used with const objects.\n<\/li>\n<li>Overloaded typecasts do not have explicit parameters, as there is no way to pass explicit arguments to them.  They do still have a hidden <code>*this<\/code> parameter, pointing to the implicit object (which is the object to be converted).\n<\/li>\n<li>Overloaded typecast do not declare a return type.  The name of the conversion (e.g. int) is used as the return type, as it is the only return type allowed.  This prevents redundancy in the declaration.\n<\/li>\n<\/ul>\n<p>Now in our example, we can call <code>printInt()<\/code> like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nint main()\r\n{\r\n    Cents cents{ 7 };\r\n    printInt(cents); \/\/ print 7\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>The compiler will first note that function <code>printInt()<\/code> has an <code>int<\/code> parameter.  Then it will note that variable <code>cents<\/code> is not an <code>int<\/code>.  Finally, it will look to see if we&#8217;ve provided a way to convert a <code>Cents<\/code> into an <code>int<\/code>.  Since we have, it will call our <code>operator int()<\/code> function, which returns an <code>int<\/code>, and the returned <code>int<\/code> will be passed to <code>printInt()<\/code>.<\/p>\n<p>Such typecasts can also be invoked explicitly via <code>static_cast<\/code>:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">std::cout &lt;&lt; static_cast&lt;int&gt;(cents);<\/code><\/pre>\n<p>You can provide overloaded typecasts for any data type you wish, including your own program-defined data types!<\/p>\n<p>Here&#8217;s a new class called <code>Dollars<\/code> that provides an overloaded <code>Cents<\/code> conversion:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">class Dollars\r\n{\r\nprivate:\r\n    int m_dollars{};\r\npublic:\r\n    Dollars(int dollars=0)\r\n        : m_dollars{ dollars }\r\n    {\r\n    }\r\n\r\n     \/\/ Allow us to convert Dollars into Cents\r\n     operator Cents() const { return Cents{ m_dollars * 100 }; }\r\n};<\/code><\/pre>\n<p>This allows us to convert a <code>Dollars<\/code> object directly into a <code>Cents<\/code> object!  This allows you to do something like this:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Cents\r\n{\r\nprivate:\r\n    int m_cents{};\r\npublic:\r\n    Cents(int cents=0)\r\n        : m_cents{ cents }\r\n    {\r\n    }\r\n\r\n    \/\/ Overloaded int cast\r\n    operator int() const { return m_cents; }\r\n\r\n    int getCents() const { return m_cents; }\r\n    void setCents(int cents) { m_cents = cents; }\r\n};\r\n\r\nclass Dollars\r\n{\r\nprivate:\r\n    int m_dollars{};\r\npublic:\r\n    Dollars(int dollars=0)\r\n        : m_dollars{ dollars }\r\n    {\r\n    }\r\n\r\n    \/\/ Allow us to convert Dollars into Cents\r\n    operator Cents() const { return Cents { m_dollars * 100 }; }\r\n};\r\n\r\nvoid printCents(Cents cents)\r\n{\r\n    std::cout &lt;&lt; cents; \/\/ cents will be implicitly cast to an int here\r\n}\r\n\r\nint main()\r\n{\r\n    Dollars dollars{ 9 };\r\n    printCents(dollars); \/\/ dollars will be implicitly cast to a Cents here\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Consequently, this program will print the value:<\/p>\n<pre>\n900\r\n<\/pre>\n<p>which makes sense, since 9 dollars is 900 cents!<\/p>\n<p>Although this demonstrates that such a thing is possible, in this case, adding a converting constructor to <code>Dollars<\/code> (with a parameter of type <code>Cents<\/code>) is actually preferable.  We&#8217;ll discuss why below.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Explicit typecasts<\/p>\n<p>Just like we can make constructors <code>explicit<\/code> so that they can&#8217;t be used for implicit conversions, we can also make our overloaded typecasts <code>explicit<\/code> for the same reason.  Explicit typecasts can only be invoked by casting (e.g. <code>static_cast<\/code>) or by a form of direct initialization (either parenthesis or brace).  They are not considered when doing copy-initialization.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nclass Cents\r\n{\r\nprivate:\r\n    int m_cents{};\r\npublic:\r\n    Cents(int cents=0)\r\n        : m_cents{ cents }\r\n    {\r\n    }\r\n\r\n    explicit operator int() const { return m_cents; } \/\/ now marked as explicit\r\n\r\n    int getCents() const { return m_cents; }\r\n    void setCents(int cents) { m_cents = cents; }\r\n};\r\n\r\nclass Dollars\r\n{\r\nprivate:\r\n    int m_dollars{};\r\npublic:\r\n    Dollars(int dollars=0)\r\n        : m_dollars{ dollars }\r\n    {\r\n    }\r\n\r\n    operator Cents() const { return Cents { m_dollars * 100 }; }\r\n};\r\n\r\nvoid printCents(Cents cents)\r\n{\r\n\/\/  std::cout &lt;&lt; cents;                   \/\/ no longer works because cents won't implicit convert to an int\r\n    std::cout &lt;&lt; static_cast&lt;int&gt;(cents); \/\/ we can use an explicit cast instead\r\n}\r\n\r\nint main()\r\n{\r\n    Dollars dollars{ 9 };\r\n    printCents(dollars); \/\/ implicit conversion from Dollars to Cents okay because its not marked as explicit\r\n\r\n    std::cout &lt;&lt; '\\n';\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>Typecasts should be generally be marked as explicit.  Exceptions can be made in cases where the conversion inexpensively converts to a similar user-defined type.  Our <code>Dollars::operator Cents()<\/code> typecast was left non-explicit because there is no reason not to let a <code>Dollars<\/code> object be used anywhere a <code>Cents<\/code> is expected.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>Just like single-parameter converting constructors should be marked as explicit, typecasts should be marked as explicit, except in cases where the type to be converted to is essentially synonymous with the destination type.\n<\/p><\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">When to use converting constructors vs overloaded typecasts<\/p>\n<p>Overloaded typecasts and converting constructors perform similar functions:<\/p>\n<ul>\n<li>A converting constructor is a member function of class type B that defines how B is created from A.\n<\/li>\n<li>An overloaded typecast is a member function of class type A that defines how A is converted to B.\n<\/li>\n<\/ul>\n<p>In both cases, we start with an A, and we end up with a B.  The main difference between the two is whether A or B has ownership of how the conversion happens.<\/p>\n<p>Since both ways require defining a member function, they can only be used for class types that can be modified.  If A is not a class type that can be modified, then you can&#8217;t use an overloaded typecast.  If B is not a class type that can be modified, then you can&#8217;t use a converting constructor.  If neither are class types that can be modified, then you will need to use a non-member conversion function instead.<\/p>\n<p>In cases where A and B are both class types that can be modified, we could use either.  But since we need only one, which should we prefer?<\/p>\n<p>In general, a converting constructor should be preferred to an overloaded typecast.  All other things equal, it is cleaner for a class type to own its own construction, rather than rely on another class to create and initialize it.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>When possible, prefer converting constructors, and avoid overloaded typecasts.\n<\/p><\/div>\n<p>There are a few cases where an overloaded typecast should be used instead:<\/p>\n<ul>\n<li>When providing a conversion to a fundamental type (since you can&#8217;t define constructors for these types).  Most conventionally, these are used to provide a conversion to <code>bool<\/code> for cases where it makes sense to be able to use an object in a conditional statement.\n<\/li>\n<li>When the conversion returns a reference or const reference.\n<\/li>\n<li>When providing a conversion to a type you can&#8217;t add members to (e.g. a conversion to <code>std::vector<\/code>, since you can&#8217;t define constructors for these types either).\n<\/li>\n<li>When you do not want the type being constructed to be aware of the type being converted from.  This can be helpful for avoiding circular dependencies.\n<\/li>\n<\/ul>\n<p>For an example of that last bullet, <code>std::string<\/code> has a constructor to create a <code>std::string<\/code> from a <code>std::string_view<\/code>.  This means <code>&lt;string&gt;<\/code> must include <code>&lt;string_view&gt;<\/code>.  If <code>std::string_view<\/code> had a constructor to create a <code>std::string_view<\/code> from a <code>std::string<\/code>, then <code>&lt;string_view&gt;<\/code> would need to include <code>&lt;string&gt;<\/code>, and this would result in a circular dependency between headers.<\/p>\n<p>Instead, <code>std::string<\/code> has an overloaded typecast that handles conversion from <code>std::string<\/code> to <code>std::string_view<\/code> (which is fine, since it&#8217;s already including <code>&lt;string_view&gt;<\/code>).  <code>std::string_view<\/code> does not know about <code>std::string<\/code> at all, and thus does not need to include <code>&lt;string&gt;<\/code>.  In this way, the circular dependency is avoided.<\/p>\n<p>When a converting constructor and an overloaded typecast are both defined for the same conversion, both are considered during overload resolution.  Depending on whether the overloaded typecast is const, the object being converted is const, and what type of cast or initialization is used (copy vs direct), either function might be chosen (which can result a typecast being selected over a converting constructor), or the result can be ambiguous (resulting in a compile error).  For this reason, you should avoid defining both an overloaded typecast and a converting constructor that can serve the same conversion.<\/p>\n<div class=\"cpp-note cpp-lightgreenbackground\">\n<p class=\"cpp-note-title cpp-bottomline\">Best practice<\/p>\n<p>When you need to define how convert type A to type B:<\/p>\n<ul>\n<li>If B is a class type you can modify, prefer using a converting constructor to create B from A.\n<\/li>\n<li>Otherwise, if A is a class type you can modify, use an overloaded typecast to convert A to B.\n<\/li>\n<li>Otherwise use a non-member function to convert A to B.\n<\/li>\n<\/ul>\n<\/div>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-the-assignment-operator\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.12<\/span>Overloading the assignment operator\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/overloading-the-parenthesis-operator\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">21.10<\/span>Overloading the parenthesis operator\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>In lesson , you learned that C++ allows you to convert one data type to another. The following example shows an int being converted into a double: int n{ 5 }; auto d{ static_cast&lt;double&gt;(n) }; \/\/ int cast to a double C++ already knows how to convert between the built-in &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/149"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=149"}],"version-history":[{"count":29,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/149\/revisions"}],"predecessor-version":[{"id":18252,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/149\/revisions\/18252"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=149"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=149"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=149"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}