{"id":12407,"date":"2022-01-18T10:15:24","date_gmt":"2022-01-18T18:15:24","guid":{"rendered":"https:\/\/www.learncpp.com\/?p=12407"},"modified":"2024-04-25T14:03:15","modified_gmt":"2024-04-25T21:03:15","slug":"pass-by-address-part-2","status":"publish","type":"post","link":"https:\/\/www.learncpp.com\/cpp-tutorial\/pass-by-address-part-2\/","title":{"rendered":"12.11 &#8212; Pass by address (part 2)"},"content":{"rendered":"<p>This lesson is a continuation of <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pass-by-address\/\">12.10 -- Pass by address<\/a>.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Pass by address for &#8220;optional&#8221; arguments<\/p>\n<p>One of the more common uses for pass by address is to allow a function to accept an &#8220;optional&#8221; argument.  This is easier to illustrate by example than to describe:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printIDNumber(const int *id=nullptr)\r\n{\r\n    if (id)\r\n        std::cout &lt;&lt; \"Your ID number is \" &lt;&lt; *id &lt;&lt; \".\\n\";\r\n    else\r\n        std::cout &lt;&lt; \"Your ID number is not known.\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    printIDNumber(); \/\/ we don't know the user's ID yet\r\n\r\n    int userid { 34 };\r\n    printIDNumber(&amp;userid); \/\/ we know the user's ID now\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This example prints:<\/p>\n<pre>\nYour ID number is not known.\r\nYour ID number is 34.\r\n<\/pre>\n<p>In this program, the <code>printIDNumber()<\/code> function has one parameter that is passed by address and defaulted to <code>nullptr<\/code>.  Inside <code>main()<\/code>, we call this function twice.  The first call, we don&#8217;t know the user&#8217;s ID, so we call <code>printIDNumber()<\/code> without an argument.  The <code>id<\/code> parameter defaults to <code>nullptr<\/code>, and the function prints <code>Your ID number is not known.<\/code>.  For the second call, we now have a valid id, so we call <code>printIDNumber(&amp;userid)<\/code>.  The <code>id<\/code> parameter receives the address of <code>userid<\/code>, so the function prints <code>Your ID number is 34.<\/code>.<\/p>\n<p>However, in many cases, function overloading is a better alternative to achieve the same result:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid printIDNumber()\r\n{\r\n    std::cout &lt;&lt; \"Your ID is not known\\n\";\r\n}\r\n\r\nvoid printIDNumber(int id)\r\n{\r\n    std::cout &lt;&lt; \"Your ID is \" &lt;&lt; id &lt;&lt; \"\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    printIDNumber(); \/\/ we don't know the user's ID yet\r\n\r\n    int userid { 34 };\r\n    printIDNumber(userid); \/\/ we know the user is 34\r\n\r\n    printIDNumber(62); \/\/ now also works with rvalue arguments\r\n    \r\n    return 0;\r\n}<\/code><\/pre>\n<p>This has a number of advantages: we no longer have to worry about null dereferences, and we can pass in literals or other rvalues as an argument.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Changing what a pointer parameter points at<\/p>\n<p>When we pass an address to a function, that address is copied from the argument into the pointer parameter (which is fine, because copying an address is fast).  Now consider the following program:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\n\/\/ [[maybe_unused]] gets rid of compiler warnings about ptr2 being set but not used\r\nvoid nullify([[maybe_unused]] int* ptr2) \r\n{\r\n    ptr2 = nullptr; \/\/ Make the function parameter a null pointer\r\n}\r\n\r\nint main()\r\n{\r\n    int x{ 5 };\r\n    int* ptr{ &amp;x }; \/\/ ptr points to x\r\n\r\n    std::cout &lt;&lt; \"ptr is \" &lt;&lt; (ptr ? \"non-null\\n\" : \"null\\n\");\r\n\r\n    nullify(ptr);\r\n\r\n    std::cout &lt;&lt; \"ptr is \" &lt;&lt; (ptr ? \"non-null\\n\" : \"null\\n\");\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\nptr is non-null\r\nptr is non-null\r\n<\/pre>\n<p>As you can see, changing the address held by the pointer parameter had no impact on the address held by the argument (<code>ptr<\/code> still points at <code>x<\/code>).  When function <code>nullify()<\/code> is called, <code>ptr2<\/code> receives a copy of the address passed in (in this case, the address held by <code>ptr<\/code>, which is the address of <code>x<\/code>).  When the function changes what <code>ptr2<\/code> points at, this only affects the copy held by <code>ptr2<\/code>.<\/p>\n<p>So what if we want to allow a function to change what a pointer argument points to?<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Pass by address&#8230; by reference?<\/p>\n<p>Yup, it&#8217;s a thing.  Just like we can pass a normal variable by reference, we can also pass pointers by reference.  Here&#8217;s the same program as above with <code>ptr2<\/code> changed to be a reference to an address:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n\r\nvoid nullify(int*&amp; refptr) \/\/ refptr is now a reference to a pointer\r\n{\r\n    refptr = nullptr; \/\/ Make the function parameter a null pointer\r\n}\r\n\r\nint main()\r\n{\r\n    int x{ 5 };\r\n    int* ptr{ &amp;x }; \/\/ ptr points to x\r\n\r\n    std::cout &lt;&lt; \"ptr is \" &lt;&lt; (ptr ? \"non-null\\n\" : \"null\\n\");\r\n\r\n    nullify(ptr);\r\n\r\n    std::cout &lt;&lt; \"ptr is \" &lt;&lt; (ptr ? \"non-null\\n\" : \"null\\n\");\r\n    return 0;\r\n}<\/code><\/pre>\n<p>This program prints:<\/p>\n<pre>\nptr is non-null\r\nptr is null\r\n<\/pre>\n<p>Because <code>refptr<\/code> is now a reference to a pointer, when <code>ptr<\/code> is passed as an argument, <code>refptr<\/code> is bound to <code>ptr<\/code>.  This means any changes to <code>refptr<\/code> are made to <code>ptr<\/code>.<\/p>\n<div class=\"cpp-note cpp-lightgraybackground\">\n<p class=\"cpp-note-title cpp-bottomline\">As an aside&#8230;<\/p>\n<p>Because references to pointers are fairly uncommon, it can be easy to mix up the syntax (is it <code>int*&amp;<\/code> or <code>int&amp;*<\/code>?).  The good news is that if you do it backwards, the compiler will error because you can&#8217;t have a pointer to a reference (because pointers must hold the address of an object, and references aren&#8217;t objects).  Then you can switch it around.\n<\/div>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">Why using <code>0<\/code> or <code>NULL<\/code> is no longer preferred (optional)<\/p>\n<p>In this subsection, we&#8217;ll explain why using <code>0<\/code> or <code>NULL<\/code> is no longer preferred.<\/p>\n<p>The literal <code>0<\/code> can be interpreted as either an integer literal, or as a null pointer literal.  In certain cases, it can be ambiguous which one we intend -- and in some of those cases, the compiler may assume we mean one when we mean the other -- with unintended consequences to the behavior of our program.<\/p>\n<p>The definition of preprocessor macro <code>NULL<\/code> is not defined by the language standard.  It can be defined as <code>0<\/code>, <code>0L<\/code>, <code>((void*)0)<\/code>, or something else entirely.<\/p>\n<p>In lesson <a href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/introduction-to-function-overloading\/\">11.1 -- Introduction to function overloading<\/a>, we discussed that functions can be overloaded (multiple functions can have the same name, so long as they can be differentiated by the number or type of parameters).  The compiler can figure out which overloaded function you desire by the arguments passed in as part of the function call.<\/p>\n<p>When using <code>0<\/code> or <code>NULL<\/code>, this can cause problems:<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;cstddef&gt; \/\/ for NULL\r\n\r\nvoid print(int x) \/\/ this function accepts an integer\r\n{\r\n\tstd::cout &lt;&lt; \"print(int): \" &lt;&lt; x &lt;&lt; '\\n';\r\n}\r\n\r\nvoid print(int* ptr) \/\/ this function accepts an integer pointer\r\n{\r\n\tstd::cout &lt;&lt; \"print(int*): \" &lt;&lt; (ptr ? \"non-null\\n\" : \"null\\n\");\r\n}\r\n\r\nint main()\r\n{\r\n\tint x{ 5 };\r\n\tint* ptr{ &amp;x };\r\n\r\n\tprint(ptr);  \/\/ always calls print(int*) because ptr has type int* (good)\r\n\tprint(0);    \/\/ always calls print(int) because 0 is an integer literal (hopefully this is what we expected)\r\n\r\n\tprint(NULL); \/\/ this statement could do any of the following:\r\n\t\/\/ call print(int) (Visual Studio does this)\r\n\t\/\/ call print(int*)\r\n\t\/\/ result in an ambiguous function call compilation error (gcc and Clang do this)\r\n\r\n\tprint(nullptr); \/\/ always calls print(int*)\r\n\r\n\treturn 0;\r\n}<\/code><\/pre>\n<p>On the author&#8217;s machine (using Visual Studio), this prints:<\/p>\n<pre>\nprint(int*): non-null\r\nprint(int): 0\r\nprint(int): 0\r\nprint(int*): null\r\n<\/pre>\n<p>When passing integer value <code>0<\/code> as a parameter, the compiler will prefer <code>print(int)<\/code> over <code>print(int*)<\/code>.  This can lead to unexpected results when we intended <code>print(int*)<\/code> to be called with a null pointer argument.<\/p>\n<p>In the case where <code>NULL<\/code> is defined as value <code>0<\/code>, <code>print(NULL)<\/code> will also call <code>print(int)<\/code>, not <code>print(int*)<\/code> like you might expect for a null pointer literal.  In cases where <code>NULL<\/code> is not defined as <code>0<\/code>, other behavior might result, like a call to <code>print(int*)<\/code> or a compilation error.<\/p>\n<p>Using <code>nullptr<\/code> removes this ambiguity (it will always call <code>print(int*)<\/code>), since <code>nullptr<\/code> will only match a pointer type.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">std::nullptr_t (optional)<\/p>\n<p>Since <code>nullptr<\/code> can be differentiated from integer values in function overloads, it must have a different type.  So what type is <code>nullptr<\/code>?  The answer is that <code>nullptr<\/code> has type <code>std::nullptr_t<\/code> (defined in header &lt;cstddef&gt;).  <code>std::nullptr_t<\/code> can only hold one value: <code>nullptr<\/code>!  While this may seem kind of silly, it&#8217;s useful in one situation.  If we want to write a function that accepts only a <code>nullptr<\/code> literal argument, we can make the parameter a <code>std::nullptr_t<\/code>.<\/p>\n<pre class=\"language-cpp line-numbers\"><code class=\"language-cpp match-braces\">#include &lt;iostream&gt;\r\n#include &lt;cstddef&gt; \/\/ for std::nullptr_t\r\n\r\nvoid print(std::nullptr_t)\r\n{\r\n    std::cout &lt;&lt; \"in print(std::nullptr_t)\\n\";\r\n}\r\n\r\nvoid print(int*)\r\n{\r\n    std::cout &lt;&lt; \"in print(int*)\\n\";\r\n}\r\n\r\nint main()\r\n{\r\n    print(nullptr); \/\/ calls print(std::nullptr_t)\r\n\r\n    int x { 5 };\r\n    int* ptr { &amp;x };\r\n\r\n    print(ptr); \/\/ calls print(int*)\r\n\r\n    ptr = nullptr;\r\n    print(ptr); \/\/ calls print(int*) (since ptr has type int*)\r\n\r\n    return 0;\r\n}<\/code><\/pre>\n<p>In the above example, the function call <code>print(nullptr)<\/code> resolves to the function <code>print(std::nullptr_t)<\/code> over <code>print(int*)<\/code> because it doesn&#8217;t require a conversion.<\/p>\n<p>The one case that might be a little confusing is when we call <code>print(ptr)<\/code> when <code>ptr<\/code> is holding the value <code>nullptr<\/code>.  Remember that function overloading matches on types, not values, and <code>ptr<\/code> has type <code>int*<\/code>.  Therefore, <code>print(int*)<\/code> will be matched.  <code>print(std::nullptr_t)<\/code> isn&#8217;t even in consideration in this case, as pointer types will not implicitly convert to a <code>std::nullptr_t<\/code>.<\/p>\n<p>You probably won&#8217;t ever need to use this, but it&#8217;s good to know, just in case.<\/p>\n<p class=\"cpp-section cpp-topline\" style=\"clear: both\">There is only pass by value<\/p>\n<p>Now that you understand the basic differences between passing by reference, address, and value, let\u2019s get reductionist for a moment. :)<\/p>\n<p>While the compiler can often optimize references away entirely, there are cases where this is not possible and a reference is actually needed.  References are normally implemented by the compiler using pointers.  This means that behind the scenes, pass by reference is essentially just a pass by address.<\/p>\n<p>And in the previous lesson, we mentioned that pass by address just copies an address from the caller to the called function -- which is just passing an address by value.<\/p>\n<p>Therefore, we can conclude that C++ really passes everything by value! The properties of pass by address (and reference) come solely from the fact that we can dereference the passed address to change the argument, which we can not do with a normal value parameter!<\/p>\n<div class=\"prevnext\"><div class=\"prevnext-inline\">\n\t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/return-by-reference-and-return-by-address\/\">\n <div class=\"nav-button nav-button-next\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-right\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Next lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.12<\/span>Return by reference and return by address\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  \t<a class=\"nav-link\" href=\"\/\">\n  <div class=\"nav-button nav-button-index\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-home\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Back to table of contents<\/div>\n    <\/div>\n<\/div><\/a>\n  \t<a class=\"nav-link\" href=\"https:\/\/www.learncpp.com\/cpp-tutorial\/pass-by-address\/\">\n  <div class=\"nav-button nav-button-prev\">\n    <div class=\"nav-button-icon\"><i class=\"fa fa-chevron-circle-left\" aria-hidden=\"true\"><\/i><\/div>\n    <div class=\"nav-button-text\">\n      <div class=\"nav-button-title\">Previous lesson<\/div>\n      <div class=\"nav-button-lesson\">\n        <span class=\"nav-button-lesson-number\">12.10<\/span>Pass by address\n      <\/div>\n    <\/div>\n  <\/div><\/a>\n  <\/div><\/div>\n","protected":false},"excerpt":{"rendered":"<p>This lesson is a continuation of . Pass by address for &#8220;optional&#8221; arguments One of the more common uses for pass by address is to allow a function to accept an &#8220;optional&#8221; argument. This is easier to illustrate by example than to describe: #include &lt;iostream&gt; void printIDNumber(const int *id=nullptr) { &hellip;<\/p>\n","protected":false},"author":1,"featured_media":0,"comment_status":"open","ping_status":"closed","sticky":false,"template":"","format":"standard","meta":[],"categories":[3],"tags":[],"_links":{"self":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12407"}],"collection":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts"}],"about":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/types\/post"}],"author":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/users\/1"}],"replies":[{"embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/comments?post=12407"}],"version-history":[{"count":24,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12407\/revisions"}],"predecessor-version":[{"id":13495,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/posts\/12407\/revisions\/13495"}],"wp:attachment":[{"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/media?parent=12407"}],"wp:term":[{"taxonomy":"category","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/categories?post=12407"},{"taxonomy":"post_tag","embeddable":true,"href":"https:\/\/www.learncpp.com\/wp-json\/wp\/v2\/tags?post=12407"}],"curies":[{"name":"wp","href":"https:\/\/api.w.org\/{rel}","templated":true}]}}